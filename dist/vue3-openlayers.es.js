var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
import { toRefs, reactive, watch, ref, onMounted, onUnmounted, provide, openBlock, createElementBlock, renderSlot, inject, createCommentVNode, computed, watchEffect } from "vue";
class BaseEvent {
  constructor(type) {
    this.propagationStopped;
    this.defaultPrevented;
    this.type = type;
    this.target = null;
  }
  preventDefault() {
    this.defaultPrevented = true;
  }
  stopPropagation() {
    this.propagationStopped = true;
  }
}
function stopPropagation(evt) {
  evt.stopPropagation();
}
var ObjectEventType = {
  PROPERTYCHANGE: "propertychange"
};
class Disposable {
  constructor() {
    this.disposed = false;
  }
  dispose() {
    if (!this.disposed) {
      this.disposed = true;
      this.disposeInternal();
    }
  }
  disposeInternal() {
  }
}
function binarySearch(haystack, needle, comparator) {
  let mid, cmp;
  comparator = comparator || numberSafeCompareFunction;
  let low = 0;
  let high = haystack.length;
  let found = false;
  while (low < high) {
    mid = low + (high - low >> 1);
    cmp = +comparator(haystack[mid], needle);
    if (cmp < 0) {
      low = mid + 1;
    } else {
      high = mid;
      found = !cmp;
    }
  }
  return found ? low : ~low;
}
function numberSafeCompareFunction(a2, b2) {
  return a2 > b2 ? 1 : a2 < b2 ? -1 : 0;
}
function linearFindNearest(arr, target, direction2) {
  const n2 = arr.length;
  if (arr[0] <= target) {
    return 0;
  } else if (target <= arr[n2 - 1]) {
    return n2 - 1;
  }
  let i2;
  if (direction2 > 0) {
    for (i2 = 1; i2 < n2; ++i2) {
      if (arr[i2] < target) {
        return i2 - 1;
      }
    }
  } else if (direction2 < 0) {
    for (i2 = 1; i2 < n2; ++i2) {
      if (arr[i2] <= target) {
        return i2;
      }
    }
  } else {
    for (i2 = 1; i2 < n2; ++i2) {
      if (arr[i2] == target) {
        return i2;
      } else if (arr[i2] < target) {
        if (typeof direction2 === "function") {
          if (direction2(target, arr[i2 - 1], arr[i2]) > 0) {
            return i2 - 1;
          }
          return i2;
        } else if (arr[i2 - 1] - target < target - arr[i2]) {
          return i2 - 1;
        }
        return i2;
      }
    }
  }
  return n2 - 1;
}
function reverseSubArray(arr, begin, end) {
  while (begin < end) {
    const tmp = arr[begin];
    arr[begin] = arr[end];
    arr[end] = tmp;
    ++begin;
    --end;
  }
}
function extend$3(arr, data2) {
  const extension = Array.isArray(data2) ? data2 : [data2];
  const length = extension.length;
  for (let i2 = 0; i2 < length; i2++) {
    arr[arr.length] = extension[i2];
  }
}
function equals$3(arr1, arr2) {
  const len1 = arr1.length;
  if (len1 !== arr2.length) {
    return false;
  }
  for (let i2 = 0; i2 < len1; i2++) {
    if (arr1[i2] !== arr2[i2]) {
      return false;
    }
  }
  return true;
}
function isSorted(arr, func, strict) {
  const compare = func || numberSafeCompareFunction;
  return arr.every(function(currentVal, index2) {
    if (index2 === 0) {
      return true;
    }
    const res = compare(arr[index2 - 1], currentVal);
    return !(res > 0 || strict && res === 0);
  });
}
function TRUE() {
  return true;
}
function FALSE() {
  return false;
}
function VOID() {
}
function memoizeOne(fn) {
  let called = false;
  let lastResult;
  let lastArgs;
  let lastThis;
  return function() {
    const nextArgs = Array.prototype.slice.call(arguments);
    if (!called || this !== lastThis || !equals$3(nextArgs, lastArgs)) {
      called = true;
      lastThis = this;
      lastArgs = nextArgs;
      lastResult = fn.apply(this, arguments);
    }
    return lastResult;
  };
}
function toPromise(getter) {
  function promiseGetter() {
    let value;
    try {
      value = getter();
    } catch (err2) {
      return Promise.reject(err2);
    }
    if (value instanceof Promise) {
      return value;
    }
    return Promise.resolve(value);
  }
  return promiseGetter();
}
function clear$1(object) {
  for (const property in object) {
    delete object[property];
  }
}
function isEmpty$1(object) {
  let property;
  for (property in object) {
    return false;
  }
  return !property;
}
class Target extends Disposable {
  constructor(target) {
    super();
    this.eventTarget_ = target;
    this.pendingRemovals_ = null;
    this.dispatching_ = null;
    this.listeners_ = null;
  }
  addEventListener(type, listener2) {
    if (!type || !listener2) {
      return;
    }
    const listeners = this.listeners_ || (this.listeners_ = {});
    const listenersForType = listeners[type] || (listeners[type] = []);
    if (!listenersForType.includes(listener2)) {
      listenersForType.push(listener2);
    }
  }
  dispatchEvent(event) {
    const isString = typeof event === "string";
    const type = isString ? event : event.type;
    const listeners = this.listeners_ && this.listeners_[type];
    if (!listeners) {
      return;
    }
    const evt = isString ? new BaseEvent(event) : event;
    if (!evt.target) {
      evt.target = this.eventTarget_ || this;
    }
    const dispatching = this.dispatching_ || (this.dispatching_ = {});
    const pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {});
    if (!(type in dispatching)) {
      dispatching[type] = 0;
      pendingRemovals[type] = 0;
    }
    ++dispatching[type];
    let propagate;
    for (let i2 = 0, ii = listeners.length; i2 < ii; ++i2) {
      if ("handleEvent" in listeners[i2]) {
        propagate = listeners[i2].handleEvent(evt);
      } else {
        propagate = listeners[i2].call(this, evt);
      }
      if (propagate === false || evt.propagationStopped) {
        propagate = false;
        break;
      }
    }
    if (--dispatching[type] === 0) {
      let pr = pendingRemovals[type];
      delete pendingRemovals[type];
      while (pr--) {
        this.removeEventListener(type, VOID);
      }
      delete dispatching[type];
    }
    return propagate;
  }
  disposeInternal() {
    this.listeners_ && clear$1(this.listeners_);
  }
  getListeners(type) {
    return this.listeners_ && this.listeners_[type] || void 0;
  }
  hasListener(type) {
    if (!this.listeners_) {
      return false;
    }
    return type ? type in this.listeners_ : Object.keys(this.listeners_).length > 0;
  }
  removeEventListener(type, listener2) {
    const listeners = this.listeners_ && this.listeners_[type];
    if (listeners) {
      const index2 = listeners.indexOf(listener2);
      if (index2 !== -1) {
        if (this.pendingRemovals_ && type in this.pendingRemovals_) {
          listeners[index2] = VOID;
          ++this.pendingRemovals_[type];
        } else {
          listeners.splice(index2, 1);
          if (listeners.length === 0) {
            delete this.listeners_[type];
          }
        }
      }
    }
  }
}
var EventType = {
  CHANGE: "change",
  ERROR: "error",
  BLUR: "blur",
  CLEAR: "clear",
  CONTEXTMENU: "contextmenu",
  CLICK: "click",
  DBLCLICK: "dblclick",
  DRAGENTER: "dragenter",
  DRAGOVER: "dragover",
  DROP: "drop",
  FOCUS: "focus",
  KEYDOWN: "keydown",
  KEYPRESS: "keypress",
  LOAD: "load",
  RESIZE: "resize",
  TOUCHMOVE: "touchmove",
  WHEEL: "wheel"
};
function listen(target, type, listener2, thisArg, once) {
  if (thisArg && thisArg !== target) {
    listener2 = listener2.bind(thisArg);
  }
  if (once) {
    const originalListener = listener2;
    listener2 = function() {
      target.removeEventListener(type, listener2);
      originalListener.apply(this, arguments);
    };
  }
  const eventsKey = {
    target,
    type,
    listener: listener2
  };
  target.addEventListener(type, listener2);
  return eventsKey;
}
function listenOnce(target, type, listener2, thisArg) {
  return listen(target, type, listener2, thisArg, true);
}
function unlistenByKey(key) {
  if (key && key.target) {
    key.target.removeEventListener(key.type, key.listener);
    clear$1(key);
  }
}
class Observable extends Target {
  constructor() {
    super();
    this.on = this.onInternal;
    this.once = this.onceInternal;
    this.un = this.unInternal;
    this.revision_ = 0;
  }
  changed() {
    ++this.revision_;
    this.dispatchEvent(EventType.CHANGE);
  }
  getRevision() {
    return this.revision_;
  }
  onInternal(type, listener2) {
    if (Array.isArray(type)) {
      const len = type.length;
      const keys3 = new Array(len);
      for (let i2 = 0; i2 < len; ++i2) {
        keys3[i2] = listen(this, type[i2], listener2);
      }
      return keys3;
    }
    return listen(this, type, listener2);
  }
  onceInternal(type, listener2) {
    let key;
    if (Array.isArray(type)) {
      const len = type.length;
      key = new Array(len);
      for (let i2 = 0; i2 < len; ++i2) {
        key[i2] = listenOnce(this, type[i2], listener2);
      }
    } else {
      key = listenOnce(this, type, listener2);
    }
    listener2.ol_key = key;
    return key;
  }
  unInternal(type, listener2) {
    const key = listener2.ol_key;
    if (key) {
      unByKey(key);
    } else if (Array.isArray(type)) {
      for (let i2 = 0, ii = type.length; i2 < ii; ++i2) {
        this.removeEventListener(type[i2], listener2);
      }
    } else {
      this.removeEventListener(type, listener2);
    }
  }
}
Observable.prototype.on;
Observable.prototype.once;
Observable.prototype.un;
function unByKey(key) {
  if (Array.isArray(key)) {
    for (let i2 = 0, ii = key.length; i2 < ii; ++i2) {
      unlistenByKey(key[i2]);
    }
  } else {
    unlistenByKey(key);
  }
}
function abstract() {
  throw new Error("Unimplemented abstract method.");
}
let uidCounter_ = 0;
function getUid(obj) {
  return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
}
const VERSION = "latest";
class ObjectEvent extends BaseEvent {
  constructor(type, key, oldValue) {
    super(type);
    this.key = key;
    this.oldValue = oldValue;
  }
}
class BaseObject extends Observable {
  constructor(values3) {
    super();
    this.on;
    this.once;
    this.un;
    getUid(this);
    this.values_ = null;
    if (values3 !== void 0) {
      this.setProperties(values3);
    }
  }
  get(key) {
    let value;
    if (this.values_ && this.values_.hasOwnProperty(key)) {
      value = this.values_[key];
    }
    return value;
  }
  getKeys() {
    return this.values_ && Object.keys(this.values_) || [];
  }
  getProperties() {
    return this.values_ && Object.assign({}, this.values_) || {};
  }
  hasProperties() {
    return !!this.values_;
  }
  notify(key, oldValue) {
    let eventType;
    eventType = `change:${key}`;
    if (this.hasListener(eventType)) {
      this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
    }
    eventType = ObjectEventType.PROPERTYCHANGE;
    if (this.hasListener(eventType)) {
      this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
    }
  }
  addChangeListener(key, listener2) {
    this.addEventListener(`change:${key}`, listener2);
  }
  removeChangeListener(key, listener2) {
    this.removeEventListener(`change:${key}`, listener2);
  }
  set(key, value, silent) {
    const values3 = this.values_ || (this.values_ = {});
    if (silent) {
      values3[key] = value;
    } else {
      const oldValue = values3[key];
      values3[key] = value;
      if (oldValue !== value) {
        this.notify(key, oldValue);
      }
    }
  }
  setProperties(values3, silent) {
    for (const key in values3) {
      this.set(key, values3[key], silent);
    }
  }
  applyProperties(source) {
    if (!source.values_) {
      return;
    }
    Object.assign(this.values_ || (this.values_ = {}), source.values_);
  }
  unset(key, silent) {
    if (this.values_ && key in this.values_) {
      const oldValue = this.values_[key];
      delete this.values_[key];
      if (isEmpty$1(this.values_)) {
        this.values_ = null;
      }
      if (!silent) {
        this.notify(key, oldValue);
      }
    }
  }
}
const messages$1 = {
  1: "The view center is not defined",
  2: "The view resolution is not defined",
  3: "The view rotation is not defined",
  4: "`image` and `src` cannot be provided at the same time",
  5: "`imgSize` must be set when `image` is provided",
  7: "`format` must be set when `url` is set",
  8: "Unknown `serverType` configured",
  9: "`url` must be configured or set using `#setUrl()`",
  10: "The default `geometryFunction` can only handle `Point` geometries",
  11: "`options.featureTypes` must be an Array",
  12: "`options.geometryName` must also be provided when `options.bbox` is set",
  13: "Invalid corner",
  14: "Invalid color",
  15: "Tried to get a value for a key that does not exist in the cache",
  16: "Tried to set a value for a key that is used already",
  17: "`resolutions` must be sorted in descending order",
  18: "Either `origin` or `origins` must be configured, never both",
  19: "Number of `tileSizes` and `resolutions` must be equal",
  20: "Number of `origins` and `resolutions` must be equal",
  22: "Either `tileSize` or `tileSizes` must be configured, never both",
  24: "Invalid extent or geometry provided as `geometry`",
  25: "Cannot fit empty extent provided as `geometry`",
  26: "Features must have an id set",
  27: "Features must have an id set",
  28: '`renderMode` must be `"hybrid"` or `"vector"`',
  30: "The passed `feature` was already added to the source",
  31: "Tried to enqueue an `element` that was already added to the queue",
  32: "Transformation matrix cannot be inverted",
  33: "Invalid units",
  34: "Invalid geometry layout",
  36: "Unknown SRS type",
  37: "Unknown geometry type found",
  38: "`styleMapValue` has an unknown type",
  39: "Unknown geometry type",
  40: "Expected `feature` to have a geometry",
  41: "Expected an `ol/style/Style` or an array of `ol/style/Style.js`",
  42: "Question unknown, the answer is 42",
  43: "Expected `layers` to be an array or a `Collection`",
  47: "Expected `controls` to be an array or an `ol/Collection`",
  48: "Expected `interactions` to be an array or an `ol/Collection`",
  49: "Expected `overlays` to be an array or an `ol/Collection`",
  50: "`options.featureTypes` should be an Array",
  51: "Either `url` or `tileJSON` options must be provided",
  52: "Unknown `serverType` configured",
  53: "Unknown `tierSizeCalculation` configured",
  55: "The {-y} placeholder requires a tile grid with extent",
  56: "mapBrowserEvent must originate from a pointer event",
  57: "At least 2 conditions are required",
  59: "Invalid command found in the PBF",
  60: "Missing or invalid `size`",
  61: "Cannot determine IIIF Image API version from provided image information JSON",
  62: "A `WebGLArrayBuffer` must either be of type `ELEMENT_ARRAY_BUFFER` or `ARRAY_BUFFER`",
  64: "Layer opacity must be a number",
  66: "`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has not been enabled. This is done by providing adequate shaders using the `hitVertexShader` and `hitFragmentShader` properties of `WebGLPointsLayerRenderer`",
  67: "A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both",
  68: "A VectorTile source can only be rendered if it has a projection compatible with the view projection"
};
class AssertionError extends Error {
  constructor(code) {
    const message = messages$1[code];
    super(message);
    this.code = code;
    this.name = "AssertionError";
    this.message = message;
  }
}
var CollectionEventType = {
  ADD: "add",
  REMOVE: "remove"
};
const Property$6 = {
  LENGTH: "length"
};
class CollectionEvent extends BaseEvent {
  constructor(type, element, index2) {
    super(type);
    this.element = element;
    this.index = index2;
  }
}
class Collection extends BaseObject {
  constructor(array, options) {
    super();
    this.on;
    this.once;
    this.un;
    options = options || {};
    this.unique_ = !!options.unique;
    this.array_ = array ? array : [];
    if (this.unique_) {
      for (let i2 = 0, ii = this.array_.length; i2 < ii; ++i2) {
        this.assertUnique_(this.array_[i2], i2);
      }
    }
    this.updateLength_();
  }
  clear() {
    while (this.getLength() > 0) {
      this.pop();
    }
  }
  extend(arr) {
    for (let i2 = 0, ii = arr.length; i2 < ii; ++i2) {
      this.push(arr[i2]);
    }
    return this;
  }
  forEach(f2) {
    const array = this.array_;
    for (let i2 = 0, ii = array.length; i2 < ii; ++i2) {
      f2(array[i2], i2, array);
    }
  }
  getArray() {
    return this.array_;
  }
  item(index2) {
    return this.array_[index2];
  }
  getLength() {
    return this.get(Property$6.LENGTH);
  }
  insertAt(index2, elem) {
    if (index2 < 0 || index2 > this.getLength()) {
      throw new Error("Index out of bounds: " + index2);
    }
    if (this.unique_) {
      this.assertUnique_(elem);
    }
    this.array_.splice(index2, 0, elem);
    this.updateLength_();
    this.dispatchEvent(new CollectionEvent(CollectionEventType.ADD, elem, index2));
  }
  pop() {
    return this.removeAt(this.getLength() - 1);
  }
  push(elem) {
    if (this.unique_) {
      this.assertUnique_(elem);
    }
    const n2 = this.getLength();
    this.insertAt(n2, elem);
    return this.getLength();
  }
  remove(elem) {
    const arr = this.array_;
    for (let i2 = 0, ii = arr.length; i2 < ii; ++i2) {
      if (arr[i2] === elem) {
        return this.removeAt(i2);
      }
    }
    return void 0;
  }
  removeAt(index2) {
    if (index2 < 0 || index2 >= this.getLength()) {
      return void 0;
    }
    const prev = this.array_[index2];
    this.array_.splice(index2, 1);
    this.updateLength_();
    this.dispatchEvent(new CollectionEvent(CollectionEventType.REMOVE, prev, index2));
    return prev;
  }
  setAt(index2, elem) {
    const n2 = this.getLength();
    if (index2 >= n2) {
      this.insertAt(index2, elem);
      return;
    }
    if (index2 < 0) {
      throw new Error("Index out of bounds: " + index2);
    }
    if (this.unique_) {
      this.assertUnique_(elem, index2);
    }
    const prev = this.array_[index2];
    this.array_[index2] = elem;
    this.dispatchEvent(new CollectionEvent(CollectionEventType.REMOVE, prev, index2));
    this.dispatchEvent(new CollectionEvent(CollectionEventType.ADD, elem, index2));
  }
  updateLength_() {
    this.set(Property$6.LENGTH, this.array_.length);
  }
  assertUnique_(elem, except) {
    for (let i2 = 0, ii = this.array_.length; i2 < ii; ++i2) {
      if (this.array_[i2] === elem && i2 !== except) {
        throw new AssertionError(58);
      }
    }
  }
}
const ua = typeof navigator !== "undefined" && typeof navigator.userAgent !== "undefined" ? navigator.userAgent.toLowerCase() : "";
const FIREFOX = ua.includes("firefox");
const SAFARI = ua.includes("safari") && !ua.includes("chrom");
const SAFARI_BUG_237906 = SAFARI && (ua.includes("version/15.4") || /cpu (os|iphone os) 15_4 like mac os x/.test(ua));
const WEBKIT = ua.includes("webkit") && !ua.includes("edge");
const MAC = ua.includes("macintosh");
const DEVICE_PIXEL_RATIO = typeof devicePixelRatio !== "undefined" ? devicePixelRatio : 1;
const WORKER_OFFSCREEN_CANVAS = typeof WorkerGlobalScope !== "undefined" && typeof OffscreenCanvas !== "undefined" && self instanceof WorkerGlobalScope;
const IMAGE_DECODE = typeof Image !== "undefined" && Image.prototype.decode;
const PASSIVE_EVENT_LISTENERS = function() {
  let passive = false;
  try {
    const options = Object.defineProperty({}, "passive", {
      get: function() {
        passive = true;
      }
    });
    window.addEventListener("_", null, options);
    window.removeEventListener("_", null, options);
  } catch (error) {
  }
  return passive;
}();
function assert(assertion, errorCode) {
  if (!assertion) {
    throw new AssertionError(errorCode);
  }
}
const tmp_ = new Array(6);
function create$7() {
  return [1, 0, 0, 1, 0, 0];
}
function reset(transform2) {
  return set$2(transform2, 1, 0, 0, 1, 0, 0);
}
function multiply(transform1, transform2) {
  const a1 = transform1[0];
  const b1 = transform1[1];
  const c1 = transform1[2];
  const d1 = transform1[3];
  const e1 = transform1[4];
  const f1 = transform1[5];
  const a2 = transform2[0];
  const b2 = transform2[1];
  const c2 = transform2[2];
  const d2 = transform2[3];
  const e2 = transform2[4];
  const f2 = transform2[5];
  transform1[0] = a1 * a2 + c1 * b2;
  transform1[1] = b1 * a2 + d1 * b2;
  transform1[2] = a1 * c2 + c1 * d2;
  transform1[3] = b1 * c2 + d1 * d2;
  transform1[4] = a1 * e2 + c1 * f2 + e1;
  transform1[5] = b1 * e2 + d1 * f2 + f1;
  return transform1;
}
function set$2(transform2, a2, b2, c2, d2, e2, f2) {
  transform2[0] = a2;
  transform2[1] = b2;
  transform2[2] = c2;
  transform2[3] = d2;
  transform2[4] = e2;
  transform2[5] = f2;
  return transform2;
}
function setFromArray(transform1, transform2) {
  transform1[0] = transform2[0];
  transform1[1] = transform2[1];
  transform1[2] = transform2[2];
  transform1[3] = transform2[3];
  transform1[4] = transform2[4];
  transform1[5] = transform2[5];
  return transform1;
}
function apply$5(transform2, coordinate) {
  const x2 = coordinate[0];
  const y2 = coordinate[1];
  coordinate[0] = transform2[0] * x2 + transform2[2] * y2 + transform2[4];
  coordinate[1] = transform2[1] * x2 + transform2[3] * y2 + transform2[5];
  return coordinate;
}
function rotate$2(transform2, angle2) {
  const cos = Math.cos(angle2);
  const sin = Math.sin(angle2);
  return multiply(transform2, set$2(tmp_, cos, sin, -sin, cos, 0, 0));
}
function scale$3(transform2, x2, y2) {
  return multiply(transform2, set$2(tmp_, x2, 0, 0, y2, 0, 0));
}
function makeScale(target, x2, y2) {
  return set$2(target, x2, 0, 0, y2, 0, 0);
}
function translate$1(transform2, dx, dy) {
  return multiply(transform2, set$2(tmp_, 1, 0, 0, 1, dx, dy));
}
function compose(transform2, dx1, dy1, sx, sy, angle2, dx2, dy2) {
  const sin = Math.sin(angle2);
  const cos = Math.cos(angle2);
  transform2[0] = sx * cos;
  transform2[1] = sy * sin;
  transform2[2] = -sx * sin;
  transform2[3] = sy * cos;
  transform2[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
  transform2[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
  return transform2;
}
function makeInverse(target, source) {
  const det = determinant(source);
  assert(det !== 0, 32);
  const a2 = source[0];
  const b2 = source[1];
  const c2 = source[2];
  const d2 = source[3];
  const e2 = source[4];
  const f2 = source[5];
  target[0] = d2 / det;
  target[1] = -b2 / det;
  target[2] = -c2 / det;
  target[3] = a2 / det;
  target[4] = (c2 * f2 - d2 * e2) / det;
  target[5] = -(a2 * f2 - b2 * e2) / det;
  return target;
}
function determinant(mat) {
  return mat[0] * mat[3] - mat[1] * mat[2];
}
let transformStringDiv;
function toString$e(mat) {
  const transformString = "matrix(" + mat.join(", ") + ")";
  if (WORKER_OFFSCREEN_CANVAS) {
    return transformString;
  }
  const node2 = transformStringDiv || (transformStringDiv = document.createElement("div"));
  node2.style.transform = transformString;
  return node2.style.transform;
}
var Relationship = {
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16
};
function boundingExtent(coordinates2) {
  const extent2 = createEmpty();
  for (let i2 = 0, ii = coordinates2.length; i2 < ii; ++i2) {
    extendCoordinate(extent2, coordinates2[i2]);
  }
  return extent2;
}
function _boundingExtentXYs(xs, ys, dest) {
  const minX = Math.min.apply(null, xs);
  const minY = Math.min.apply(null, ys);
  const maxX = Math.max.apply(null, xs);
  const maxY = Math.max.apply(null, ys);
  return createOrUpdate$2(minX, minY, maxX, maxY, dest);
}
function buffer$2(extent2, value, dest) {
  if (dest) {
    dest[0] = extent2[0] - value;
    dest[1] = extent2[1] - value;
    dest[2] = extent2[2] + value;
    dest[3] = extent2[3] + value;
    return dest;
  }
  return [
    extent2[0] - value,
    extent2[1] - value,
    extent2[2] + value,
    extent2[3] + value
  ];
}
function clone$1(extent2, dest) {
  if (dest) {
    dest[0] = extent2[0];
    dest[1] = extent2[1];
    dest[2] = extent2[2];
    dest[3] = extent2[3];
    return dest;
  }
  return extent2.slice();
}
function closestSquaredDistanceXY(extent2, x2, y2) {
  let dx, dy;
  if (x2 < extent2[0]) {
    dx = extent2[0] - x2;
  } else if (extent2[2] < x2) {
    dx = x2 - extent2[2];
  } else {
    dx = 0;
  }
  if (y2 < extent2[1]) {
    dy = extent2[1] - y2;
  } else if (extent2[3] < y2) {
    dy = y2 - extent2[3];
  } else {
    dy = 0;
  }
  return dx * dx + dy * dy;
}
function containsCoordinate(extent2, coordinate) {
  return containsXY(extent2, coordinate[0], coordinate[1]);
}
function containsExtent(extent1, extent2) {
  return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
}
function containsXY(extent2, x2, y2) {
  return extent2[0] <= x2 && x2 <= extent2[2] && extent2[1] <= y2 && y2 <= extent2[3];
}
function coordinateRelationship(extent2, coordinate) {
  const minX = extent2[0];
  const minY = extent2[1];
  const maxX = extent2[2];
  const maxY = extent2[3];
  const x2 = coordinate[0];
  const y2 = coordinate[1];
  let relationship = Relationship.UNKNOWN;
  if (x2 < minX) {
    relationship = relationship | Relationship.LEFT;
  } else if (x2 > maxX) {
    relationship = relationship | Relationship.RIGHT;
  }
  if (y2 < minY) {
    relationship = relationship | Relationship.BELOW;
  } else if (y2 > maxY) {
    relationship = relationship | Relationship.ABOVE;
  }
  if (relationship === Relationship.UNKNOWN) {
    relationship = Relationship.INTERSECTING;
  }
  return relationship;
}
function createEmpty() {
  return [Infinity, Infinity, -Infinity, -Infinity];
}
function createOrUpdate$2(minX, minY, maxX, maxY, dest) {
  if (dest) {
    dest[0] = minX;
    dest[1] = minY;
    dest[2] = maxX;
    dest[3] = maxY;
    return dest;
  }
  return [minX, minY, maxX, maxY];
}
function createOrUpdateEmpty(dest) {
  return createOrUpdate$2(Infinity, Infinity, -Infinity, -Infinity, dest);
}
function createOrUpdateFromCoordinate(coordinate, dest) {
  const x2 = coordinate[0];
  const y2 = coordinate[1];
  return createOrUpdate$2(x2, y2, x2, y2, dest);
}
function createOrUpdateFromCoordinates(coordinates2, dest) {
  const extent2 = createOrUpdateEmpty(dest);
  return extendCoordinates(extent2, coordinates2);
}
function createOrUpdateFromFlatCoordinates(flatCoordinates, offset2, end, stride, dest) {
  const extent2 = createOrUpdateEmpty(dest);
  return extendFlatCoordinates(extent2, flatCoordinates, offset2, end, stride);
}
function createOrUpdateFromRings(rings, dest) {
  const extent2 = createOrUpdateEmpty(dest);
  return extendRings(extent2, rings);
}
function equals$2(extent1, extent2) {
  return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];
}
function approximatelyEquals(extent1, extent2, tolerance) {
  return Math.abs(extent1[0] - extent2[0]) < tolerance && Math.abs(extent1[2] - extent2[2]) < tolerance && Math.abs(extent1[1] - extent2[1]) < tolerance && Math.abs(extent1[3] - extent2[3]) < tolerance;
}
function extend$2(extent1, extent2) {
  if (extent2[0] < extent1[0]) {
    extent1[0] = extent2[0];
  }
  if (extent2[2] > extent1[2]) {
    extent1[2] = extent2[2];
  }
  if (extent2[1] < extent1[1]) {
    extent1[1] = extent2[1];
  }
  if (extent2[3] > extent1[3]) {
    extent1[3] = extent2[3];
  }
  return extent1;
}
function extendCoordinate(extent2, coordinate) {
  if (coordinate[0] < extent2[0]) {
    extent2[0] = coordinate[0];
  }
  if (coordinate[0] > extent2[2]) {
    extent2[2] = coordinate[0];
  }
  if (coordinate[1] < extent2[1]) {
    extent2[1] = coordinate[1];
  }
  if (coordinate[1] > extent2[3]) {
    extent2[3] = coordinate[1];
  }
}
function extendCoordinates(extent2, coordinates2) {
  for (let i2 = 0, ii = coordinates2.length; i2 < ii; ++i2) {
    extendCoordinate(extent2, coordinates2[i2]);
  }
  return extent2;
}
function extendFlatCoordinates(extent2, flatCoordinates, offset2, end, stride) {
  for (; offset2 < end; offset2 += stride) {
    extendXY(extent2, flatCoordinates[offset2], flatCoordinates[offset2 + 1]);
  }
  return extent2;
}
function extendRings(extent2, rings) {
  for (let i2 = 0, ii = rings.length; i2 < ii; ++i2) {
    extendCoordinates(extent2, rings[i2]);
  }
  return extent2;
}
function extendXY(extent2, x2, y2) {
  extent2[0] = Math.min(extent2[0], x2);
  extent2[1] = Math.min(extent2[1], y2);
  extent2[2] = Math.max(extent2[2], x2);
  extent2[3] = Math.max(extent2[3], y2);
}
function forEachCorner(extent2, callback) {
  let val;
  val = callback(getBottomLeft(extent2));
  if (val) {
    return val;
  }
  val = callback(getBottomRight(extent2));
  if (val) {
    return val;
  }
  val = callback(getTopRight(extent2));
  if (val) {
    return val;
  }
  val = callback(getTopLeft(extent2));
  if (val) {
    return val;
  }
  return false;
}
function getArea(extent2) {
  let area2 = 0;
  if (!isEmpty(extent2)) {
    area2 = getWidth(extent2) * getHeight(extent2);
  }
  return area2;
}
function getBottomLeft(extent2) {
  return [extent2[0], extent2[1]];
}
function getBottomRight(extent2) {
  return [extent2[2], extent2[1]];
}
function getCenter(extent2) {
  return [(extent2[0] + extent2[2]) / 2, (extent2[1] + extent2[3]) / 2];
}
function getCorner(extent2, corner) {
  let coordinate;
  if (corner === "bottom-left") {
    coordinate = getBottomLeft(extent2);
  } else if (corner === "bottom-right") {
    coordinate = getBottomRight(extent2);
  } else if (corner === "top-left") {
    coordinate = getTopLeft(extent2);
  } else if (corner === "top-right") {
    coordinate = getTopRight(extent2);
  } else {
    assert(false, 13);
  }
  return coordinate;
}
function getEnlargedArea(extent1, extent2) {
  const minX = Math.min(extent1[0], extent2[0]);
  const minY = Math.min(extent1[1], extent2[1]);
  const maxX = Math.max(extent1[2], extent2[2]);
  const maxY = Math.max(extent1[3], extent2[3]);
  return (maxX - minX) * (maxY - minY);
}
function getForViewAndSize(center, resolution, rotation, size, dest) {
  const [x0, y0, x1, y1, x2, y2, x3, y3] = getRotatedViewport(center, resolution, rotation, size);
  return createOrUpdate$2(Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3), Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3), dest);
}
function getRotatedViewport(center, resolution, rotation, size) {
  const dx = resolution * size[0] / 2;
  const dy = resolution * size[1] / 2;
  const cosRotation = Math.cos(rotation);
  const sinRotation = Math.sin(rotation);
  const xCos = dx * cosRotation;
  const xSin = dx * sinRotation;
  const yCos = dy * cosRotation;
  const ySin = dy * sinRotation;
  const x2 = center[0];
  const y2 = center[1];
  return [
    x2 - xCos + ySin,
    y2 - xSin - yCos,
    x2 - xCos - ySin,
    y2 - xSin + yCos,
    x2 + xCos - ySin,
    y2 + xSin + yCos,
    x2 + xCos + ySin,
    y2 + xSin - yCos,
    x2 - xCos + ySin,
    y2 - xSin - yCos
  ];
}
function getHeight(extent2) {
  return extent2[3] - extent2[1];
}
function getIntersectionArea(extent1, extent2) {
  const intersection = getIntersection(extent1, extent2);
  return getArea(intersection);
}
function getIntersection(extent1, extent2, dest) {
  const intersection = dest ? dest : createEmpty();
  if (intersects$2(extent1, extent2)) {
    if (extent1[0] > extent2[0]) {
      intersection[0] = extent1[0];
    } else {
      intersection[0] = extent2[0];
    }
    if (extent1[1] > extent2[1]) {
      intersection[1] = extent1[1];
    } else {
      intersection[1] = extent2[1];
    }
    if (extent1[2] < extent2[2]) {
      intersection[2] = extent1[2];
    } else {
      intersection[2] = extent2[2];
    }
    if (extent1[3] < extent2[3]) {
      intersection[3] = extent1[3];
    } else {
      intersection[3] = extent2[3];
    }
  } else {
    createOrUpdateEmpty(intersection);
  }
  return intersection;
}
function getMargin(extent2) {
  return getWidth(extent2) + getHeight(extent2);
}
function getSize(extent2) {
  return [extent2[2] - extent2[0], extent2[3] - extent2[1]];
}
function getTopLeft(extent2) {
  return [extent2[0], extent2[3]];
}
function getTopRight(extent2) {
  return [extent2[2], extent2[3]];
}
function getWidth(extent2) {
  return extent2[2] - extent2[0];
}
function intersects$2(extent1, extent2) {
  return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];
}
function isEmpty(extent2) {
  return extent2[2] < extent2[0] || extent2[3] < extent2[1];
}
function returnOrUpdate(extent2, dest) {
  if (dest) {
    dest[0] = extent2[0];
    dest[1] = extent2[1];
    dest[2] = extent2[2];
    dest[3] = extent2[3];
    return dest;
  }
  return extent2;
}
function scaleFromCenter(extent2, value) {
  const deltaX = (extent2[2] - extent2[0]) / 2 * (value - 1);
  const deltaY = (extent2[3] - extent2[1]) / 2 * (value - 1);
  extent2[0] -= deltaX;
  extent2[2] += deltaX;
  extent2[1] -= deltaY;
  extent2[3] += deltaY;
}
function intersectsSegment(extent2, start2, end) {
  let intersects2 = false;
  const startRel = coordinateRelationship(extent2, start2);
  const endRel = coordinateRelationship(extent2, end);
  if (startRel === Relationship.INTERSECTING || endRel === Relationship.INTERSECTING) {
    intersects2 = true;
  } else {
    const minX = extent2[0];
    const minY = extent2[1];
    const maxX = extent2[2];
    const maxY = extent2[3];
    const startX = start2[0];
    const startY = start2[1];
    const endX = end[0];
    const endY = end[1];
    const slope = (endY - startY) / (endX - startX);
    let x2, y2;
    if (!!(endRel & Relationship.ABOVE) && !(startRel & Relationship.ABOVE)) {
      x2 = endX - (endY - maxY) / slope;
      intersects2 = x2 >= minX && x2 <= maxX;
    }
    if (!intersects2 && !!(endRel & Relationship.RIGHT) && !(startRel & Relationship.RIGHT)) {
      y2 = endY - (endX - maxX) * slope;
      intersects2 = y2 >= minY && y2 <= maxY;
    }
    if (!intersects2 && !!(endRel & Relationship.BELOW) && !(startRel & Relationship.BELOW)) {
      x2 = endX - (endY - minY) / slope;
      intersects2 = x2 >= minX && x2 <= maxX;
    }
    if (!intersects2 && !!(endRel & Relationship.LEFT) && !(startRel & Relationship.LEFT)) {
      y2 = endY - (endX - minX) * slope;
      intersects2 = y2 >= minY && y2 <= maxY;
    }
  }
  return intersects2;
}
function applyTransform(extent2, transformFn, dest, stops) {
  let coordinates2 = [];
  if (stops > 1) {
    const width = extent2[2] - extent2[0];
    const height = extent2[3] - extent2[1];
    for (let i2 = 0; i2 < stops; ++i2) {
      coordinates2.push(extent2[0] + width * i2 / stops, extent2[1], extent2[2], extent2[1] + height * i2 / stops, extent2[2] - width * i2 / stops, extent2[3], extent2[0], extent2[3] - height * i2 / stops);
    }
  } else {
    coordinates2 = [
      extent2[0],
      extent2[1],
      extent2[2],
      extent2[1],
      extent2[2],
      extent2[3],
      extent2[0],
      extent2[3]
    ];
  }
  transformFn(coordinates2, coordinates2, 2);
  const xs = [];
  const ys = [];
  for (let i2 = 0, l2 = coordinates2.length; i2 < l2; i2 += 2) {
    xs.push(coordinates2[i2]);
    ys.push(coordinates2[i2 + 1]);
  }
  return _boundingExtentXYs(xs, ys, dest);
}
function wrapX$2(extent2, projection) {
  const projectionExtent = projection.getExtent();
  const center = getCenter(extent2);
  if (projection.canWrapX() && (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])) {
    const worldWidth = getWidth(projectionExtent);
    const worldsAway = Math.floor((center[0] - projectionExtent[0]) / worldWidth);
    const offset2 = worldsAway * worldWidth;
    extent2[0] -= offset2;
    extent2[2] -= offset2;
  }
  return extent2;
}
function wrapAndSliceX(extent2, projection) {
  if (projection.canWrapX()) {
    const projectionExtent = projection.getExtent();
    if (!isFinite(extent2[0]) || !isFinite(extent2[2])) {
      return [[projectionExtent[0], extent2[1], projectionExtent[2], extent2[3]]];
    }
    wrapX$2(extent2, projection);
    const worldWidth = getWidth(projectionExtent);
    if (getWidth(extent2) > worldWidth) {
      return [[projectionExtent[0], extent2[1], projectionExtent[2], extent2[3]]];
    } else if (extent2[0] < projectionExtent[0]) {
      return [
        [extent2[0] + worldWidth, extent2[1], projectionExtent[2], extent2[3]],
        [projectionExtent[0], extent2[1], extent2[2], extent2[3]]
      ];
    } else if (extent2[2] > projectionExtent[2]) {
      return [
        [extent2[0], extent2[1], projectionExtent[2], extent2[3]],
        [projectionExtent[0], extent2[1], extent2[2] - worldWidth, extent2[3]]
      ];
    }
  }
  return [extent2];
}
var extent = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boundingExtent,
  buffer: buffer$2,
  clone: clone$1,
  closestSquaredDistanceXY,
  containsCoordinate,
  containsExtent,
  containsXY,
  coordinateRelationship,
  createEmpty,
  createOrUpdate: createOrUpdate$2,
  createOrUpdateEmpty,
  createOrUpdateFromCoordinate,
  createOrUpdateFromCoordinates,
  createOrUpdateFromFlatCoordinates,
  createOrUpdateFromRings,
  equals: equals$2,
  approximatelyEquals,
  extend: extend$2,
  extendCoordinate,
  extendCoordinates,
  extendFlatCoordinates,
  extendRings,
  extendXY,
  forEachCorner,
  getArea,
  getBottomLeft,
  getBottomRight,
  getCenter,
  getCorner,
  getEnlargedArea,
  getForViewAndSize,
  getRotatedViewport,
  getHeight,
  getIntersectionArea,
  getIntersection,
  getMargin,
  getSize,
  getTopLeft,
  getTopRight,
  getWidth,
  intersects: intersects$2,
  isEmpty,
  returnOrUpdate,
  scaleFromCenter,
  intersectsSegment,
  applyTransform,
  wrapX: wrapX$2,
  wrapAndSliceX
}, Symbol.toStringTag, { value: "Module" }));
function clamp(value, min2, max2) {
  return Math.min(Math.max(value, min2), max2);
}
function squaredSegmentDistance(x2, y2, x1, y1, x22, y22) {
  const dx = x22 - x1;
  const dy = y22 - y1;
  if (dx !== 0 || dy !== 0) {
    const t3 = ((x2 - x1) * dx + (y2 - y1) * dy) / (dx * dx + dy * dy);
    if (t3 > 1) {
      x1 = x22;
      y1 = y22;
    } else if (t3 > 0) {
      x1 += dx * t3;
      y1 += dy * t3;
    }
  }
  return squaredDistance$1(x2, y2, x1, y1);
}
function squaredDistance$1(x1, y1, x2, y2) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  return dx * dx + dy * dy;
}
function solveLinearSystem(mat) {
  const n2 = mat.length;
  for (let i2 = 0; i2 < n2; i2++) {
    let maxRow = i2;
    let maxEl = Math.abs(mat[i2][i2]);
    for (let r2 = i2 + 1; r2 < n2; r2++) {
      const absValue = Math.abs(mat[r2][i2]);
      if (absValue > maxEl) {
        maxEl = absValue;
        maxRow = r2;
      }
    }
    if (maxEl === 0) {
      return null;
    }
    const tmp = mat[maxRow];
    mat[maxRow] = mat[i2];
    mat[i2] = tmp;
    for (let j2 = i2 + 1; j2 < n2; j2++) {
      const coef = -mat[j2][i2] / mat[i2][i2];
      for (let k2 = i2; k2 < n2 + 1; k2++) {
        if (i2 == k2) {
          mat[j2][k2] = 0;
        } else {
          mat[j2][k2] += coef * mat[i2][k2];
        }
      }
    }
  }
  const x2 = new Array(n2);
  for (let l2 = n2 - 1; l2 >= 0; l2--) {
    x2[l2] = mat[l2][n2] / mat[l2][l2];
    for (let m2 = l2 - 1; m2 >= 0; m2--) {
      mat[m2][n2] -= mat[m2][l2] * x2[l2];
    }
  }
  return x2;
}
function toDegrees(angleInRadians) {
  return angleInRadians * 180 / Math.PI;
}
function toRadians(angleInDegrees) {
  return angleInDegrees * Math.PI / 180;
}
function modulo(a2, b2) {
  const r2 = a2 % b2;
  return r2 * b2 < 0 ? r2 + b2 : r2;
}
function lerp$2(a2, b2, x2) {
  return a2 + x2 * (b2 - a2);
}
function toFixed(n2, decimals) {
  const factor = Math.pow(10, decimals);
  return Math.round(n2 * factor) / factor;
}
function round(n2, decimals) {
  return Math.round(toFixed(n2, decimals));
}
function floor$2(n2, decimals) {
  return Math.floor(toFixed(n2, decimals));
}
function ceil$1(n2, decimals) {
  return Math.ceil(toFixed(n2, decimals));
}
const HEX_COLOR_RE_ = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i;
const NAMED_COLOR_RE_ = /^([a-z]*)$|^hsla?\(.*\)$/i;
function asString$1(color2) {
  if (typeof color2 === "string") {
    return color2;
  }
  return toString$d(color2);
}
function fromNamed(color2) {
  const el = document.createElement("div");
  el.style.color = color2;
  if (el.style.color !== "") {
    document.body.appendChild(el);
    const rgb2 = getComputedStyle(el).color;
    document.body.removeChild(el);
    return rgb2;
  }
  return "";
}
const fromString = function() {
  const MAX_CACHE_SIZE = 1024;
  const cache2 = {};
  let cacheSize = 0;
  return function(s2) {
    let color2;
    if (cache2.hasOwnProperty(s2)) {
      color2 = cache2[s2];
    } else {
      if (cacheSize >= MAX_CACHE_SIZE) {
        let i2 = 0;
        for (const key in cache2) {
          if ((i2++ & 3) === 0) {
            delete cache2[key];
            --cacheSize;
          }
        }
      }
      color2 = fromStringInternal_(s2);
      cache2[s2] = color2;
      ++cacheSize;
    }
    return color2;
  };
}();
function asArray(color2) {
  if (Array.isArray(color2)) {
    return color2;
  }
  return fromString(color2);
}
function fromStringInternal_(s2) {
  let r2, g2, b2, a2, color2;
  if (NAMED_COLOR_RE_.exec(s2)) {
    s2 = fromNamed(s2);
  }
  if (HEX_COLOR_RE_.exec(s2)) {
    const n2 = s2.length - 1;
    let d2;
    if (n2 <= 4) {
      d2 = 1;
    } else {
      d2 = 2;
    }
    const hasAlpha = n2 === 4 || n2 === 8;
    r2 = parseInt(s2.substr(1 + 0 * d2, d2), 16);
    g2 = parseInt(s2.substr(1 + 1 * d2, d2), 16);
    b2 = parseInt(s2.substr(1 + 2 * d2, d2), 16);
    if (hasAlpha) {
      a2 = parseInt(s2.substr(1 + 3 * d2, d2), 16);
    } else {
      a2 = 255;
    }
    if (d2 == 1) {
      r2 = (r2 << 4) + r2;
      g2 = (g2 << 4) + g2;
      b2 = (b2 << 4) + b2;
      if (hasAlpha) {
        a2 = (a2 << 4) + a2;
      }
    }
    color2 = [r2, g2, b2, a2 / 255];
  } else if (s2.startsWith("rgba(")) {
    color2 = s2.slice(5, -1).split(",").map(Number);
    normalize$1(color2);
  } else if (s2.startsWith("rgb(")) {
    color2 = s2.slice(4, -1).split(",").map(Number);
    color2.push(1);
    normalize$1(color2);
  } else {
    assert(false, 14);
  }
  return color2;
}
function normalize$1(color2) {
  color2[0] = clamp(color2[0] + 0.5 | 0, 0, 255);
  color2[1] = clamp(color2[1] + 0.5 | 0, 0, 255);
  color2[2] = clamp(color2[2] + 0.5 | 0, 0, 255);
  color2[3] = clamp(color2[3], 0, 1);
  return color2;
}
function toString$d(color2) {
  let r2 = color2[0];
  if (r2 != (r2 | 0)) {
    r2 = r2 + 0.5 | 0;
  }
  let g2 = color2[1];
  if (g2 != (g2 | 0)) {
    g2 = g2 + 0.5 | 0;
  }
  let b2 = color2[2];
  if (b2 != (b2 | 0)) {
    b2 = b2 + 0.5 | 0;
  }
  const a2 = color2[3] === void 0 ? 1 : Math.round(color2[3] * 100) / 100;
  return "rgba(" + r2 + "," + g2 + "," + b2 + "," + a2 + ")";
}
function isStringColor(s2) {
  if (NAMED_COLOR_RE_.test(s2)) {
    s2 = fromNamed(s2);
  }
  return HEX_COLOR_RE_.test(s2) || s2.startsWith("rgba(") || s2.startsWith("rgb(");
}
class IconImageCache {
  constructor() {
    this.cache_ = {};
    this.cacheSize_ = 0;
    this.maxCacheSize_ = 32;
  }
  clear() {
    this.cache_ = {};
    this.cacheSize_ = 0;
  }
  canExpireCache() {
    return this.cacheSize_ > this.maxCacheSize_;
  }
  expire() {
    if (this.canExpireCache()) {
      let i2 = 0;
      for (const key in this.cache_) {
        const iconImage = this.cache_[key];
        if ((i2++ & 3) === 0 && !iconImage.hasListener()) {
          delete this.cache_[key];
          --this.cacheSize_;
        }
      }
    }
  }
  get(src, crossOrigin, color2) {
    const key = getKey$1(src, crossOrigin, color2);
    return key in this.cache_ ? this.cache_[key] : null;
  }
  set(src, crossOrigin, color2, iconImage) {
    const key = getKey$1(src, crossOrigin, color2);
    this.cache_[key] = iconImage;
    ++this.cacheSize_;
  }
  setSize(maxCacheSize) {
    this.maxCacheSize_ = maxCacheSize;
    this.expire();
  }
}
function getKey$1(src, crossOrigin, color2) {
  const colorString = color2 ? asString$1(color2) : "null";
  return crossOrigin + ":" + src + ":" + colorString;
}
const shared$5 = new IconImageCache();
var LayerProperty = {
  OPACITY: "opacity",
  VISIBLE: "visible",
  EXTENT: "extent",
  Z_INDEX: "zIndex",
  MAX_RESOLUTION: "maxResolution",
  MIN_RESOLUTION: "minResolution",
  MAX_ZOOM: "maxZoom",
  MIN_ZOOM: "minZoom",
  SOURCE: "source",
  MAP: "map"
};
class BaseLayer$1 extends BaseObject {
  constructor(options) {
    super();
    this.on;
    this.once;
    this.un;
    this.background_ = options.background;
    const properties = Object.assign({}, options);
    if (typeof options.properties === "object") {
      delete properties.properties;
      Object.assign(properties, options.properties);
    }
    properties[LayerProperty.OPACITY] = options.opacity !== void 0 ? options.opacity : 1;
    assert(typeof properties[LayerProperty.OPACITY] === "number", 64);
    properties[LayerProperty.VISIBLE] = options.visible !== void 0 ? options.visible : true;
    properties[LayerProperty.Z_INDEX] = options.zIndex;
    properties[LayerProperty.MAX_RESOLUTION] = options.maxResolution !== void 0 ? options.maxResolution : Infinity;
    properties[LayerProperty.MIN_RESOLUTION] = options.minResolution !== void 0 ? options.minResolution : 0;
    properties[LayerProperty.MIN_ZOOM] = options.minZoom !== void 0 ? options.minZoom : -Infinity;
    properties[LayerProperty.MAX_ZOOM] = options.maxZoom !== void 0 ? options.maxZoom : Infinity;
    this.className_ = properties.className !== void 0 ? properties.className : "ol-layer";
    delete properties.className;
    this.setProperties(properties);
    this.state_ = null;
  }
  getBackground() {
    return this.background_;
  }
  getClassName() {
    return this.className_;
  }
  getLayerState(managed) {
    const state = this.state_ || {
      layer: this,
      managed: managed === void 0 ? true : managed
    };
    const zIndex2 = this.getZIndex();
    state.opacity = clamp(Math.round(this.getOpacity() * 100) / 100, 0, 1);
    state.visible = this.getVisible();
    state.extent = this.getExtent();
    state.zIndex = zIndex2 === void 0 && !state.managed ? Infinity : zIndex2;
    state.maxResolution = this.getMaxResolution();
    state.minResolution = Math.max(this.getMinResolution(), 0);
    state.minZoom = this.getMinZoom();
    state.maxZoom = this.getMaxZoom();
    this.state_ = state;
    return state;
  }
  getLayersArray(array) {
    return abstract();
  }
  getLayerStatesArray(states) {
    return abstract();
  }
  getExtent() {
    return this.get(LayerProperty.EXTENT);
  }
  getMaxResolution() {
    return this.get(LayerProperty.MAX_RESOLUTION);
  }
  getMinResolution() {
    return this.get(LayerProperty.MIN_RESOLUTION);
  }
  getMinZoom() {
    return this.get(LayerProperty.MIN_ZOOM);
  }
  getMaxZoom() {
    return this.get(LayerProperty.MAX_ZOOM);
  }
  getOpacity() {
    return this.get(LayerProperty.OPACITY);
  }
  getSourceState() {
    return abstract();
  }
  getVisible() {
    return this.get(LayerProperty.VISIBLE);
  }
  getZIndex() {
    return this.get(LayerProperty.Z_INDEX);
  }
  setBackground(background) {
    this.background_ = background;
    this.changed();
  }
  setExtent(extent2) {
    this.set(LayerProperty.EXTENT, extent2);
  }
  setMaxResolution(maxResolution) {
    this.set(LayerProperty.MAX_RESOLUTION, maxResolution);
  }
  setMinResolution(minResolution) {
    this.set(LayerProperty.MIN_RESOLUTION, minResolution);
  }
  setMaxZoom(maxZoom) {
    this.set(LayerProperty.MAX_ZOOM, maxZoom);
  }
  setMinZoom(minZoom) {
    this.set(LayerProperty.MIN_ZOOM, minZoom);
  }
  setOpacity(opacity2) {
    assert(typeof opacity2 === "number", 64);
    this.set(LayerProperty.OPACITY, opacity2);
  }
  setVisible(visible) {
    this.set(LayerProperty.VISIBLE, visible);
  }
  setZIndex(zindex) {
    this.set(LayerProperty.Z_INDEX, zindex);
  }
  disposeInternal() {
    if (this.state_) {
      this.state_.layer = null;
      this.state_ = null;
    }
    super.disposeInternal();
  }
}
var RenderEventType = {
  PRERENDER: "prerender",
  POSTRENDER: "postrender",
  PRECOMPOSE: "precompose",
  POSTCOMPOSE: "postcompose",
  RENDERCOMPLETE: "rendercomplete"
};
class Layer extends BaseLayer$1 {
  constructor(options) {
    const baseOptions = Object.assign({}, options);
    delete baseOptions.source;
    super(baseOptions);
    this.on;
    this.once;
    this.un;
    this.mapPrecomposeKey_ = null;
    this.mapRenderKey_ = null;
    this.sourceChangeKey_ = null;
    this.renderer_ = null;
    this.sourceReady_ = false;
    this.rendered = false;
    if (options.render) {
      this.render = options.render;
    }
    if (options.map) {
      this.setMap(options.map);
    }
    this.addChangeListener(LayerProperty.SOURCE, this.handleSourcePropertyChange_);
    const source = options.source ? options.source : null;
    this.setSource(source);
  }
  getLayersArray(array) {
    array = array ? array : [];
    array.push(this);
    return array;
  }
  getLayerStatesArray(states) {
    states = states ? states : [];
    states.push(this.getLayerState());
    return states;
  }
  getSource() {
    return this.get(LayerProperty.SOURCE) || null;
  }
  getRenderSource() {
    return this.getSource();
  }
  getSourceState() {
    const source = this.getSource();
    return !source ? "undefined" : source.getState();
  }
  handleSourceChange_() {
    this.changed();
    if (this.sourceReady_ || this.getSource().getState() !== "ready") {
      return;
    }
    this.sourceReady_ = true;
    this.dispatchEvent("sourceready");
  }
  handleSourcePropertyChange_() {
    if (this.sourceChangeKey_) {
      unlistenByKey(this.sourceChangeKey_);
      this.sourceChangeKey_ = null;
    }
    this.sourceReady_ = false;
    const source = this.getSource();
    if (source) {
      this.sourceChangeKey_ = listen(source, EventType.CHANGE, this.handleSourceChange_, this);
      if (source.getState() === "ready") {
        this.sourceReady_ = true;
        setTimeout(() => {
          this.dispatchEvent("sourceready");
        }, 0);
      }
    }
    this.changed();
  }
  getFeatures(pixel) {
    if (!this.renderer_) {
      return Promise.resolve([]);
    }
    return this.renderer_.getFeatures(pixel);
  }
  getData(pixel) {
    if (!this.renderer_ || !this.rendered) {
      return null;
    }
    return this.renderer_.getData(pixel);
  }
  render(frameState, target) {
    const layerRenderer = this.getRenderer();
    if (layerRenderer.prepareFrame(frameState)) {
      this.rendered = true;
      return layerRenderer.renderFrame(frameState, target);
    }
  }
  unrender() {
    this.rendered = false;
  }
  setMapInternal(map) {
    if (!map) {
      this.unrender();
    }
    this.set(LayerProperty.MAP, map);
  }
  getMapInternal() {
    return this.get(LayerProperty.MAP);
  }
  setMap(map) {
    if (this.mapPrecomposeKey_) {
      unlistenByKey(this.mapPrecomposeKey_);
      this.mapPrecomposeKey_ = null;
    }
    if (!map) {
      this.changed();
    }
    if (this.mapRenderKey_) {
      unlistenByKey(this.mapRenderKey_);
      this.mapRenderKey_ = null;
    }
    if (map) {
      this.mapPrecomposeKey_ = listen(map, RenderEventType.PRECOMPOSE, function(evt) {
        const renderEvent = evt;
        const layerStatesArray = renderEvent.frameState.layerStatesArray;
        const layerState = this.getLayerState(false);
        assert(!layerStatesArray.some(function(arrayLayerState) {
          return arrayLayerState.layer === layerState.layer;
        }), 67);
        layerStatesArray.push(layerState);
      }, this);
      this.mapRenderKey_ = listen(this, EventType.CHANGE, map.render, map);
      this.changed();
    }
  }
  setSource(source) {
    this.set(LayerProperty.SOURCE, source);
  }
  getRenderer() {
    if (!this.renderer_) {
      this.renderer_ = this.createRenderer();
    }
    return this.renderer_;
  }
  hasRenderer() {
    return !!this.renderer_;
  }
  createRenderer() {
    return null;
  }
  disposeInternal() {
    if (this.renderer_) {
      this.renderer_.dispose();
      delete this.renderer_;
    }
    this.setSource(null);
    super.disposeInternal();
  }
}
function inView(layerState, viewState) {
  if (!layerState.visible) {
    return false;
  }
  const resolution = viewState.resolution;
  if (resolution < layerState.minResolution || resolution >= layerState.maxResolution) {
    return false;
  }
  const zoom = viewState.zoom;
  return zoom > layerState.minZoom && zoom <= layerState.maxZoom;
}
function padNumber(number, width, precision) {
  const numberString = precision !== void 0 ? number.toFixed(precision) : "" + number;
  let decimal = numberString.indexOf(".");
  decimal = decimal === -1 ? numberString.length : decimal;
  return decimal > width ? numberString : new Array(1 + width - decimal).join("0") + numberString;
}
function compareVersions(v1, v2) {
  const s1 = ("" + v1).split(".");
  const s2 = ("" + v2).split(".");
  for (let i2 = 0; i2 < Math.max(s1.length, s2.length); i2++) {
    const n1 = parseInt(s1[i2] || "0", 10);
    const n2 = parseInt(s2[i2] || "0", 10);
    if (n1 > n2) {
      return 1;
    }
    if (n2 > n1) {
      return -1;
    }
  }
  return 0;
}
function add$3(coordinate, delta) {
  coordinate[0] += +delta[0];
  coordinate[1] += +delta[1];
  return coordinate;
}
function closestOnCircle(coordinate, circle) {
  const r2 = circle.getRadius();
  const center = circle.getCenter();
  const x0 = center[0];
  const y0 = center[1];
  const x1 = coordinate[0];
  const y1 = coordinate[1];
  let dx = x1 - x0;
  const dy = y1 - y0;
  if (dx === 0 && dy === 0) {
    dx = 1;
  }
  const d2 = Math.sqrt(dx * dx + dy * dy);
  const x2 = x0 + r2 * dx / d2;
  const y2 = y0 + r2 * dy / d2;
  return [x2, y2];
}
function closestOnSegment(coordinate, segment) {
  const x0 = coordinate[0];
  const y0 = coordinate[1];
  const start2 = segment[0];
  const end = segment[1];
  const x1 = start2[0];
  const y1 = start2[1];
  const x2 = end[0];
  const y2 = end[1];
  const dx = x2 - x1;
  const dy = y2 - y1;
  const along = dx === 0 && dy === 0 ? 0 : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);
  let x3, y3;
  if (along <= 0) {
    x3 = x1;
    y3 = y1;
  } else if (along >= 1) {
    x3 = x2;
    y3 = y2;
  } else {
    x3 = x1 + along * dx;
    y3 = y1 + along * dy;
  }
  return [x3, y3];
}
function equals$1(coordinate1, coordinate2) {
  let equals2 = true;
  for (let i2 = coordinate1.length - 1; i2 >= 0; --i2) {
    if (coordinate1[i2] != coordinate2[i2]) {
      equals2 = false;
      break;
    }
  }
  return equals2;
}
function rotate$1(coordinate, angle2) {
  const cosAngle = Math.cos(angle2);
  const sinAngle = Math.sin(angle2);
  const x2 = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  const y2 = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  coordinate[0] = x2;
  coordinate[1] = y2;
  return coordinate;
}
function scale$2(coordinate, scale2) {
  coordinate[0] *= scale2;
  coordinate[1] *= scale2;
  return coordinate;
}
function squaredDistance(coord1, coord2) {
  const dx = coord1[0] - coord2[0];
  const dy = coord1[1] - coord2[1];
  return dx * dx + dy * dy;
}
function distance$1(coord1, coord2) {
  return Math.sqrt(squaredDistance(coord1, coord2));
}
function squaredDistanceToSegment(coordinate, segment) {
  return squaredDistance(coordinate, closestOnSegment(coordinate, segment));
}
function wrapX$1(coordinate, projection) {
  if (projection.canWrapX()) {
    const worldWidth = getWidth(projection.getExtent());
    const worldsAway = getWorldsAway(coordinate, projection, worldWidth);
    if (worldsAway) {
      coordinate[0] -= worldsAway * worldWidth;
    }
  }
  return coordinate;
}
function getWorldsAway(coordinate, projection, sourceExtentWidth) {
  const projectionExtent = projection.getExtent();
  let worldsAway = 0;
  if (projection.canWrapX() && (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])) {
    sourceExtentWidth = sourceExtentWidth || getWidth(projectionExtent);
    worldsAway = Math.floor((coordinate[0] - projectionExtent[0]) / sourceExtentWidth);
  }
  return worldsAway;
}
class MapRenderer extends Disposable {
  constructor(map) {
    super();
    this.map_ = map;
  }
  dispatchRenderEvent(type, frameState) {
    abstract();
  }
  calculateMatrices2D(frameState) {
    const viewState = frameState.viewState;
    const coordinateToPixelTransform = frameState.coordinateToPixelTransform;
    const pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;
    compose(coordinateToPixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / viewState.resolution, -1 / viewState.resolution, -viewState.rotation, -viewState.center[0], -viewState.center[1]);
    makeInverse(pixelToCoordinateTransform, coordinateToPixelTransform);
  }
  forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, callback, thisArg, layerFilter, thisArg2) {
    let result;
    const viewState = frameState.viewState;
    function forEachFeatureAtCoordinate(managed, feature, layer, geometry) {
      return callback.call(thisArg, feature, managed ? layer : null, geometry);
    }
    const projection = viewState.projection;
    const translatedCoordinate = wrapX$1(coordinate.slice(), projection);
    const offsets = [[0, 0]];
    if (projection.canWrapX() && checkWrapped) {
      const projectionExtent = projection.getExtent();
      const worldWidth = getWidth(projectionExtent);
      offsets.push([-worldWidth, 0], [worldWidth, 0]);
    }
    const layerStates = frameState.layerStatesArray;
    const numLayers = layerStates.length;
    const matches = [];
    const tmpCoord = [];
    for (let i2 = 0; i2 < offsets.length; i2++) {
      for (let j2 = numLayers - 1; j2 >= 0; --j2) {
        const layerState = layerStates[j2];
        const layer = layerState.layer;
        if (layer.hasRenderer() && inView(layerState, viewState) && layerFilter.call(thisArg2, layer)) {
          const layerRenderer = layer.getRenderer();
          const source = layer.getSource();
          if (layerRenderer && source) {
            const coordinates2 = source.getWrapX() ? translatedCoordinate : coordinate;
            const callback2 = forEachFeatureAtCoordinate.bind(null, layerState.managed);
            tmpCoord[0] = coordinates2[0] + offsets[i2][0];
            tmpCoord[1] = coordinates2[1] + offsets[i2][1];
            result = layerRenderer.forEachFeatureAtCoordinate(tmpCoord, frameState, hitTolerance, callback2, matches);
          }
          if (result) {
            return result;
          }
        }
      }
    }
    if (matches.length === 0) {
      return void 0;
    }
    const order = 1 / matches.length;
    matches.forEach((m2, i2) => m2.distanceSq += i2 * order);
    matches.sort((a2, b2) => a2.distanceSq - b2.distanceSq);
    matches.some((m2) => {
      return result = m2.callback(m2.feature, m2.layer, m2.geometry);
    });
    return result;
  }
  hasFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, layerFilter, thisArg) {
    const hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, TRUE, this, layerFilter, thisArg);
    return hasFeature !== void 0;
  }
  getMap() {
    return this.map_;
  }
  renderFrame(frameState) {
    abstract();
  }
  scheduleExpireIconCache(frameState) {
    if (shared$5.canExpireCache()) {
      frameState.postRenderFunctions.push(expireIconCache);
    }
  }
}
function expireIconCache(map, frameState) {
  shared$5.expire();
}
class RenderEvent extends BaseEvent {
  constructor(type, inversePixelTransform, frameState, context2) {
    super(type);
    this.inversePixelTransform = inversePixelTransform;
    this.frameState = frameState;
    this.context = context2;
  }
}
const CLASS_HIDDEN = "ol-hidden";
const CLASS_SELECTABLE = "ol-selectable";
const CLASS_UNSELECTABLE = "ol-unselectable";
const CLASS_UNSUPPORTED = "ol-unsupported";
const CLASS_CONTROL = "ol-control";
const CLASS_COLLAPSED = "ol-collapsed";
const fontRegEx = new RegExp([
  "^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)",
  "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)",
  "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)",
  "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?",
  "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))",
  "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))",
  `?\\s*([-,\\"\\'\\sa-z]+?)\\s*$`
].join(""), "i");
const fontRegExMatchIndex = [
  "style",
  "variant",
  "weight",
  "size",
  "lineHeight",
  "family"
];
const getFontParameters = function(fontSpec) {
  const match2 = fontSpec.match(fontRegEx);
  if (!match2) {
    return null;
  }
  const style2 = {
    lineHeight: "normal",
    size: "1.2em",
    style: "normal",
    weight: "normal",
    variant: "normal"
  };
  for (let i2 = 0, ii = fontRegExMatchIndex.length; i2 < ii; ++i2) {
    const value = match2[i2 + 1];
    if (value !== void 0) {
      style2[fontRegExMatchIndex[i2]] = value;
    }
  }
  style2.families = style2.family.split(/,\s?/);
  return style2;
};
function createCanvasContext2D(width, height, canvasPool2, settings) {
  let canvas;
  if (canvasPool2 && canvasPool2.length) {
    canvas = canvasPool2.shift();
  } else if (WORKER_OFFSCREEN_CANVAS) {
    canvas = new OffscreenCanvas(width || 300, height || 300);
  } else {
    canvas = document.createElement("canvas");
  }
  if (width) {
    canvas.width = width;
  }
  if (height) {
    canvas.height = height;
  }
  return canvas.getContext("2d", settings);
}
function releaseCanvas$1(context2) {
  const canvas = context2.canvas;
  canvas.width = 1;
  canvas.height = 1;
  context2.clearRect(0, 0, 1, 1);
}
function outerWidth(element) {
  let width = element.offsetWidth;
  const style2 = getComputedStyle(element);
  width += parseInt(style2.marginLeft, 10) + parseInt(style2.marginRight, 10);
  return width;
}
function outerHeight(element) {
  let height = element.offsetHeight;
  const style2 = getComputedStyle(element);
  height += parseInt(style2.marginTop, 10) + parseInt(style2.marginBottom, 10);
  return height;
}
function replaceNode(newNode, oldNode) {
  const parent = oldNode.parentNode;
  if (parent) {
    parent.replaceChild(newNode, oldNode);
  }
}
function removeNode$1(node2) {
  return node2 && node2.parentNode ? node2.parentNode.removeChild(node2) : null;
}
function removeChildren(node2) {
  while (node2.lastChild) {
    node2.removeChild(node2.lastChild);
  }
}
function replaceChildren(node2, children) {
  const oldChildren = node2.childNodes;
  for (let i2 = 0; true; ++i2) {
    const oldChild = oldChildren[i2];
    const newChild = children[i2];
    if (!oldChild && !newChild) {
      break;
    }
    if (oldChild === newChild) {
      continue;
    }
    if (!oldChild) {
      node2.appendChild(newChild);
      continue;
    }
    if (!newChild) {
      node2.removeChild(oldChild);
      --i2;
      continue;
    }
    node2.insertBefore(newChild, oldChild);
  }
}
const defaultFont = "10px sans-serif";
const defaultFillStyle = "#000";
const defaultLineCap = "round";
const defaultLineDash = [];
const defaultLineDashOffset = 0;
const defaultLineJoin = "round";
const defaultMiterLimit = 10;
const defaultStrokeStyle = "#000";
const defaultTextAlign = "center";
const defaultTextBaseline = "middle";
const defaultPadding = [0, 0, 0, 0];
const defaultLineWidth = 1;
const checkedFonts = new BaseObject();
let measureContext = null;
let measureFont;
const textHeights = {};
const registerFont = function() {
  const retries = 100;
  const size = "32px ";
  const referenceFonts = ["monospace", "serif"];
  const len = referenceFonts.length;
  const text2 = "wmytzilWMYTZIL@#/&?$%10\uF013";
  let interval, referenceWidth;
  function isAvailable(fontStyle2, fontWeight2, fontFamily2) {
    let available = true;
    for (let i2 = 0; i2 < len; ++i2) {
      const referenceFont = referenceFonts[i2];
      referenceWidth = measureTextWidth(fontStyle2 + " " + fontWeight2 + " " + size + referenceFont, text2);
      if (fontFamily2 != referenceFont) {
        const width = measureTextWidth(fontStyle2 + " " + fontWeight2 + " " + size + fontFamily2 + "," + referenceFont, text2);
        available = available && width != referenceWidth;
      }
    }
    if (available) {
      return true;
    }
    return false;
  }
  function check2() {
    let done = true;
    const fonts = checkedFonts.getKeys();
    for (let i2 = 0, ii = fonts.length; i2 < ii; ++i2) {
      const font = fonts[i2];
      if (checkedFonts.get(font) < retries) {
        if (isAvailable.apply(this, font.split("\n"))) {
          clear$1(textHeights);
          measureContext = null;
          measureFont = void 0;
          checkedFonts.set(font, retries);
        } else {
          checkedFonts.set(font, checkedFonts.get(font) + 1, true);
          done = false;
        }
      }
    }
    if (done) {
      clearInterval(interval);
      interval = void 0;
    }
  }
  return function(fontSpec) {
    const font = getFontParameters(fontSpec);
    if (!font) {
      return;
    }
    const families = font.families;
    for (let i2 = 0, ii = families.length; i2 < ii; ++i2) {
      const family = families[i2];
      const key = font.style + "\n" + font.weight + "\n" + family;
      if (checkedFonts.get(key) === void 0) {
        checkedFonts.set(key, retries, true);
        if (!isAvailable(font.style, font.weight, family)) {
          checkedFonts.set(key, 0, true);
          if (interval === void 0) {
            interval = setInterval(check2, 32);
          }
        }
      }
    }
  };
}();
const measureTextHeight = function() {
  let measureElement;
  return function(fontSpec) {
    let height = textHeights[fontSpec];
    if (height == void 0) {
      if (WORKER_OFFSCREEN_CANVAS) {
        const font = getFontParameters(fontSpec);
        const metrics = measureText(fontSpec, "\u017Dg");
        const lineHeight2 = isNaN(Number(font.lineHeight)) ? 1.2 : Number(font.lineHeight);
        height = lineHeight2 * (metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent);
      } else {
        if (!measureElement) {
          measureElement = document.createElement("div");
          measureElement.innerHTML = "M";
          measureElement.style.minHeight = "0";
          measureElement.style.maxHeight = "none";
          measureElement.style.height = "auto";
          measureElement.style.padding = "0";
          measureElement.style.border = "none";
          measureElement.style.position = "absolute";
          measureElement.style.display = "block";
          measureElement.style.left = "-99999px";
        }
        measureElement.style.font = fontSpec;
        document.body.appendChild(measureElement);
        height = measureElement.offsetHeight;
        document.body.removeChild(measureElement);
      }
      textHeights[fontSpec] = height;
    }
    return height;
  };
}();
function measureText(font, text2) {
  if (!measureContext) {
    measureContext = createCanvasContext2D(1, 1);
  }
  if (font != measureFont) {
    measureContext.font = font;
    measureFont = measureContext.font;
  }
  return measureContext.measureText(text2);
}
function measureTextWidth(font, text2) {
  return measureText(font, text2).width;
}
function measureAndCacheTextWidth(font, text2, cache2) {
  if (text2 in cache2) {
    return cache2[text2];
  }
  const width = text2.split("\n").reduce((prev, curr) => Math.max(prev, measureTextWidth(font, curr)), 0);
  cache2[text2] = width;
  return width;
}
function getTextDimensions(baseStyle, chunks) {
  const widths = [];
  const heights = [];
  const lineWidths = [];
  let width = 0;
  let lineWidth = 0;
  let height = 0;
  let lineHeight2 = 0;
  for (let i2 = 0, ii = chunks.length; i2 <= ii; i2 += 2) {
    const text2 = chunks[i2];
    if (text2 === "\n" || i2 === ii) {
      width = Math.max(width, lineWidth);
      lineWidths.push(lineWidth);
      lineWidth = 0;
      height += lineHeight2;
      continue;
    }
    const font = chunks[i2 + 1] || baseStyle.font;
    const currentWidth = measureTextWidth(font, text2);
    widths.push(currentWidth);
    lineWidth += currentWidth;
    const currentHeight = measureTextHeight(font);
    heights.push(currentHeight);
    lineHeight2 = Math.max(lineHeight2, currentHeight);
  }
  return { width, height, widths, heights, lineWidths };
}
function drawImageOrLabel(context2, transform2, opacity2, labelOrImage, originX, originY, w2, h2, x2, y2, scale2) {
  context2.save();
  if (opacity2 !== 1) {
    context2.globalAlpha *= opacity2;
  }
  if (transform2) {
    context2.setTransform.apply(context2, transform2);
  }
  if (labelOrImage.contextInstructions) {
    context2.translate(x2, y2);
    context2.scale(scale2[0], scale2[1]);
    executeLabelInstructions(labelOrImage, context2);
  } else if (scale2[0] < 0 || scale2[1] < 0) {
    context2.translate(x2, y2);
    context2.scale(scale2[0], scale2[1]);
    context2.drawImage(labelOrImage, originX, originY, w2, h2, 0, 0, w2, h2);
  } else {
    context2.drawImage(labelOrImage, originX, originY, w2, h2, x2, y2, w2 * scale2[0], h2 * scale2[1]);
  }
  context2.restore();
}
function executeLabelInstructions(label, context2) {
  const contextInstructions = label.contextInstructions;
  for (let i2 = 0, ii = contextInstructions.length; i2 < ii; i2 += 2) {
    if (Array.isArray(contextInstructions[i2 + 1])) {
      context2[contextInstructions[i2]].apply(context2, contextInstructions[i2 + 1]);
    } else {
      context2[contextInstructions[i2]] = contextInstructions[i2 + 1];
    }
  }
}
class CompositeMapRenderer extends MapRenderer {
  constructor(map) {
    super(map);
    this.fontChangeListenerKey_ = listen(checkedFonts, ObjectEventType.PROPERTYCHANGE, map.redrawText.bind(map));
    this.element_ = document.createElement("div");
    const style2 = this.element_.style;
    style2.position = "absolute";
    style2.width = "100%";
    style2.height = "100%";
    style2.zIndex = "0";
    this.element_.className = CLASS_UNSELECTABLE + " ol-layers";
    const container = map.getViewport();
    container.insertBefore(this.element_, container.firstChild || null);
    this.children_ = [];
    this.renderedVisible_ = true;
  }
  dispatchRenderEvent(type, frameState) {
    const map = this.getMap();
    if (map.hasListener(type)) {
      const event = new RenderEvent(type, void 0, frameState);
      map.dispatchEvent(event);
    }
  }
  disposeInternal() {
    unlistenByKey(this.fontChangeListenerKey_);
    this.element_.parentNode.removeChild(this.element_);
    super.disposeInternal();
  }
  renderFrame(frameState) {
    if (!frameState) {
      if (this.renderedVisible_) {
        this.element_.style.display = "none";
        this.renderedVisible_ = false;
      }
      return;
    }
    this.calculateMatrices2D(frameState);
    this.dispatchRenderEvent(RenderEventType.PRECOMPOSE, frameState);
    const layerStatesArray = frameState.layerStatesArray.sort(function(a2, b2) {
      return a2.zIndex - b2.zIndex;
    });
    const viewState = frameState.viewState;
    this.children_.length = 0;
    const declutterLayers = [];
    let previousElement = null;
    for (let i2 = 0, ii = layerStatesArray.length; i2 < ii; ++i2) {
      const layerState = layerStatesArray[i2];
      frameState.layerIndex = i2;
      const layer = layerState.layer;
      const sourceState = layer.getSourceState();
      if (!inView(layerState, viewState) || sourceState != "ready" && sourceState != "undefined") {
        layer.unrender();
        continue;
      }
      const element = layer.render(frameState, previousElement);
      if (!element) {
        continue;
      }
      if (element !== previousElement) {
        this.children_.push(element);
        previousElement = element;
      }
      if ("getDeclutter" in layer) {
        declutterLayers.push(layer);
      }
    }
    for (let i2 = declutterLayers.length - 1; i2 >= 0; --i2) {
      declutterLayers[i2].renderDeclutter(frameState);
    }
    replaceChildren(this.element_, this.children_);
    this.dispatchRenderEvent(RenderEventType.POSTCOMPOSE, frameState);
    if (!this.renderedVisible_) {
      this.element_.style.display = "";
      this.renderedVisible_ = true;
    }
    this.scheduleExpireIconCache(frameState);
  }
}
class GroupEvent extends BaseEvent {
  constructor(type, layer) {
    super(type);
    this.layer = layer;
  }
}
const Property$5 = {
  LAYERS: "layers"
};
class LayerGroup extends BaseLayer$1 {
  constructor(options) {
    options = options || {};
    const baseOptions = Object.assign({}, options);
    delete baseOptions.layers;
    let layers = options.layers;
    super(baseOptions);
    this.on;
    this.once;
    this.un;
    this.layersListenerKeys_ = [];
    this.listenerKeys_ = {};
    this.addChangeListener(Property$5.LAYERS, this.handleLayersChanged_);
    if (layers) {
      if (Array.isArray(layers)) {
        layers = new Collection(layers.slice(), { unique: true });
      } else {
        assert(typeof layers.getArray === "function", 43);
      }
    } else {
      layers = new Collection(void 0, { unique: true });
    }
    this.setLayers(layers);
  }
  handleLayerChange_() {
    this.changed();
  }
  handleLayersChanged_() {
    this.layersListenerKeys_.forEach(unlistenByKey);
    this.layersListenerKeys_.length = 0;
    const layers = this.getLayers();
    this.layersListenerKeys_.push(listen(layers, CollectionEventType.ADD, this.handleLayersAdd_, this), listen(layers, CollectionEventType.REMOVE, this.handleLayersRemove_, this));
    for (const id in this.listenerKeys_) {
      this.listenerKeys_[id].forEach(unlistenByKey);
    }
    clear$1(this.listenerKeys_);
    const layersArray = layers.getArray();
    for (let i2 = 0, ii = layersArray.length; i2 < ii; i2++) {
      const layer = layersArray[i2];
      this.registerLayerListeners_(layer);
      this.dispatchEvent(new GroupEvent("addlayer", layer));
    }
    this.changed();
  }
  registerLayerListeners_(layer) {
    const listenerKeys = [
      listen(layer, ObjectEventType.PROPERTYCHANGE, this.handleLayerChange_, this),
      listen(layer, EventType.CHANGE, this.handleLayerChange_, this)
    ];
    if (layer instanceof LayerGroup) {
      listenerKeys.push(listen(layer, "addlayer", this.handleLayerGroupAdd_, this), listen(layer, "removelayer", this.handleLayerGroupRemove_, this));
    }
    this.listenerKeys_[getUid(layer)] = listenerKeys;
  }
  handleLayerGroupAdd_(event) {
    this.dispatchEvent(new GroupEvent("addlayer", event.layer));
  }
  handleLayerGroupRemove_(event) {
    this.dispatchEvent(new GroupEvent("removelayer", event.layer));
  }
  handleLayersAdd_(collectionEvent) {
    const layer = collectionEvent.element;
    this.registerLayerListeners_(layer);
    this.dispatchEvent(new GroupEvent("addlayer", layer));
    this.changed();
  }
  handleLayersRemove_(collectionEvent) {
    const layer = collectionEvent.element;
    const key = getUid(layer);
    this.listenerKeys_[key].forEach(unlistenByKey);
    delete this.listenerKeys_[key];
    this.dispatchEvent(new GroupEvent("removelayer", layer));
    this.changed();
  }
  getLayers() {
    return this.get(Property$5.LAYERS);
  }
  setLayers(layers) {
    const collection = this.getLayers();
    if (collection) {
      const currentLayers = collection.getArray();
      for (let i2 = 0, ii = currentLayers.length; i2 < ii; ++i2) {
        this.dispatchEvent(new GroupEvent("removelayer", currentLayers[i2]));
      }
    }
    this.set(Property$5.LAYERS, layers);
  }
  getLayersArray(array) {
    array = array !== void 0 ? array : [];
    this.getLayers().forEach(function(layer) {
      layer.getLayersArray(array);
    });
    return array;
  }
  getLayerStatesArray(dest) {
    const states = dest !== void 0 ? dest : [];
    const pos = states.length;
    this.getLayers().forEach(function(layer) {
      layer.getLayerStatesArray(states);
    });
    const ownLayerState = this.getLayerState();
    let defaultZIndex = ownLayerState.zIndex;
    if (!dest && ownLayerState.zIndex === void 0) {
      defaultZIndex = 0;
    }
    for (let i2 = pos, ii = states.length; i2 < ii; i2++) {
      const layerState = states[i2];
      layerState.opacity *= ownLayerState.opacity;
      layerState.visible = layerState.visible && ownLayerState.visible;
      layerState.maxResolution = Math.min(layerState.maxResolution, ownLayerState.maxResolution);
      layerState.minResolution = Math.max(layerState.minResolution, ownLayerState.minResolution);
      layerState.minZoom = Math.max(layerState.minZoom, ownLayerState.minZoom);
      layerState.maxZoom = Math.min(layerState.maxZoom, ownLayerState.maxZoom);
      if (ownLayerState.extent !== void 0) {
        if (layerState.extent !== void 0) {
          layerState.extent = getIntersection(layerState.extent, ownLayerState.extent);
        } else {
          layerState.extent = ownLayerState.extent;
        }
      }
      if (layerState.zIndex === void 0) {
        layerState.zIndex = defaultZIndex;
      }
    }
    return states;
  }
  getSourceState() {
    return "ready";
  }
}
class MapEvent extends BaseEvent {
  constructor(type, map, frameState) {
    super(type);
    this.map = map;
    this.frameState = frameState !== void 0 ? frameState : null;
  }
}
class MapBrowserEvent extends MapEvent {
  constructor(type, map, originalEvent, dragging, frameState, activePointers) {
    super(type, map, frameState);
    this.originalEvent = originalEvent;
    this.pixel_ = null;
    this.coordinate_ = null;
    this.dragging = dragging !== void 0 ? dragging : false;
    this.activePointers = activePointers;
  }
  get pixel() {
    if (!this.pixel_) {
      this.pixel_ = this.map.getEventPixel(this.originalEvent);
    }
    return this.pixel_;
  }
  set pixel(pixel) {
    this.pixel_ = pixel;
  }
  get coordinate() {
    if (!this.coordinate_) {
      this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel);
    }
    return this.coordinate_;
  }
  set coordinate(coordinate) {
    this.coordinate_ = coordinate;
  }
  preventDefault() {
    super.preventDefault();
    if ("preventDefault" in this.originalEvent) {
      this.originalEvent.preventDefault();
    }
  }
  stopPropagation() {
    super.stopPropagation();
    if ("stopPropagation" in this.originalEvent) {
      this.originalEvent.stopPropagation();
    }
  }
}
var MapBrowserEventType = {
  SINGLECLICK: "singleclick",
  CLICK: EventType.CLICK,
  DBLCLICK: EventType.DBLCLICK,
  POINTERDRAG: "pointerdrag",
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown",
  POINTERUP: "pointerup",
  POINTEROVER: "pointerover",
  POINTEROUT: "pointerout",
  POINTERENTER: "pointerenter",
  POINTERLEAVE: "pointerleave",
  POINTERCANCEL: "pointercancel"
};
var PointerEventType = {
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown",
  POINTERUP: "pointerup",
  POINTEROVER: "pointerover",
  POINTEROUT: "pointerout",
  POINTERENTER: "pointerenter",
  POINTERLEAVE: "pointerleave",
  POINTERCANCEL: "pointercancel"
};
class MapBrowserEventHandler extends Target {
  constructor(map, moveTolerance) {
    super(map);
    this.map_ = map;
    this.clickTimeoutId_;
    this.emulateClicks_ = false;
    this.dragging_ = false;
    this.dragListenerKeys_ = [];
    this.moveTolerance_ = moveTolerance === void 0 ? 1 : moveTolerance;
    this.down_ = null;
    const element = this.map_.getViewport();
    this.activePointers_ = [];
    this.trackedTouches_ = {};
    this.element_ = element;
    this.pointerdownListenerKey_ = listen(element, PointerEventType.POINTERDOWN, this.handlePointerDown_, this);
    this.originalPointerMoveEvent_;
    this.relayedListenerKey_ = listen(element, PointerEventType.POINTERMOVE, this.relayMoveEvent_, this);
    this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this);
    this.element_.addEventListener(EventType.TOUCHMOVE, this.boundHandleTouchMove_, PASSIVE_EVENT_LISTENERS ? { passive: false } : false);
  }
  emulateClick_(pointerEvent) {
    let newEvent = new MapBrowserEvent(MapBrowserEventType.CLICK, this.map_, pointerEvent);
    this.dispatchEvent(newEvent);
    if (this.clickTimeoutId_ !== void 0) {
      clearTimeout(this.clickTimeoutId_);
      this.clickTimeoutId_ = void 0;
      newEvent = new MapBrowserEvent(MapBrowserEventType.DBLCLICK, this.map_, pointerEvent);
      this.dispatchEvent(newEvent);
    } else {
      this.clickTimeoutId_ = setTimeout(() => {
        this.clickTimeoutId_ = void 0;
        const newEvent2 = new MapBrowserEvent(MapBrowserEventType.SINGLECLICK, this.map_, pointerEvent);
        this.dispatchEvent(newEvent2);
      }, 250);
    }
  }
  updateActivePointers_(pointerEvent) {
    const event = pointerEvent;
    const id = event.pointerId;
    if (event.type == MapBrowserEventType.POINTERUP || event.type == MapBrowserEventType.POINTERCANCEL) {
      delete this.trackedTouches_[id];
      for (const pointerId in this.trackedTouches_) {
        if (this.trackedTouches_[pointerId].target !== event.target) {
          delete this.trackedTouches_[pointerId];
          break;
        }
      }
    } else if (event.type == MapBrowserEventType.POINTERDOWN || event.type == MapBrowserEventType.POINTERMOVE) {
      this.trackedTouches_[id] = event;
    }
    this.activePointers_ = Object.values(this.trackedTouches_);
  }
  handlePointerUp_(pointerEvent) {
    this.updateActivePointers_(pointerEvent);
    const newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERUP, this.map_, pointerEvent, void 0, void 0, this.activePointers_);
    this.dispatchEvent(newEvent);
    if (this.emulateClicks_ && !newEvent.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {
      this.emulateClick_(this.down_);
    }
    if (this.activePointers_.length === 0) {
      this.dragListenerKeys_.forEach(unlistenByKey);
      this.dragListenerKeys_.length = 0;
      this.dragging_ = false;
      this.down_ = null;
    }
  }
  isMouseActionButton_(pointerEvent) {
    return pointerEvent.button === 0;
  }
  handlePointerDown_(pointerEvent) {
    this.emulateClicks_ = this.activePointers_.length === 0;
    this.updateActivePointers_(pointerEvent);
    const newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERDOWN, this.map_, pointerEvent, void 0, void 0, this.activePointers_);
    this.dispatchEvent(newEvent);
    this.down_ = {};
    for (const property in pointerEvent) {
      const value = pointerEvent[property];
      this.down_[property] = typeof value === "function" ? VOID : value;
    }
    if (this.dragListenerKeys_.length === 0) {
      const doc = this.map_.getOwnerDocument();
      this.dragListenerKeys_.push(listen(doc, MapBrowserEventType.POINTERMOVE, this.handlePointerMove_, this), listen(doc, MapBrowserEventType.POINTERUP, this.handlePointerUp_, this), listen(this.element_, MapBrowserEventType.POINTERCANCEL, this.handlePointerUp_, this));
      if (this.element_.getRootNode && this.element_.getRootNode() !== doc) {
        this.dragListenerKeys_.push(listen(this.element_.getRootNode(), MapBrowserEventType.POINTERUP, this.handlePointerUp_, this));
      }
    }
  }
  handlePointerMove_(pointerEvent) {
    if (this.isMoving_(pointerEvent)) {
      this.updateActivePointers_(pointerEvent);
      this.dragging_ = true;
      const newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERDRAG, this.map_, pointerEvent, this.dragging_, void 0, this.activePointers_);
      this.dispatchEvent(newEvent);
    }
  }
  relayMoveEvent_(pointerEvent) {
    this.originalPointerMoveEvent_ = pointerEvent;
    const dragging = !!(this.down_ && this.isMoving_(pointerEvent));
    this.dispatchEvent(new MapBrowserEvent(MapBrowserEventType.POINTERMOVE, this.map_, pointerEvent, dragging));
  }
  handleTouchMove_(event) {
    const originalEvent = this.originalPointerMoveEvent_;
    if ((!originalEvent || originalEvent.defaultPrevented) && (typeof event.cancelable !== "boolean" || event.cancelable === true)) {
      event.preventDefault();
    }
  }
  isMoving_(pointerEvent) {
    return this.dragging_ || Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;
  }
  disposeInternal() {
    if (this.relayedListenerKey_) {
      unlistenByKey(this.relayedListenerKey_);
      this.relayedListenerKey_ = null;
    }
    this.element_.removeEventListener(EventType.TOUCHMOVE, this.boundHandleTouchMove_);
    if (this.pointerdownListenerKey_) {
      unlistenByKey(this.pointerdownListenerKey_);
      this.pointerdownListenerKey_ = null;
    }
    this.dragListenerKeys_.forEach(unlistenByKey);
    this.dragListenerKeys_.length = 0;
    this.element_ = null;
    super.disposeInternal();
  }
}
var MapEventType = {
  POSTRENDER: "postrender",
  MOVESTART: "movestart",
  MOVEEND: "moveend",
  LOADSTART: "loadstart",
  LOADEND: "loadend"
};
var MapProperty = {
  LAYERGROUP: "layergroup",
  SIZE: "size",
  TARGET: "target",
  VIEW: "view"
};
const DROP = Infinity;
class PriorityQueue {
  constructor(priorityFunction, keyFunction) {
    this.priorityFunction_ = priorityFunction;
    this.keyFunction_ = keyFunction;
    this.elements_ = [];
    this.priorities_ = [];
    this.queuedElements_ = {};
  }
  clear() {
    this.elements_.length = 0;
    this.priorities_.length = 0;
    clear$1(this.queuedElements_);
  }
  dequeue() {
    const elements2 = this.elements_;
    const priorities = this.priorities_;
    const element = elements2[0];
    if (elements2.length == 1) {
      elements2.length = 0;
      priorities.length = 0;
    } else {
      elements2[0] = elements2.pop();
      priorities[0] = priorities.pop();
      this.siftUp_(0);
    }
    const elementKey = this.keyFunction_(element);
    delete this.queuedElements_[elementKey];
    return element;
  }
  enqueue(element) {
    assert(!(this.keyFunction_(element) in this.queuedElements_), 31);
    const priority = this.priorityFunction_(element);
    if (priority != DROP) {
      this.elements_.push(element);
      this.priorities_.push(priority);
      this.queuedElements_[this.keyFunction_(element)] = true;
      this.siftDown_(0, this.elements_.length - 1);
      return true;
    }
    return false;
  }
  getCount() {
    return this.elements_.length;
  }
  getLeftChildIndex_(index2) {
    return index2 * 2 + 1;
  }
  getRightChildIndex_(index2) {
    return index2 * 2 + 2;
  }
  getParentIndex_(index2) {
    return index2 - 1 >> 1;
  }
  heapify_() {
    let i2;
    for (i2 = (this.elements_.length >> 1) - 1; i2 >= 0; i2--) {
      this.siftUp_(i2);
    }
  }
  isEmpty() {
    return this.elements_.length === 0;
  }
  isKeyQueued(key) {
    return key in this.queuedElements_;
  }
  isQueued(element) {
    return this.isKeyQueued(this.keyFunction_(element));
  }
  siftUp_(index2) {
    const elements2 = this.elements_;
    const priorities = this.priorities_;
    const count = elements2.length;
    const element = elements2[index2];
    const priority = priorities[index2];
    const startIndex = index2;
    while (index2 < count >> 1) {
      const lIndex = this.getLeftChildIndex_(index2);
      const rIndex = this.getRightChildIndex_(index2);
      const smallerChildIndex = rIndex < count && priorities[rIndex] < priorities[lIndex] ? rIndex : lIndex;
      elements2[index2] = elements2[smallerChildIndex];
      priorities[index2] = priorities[smallerChildIndex];
      index2 = smallerChildIndex;
    }
    elements2[index2] = element;
    priorities[index2] = priority;
    this.siftDown_(startIndex, index2);
  }
  siftDown_(startIndex, index2) {
    const elements2 = this.elements_;
    const priorities = this.priorities_;
    const element = elements2[index2];
    const priority = priorities[index2];
    while (index2 > startIndex) {
      const parentIndex = this.getParentIndex_(index2);
      if (priorities[parentIndex] > priority) {
        elements2[index2] = elements2[parentIndex];
        priorities[index2] = priorities[parentIndex];
        index2 = parentIndex;
      } else {
        break;
      }
    }
    elements2[index2] = element;
    priorities[index2] = priority;
  }
  reprioritize() {
    const priorityFunction = this.priorityFunction_;
    const elements2 = this.elements_;
    const priorities = this.priorities_;
    let index2 = 0;
    const n2 = elements2.length;
    let element, i2, priority;
    for (i2 = 0; i2 < n2; ++i2) {
      element = elements2[i2];
      priority = priorityFunction(element);
      if (priority == DROP) {
        delete this.queuedElements_[this.keyFunction_(element)];
      } else {
        priorities[index2] = priority;
        elements2[index2++] = element;
      }
    }
    elements2.length = index2;
    priorities.length = index2;
    this.heapify_();
  }
}
var TileState = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3,
  EMPTY: 4
};
class TileQueue extends PriorityQueue {
  constructor(tilePriorityFunction, tileChangeCallback) {
    super(function(element) {
      return tilePriorityFunction.apply(null, element);
    }, function(element) {
      return element[0].getKey();
    });
    this.boundHandleTileChange_ = this.handleTileChange.bind(this);
    this.tileChangeCallback_ = tileChangeCallback;
    this.tilesLoading_ = 0;
    this.tilesLoadingKeys_ = {};
  }
  enqueue(element) {
    const added = super.enqueue(element);
    if (added) {
      const tile2 = element[0];
      tile2.addEventListener(EventType.CHANGE, this.boundHandleTileChange_);
    }
    return added;
  }
  getTilesLoading() {
    return this.tilesLoading_;
  }
  handleTileChange(event) {
    const tile2 = event.target;
    const state = tile2.getState();
    if (state === TileState.LOADED || state === TileState.ERROR || state === TileState.EMPTY) {
      if (state !== TileState.ERROR) {
        tile2.removeEventListener(EventType.CHANGE, this.boundHandleTileChange_);
      }
      const tileKey = tile2.getKey();
      if (tileKey in this.tilesLoadingKeys_) {
        delete this.tilesLoadingKeys_[tileKey];
        --this.tilesLoading_;
      }
      this.tileChangeCallback_();
    }
  }
  loadMoreTiles(maxTotalLoading, maxNewLoads) {
    let newLoads = 0;
    let state, tile2, tileKey;
    while (this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads && this.getCount() > 0) {
      tile2 = this.dequeue()[0];
      tileKey = tile2.getKey();
      state = tile2.getState();
      if (state === TileState.IDLE && !(tileKey in this.tilesLoadingKeys_)) {
        this.tilesLoadingKeys_[tileKey] = true;
        ++this.tilesLoading_;
        ++newLoads;
        tile2.load();
      }
    }
  }
}
function getTilePriority(frameState, tile2, tileSourceKey, tileCenter, tileResolution) {
  if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {
    return DROP;
  }
  if (!frameState.wantedTiles[tileSourceKey][tile2.getKey()]) {
    return DROP;
  }
  const center = frameState.viewState.center;
  const deltaX = tileCenter[0] - center[0];
  const deltaY = tileCenter[1] - center[1];
  return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;
}
var ViewHint = {
  ANIMATING: 0,
  INTERACTING: 1
};
var ViewProperty = {
  CENTER: "center",
  RESOLUTION: "resolution",
  ROTATION: "rotation"
};
const DEFAULT_MAX_ZOOM = 42;
const DEFAULT_TILE_SIZE = 256;
const unitByCode = {
  "9001": "m",
  "9002": "ft",
  "9003": "us-ft",
  "9101": "radians",
  "9102": "degrees"
};
function fromCode(code) {
  return unitByCode[code];
}
const METERS_PER_UNIT$1 = {
  "radians": 6370997 / (2 * Math.PI),
  "degrees": 2 * Math.PI * 6370997 / 360,
  "ft": 0.3048,
  "m": 1,
  "us-ft": 1200 / 3937
};
class Projection$2 {
  constructor(options) {
    this.code_ = options.code;
    this.units_ = options.units;
    this.extent_ = options.extent !== void 0 ? options.extent : null;
    this.worldExtent_ = options.worldExtent !== void 0 ? options.worldExtent : null;
    this.axisOrientation_ = options.axisOrientation !== void 0 ? options.axisOrientation : "enu";
    this.global_ = options.global !== void 0 ? options.global : false;
    this.canWrapX_ = !!(this.global_ && this.extent_);
    this.getPointResolutionFunc_ = options.getPointResolution;
    this.defaultTileGrid_ = null;
    this.metersPerUnit_ = options.metersPerUnit;
  }
  canWrapX() {
    return this.canWrapX_;
  }
  getCode() {
    return this.code_;
  }
  getExtent() {
    return this.extent_;
  }
  getUnits() {
    return this.units_;
  }
  getMetersPerUnit() {
    return this.metersPerUnit_ || METERS_PER_UNIT$1[this.units_];
  }
  getWorldExtent() {
    return this.worldExtent_;
  }
  getAxisOrientation() {
    return this.axisOrientation_;
  }
  isGlobal() {
    return this.global_;
  }
  setGlobal(global2) {
    this.global_ = global2;
    this.canWrapX_ = !!(global2 && this.extent_);
  }
  getDefaultTileGrid() {
    return this.defaultTileGrid_;
  }
  setDefaultTileGrid(tileGrid) {
    this.defaultTileGrid_ = tileGrid;
  }
  setExtent(extent2) {
    this.extent_ = extent2;
    this.canWrapX_ = !!(this.global_ && extent2);
  }
  setWorldExtent(worldExtent) {
    this.worldExtent_ = worldExtent;
  }
  setGetPointResolution(func) {
    this.getPointResolutionFunc_ = func;
  }
  getPointResolutionFunc() {
    return this.getPointResolutionFunc_;
  }
}
const RADIUS$1 = 6378137;
const HALF_SIZE = Math.PI * RADIUS$1;
const EXTENT$1 = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];
const WORLD_EXTENT = [-180, -85, 180, 85];
const MAX_SAFE_Y = RADIUS$1 * Math.log(Math.tan(Math.PI / 2));
class EPSG3857Projection extends Projection$2 {
  constructor(code) {
    super({
      code,
      units: "m",
      extent: EXTENT$1,
      global: true,
      worldExtent: WORLD_EXTENT,
      getPointResolution: function(resolution, point) {
        return resolution / Math.cosh(point[1] / RADIUS$1);
      }
    });
  }
}
const PROJECTIONS$1 = [
  new EPSG3857Projection("EPSG:3857"),
  new EPSG3857Projection("EPSG:102100"),
  new EPSG3857Projection("EPSG:102113"),
  new EPSG3857Projection("EPSG:900913"),
  new EPSG3857Projection("http://www.opengis.net/def/crs/EPSG/0/3857"),
  new EPSG3857Projection("http://www.opengis.net/gml/srs/epsg.xml#3857")
];
function fromEPSG4326(input, output, dimension) {
  const length = input.length;
  dimension = dimension > 1 ? dimension : 2;
  if (output === void 0) {
    if (dimension > 2) {
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (let i2 = 0; i2 < length; i2 += dimension) {
    output[i2] = HALF_SIZE * input[i2] / 180;
    let y2 = RADIUS$1 * Math.log(Math.tan(Math.PI * (+input[i2 + 1] + 90) / 360));
    if (y2 > MAX_SAFE_Y) {
      y2 = MAX_SAFE_Y;
    } else if (y2 < -MAX_SAFE_Y) {
      y2 = -MAX_SAFE_Y;
    }
    output[i2 + 1] = y2;
  }
  return output;
}
function toEPSG4326(input, output, dimension) {
  const length = input.length;
  dimension = dimension > 1 ? dimension : 2;
  if (output === void 0) {
    if (dimension > 2) {
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (let i2 = 0; i2 < length; i2 += dimension) {
    output[i2] = 180 * input[i2] / HALF_SIZE;
    output[i2 + 1] = 360 * Math.atan(Math.exp(input[i2 + 1] / RADIUS$1)) / Math.PI - 90;
  }
  return output;
}
const RADIUS = 6378137;
const EXTENT = [-180, -90, 180, 90];
const METERS_PER_UNIT = Math.PI * RADIUS / 180;
class EPSG4326Projection extends Projection$2 {
  constructor(code, axisOrientation) {
    super({
      code,
      units: "degrees",
      extent: EXTENT,
      axisOrientation,
      global: true,
      metersPerUnit: METERS_PER_UNIT,
      worldExtent: EXTENT
    });
  }
}
const PROJECTIONS = [
  new EPSG4326Projection("CRS:84"),
  new EPSG4326Projection("EPSG:4326", "neu"),
  new EPSG4326Projection("urn:ogc:def:crs:OGC:1.3:CRS84"),
  new EPSG4326Projection("urn:ogc:def:crs:OGC:2:84"),
  new EPSG4326Projection("http://www.opengis.net/def/crs/OGC/1.3/CRS84"),
  new EPSG4326Projection("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"),
  new EPSG4326Projection("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")
];
let cache = {};
function get$6(code) {
  return cache[code] || cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
}
function add$2(code, projection) {
  cache[code] = projection;
}
let transforms = {};
function add$1(source, destination, transformFn) {
  const sourceCode = source.getCode();
  const destinationCode = destination.getCode();
  if (!(sourceCode in transforms)) {
    transforms[sourceCode] = {};
  }
  transforms[sourceCode][destinationCode] = transformFn;
}
function get$5(sourceCode, destinationCode) {
  let transform2;
  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
    transform2 = transforms[sourceCode][destinationCode];
  }
  return transform2;
}
const DEFAULT_RADIUS = 63710088e-1;
function getDistance(c1, c2, radius) {
  radius = radius || DEFAULT_RADIUS;
  const lat1 = toRadians(c1[1]);
  const lat2 = toRadians(c2[1]);
  const deltaLatBy2 = (lat2 - lat1) / 2;
  const deltaLonBy2 = toRadians(c2[0] - c1[0]) / 2;
  const a2 = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);
  return 2 * radius * Math.atan2(Math.sqrt(a2), Math.sqrt(1 - a2));
}
function offset(c1, distance2, bearing, radius) {
  radius = radius || DEFAULT_RADIUS;
  const lat1 = toRadians(c1[1]);
  const lon1 = toRadians(c1[0]);
  const dByR = distance2 / radius;
  const lat = Math.asin(Math.sin(lat1) * Math.cos(dByR) + Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));
  const lon = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1), Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));
  return [toDegrees(lon), toDegrees(lat)];
}
let showCoordinateWarning = true;
function disableCoordinateWarning(disable2) {
  const hide = disable2 === void 0 ? true : disable2;
  showCoordinateWarning = !hide;
}
function cloneTransform(input, output, dimension) {
  if (output !== void 0) {
    for (let i2 = 0, ii = input.length; i2 < ii; ++i2) {
      output[i2] = input[i2];
    }
    output = output;
  } else {
    output = input.slice();
  }
  return output;
}
function identityTransform(input, output, dimension) {
  if (output !== void 0 && input !== output) {
    for (let i2 = 0, ii = input.length; i2 < ii; ++i2) {
      output[i2] = input[i2];
    }
    input = output;
  }
  return input;
}
function addProjection(projection) {
  add$2(projection.getCode(), projection);
  add$1(projection, projection, cloneTransform);
}
function addProjections(projections2) {
  projections2.forEach(addProjection);
}
function get$4(projectionLike) {
  return typeof projectionLike === "string" ? get$6(projectionLike) : projectionLike || null;
}
function getPointResolution(projection, resolution, point, units2) {
  projection = get$4(projection);
  let pointResolution;
  const getter = projection.getPointResolutionFunc();
  if (getter) {
    pointResolution = getter(resolution, point);
    if (units2 && units2 !== projection.getUnits()) {
      const metersPerUnit = projection.getMetersPerUnit();
      if (metersPerUnit) {
        pointResolution = pointResolution * metersPerUnit / METERS_PER_UNIT$1[units2];
      }
    }
  } else {
    const projUnits = projection.getUnits();
    if (projUnits == "degrees" && !units2 || units2 == "degrees") {
      pointResolution = resolution;
    } else {
      const toEPSG43262 = getTransformFromProjections(projection, get$4("EPSG:4326"));
      if (toEPSG43262 === identityTransform && projUnits !== "degrees") {
        pointResolution = resolution * projection.getMetersPerUnit();
      } else {
        let vertices = [
          point[0] - resolution / 2,
          point[1],
          point[0] + resolution / 2,
          point[1],
          point[0],
          point[1] - resolution / 2,
          point[0],
          point[1] + resolution / 2
        ];
        vertices = toEPSG43262(vertices, vertices, 2);
        const width = getDistance(vertices.slice(0, 2), vertices.slice(2, 4));
        const height = getDistance(vertices.slice(4, 6), vertices.slice(6, 8));
        pointResolution = (width + height) / 2;
      }
      const metersPerUnit = units2 ? METERS_PER_UNIT$1[units2] : projection.getMetersPerUnit();
      if (metersPerUnit !== void 0) {
        pointResolution /= metersPerUnit;
      }
    }
  }
  return pointResolution;
}
function addEquivalentProjections(projections2) {
  addProjections(projections2);
  projections2.forEach(function(source) {
    projections2.forEach(function(destination) {
      if (source !== destination) {
        add$1(source, destination, cloneTransform);
      }
    });
  });
}
function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
  projections1.forEach(function(projection1) {
    projections2.forEach(function(projection2) {
      add$1(projection1, projection2, forwardTransform);
      add$1(projection2, projection1, inverseTransform);
    });
  });
}
function createProjection(projection, defaultCode) {
  if (!projection) {
    return get$4(defaultCode);
  } else if (typeof projection === "string") {
    return get$4(projection);
  }
  return projection;
}
function createTransformFromCoordinateTransform(coordTransform) {
  return function(input, output, dimension) {
    const length = input.length;
    dimension = dimension !== void 0 ? dimension : 2;
    output = output !== void 0 ? output : new Array(length);
    for (let i2 = 0; i2 < length; i2 += dimension) {
      const point = coordTransform(input.slice(i2, i2 + dimension));
      const pointLength = point.length;
      for (let j2 = 0, jj = dimension; j2 < jj; ++j2) {
        output[i2 + j2] = j2 >= pointLength ? input[i2 + j2] : point[j2];
      }
    }
    return output;
  };
}
function addCoordinateTransforms(source, destination, forward2, inverse2) {
  const sourceProj = get$4(source);
  const destProj = get$4(destination);
  add$1(sourceProj, destProj, createTransformFromCoordinateTransform(forward2));
  add$1(destProj, sourceProj, createTransformFromCoordinateTransform(inverse2));
}
function equivalent(projection1, projection2) {
  if (projection1 === projection2) {
    return true;
  }
  const equalUnits = projection1.getUnits() === projection2.getUnits();
  if (projection1.getCode() === projection2.getCode()) {
    return equalUnits;
  }
  const transformFunc = getTransformFromProjections(projection1, projection2);
  return transformFunc === cloneTransform && equalUnits;
}
function getTransformFromProjections(sourceProjection, destinationProjection) {
  const sourceCode = sourceProjection.getCode();
  const destinationCode = destinationProjection.getCode();
  let transformFunc = get$5(sourceCode, destinationCode);
  if (!transformFunc) {
    transformFunc = identityTransform;
  }
  return transformFunc;
}
function getTransform(source, destination) {
  const sourceProjection = get$4(source);
  const destinationProjection = get$4(destination);
  return getTransformFromProjections(sourceProjection, destinationProjection);
}
function transform$3(coordinate, source, destination) {
  const transformFunc = getTransform(source, destination);
  return transformFunc(coordinate, void 0, coordinate.length);
}
function transformExtent(extent2, source, destination, stops) {
  const transformFunc = getTransform(source, destination);
  return applyTransform(extent2, transformFunc, void 0, stops);
}
function toUserCoordinate(coordinate, sourceProjection) {
  {
    return coordinate;
  }
}
function fromUserCoordinate(coordinate, destProjection) {
  {
    if (showCoordinateWarning && !equals$1(coordinate, [0, 0]) && coordinate[0] >= -180 && coordinate[0] <= 180 && coordinate[1] >= -90 && coordinate[1] <= 90) {
      showCoordinateWarning = false;
      console.warn("Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates.");
    }
    return coordinate;
  }
}
function toUserExtent(extent2, sourceProjection) {
  {
    return extent2;
  }
}
function fromUserExtent(extent2, destProjection) {
  {
    return extent2;
  }
}
function fromUserResolution(resolution, destProjection) {
  {
    return resolution;
  }
}
function createSafeCoordinateTransform(sourceProj, destProj, transform2) {
  return function(coord) {
    let transformed, worldsAway;
    if (sourceProj.canWrapX()) {
      const sourceExtent = sourceProj.getExtent();
      const sourceExtentWidth = getWidth(sourceExtent);
      coord = coord.slice(0);
      worldsAway = getWorldsAway(coord, sourceProj, sourceExtentWidth);
      if (worldsAway) {
        coord[0] = coord[0] - worldsAway * sourceExtentWidth;
      }
      coord[0] = clamp(coord[0], sourceExtent[0], sourceExtent[2]);
      coord[1] = clamp(coord[1], sourceExtent[1], sourceExtent[3]);
      transformed = transform2(coord);
    } else {
      transformed = transform2(coord);
    }
    if (worldsAway && destProj.canWrapX()) {
      transformed[0] += worldsAway * getWidth(destProj.getExtent());
    }
    return transformed;
  };
}
function addCommon() {
  addEquivalentProjections(PROJECTIONS$1);
  addEquivalentProjections(PROJECTIONS);
  addEquivalentTransforms(PROJECTIONS, PROJECTIONS$1, fromEPSG4326, toEPSG4326);
}
addCommon();
function createExtent(extent2, onlyCenter, smooth) {
  return function(center, resolution, size, isMoving, centerShift) {
    if (!center) {
      return void 0;
    }
    if (!resolution && !onlyCenter) {
      return center;
    }
    const viewWidth = onlyCenter ? 0 : size[0] * resolution;
    const viewHeight = onlyCenter ? 0 : size[1] * resolution;
    const shiftX = centerShift ? centerShift[0] : 0;
    const shiftY = centerShift ? centerShift[1] : 0;
    let minX = extent2[0] + viewWidth / 2 + shiftX;
    let maxX = extent2[2] - viewWidth / 2 + shiftX;
    let minY = extent2[1] + viewHeight / 2 + shiftY;
    let maxY = extent2[3] - viewHeight / 2 + shiftY;
    if (minX > maxX) {
      minX = (maxX + minX) / 2;
      maxX = minX;
    }
    if (minY > maxY) {
      minY = (maxY + minY) / 2;
      maxY = minY;
    }
    let x2 = clamp(center[0], minX, maxX);
    let y2 = clamp(center[1], minY, maxY);
    if (isMoving && smooth && resolution) {
      const ratio = 30 * resolution;
      x2 += -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) + ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);
      y2 += -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) + ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);
    }
    return [x2, y2];
  };
}
function none$1(center) {
  return center;
}
function getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {
  const xResolution = getWidth(maxExtent) / viewportSize[0];
  const yResolution = getHeight(maxExtent) / viewportSize[1];
  if (showFullExtent) {
    return Math.min(resolution, Math.max(xResolution, yResolution));
  }
  return Math.min(resolution, Math.min(xResolution, yResolution));
}
function getSmoothClampedResolution(resolution, maxResolution, minResolution) {
  let result = Math.min(resolution, maxResolution);
  const ratio = 50;
  result *= Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio + 1;
  if (minResolution) {
    result = Math.max(result, minResolution);
    result /= Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) / ratio + 1;
  }
  return clamp(result, minResolution / 2, maxResolution * 2);
}
function createSnapToResolutions(resolutions, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== void 0 ? smooth : true;
  return function(resolution, direction2, size, isMoving) {
    if (resolution !== void 0) {
      const maxResolution = resolutions[0];
      const minResolution = resolutions[resolutions.length - 1];
      const cappedMaxRes = maxExtent ? getViewportClampedResolution(maxResolution, maxExtent, size, showFullExtent) : maxResolution;
      if (isMoving) {
        if (!smooth) {
          return clamp(resolution, minResolution, cappedMaxRes);
        }
        return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
      }
      const capped = Math.min(cappedMaxRes, resolution);
      const z2 = Math.floor(linearFindNearest(resolutions, capped, direction2));
      if (resolutions[z2] > cappedMaxRes && z2 < resolutions.length - 1) {
        return resolutions[z2 + 1];
      }
      return resolutions[z2];
    }
    return void 0;
  };
}
function createSnapToPower(power, maxResolution, minResolution, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== void 0 ? smooth : true;
  minResolution = minResolution !== void 0 ? minResolution : 0;
  return function(resolution, direction2, size, isMoving) {
    if (resolution !== void 0) {
      const cappedMaxRes = maxExtent ? getViewportClampedResolution(maxResolution, maxExtent, size, showFullExtent) : maxResolution;
      if (isMoving) {
        if (!smooth) {
          return clamp(resolution, minResolution, cappedMaxRes);
        }
        return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
      }
      const tolerance = 1e-9;
      const minZoomLevel = Math.ceil(Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance);
      const offset2 = -direction2 * (0.5 - tolerance) + 0.5;
      const capped = Math.min(cappedMaxRes, resolution);
      const cappedZoomLevel = Math.floor(Math.log(maxResolution / capped) / Math.log(power) + offset2);
      const zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);
      const newResolution = maxResolution / Math.pow(power, zoomLevel);
      return clamp(newResolution, minResolution, cappedMaxRes);
    }
    return void 0;
  };
}
function createMinMaxResolution(maxResolution, minResolution, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== void 0 ? smooth : true;
  return function(resolution, direction2, size, isMoving) {
    if (resolution !== void 0) {
      const cappedMaxRes = maxExtent ? getViewportClampedResolution(maxResolution, maxExtent, size, showFullExtent) : maxResolution;
      if (!smooth || !isMoving) {
        return clamp(resolution, minResolution, cappedMaxRes);
      }
      return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
    }
    return void 0;
  };
}
function disable(rotation) {
  if (rotation !== void 0) {
    return 0;
  }
  return void 0;
}
function none(rotation) {
  if (rotation !== void 0) {
    return rotation;
  }
  return void 0;
}
function createSnapToN(n2) {
  const theta = 2 * Math.PI / n2;
  return function(rotation, isMoving) {
    if (isMoving) {
      return rotation;
    }
    if (rotation !== void 0) {
      rotation = Math.floor(rotation / theta + 0.5) * theta;
      return rotation;
    }
    return void 0;
  };
}
function createSnapToZero(tolerance) {
  tolerance = tolerance || toRadians(5);
  return function(rotation, isMoving) {
    if (isMoving) {
      return rotation;
    }
    if (rotation !== void 0) {
      if (Math.abs(rotation) <= tolerance) {
        return 0;
      }
      return rotation;
    }
    return void 0;
  };
}
function easeIn(t3) {
  return Math.pow(t3, 3);
}
function easeOut(t3) {
  return 1 - easeIn(1 - t3);
}
function inAndOut(t3) {
  return 3 * t3 * t3 - 2 * t3 * t3 * t3;
}
function linear(t3) {
  return t3;
}
function upAndDown(t3) {
  if (t3 < 0.5) {
    return inAndOut(2 * t3);
  }
  return 1 - inAndOut(2 * (t3 - 0.5));
}
var animations = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  easeIn,
  easeOut,
  inAndOut,
  linear,
  upAndDown
}, Symbol.toStringTag, { value: "Module" }));
function transform2D(flatCoordinates, offset2, end, stride, transform2, dest) {
  dest = dest ? dest : [];
  let i2 = 0;
  for (let j2 = offset2; j2 < end; j2 += stride) {
    const x2 = flatCoordinates[j2];
    const y2 = flatCoordinates[j2 + 1];
    dest[i2++] = transform2[0] * x2 + transform2[2] * y2 + transform2[4];
    dest[i2++] = transform2[1] * x2 + transform2[3] * y2 + transform2[5];
  }
  if (dest && dest.length != i2) {
    dest.length = i2;
  }
  return dest;
}
function rotate(flatCoordinates, offset2, end, stride, angle2, anchor, dest) {
  dest = dest ? dest : [];
  const cos = Math.cos(angle2);
  const sin = Math.sin(angle2);
  const anchorX = anchor[0];
  const anchorY = anchor[1];
  let i2 = 0;
  for (let j2 = offset2; j2 < end; j2 += stride) {
    const deltaX = flatCoordinates[j2] - anchorX;
    const deltaY = flatCoordinates[j2 + 1] - anchorY;
    dest[i2++] = anchorX + deltaX * cos - deltaY * sin;
    dest[i2++] = anchorY + deltaX * sin + deltaY * cos;
    for (let k2 = j2 + 2; k2 < j2 + stride; ++k2) {
      dest[i2++] = flatCoordinates[k2];
    }
  }
  if (dest && dest.length != i2) {
    dest.length = i2;
  }
  return dest;
}
function scale$1(flatCoordinates, offset2, end, stride, sx, sy, anchor, dest) {
  dest = dest ? dest : [];
  const anchorX = anchor[0];
  const anchorY = anchor[1];
  let i2 = 0;
  for (let j2 = offset2; j2 < end; j2 += stride) {
    const deltaX = flatCoordinates[j2] - anchorX;
    const deltaY = flatCoordinates[j2 + 1] - anchorY;
    dest[i2++] = anchorX + sx * deltaX;
    dest[i2++] = anchorY + sy * deltaY;
    for (let k2 = j2 + 2; k2 < j2 + stride; ++k2) {
      dest[i2++] = flatCoordinates[k2];
    }
  }
  if (dest && dest.length != i2) {
    dest.length = i2;
  }
  return dest;
}
function translate(flatCoordinates, offset2, end, stride, deltaX, deltaY, dest) {
  dest = dest ? dest : [];
  let i2 = 0;
  for (let j2 = offset2; j2 < end; j2 += stride) {
    dest[i2++] = flatCoordinates[j2] + deltaX;
    dest[i2++] = flatCoordinates[j2 + 1] + deltaY;
    for (let k2 = j2 + 2; k2 < j2 + stride; ++k2) {
      dest[i2++] = flatCoordinates[k2];
    }
  }
  if (dest && dest.length != i2) {
    dest.length = i2;
  }
  return dest;
}
const tmpTransform$1 = create$7();
class Geometry extends BaseObject {
  constructor() {
    super();
    this.extent_ = createEmpty();
    this.extentRevision_ = -1;
    this.simplifiedGeometryMaxMinSquaredTolerance = 0;
    this.simplifiedGeometryRevision = 0;
    this.simplifyTransformedInternal = memoizeOne(function(revision, squaredTolerance, transform2) {
      if (!transform2) {
        return this.getSimplifiedGeometry(squaredTolerance);
      }
      const clone2 = this.clone();
      clone2.applyTransform(transform2);
      return clone2.getSimplifiedGeometry(squaredTolerance);
    });
  }
  simplifyTransformed(squaredTolerance, transform2) {
    return this.simplifyTransformedInternal(this.getRevision(), squaredTolerance, transform2);
  }
  clone() {
    return abstract();
  }
  closestPointXY(x2, y2, closestPoint, minSquaredDistance) {
    return abstract();
  }
  containsXY(x2, y2) {
    const coord = this.getClosestPoint([x2, y2]);
    return coord[0] === x2 && coord[1] === y2;
  }
  getClosestPoint(point, closestPoint) {
    closestPoint = closestPoint ? closestPoint : [NaN, NaN];
    this.closestPointXY(point[0], point[1], closestPoint, Infinity);
    return closestPoint;
  }
  intersectsCoordinate(coordinate) {
    return this.containsXY(coordinate[0], coordinate[1]);
  }
  computeExtent(extent2) {
    return abstract();
  }
  getExtent(extent2) {
    if (this.extentRevision_ != this.getRevision()) {
      const extent3 = this.computeExtent(this.extent_);
      if (isNaN(extent3[0]) || isNaN(extent3[1])) {
        createOrUpdateEmpty(extent3);
      }
      this.extentRevision_ = this.getRevision();
    }
    return returnOrUpdate(this.extent_, extent2);
  }
  rotate(angle2, anchor) {
    abstract();
  }
  scale(sx, sy, anchor) {
    abstract();
  }
  simplify(tolerance) {
    return this.getSimplifiedGeometry(tolerance * tolerance);
  }
  getSimplifiedGeometry(squaredTolerance) {
    return abstract();
  }
  getType() {
    return abstract();
  }
  applyTransform(transformFn) {
    abstract();
  }
  intersectsExtent(extent2) {
    return abstract();
  }
  translate(deltaX, deltaY) {
    abstract();
  }
  transform(source, destination) {
    const sourceProj = get$4(source);
    const transformFn = sourceProj.getUnits() == "tile-pixels" ? function(inCoordinates, outCoordinates, stride) {
      const pixelExtent = sourceProj.getExtent();
      const projectedExtent = sourceProj.getWorldExtent();
      const scale2 = getHeight(projectedExtent) / getHeight(pixelExtent);
      compose(tmpTransform$1, projectedExtent[0], projectedExtent[3], scale2, -scale2, 0, 0, 0);
      transform2D(inCoordinates, 0, inCoordinates.length, stride, tmpTransform$1, outCoordinates);
      return getTransform(sourceProj, destination)(inCoordinates, outCoordinates, stride);
    } : getTransform(sourceProj, destination);
    this.applyTransform(transformFn);
    return this;
  }
}
class SimpleGeometry extends Geometry {
  constructor() {
    super();
    this.layout = "XY";
    this.stride = 2;
    this.flatCoordinates = null;
  }
  computeExtent(extent2) {
    return createOrUpdateFromFlatCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent2);
  }
  getCoordinates() {
    return abstract();
  }
  getFirstCoordinate() {
    return this.flatCoordinates.slice(0, this.stride);
  }
  getFlatCoordinates() {
    return this.flatCoordinates;
  }
  getLastCoordinate() {
    return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);
  }
  getLayout() {
    return this.layout;
  }
  getSimplifiedGeometry(squaredTolerance) {
    if (this.simplifiedGeometryRevision !== this.getRevision()) {
      this.simplifiedGeometryMaxMinSquaredTolerance = 0;
      this.simplifiedGeometryRevision = this.getRevision();
    }
    if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance) {
      return this;
    }
    const simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);
    const simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();
    if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
      return simplifiedGeometry;
    }
    this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
    return this;
  }
  getSimplifiedGeometryInternal(squaredTolerance) {
    return this;
  }
  getStride() {
    return this.stride;
  }
  setFlatCoordinates(layout, flatCoordinates) {
    this.stride = getStrideForLayout(layout);
    this.layout = layout;
    this.flatCoordinates = flatCoordinates;
  }
  setCoordinates(coordinates2, layout) {
    abstract();
  }
  setLayout(layout, coordinates2, nesting) {
    let stride;
    if (layout) {
      stride = getStrideForLayout(layout);
    } else {
      for (let i2 = 0; i2 < nesting; ++i2) {
        if (coordinates2.length === 0) {
          this.layout = "XY";
          this.stride = 2;
          return;
        }
        coordinates2 = coordinates2[0];
      }
      stride = coordinates2.length;
      layout = getLayoutForStride(stride);
    }
    this.layout = layout;
    this.stride = stride;
  }
  applyTransform(transformFn) {
    if (this.flatCoordinates) {
      transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);
      this.changed();
    }
  }
  rotate(angle2, anchor) {
    const flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      const stride = this.getStride();
      rotate(flatCoordinates, 0, flatCoordinates.length, stride, angle2, anchor, flatCoordinates);
      this.changed();
    }
  }
  scale(sx, sy, anchor) {
    if (sy === void 0) {
      sy = sx;
    }
    if (!anchor) {
      anchor = getCenter(this.getExtent());
    }
    const flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      const stride = this.getStride();
      scale$1(flatCoordinates, 0, flatCoordinates.length, stride, sx, sy, anchor, flatCoordinates);
      this.changed();
    }
  }
  translate(deltaX, deltaY) {
    const flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      const stride = this.getStride();
      translate(flatCoordinates, 0, flatCoordinates.length, stride, deltaX, deltaY, flatCoordinates);
      this.changed();
    }
  }
}
function getLayoutForStride(stride) {
  let layout;
  if (stride == 2) {
    layout = "XY";
  } else if (stride == 3) {
    layout = "XYZ";
  } else if (stride == 4) {
    layout = "XYZM";
  }
  return layout;
}
function getStrideForLayout(layout) {
  let stride;
  if (layout == "XY") {
    stride = 2;
  } else if (layout == "XYZ" || layout == "XYM") {
    stride = 3;
  } else if (layout == "XYZM") {
    stride = 4;
  }
  return stride;
}
function transformGeom2D(simpleGeometry, transform2, dest) {
  const flatCoordinates = simpleGeometry.getFlatCoordinates();
  if (!flatCoordinates) {
    return null;
  }
  const stride = simpleGeometry.getStride();
  return transform2D(flatCoordinates, 0, flatCoordinates.length, stride, transform2, dest);
}
function assignClosest(flatCoordinates, offset1, offset2, stride, x2, y2, closestPoint) {
  const x1 = flatCoordinates[offset1];
  const y1 = flatCoordinates[offset1 + 1];
  const dx = flatCoordinates[offset2] - x1;
  const dy = flatCoordinates[offset2 + 1] - y1;
  let offset3;
  if (dx === 0 && dy === 0) {
    offset3 = offset1;
  } else {
    const t3 = ((x2 - x1) * dx + (y2 - y1) * dy) / (dx * dx + dy * dy);
    if (t3 > 1) {
      offset3 = offset2;
    } else if (t3 > 0) {
      for (let i2 = 0; i2 < stride; ++i2) {
        closestPoint[i2] = lerp$2(flatCoordinates[offset1 + i2], flatCoordinates[offset2 + i2], t3);
      }
      closestPoint.length = stride;
      return;
    } else {
      offset3 = offset1;
    }
  }
  for (let i2 = 0; i2 < stride; ++i2) {
    closestPoint[i2] = flatCoordinates[offset3 + i2];
  }
  closestPoint.length = stride;
}
function maxSquaredDelta(flatCoordinates, offset2, end, stride, max2) {
  let x1 = flatCoordinates[offset2];
  let y1 = flatCoordinates[offset2 + 1];
  for (offset2 += stride; offset2 < end; offset2 += stride) {
    const x2 = flatCoordinates[offset2];
    const y2 = flatCoordinates[offset2 + 1];
    const squaredDelta = squaredDistance$1(x1, y1, x2, y2);
    if (squaredDelta > max2) {
      max2 = squaredDelta;
    }
    x1 = x2;
    y1 = y2;
  }
  return max2;
}
function arrayMaxSquaredDelta(flatCoordinates, offset2, ends, stride, max2) {
  for (let i2 = 0, ii = ends.length; i2 < ii; ++i2) {
    const end = ends[i2];
    max2 = maxSquaredDelta(flatCoordinates, offset2, end, stride, max2);
    offset2 = end;
  }
  return max2;
}
function multiArrayMaxSquaredDelta(flatCoordinates, offset2, endss, stride, max2) {
  for (let i2 = 0, ii = endss.length; i2 < ii; ++i2) {
    const ends = endss[i2];
    max2 = arrayMaxSquaredDelta(flatCoordinates, offset2, ends, stride, max2);
    offset2 = ends[ends.length - 1];
  }
  return max2;
}
function assignClosestPoint(flatCoordinates, offset2, end, stride, maxDelta, isRing, x2, y2, closestPoint, minSquaredDistance, tmpPoint) {
  if (offset2 == end) {
    return minSquaredDistance;
  }
  let i2, squaredDistance2;
  if (maxDelta === 0) {
    squaredDistance2 = squaredDistance$1(x2, y2, flatCoordinates[offset2], flatCoordinates[offset2 + 1]);
    if (squaredDistance2 < minSquaredDistance) {
      for (i2 = 0; i2 < stride; ++i2) {
        closestPoint[i2] = flatCoordinates[offset2 + i2];
      }
      closestPoint.length = stride;
      return squaredDistance2;
    }
    return minSquaredDistance;
  }
  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
  let index2 = offset2 + stride;
  while (index2 < end) {
    assignClosest(flatCoordinates, index2 - stride, index2, stride, x2, y2, tmpPoint);
    squaredDistance2 = squaredDistance$1(x2, y2, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance2 < minSquaredDistance) {
      minSquaredDistance = squaredDistance2;
      for (i2 = 0; i2 < stride; ++i2) {
        closestPoint[i2] = tmpPoint[i2];
      }
      closestPoint.length = stride;
      index2 += stride;
    } else {
      index2 += stride * Math.max((Math.sqrt(squaredDistance2) - Math.sqrt(minSquaredDistance)) / maxDelta | 0, 1);
    }
  }
  if (isRing) {
    assignClosest(flatCoordinates, end - stride, offset2, stride, x2, y2, tmpPoint);
    squaredDistance2 = squaredDistance$1(x2, y2, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance2 < minSquaredDistance) {
      minSquaredDistance = squaredDistance2;
      for (i2 = 0; i2 < stride; ++i2) {
        closestPoint[i2] = tmpPoint[i2];
      }
      closestPoint.length = stride;
    }
  }
  return minSquaredDistance;
}
function assignClosestArrayPoint(flatCoordinates, offset2, ends, stride, maxDelta, isRing, x2, y2, closestPoint, minSquaredDistance, tmpPoint) {
  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
  for (let i2 = 0, ii = ends.length; i2 < ii; ++i2) {
    const end = ends[i2];
    minSquaredDistance = assignClosestPoint(flatCoordinates, offset2, end, stride, maxDelta, isRing, x2, y2, closestPoint, minSquaredDistance, tmpPoint);
    offset2 = end;
  }
  return minSquaredDistance;
}
function assignClosestMultiArrayPoint(flatCoordinates, offset2, endss, stride, maxDelta, isRing, x2, y2, closestPoint, minSquaredDistance, tmpPoint) {
  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
  for (let i2 = 0, ii = endss.length; i2 < ii; ++i2) {
    const ends = endss[i2];
    minSquaredDistance = assignClosestArrayPoint(flatCoordinates, offset2, ends, stride, maxDelta, isRing, x2, y2, closestPoint, minSquaredDistance, tmpPoint);
    offset2 = ends[ends.length - 1];
  }
  return minSquaredDistance;
}
function deflateCoordinate(flatCoordinates, offset2, coordinate, stride) {
  for (let i2 = 0, ii = coordinate.length; i2 < ii; ++i2) {
    flatCoordinates[offset2++] = coordinate[i2];
  }
  return offset2;
}
function deflateCoordinates(flatCoordinates, offset2, coordinates2, stride) {
  for (let i2 = 0, ii = coordinates2.length; i2 < ii; ++i2) {
    const coordinate = coordinates2[i2];
    for (let j2 = 0; j2 < stride; ++j2) {
      flatCoordinates[offset2++] = coordinate[j2];
    }
  }
  return offset2;
}
function deflateCoordinatesArray(flatCoordinates, offset2, coordinatess, stride, ends) {
  ends = ends ? ends : [];
  let i2 = 0;
  for (let j2 = 0, jj = coordinatess.length; j2 < jj; ++j2) {
    const end = deflateCoordinates(flatCoordinates, offset2, coordinatess[j2], stride);
    ends[i2++] = end;
    offset2 = end;
  }
  ends.length = i2;
  return ends;
}
function deflateMultiCoordinatesArray(flatCoordinates, offset2, coordinatesss, stride, endss) {
  endss = endss ? endss : [];
  let i2 = 0;
  for (let j2 = 0, jj = coordinatesss.length; j2 < jj; ++j2) {
    const ends = deflateCoordinatesArray(flatCoordinates, offset2, coordinatesss[j2], stride, endss[i2]);
    if (ends.length === 0) {
      ends[0] = offset2;
    }
    endss[i2++] = ends;
    offset2 = ends[ends.length - 1];
  }
  endss.length = i2;
  return endss;
}
function douglasPeucker(flatCoordinates, offset2, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  const n2 = (end - offset2) / stride;
  if (n2 < 3) {
    for (; offset2 < end; offset2 += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset2];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset2 + 1];
    }
    return simplifiedOffset;
  }
  const markers = new Array(n2);
  markers[0] = 1;
  markers[n2 - 1] = 1;
  const stack = [offset2, end - stride];
  let index2 = 0;
  while (stack.length > 0) {
    const last = stack.pop();
    const first = stack.pop();
    let maxSquaredDistance = 0;
    const x1 = flatCoordinates[first];
    const y1 = flatCoordinates[first + 1];
    const x2 = flatCoordinates[last];
    const y2 = flatCoordinates[last + 1];
    for (let i2 = first + stride; i2 < last; i2 += stride) {
      const x3 = flatCoordinates[i2];
      const y3 = flatCoordinates[i2 + 1];
      const squaredDistance2 = squaredSegmentDistance(x3, y3, x1, y1, x2, y2);
      if (squaredDistance2 > maxSquaredDistance) {
        index2 = i2;
        maxSquaredDistance = squaredDistance2;
      }
    }
    if (maxSquaredDistance > squaredTolerance) {
      markers[(index2 - offset2) / stride] = 1;
      if (first + stride < index2) {
        stack.push(first, index2);
      }
      if (index2 + stride < last) {
        stack.push(index2, last);
      }
    }
  }
  for (let i2 = 0; i2 < n2; ++i2) {
    if (markers[i2]) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset2 + i2 * stride];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset2 + i2 * stride + 1];
    }
  }
  return simplifiedOffset;
}
function douglasPeuckerArray(flatCoordinates, offset2, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  for (let i2 = 0, ii = ends.length; i2 < ii; ++i2) {
    const end = ends[i2];
    simplifiedOffset = douglasPeucker(flatCoordinates, offset2, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset);
    simplifiedEnds.push(simplifiedOffset);
    offset2 = end;
  }
  return simplifiedOffset;
}
function snap(value, tolerance) {
  return tolerance * Math.round(value / tolerance);
}
function quantize(flatCoordinates, offset2, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  if (offset2 == end) {
    return simplifiedOffset;
  }
  let x1 = snap(flatCoordinates[offset2], tolerance);
  let y1 = snap(flatCoordinates[offset2 + 1], tolerance);
  offset2 += stride;
  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  let x2, y2;
  do {
    x2 = snap(flatCoordinates[offset2], tolerance);
    y2 = snap(flatCoordinates[offset2 + 1], tolerance);
    offset2 += stride;
    if (offset2 == end) {
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      return simplifiedOffset;
    }
  } while (x2 == x1 && y2 == y1);
  while (offset2 < end) {
    const x3 = snap(flatCoordinates[offset2], tolerance);
    const y3 = snap(flatCoordinates[offset2 + 1], tolerance);
    offset2 += stride;
    if (x3 == x2 && y3 == y2) {
      continue;
    }
    const dx1 = x2 - x1;
    const dy1 = y2 - y1;
    const dx2 = x3 - x1;
    const dy2 = y3 - y1;
    if (dx1 * dy2 == dy1 * dx2 && (dx1 < 0 && dx2 < dx1 || dx1 == dx2 || dx1 > 0 && dx2 > dx1) && (dy1 < 0 && dy2 < dy1 || dy1 == dy2 || dy1 > 0 && dy2 > dy1)) {
      x2 = x3;
      y2 = y3;
      continue;
    }
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    x1 = x2;
    y1 = y2;
    x2 = x3;
    y2 = y3;
  }
  simplifiedFlatCoordinates[simplifiedOffset++] = x2;
  simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  return simplifiedOffset;
}
function quantizeArray(flatCoordinates, offset2, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  for (let i2 = 0, ii = ends.length; i2 < ii; ++i2) {
    const end = ends[i2];
    simplifiedOffset = quantize(flatCoordinates, offset2, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset);
    simplifiedEnds.push(simplifiedOffset);
    offset2 = end;
  }
  return simplifiedOffset;
}
function quantizeMultiArray(flatCoordinates, offset2, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
  for (let i2 = 0, ii = endss.length; i2 < ii; ++i2) {
    const ends = endss[i2];
    const simplifiedEnds = [];
    simplifiedOffset = quantizeArray(flatCoordinates, offset2, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
    simplifiedEndss.push(simplifiedEnds);
    offset2 = ends[ends.length - 1];
  }
  return simplifiedOffset;
}
function inflateCoordinates(flatCoordinates, offset2, end, stride, coordinates2) {
  coordinates2 = coordinates2 !== void 0 ? coordinates2 : [];
  let i2 = 0;
  for (let j2 = offset2; j2 < end; j2 += stride) {
    coordinates2[i2++] = flatCoordinates.slice(j2, j2 + stride);
  }
  coordinates2.length = i2;
  return coordinates2;
}
function inflateCoordinatesArray(flatCoordinates, offset2, ends, stride, coordinatess) {
  coordinatess = coordinatess !== void 0 ? coordinatess : [];
  let i2 = 0;
  for (let j2 = 0, jj = ends.length; j2 < jj; ++j2) {
    const end = ends[j2];
    coordinatess[i2++] = inflateCoordinates(flatCoordinates, offset2, end, stride, coordinatess[i2]);
    offset2 = end;
  }
  coordinatess.length = i2;
  return coordinatess;
}
function inflateMultiCoordinatesArray(flatCoordinates, offset2, endss, stride, coordinatesss) {
  coordinatesss = coordinatesss !== void 0 ? coordinatesss : [];
  let i2 = 0;
  for (let j2 = 0, jj = endss.length; j2 < jj; ++j2) {
    const ends = endss[j2];
    coordinatesss[i2++] = ends.length === 1 && ends[0] === offset2 ? [] : inflateCoordinatesArray(flatCoordinates, offset2, ends, stride, coordinatesss[i2]);
    offset2 = ends[ends.length - 1];
  }
  coordinatesss.length = i2;
  return coordinatesss;
}
function linearRing(flatCoordinates, offset2, end, stride) {
  let twiceArea = 0;
  let x1 = flatCoordinates[end - stride];
  let y1 = flatCoordinates[end - stride + 1];
  for (; offset2 < end; offset2 += stride) {
    const x2 = flatCoordinates[offset2];
    const y2 = flatCoordinates[offset2 + 1];
    twiceArea += y1 * x2 - x1 * y2;
    x1 = x2;
    y1 = y2;
  }
  return twiceArea / 2;
}
function linearRings(flatCoordinates, offset2, ends, stride) {
  let area2 = 0;
  for (let i2 = 0, ii = ends.length; i2 < ii; ++i2) {
    const end = ends[i2];
    area2 += linearRing(flatCoordinates, offset2, end, stride);
    offset2 = end;
  }
  return area2;
}
function linearRingss$1(flatCoordinates, offset2, endss, stride) {
  let area2 = 0;
  for (let i2 = 0, ii = endss.length; i2 < ii; ++i2) {
    const ends = endss[i2];
    area2 += linearRings(flatCoordinates, offset2, ends, stride);
    offset2 = ends[ends.length - 1];
  }
  return area2;
}
class LinearRing extends SimpleGeometry {
  constructor(coordinates2, layout) {
    super();
    this.maxDelta_ = -1;
    this.maxDeltaRevision_ = -1;
    if (layout !== void 0 && !Array.isArray(coordinates2[0])) {
      this.setFlatCoordinates(layout, coordinates2);
    } else {
      this.setCoordinates(coordinates2, layout);
    }
  }
  clone() {
    return new LinearRing(this.flatCoordinates.slice(), this.layout);
  }
  closestPointXY(x2, y2, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x2, y2)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(maxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
      this.maxDeltaRevision_ = this.getRevision();
    }
    return assignClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, true, x2, y2, closestPoint, minSquaredDistance);
  }
  getArea() {
    return linearRing(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  }
  getCoordinates() {
    return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  }
  getSimplifiedGeometryInternal(squaredTolerance) {
    const simplifiedFlatCoordinates = [];
    simplifiedFlatCoordinates.length = douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
    return new LinearRing(simplifiedFlatCoordinates, "XY");
  }
  getType() {
    return "LinearRing";
  }
  intersectsExtent(extent2) {
    return false;
  }
  setCoordinates(coordinates2, layout) {
    this.setLayout(layout, coordinates2, 1);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates2, this.stride);
    this.changed();
  }
}
class Point$3 extends SimpleGeometry {
  constructor(coordinates2, layout) {
    super();
    this.setCoordinates(coordinates2, layout);
  }
  clone() {
    const point = new Point$3(this.flatCoordinates.slice(), this.layout);
    point.applyProperties(this);
    return point;
  }
  closestPointXY(x2, y2, closestPoint, minSquaredDistance) {
    const flatCoordinates = this.flatCoordinates;
    const squaredDistance2 = squaredDistance$1(x2, y2, flatCoordinates[0], flatCoordinates[1]);
    if (squaredDistance2 < minSquaredDistance) {
      const stride = this.stride;
      for (let i2 = 0; i2 < stride; ++i2) {
        closestPoint[i2] = flatCoordinates[i2];
      }
      closestPoint.length = stride;
      return squaredDistance2;
    }
    return minSquaredDistance;
  }
  getCoordinates() {
    return !this.flatCoordinates ? [] : this.flatCoordinates.slice();
  }
  computeExtent(extent2) {
    return createOrUpdateFromCoordinate(this.flatCoordinates, extent2);
  }
  getType() {
    return "Point";
  }
  intersectsExtent(extent2) {
    return containsXY(extent2, this.flatCoordinates[0], this.flatCoordinates[1]);
  }
  setCoordinates(coordinates2, layout) {
    this.setLayout(layout, coordinates2, 0);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = deflateCoordinate(this.flatCoordinates, 0, coordinates2, this.stride);
    this.changed();
  }
}
function linearRingContainsExtent(flatCoordinates, offset2, end, stride, extent2) {
  const outside = forEachCorner(extent2, function(coordinate) {
    return !linearRingContainsXY(flatCoordinates, offset2, end, stride, coordinate[0], coordinate[1]);
  });
  return !outside;
}
function linearRingContainsXY(flatCoordinates, offset2, end, stride, x2, y2) {
  let wn = 0;
  let x1 = flatCoordinates[end - stride];
  let y1 = flatCoordinates[end - stride + 1];
  for (; offset2 < end; offset2 += stride) {
    const x22 = flatCoordinates[offset2];
    const y22 = flatCoordinates[offset2 + 1];
    if (y1 <= y2) {
      if (y22 > y2 && (x22 - x1) * (y2 - y1) - (x2 - x1) * (y22 - y1) > 0) {
        wn++;
      }
    } else if (y22 <= y2 && (x22 - x1) * (y2 - y1) - (x2 - x1) * (y22 - y1) < 0) {
      wn--;
    }
    x1 = x22;
    y1 = y22;
  }
  return wn !== 0;
}
function linearRingsContainsXY(flatCoordinates, offset2, ends, stride, x2, y2) {
  if (ends.length === 0) {
    return false;
  }
  if (!linearRingContainsXY(flatCoordinates, offset2, ends[0], stride, x2, y2)) {
    return false;
  }
  for (let i2 = 1, ii = ends.length; i2 < ii; ++i2) {
    if (linearRingContainsXY(flatCoordinates, ends[i2 - 1], ends[i2], stride, x2, y2)) {
      return false;
    }
  }
  return true;
}
function linearRingssContainsXY(flatCoordinates, offset2, endss, stride, x2, y2) {
  if (endss.length === 0) {
    return false;
  }
  for (let i2 = 0, ii = endss.length; i2 < ii; ++i2) {
    const ends = endss[i2];
    if (linearRingsContainsXY(flatCoordinates, offset2, ends, stride, x2, y2)) {
      return true;
    }
    offset2 = ends[ends.length - 1];
  }
  return false;
}
function getInteriorPointOfArray(flatCoordinates, offset2, ends, stride, flatCenters, flatCentersOffset, dest) {
  let i2, ii, x2, x1, x22, y1, y2;
  const y3 = flatCenters[flatCentersOffset + 1];
  const intersections = [];
  for (let r2 = 0, rr = ends.length; r2 < rr; ++r2) {
    const end = ends[r2];
    x1 = flatCoordinates[end - stride];
    y1 = flatCoordinates[end - stride + 1];
    for (i2 = offset2; i2 < end; i2 += stride) {
      x22 = flatCoordinates[i2];
      y2 = flatCoordinates[i2 + 1];
      if (y3 <= y1 && y2 <= y3 || y1 <= y3 && y3 <= y2) {
        x2 = (y3 - y1) / (y2 - y1) * (x22 - x1) + x1;
        intersections.push(x2);
      }
      x1 = x22;
      y1 = y2;
    }
  }
  let pointX = NaN;
  let maxSegmentLength = -Infinity;
  intersections.sort(numberSafeCompareFunction);
  x1 = intersections[0];
  for (i2 = 1, ii = intersections.length; i2 < ii; ++i2) {
    x22 = intersections[i2];
    const segmentLength = Math.abs(x22 - x1);
    if (segmentLength > maxSegmentLength) {
      x2 = (x1 + x22) / 2;
      if (linearRingsContainsXY(flatCoordinates, offset2, ends, stride, x2, y3)) {
        pointX = x2;
        maxSegmentLength = segmentLength;
      }
    }
    x1 = x22;
  }
  if (isNaN(pointX)) {
    pointX = flatCenters[flatCentersOffset];
  }
  if (dest) {
    dest.push(pointX, y3, maxSegmentLength);
    return dest;
  }
  return [pointX, y3, maxSegmentLength];
}
function getInteriorPointsOfMultiArray(flatCoordinates, offset2, endss, stride, flatCenters) {
  let interiorPoints = [];
  for (let i2 = 0, ii = endss.length; i2 < ii; ++i2) {
    const ends = endss[i2];
    interiorPoints = getInteriorPointOfArray(flatCoordinates, offset2, ends, stride, flatCenters, 2 * i2, interiorPoints);
    offset2 = ends[ends.length - 1];
  }
  return interiorPoints;
}
function forEach(flatCoordinates, offset2, end, stride, callback) {
  let ret;
  offset2 += stride;
  for (; offset2 < end; offset2 += stride) {
    ret = callback(flatCoordinates.slice(offset2 - stride, offset2), flatCoordinates.slice(offset2, offset2 + stride));
    if (ret) {
      return ret;
    }
  }
  return false;
}
function intersectsLineString(flatCoordinates, offset2, end, stride, extent2) {
  const coordinatesExtent = extendFlatCoordinates(createEmpty(), flatCoordinates, offset2, end, stride);
  if (!intersects$2(extent2, coordinatesExtent)) {
    return false;
  }
  if (containsExtent(extent2, coordinatesExtent)) {
    return true;
  }
  if (coordinatesExtent[0] >= extent2[0] && coordinatesExtent[2] <= extent2[2]) {
    return true;
  }
  if (coordinatesExtent[1] >= extent2[1] && coordinatesExtent[3] <= extent2[3]) {
    return true;
  }
  return forEach(flatCoordinates, offset2, end, stride, function(point1, point2) {
    return intersectsSegment(extent2, point1, point2);
  });
}
function intersectsLineStringArray(flatCoordinates, offset2, ends, stride, extent2) {
  for (let i2 = 0, ii = ends.length; i2 < ii; ++i2) {
    if (intersectsLineString(flatCoordinates, offset2, ends[i2], stride, extent2)) {
      return true;
    }
    offset2 = ends[i2];
  }
  return false;
}
function intersectsLinearRing(flatCoordinates, offset2, end, stride, extent2) {
  if (intersectsLineString(flatCoordinates, offset2, end, stride, extent2)) {
    return true;
  }
  if (linearRingContainsXY(flatCoordinates, offset2, end, stride, extent2[0], extent2[1])) {
    return true;
  }
  if (linearRingContainsXY(flatCoordinates, offset2, end, stride, extent2[0], extent2[3])) {
    return true;
  }
  if (linearRingContainsXY(flatCoordinates, offset2, end, stride, extent2[2], extent2[1])) {
    return true;
  }
  if (linearRingContainsXY(flatCoordinates, offset2, end, stride, extent2[2], extent2[3])) {
    return true;
  }
  return false;
}
function intersectsLinearRingArray(flatCoordinates, offset2, ends, stride, extent2) {
  if (!intersectsLinearRing(flatCoordinates, offset2, ends[0], stride, extent2)) {
    return false;
  }
  if (ends.length === 1) {
    return true;
  }
  for (let i2 = 1, ii = ends.length; i2 < ii; ++i2) {
    if (linearRingContainsExtent(flatCoordinates, ends[i2 - 1], ends[i2], stride, extent2)) {
      if (!intersectsLineString(flatCoordinates, ends[i2 - 1], ends[i2], stride, extent2)) {
        return false;
      }
    }
  }
  return true;
}
function intersectsLinearRingMultiArray(flatCoordinates, offset2, endss, stride, extent2) {
  for (let i2 = 0, ii = endss.length; i2 < ii; ++i2) {
    const ends = endss[i2];
    if (intersectsLinearRingArray(flatCoordinates, offset2, ends, stride, extent2)) {
      return true;
    }
    offset2 = ends[ends.length - 1];
  }
  return false;
}
function coordinates(flatCoordinates, offset2, end, stride) {
  while (offset2 < end - stride) {
    for (let i2 = 0; i2 < stride; ++i2) {
      const tmp = flatCoordinates[offset2 + i2];
      flatCoordinates[offset2 + i2] = flatCoordinates[end - stride + i2];
      flatCoordinates[end - stride + i2] = tmp;
    }
    offset2 += stride;
    end -= stride;
  }
}
function linearRingIsClockwise(flatCoordinates, offset2, end, stride) {
  let edge = 0;
  let x1 = flatCoordinates[end - stride];
  let y1 = flatCoordinates[end - stride + 1];
  for (; offset2 < end; offset2 += stride) {
    const x2 = flatCoordinates[offset2];
    const y2 = flatCoordinates[offset2 + 1];
    edge += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }
  return edge === 0 ? void 0 : edge > 0;
}
function linearRingsAreOriented(flatCoordinates, offset2, ends, stride, right) {
  right = right !== void 0 ? right : false;
  for (let i2 = 0, ii = ends.length; i2 < ii; ++i2) {
    const end = ends[i2];
    const isClockwise = linearRingIsClockwise(flatCoordinates, offset2, end, stride);
    if (i2 === 0) {
      if (right && isClockwise || !right && !isClockwise) {
        return false;
      }
    } else {
      if (right && !isClockwise || !right && isClockwise) {
        return false;
      }
    }
    offset2 = end;
  }
  return true;
}
function linearRingssAreOriented(flatCoordinates, offset2, endss, stride, right) {
  for (let i2 = 0, ii = endss.length; i2 < ii; ++i2) {
    const ends = endss[i2];
    if (!linearRingsAreOriented(flatCoordinates, offset2, ends, stride, right)) {
      return false;
    }
    if (ends.length) {
      offset2 = ends[ends.length - 1];
    }
  }
  return true;
}
function orientLinearRings(flatCoordinates, offset2, ends, stride, right) {
  right = right !== void 0 ? right : false;
  for (let i2 = 0, ii = ends.length; i2 < ii; ++i2) {
    const end = ends[i2];
    const isClockwise = linearRingIsClockwise(flatCoordinates, offset2, end, stride);
    const reverse2 = i2 === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;
    if (reverse2) {
      coordinates(flatCoordinates, offset2, end, stride);
    }
    offset2 = end;
  }
  return offset2;
}
function orientLinearRingsArray(flatCoordinates, offset2, endss, stride, right) {
  for (let i2 = 0, ii = endss.length; i2 < ii; ++i2) {
    offset2 = orientLinearRings(flatCoordinates, offset2, endss[i2], stride, right);
  }
  return offset2;
}
function inflateEnds(flatCoordinates, ends) {
  const endss = [];
  let offset2 = 0;
  let prevEndIndex = 0;
  for (let i2 = 0, ii = ends.length; i2 < ii; ++i2) {
    const end = ends[i2];
    if (!linearRingIsClockwise(flatCoordinates, offset2, end, 2)) {
      endss.push(ends.slice(prevEndIndex, i2 + 1));
    } else {
      if (endss.length === 0) {
        continue;
      }
      endss[endss.length - 1].push(ends[prevEndIndex]);
    }
    prevEndIndex = i2 + 1;
    offset2 = end;
  }
  return endss;
}
class Polygon$1 extends SimpleGeometry {
  constructor(coordinates2, layout, ends) {
    super();
    this.ends_ = [];
    this.flatInteriorPointRevision_ = -1;
    this.flatInteriorPoint_ = null;
    this.maxDelta_ = -1;
    this.maxDeltaRevision_ = -1;
    this.orientedRevision_ = -1;
    this.orientedFlatCoordinates_ = null;
    if (layout !== void 0 && ends) {
      this.setFlatCoordinates(layout, coordinates2);
      this.ends_ = ends;
    } else {
      this.setCoordinates(coordinates2, layout);
    }
  }
  appendLinearRing(linearRing2) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = linearRing2.getFlatCoordinates().slice();
    } else {
      extend$3(this.flatCoordinates, linearRing2.getFlatCoordinates());
    }
    this.ends_.push(this.flatCoordinates.length);
    this.changed();
  }
  clone() {
    const polygon = new Polygon$1(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
    polygon.applyProperties(this);
    return polygon;
  }
  closestPointXY(x2, y2, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x2, y2)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));
      this.maxDeltaRevision_ = this.getRevision();
    }
    return assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, true, x2, y2, closestPoint, minSquaredDistance);
  }
  containsXY(x2, y2) {
    return linearRingsContainsXY(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x2, y2);
  }
  getArea() {
    return linearRings(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);
  }
  getCoordinates(right) {
    let flatCoordinates;
    if (right !== void 0) {
      flatCoordinates = this.getOrientedFlatCoordinates().slice();
      orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, right);
    } else {
      flatCoordinates = this.flatCoordinates;
    }
    return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);
  }
  getEnds() {
    return this.ends_;
  }
  getFlatInteriorPoint() {
    if (this.flatInteriorPointRevision_ != this.getRevision()) {
      const flatCenter = getCenter(this.getExtent());
      this.flatInteriorPoint_ = getInteriorPointOfArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, flatCenter, 0);
      this.flatInteriorPointRevision_ = this.getRevision();
    }
    return this.flatInteriorPoint_;
  }
  getInteriorPoint() {
    return new Point$3(this.getFlatInteriorPoint(), "XYM");
  }
  getLinearRingCount() {
    return this.ends_.length;
  }
  getLinearRing(index2) {
    if (index2 < 0 || this.ends_.length <= index2) {
      return null;
    }
    return new LinearRing(this.flatCoordinates.slice(index2 === 0 ? 0 : this.ends_[index2 - 1], this.ends_[index2]), this.layout);
  }
  getLinearRings() {
    const layout = this.layout;
    const flatCoordinates = this.flatCoordinates;
    const ends = this.ends_;
    const linearRings2 = [];
    let offset2 = 0;
    for (let i2 = 0, ii = ends.length; i2 < ii; ++i2) {
      const end = ends[i2];
      const linearRing2 = new LinearRing(flatCoordinates.slice(offset2, end), layout);
      linearRings2.push(linearRing2);
      offset2 = end;
    }
    return linearRings2;
  }
  getOrientedFlatCoordinates() {
    if (this.orientedRevision_ != this.getRevision()) {
      const flatCoordinates = this.flatCoordinates;
      if (linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {
        this.orientedFlatCoordinates_ = flatCoordinates;
      } else {
        this.orientedFlatCoordinates_ = flatCoordinates.slice();
        this.orientedFlatCoordinates_.length = orientLinearRings(this.orientedFlatCoordinates_, 0, this.ends_, this.stride);
      }
      this.orientedRevision_ = this.getRevision();
    }
    return this.orientedFlatCoordinates_;
  }
  getSimplifiedGeometryInternal(squaredTolerance) {
    const simplifiedFlatCoordinates = [];
    const simplifiedEnds = [];
    simplifiedFlatCoordinates.length = quantizeArray(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);
    return new Polygon$1(simplifiedFlatCoordinates, "XY", simplifiedEnds);
  }
  getType() {
    return "Polygon";
  }
  intersectsExtent(extent2) {
    return intersectsLinearRingArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent2);
  }
  setCoordinates(coordinates2, layout) {
    this.setLayout(layout, coordinates2, 2);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    const ends = deflateCoordinatesArray(this.flatCoordinates, 0, coordinates2, this.stride, this.ends_);
    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
    this.changed();
  }
}
function circular(center, radius, n2, sphereRadius) {
  n2 = n2 ? n2 : 32;
  const flatCoordinates = [];
  for (let i2 = 0; i2 < n2; ++i2) {
    extend$3(flatCoordinates, offset(center, radius, 2 * Math.PI * i2 / n2, sphereRadius));
  }
  flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);
  return new Polygon$1(flatCoordinates, "XY", [flatCoordinates.length]);
}
function fromExtent(extent2) {
  const minX = extent2[0];
  const minY = extent2[1];
  const maxX = extent2[2];
  const maxY = extent2[3];
  const flatCoordinates = [
    minX,
    minY,
    minX,
    maxY,
    maxX,
    maxY,
    maxX,
    minY,
    minX,
    minY
  ];
  return new Polygon$1(flatCoordinates, "XY", [flatCoordinates.length]);
}
function fromCircle(circle, sides, angle2) {
  sides = sides ? sides : 32;
  const stride = circle.getStride();
  const layout = circle.getLayout();
  const center = circle.getCenter();
  const arrayLength = stride * (sides + 1);
  const flatCoordinates = new Array(arrayLength);
  for (let i2 = 0; i2 < arrayLength; i2 += stride) {
    flatCoordinates[i2] = 0;
    flatCoordinates[i2 + 1] = 0;
    for (let j2 = 2; j2 < stride; j2++) {
      flatCoordinates[i2 + j2] = center[j2];
    }
  }
  const ends = [flatCoordinates.length];
  const polygon = new Polygon$1(flatCoordinates, layout, ends);
  makeRegular(polygon, center, circle.getRadius(), angle2);
  return polygon;
}
function makeRegular(polygon, center, radius, angle2) {
  const flatCoordinates = polygon.getFlatCoordinates();
  const stride = polygon.getStride();
  const sides = flatCoordinates.length / stride - 1;
  const startAngle = angle2 ? angle2 : 0;
  for (let i2 = 0; i2 <= sides; ++i2) {
    const offset2 = i2 * stride;
    const angle3 = startAngle + modulo(i2, sides) * 2 * Math.PI / sides;
    flatCoordinates[offset2] = center[0] + radius * Math.cos(angle3);
    flatCoordinates[offset2 + 1] = center[1] + radius * Math.sin(angle3);
  }
  polygon.changed();
}
const DEFAULT_MIN_ZOOM = 0;
class View$1 extends BaseObject {
  constructor(options) {
    super();
    this.on;
    this.once;
    this.un;
    options = Object.assign({}, options);
    this.hints_ = [0, 0];
    this.animations_ = [];
    this.updateAnimationKey_;
    this.projection_ = createProjection(options.projection, "EPSG:3857");
    this.viewportSize_ = [100, 100];
    this.targetCenter_ = null;
    this.targetResolution_;
    this.targetRotation_;
    this.nextCenter_ = null;
    this.nextResolution_;
    this.nextRotation_;
    this.cancelAnchor_ = void 0;
    if (options.projection) {
      disableCoordinateWarning();
    }
    if (options.center) {
      options.center = fromUserCoordinate(options.center, this.projection_);
    }
    if (options.extent) {
      options.extent = fromUserExtent(options.extent, this.projection_);
    }
    this.applyOptions_(options);
  }
  applyOptions_(options) {
    const properties = Object.assign({}, options);
    for (const key in ViewProperty) {
      delete properties[key];
    }
    this.setProperties(properties, true);
    const resolutionConstraintInfo = createResolutionConstraint(options);
    this.maxResolution_ = resolutionConstraintInfo.maxResolution;
    this.minResolution_ = resolutionConstraintInfo.minResolution;
    this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;
    this.resolutions_ = options.resolutions;
    this.padding_ = options.padding;
    this.minZoom_ = resolutionConstraintInfo.minZoom;
    const centerConstraint = createCenterConstraint(options);
    const resolutionConstraint = resolutionConstraintInfo.constraint;
    const rotationConstraint = createRotationConstraint(options);
    this.constraints_ = {
      center: centerConstraint,
      resolution: resolutionConstraint,
      rotation: rotationConstraint
    };
    this.setRotation(options.rotation !== void 0 ? options.rotation : 0);
    this.setCenterInternal(options.center !== void 0 ? options.center : null);
    if (options.resolution !== void 0) {
      this.setResolution(options.resolution);
    } else if (options.zoom !== void 0) {
      this.setZoom(options.zoom);
    }
  }
  get padding() {
    return this.padding_;
  }
  set padding(padding) {
    let oldPadding = this.padding_;
    this.padding_ = padding;
    const center = this.getCenter();
    if (center) {
      const newPadding = padding || [0, 0, 0, 0];
      oldPadding = oldPadding || [0, 0, 0, 0];
      const resolution = this.getResolution();
      const offsetX = resolution / 2 * (newPadding[3] - oldPadding[3] + oldPadding[1] - newPadding[1]);
      const offsetY = resolution / 2 * (newPadding[0] - oldPadding[0] + oldPadding[2] - newPadding[2]);
      this.setCenterInternal([center[0] + offsetX, center[1] - offsetY]);
    }
  }
  getUpdatedOptions_(newOptions) {
    const options = this.getProperties();
    if (options.resolution !== void 0) {
      options.resolution = this.getResolution();
    } else {
      options.zoom = this.getZoom();
    }
    options.center = this.getCenterInternal();
    options.rotation = this.getRotation();
    return Object.assign({}, options, newOptions);
  }
  animate(var_args) {
    if (this.isDef() && !this.getAnimating()) {
      this.resolveConstraints(0);
    }
    const args = new Array(arguments.length);
    for (let i2 = 0; i2 < args.length; ++i2) {
      let options = arguments[i2];
      if (options.center) {
        options = Object.assign({}, options);
        options.center = fromUserCoordinate(options.center, this.getProjection());
      }
      if (options.anchor) {
        options = Object.assign({}, options);
        options.anchor = fromUserCoordinate(options.anchor, this.getProjection());
      }
      args[i2] = options;
    }
    this.animateInternal.apply(this, args);
  }
  animateInternal(var_args) {
    let animationCount = arguments.length;
    let callback;
    if (animationCount > 1 && typeof arguments[animationCount - 1] === "function") {
      callback = arguments[animationCount - 1];
      --animationCount;
    }
    let i2 = 0;
    for (; i2 < animationCount && !this.isDef(); ++i2) {
      const state = arguments[i2];
      if (state.center) {
        this.setCenterInternal(state.center);
      }
      if (state.zoom !== void 0) {
        this.setZoom(state.zoom);
      } else if (state.resolution) {
        this.setResolution(state.resolution);
      }
      if (state.rotation !== void 0) {
        this.setRotation(state.rotation);
      }
    }
    if (i2 === animationCount) {
      if (callback) {
        animationCallback(callback, true);
      }
      return;
    }
    let start2 = Date.now();
    let center = this.targetCenter_.slice();
    let resolution = this.targetResolution_;
    let rotation = this.targetRotation_;
    const series = [];
    for (; i2 < animationCount; ++i2) {
      const options = arguments[i2];
      const animation = {
        start: start2,
        complete: false,
        anchor: options.anchor,
        duration: options.duration !== void 0 ? options.duration : 1e3,
        easing: options.easing || inAndOut,
        callback
      };
      if (options.center) {
        animation.sourceCenter = center;
        animation.targetCenter = options.center.slice();
        center = animation.targetCenter;
      }
      if (options.zoom !== void 0) {
        animation.sourceResolution = resolution;
        animation.targetResolution = this.getResolutionForZoom(options.zoom);
        resolution = animation.targetResolution;
      } else if (options.resolution) {
        animation.sourceResolution = resolution;
        animation.targetResolution = options.resolution;
        resolution = animation.targetResolution;
      }
      if (options.rotation !== void 0) {
        animation.sourceRotation = rotation;
        const delta = modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
        animation.targetRotation = rotation + delta;
        rotation = animation.targetRotation;
      }
      if (isNoopAnimation(animation)) {
        animation.complete = true;
      } else {
        start2 += animation.duration;
      }
      series.push(animation);
    }
    this.animations_.push(series);
    this.setHint(ViewHint.ANIMATING, 1);
    this.updateAnimations_();
  }
  getAnimating() {
    return this.hints_[ViewHint.ANIMATING] > 0;
  }
  getInteracting() {
    return this.hints_[ViewHint.INTERACTING] > 0;
  }
  cancelAnimations() {
    this.setHint(ViewHint.ANIMATING, -this.hints_[ViewHint.ANIMATING]);
    let anchor;
    for (let i2 = 0, ii = this.animations_.length; i2 < ii; ++i2) {
      const series = this.animations_[i2];
      if (series[0].callback) {
        animationCallback(series[0].callback, false);
      }
      if (!anchor) {
        for (let j2 = 0, jj = series.length; j2 < jj; ++j2) {
          const animation = series[j2];
          if (!animation.complete) {
            anchor = animation.anchor;
            break;
          }
        }
      }
    }
    this.animations_.length = 0;
    this.cancelAnchor_ = anchor;
    this.nextCenter_ = null;
    this.nextResolution_ = NaN;
    this.nextRotation_ = NaN;
  }
  updateAnimations_() {
    if (this.updateAnimationKey_ !== void 0) {
      cancelAnimationFrame(this.updateAnimationKey_);
      this.updateAnimationKey_ = void 0;
    }
    if (!this.getAnimating()) {
      return;
    }
    const now2 = Date.now();
    let more = false;
    for (let i2 = this.animations_.length - 1; i2 >= 0; --i2) {
      const series = this.animations_[i2];
      let seriesComplete = true;
      for (let j2 = 0, jj = series.length; j2 < jj; ++j2) {
        const animation = series[j2];
        if (animation.complete) {
          continue;
        }
        const elapsed = now2 - animation.start;
        let fraction = animation.duration > 0 ? elapsed / animation.duration : 1;
        if (fraction >= 1) {
          animation.complete = true;
          fraction = 1;
        } else {
          seriesComplete = false;
        }
        const progress = animation.easing(fraction);
        if (animation.sourceCenter) {
          const x0 = animation.sourceCenter[0];
          const y0 = animation.sourceCenter[1];
          const x1 = animation.targetCenter[0];
          const y1 = animation.targetCenter[1];
          this.nextCenter_ = animation.targetCenter;
          const x2 = x0 + progress * (x1 - x0);
          const y2 = y0 + progress * (y1 - y0);
          this.targetCenter_ = [x2, y2];
        }
        if (animation.sourceResolution && animation.targetResolution) {
          const resolution = progress === 1 ? animation.targetResolution : animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);
          if (animation.anchor) {
            const size = this.getViewportSize_(this.getRotation());
            const constrainedResolution = this.constraints_.resolution(resolution, 0, size, true);
            this.targetCenter_ = this.calculateCenterZoom(constrainedResolution, animation.anchor);
          }
          this.nextResolution_ = animation.targetResolution;
          this.targetResolution_ = resolution;
          this.applyTargetState_(true);
        }
        if (animation.sourceRotation !== void 0 && animation.targetRotation !== void 0) {
          const rotation = progress === 1 ? modulo(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);
          if (animation.anchor) {
            const constrainedRotation = this.constraints_.rotation(rotation, true);
            this.targetCenter_ = this.calculateCenterRotate(constrainedRotation, animation.anchor);
          }
          this.nextRotation_ = animation.targetRotation;
          this.targetRotation_ = rotation;
        }
        this.applyTargetState_(true);
        more = true;
        if (!animation.complete) {
          break;
        }
      }
      if (seriesComplete) {
        this.animations_[i2] = null;
        this.setHint(ViewHint.ANIMATING, -1);
        this.nextCenter_ = null;
        this.nextResolution_ = NaN;
        this.nextRotation_ = NaN;
        const callback = series[0].callback;
        if (callback) {
          animationCallback(callback, true);
        }
      }
    }
    this.animations_ = this.animations_.filter(Boolean);
    if (more && this.updateAnimationKey_ === void 0) {
      this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_.bind(this));
    }
  }
  calculateCenterRotate(rotation, anchor) {
    let center;
    const currentCenter = this.getCenterInternal();
    if (currentCenter !== void 0) {
      center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];
      rotate$1(center, rotation - this.getRotation());
      add$3(center, anchor);
    }
    return center;
  }
  calculateCenterZoom(resolution, anchor) {
    let center;
    const currentCenter = this.getCenterInternal();
    const currentResolution = this.getResolution();
    if (currentCenter !== void 0 && currentResolution !== void 0) {
      const x2 = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;
      const y2 = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;
      center = [x2, y2];
    }
    return center;
  }
  getViewportSize_(rotation) {
    const size = this.viewportSize_;
    if (rotation) {
      const w2 = size[0];
      const h2 = size[1];
      return [
        Math.abs(w2 * Math.cos(rotation)) + Math.abs(h2 * Math.sin(rotation)),
        Math.abs(w2 * Math.sin(rotation)) + Math.abs(h2 * Math.cos(rotation))
      ];
    }
    return size;
  }
  setViewportSize(size) {
    this.viewportSize_ = Array.isArray(size) ? size.slice() : [100, 100];
    if (!this.getAnimating()) {
      this.resolveConstraints(0);
    }
  }
  getCenter() {
    const center = this.getCenterInternal();
    if (!center) {
      return center;
    }
    return toUserCoordinate(center, this.getProjection());
  }
  getCenterInternal() {
    return this.get(ViewProperty.CENTER);
  }
  getConstraints() {
    return this.constraints_;
  }
  getConstrainResolution() {
    return this.get("constrainResolution");
  }
  getHints(hints) {
    if (hints !== void 0) {
      hints[0] = this.hints_[0];
      hints[1] = this.hints_[1];
      return hints;
    }
    return this.hints_.slice();
  }
  calculateExtent(size) {
    const extent2 = this.calculateExtentInternal(size);
    return toUserExtent(extent2, this.getProjection());
  }
  calculateExtentInternal(size) {
    size = size || this.getViewportSizeMinusPadding_();
    const center = this.getCenterInternal();
    assert(center, 1);
    const resolution = this.getResolution();
    assert(resolution !== void 0, 2);
    const rotation = this.getRotation();
    assert(rotation !== void 0, 3);
    return getForViewAndSize(center, resolution, rotation, size);
  }
  getMaxResolution() {
    return this.maxResolution_;
  }
  getMinResolution() {
    return this.minResolution_;
  }
  getMaxZoom() {
    return this.getZoomForResolution(this.minResolution_);
  }
  setMaxZoom(zoom) {
    this.applyOptions_(this.getUpdatedOptions_({ maxZoom: zoom }));
  }
  getMinZoom() {
    return this.getZoomForResolution(this.maxResolution_);
  }
  setMinZoom(zoom) {
    this.applyOptions_(this.getUpdatedOptions_({ minZoom: zoom }));
  }
  setConstrainResolution(enabled) {
    this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: enabled }));
  }
  getProjection() {
    return this.projection_;
  }
  getResolution() {
    return this.get(ViewProperty.RESOLUTION);
  }
  getResolutions() {
    return this.resolutions_;
  }
  getResolutionForExtent(extent2, size) {
    return this.getResolutionForExtentInternal(fromUserExtent(extent2, this.getProjection()), size);
  }
  getResolutionForExtentInternal(extent2, size) {
    size = size || this.getViewportSizeMinusPadding_();
    const xResolution = getWidth(extent2) / size[0];
    const yResolution = getHeight(extent2) / size[1];
    return Math.max(xResolution, yResolution);
  }
  getResolutionForValueFunction(power) {
    power = power || 2;
    const maxResolution = this.getConstrainedResolution(this.maxResolution_);
    const minResolution = this.minResolution_;
    const max2 = Math.log(maxResolution / minResolution) / Math.log(power);
    return function(value) {
      const resolution = maxResolution / Math.pow(power, value * max2);
      return resolution;
    };
  }
  getRotation() {
    return this.get(ViewProperty.ROTATION);
  }
  getValueForResolutionFunction(power) {
    const logPower = Math.log(power || 2);
    const maxResolution = this.getConstrainedResolution(this.maxResolution_);
    const minResolution = this.minResolution_;
    const max2 = Math.log(maxResolution / minResolution) / logPower;
    return function(resolution) {
      const value = Math.log(maxResolution / resolution) / logPower / max2;
      return value;
    };
  }
  getViewportSizeMinusPadding_(rotation) {
    let size = this.getViewportSize_(rotation);
    const padding = this.padding_;
    if (padding) {
      size = [
        size[0] - padding[1] - padding[3],
        size[1] - padding[0] - padding[2]
      ];
    }
    return size;
  }
  getState() {
    const projection = this.getProjection();
    const resolution = this.getResolution();
    const rotation = this.getRotation();
    let center = this.getCenterInternal();
    const padding = this.padding_;
    if (padding) {
      const reducedSize = this.getViewportSizeMinusPadding_();
      center = calculateCenterOn(center, this.getViewportSize_(), [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]], resolution, rotation);
    }
    return {
      center: center.slice(0),
      projection: projection !== void 0 ? projection : null,
      resolution,
      nextCenter: this.nextCenter_,
      nextResolution: this.nextResolution_,
      nextRotation: this.nextRotation_,
      rotation,
      zoom: this.getZoom()
    };
  }
  getZoom() {
    let zoom;
    const resolution = this.getResolution();
    if (resolution !== void 0) {
      zoom = this.getZoomForResolution(resolution);
    }
    return zoom;
  }
  getZoomForResolution(resolution) {
    let offset2 = this.minZoom_ || 0;
    let max2, zoomFactor;
    if (this.resolutions_) {
      const nearest = linearFindNearest(this.resolutions_, resolution, 1);
      offset2 = nearest;
      max2 = this.resolutions_[nearest];
      if (nearest == this.resolutions_.length - 1) {
        zoomFactor = 2;
      } else {
        zoomFactor = max2 / this.resolutions_[nearest + 1];
      }
    } else {
      max2 = this.maxResolution_;
      zoomFactor = this.zoomFactor_;
    }
    return offset2 + Math.log(max2 / resolution) / Math.log(zoomFactor);
  }
  getResolutionForZoom(zoom) {
    if (this.resolutions_) {
      if (this.resolutions_.length <= 1) {
        return 0;
      }
      const baseLevel = clamp(Math.floor(zoom), 0, this.resolutions_.length - 2);
      const zoomFactor = this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];
      return this.resolutions_[baseLevel] / Math.pow(zoomFactor, clamp(zoom - baseLevel, 0, 1));
    }
    return this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_);
  }
  fit(geometryOrExtent, options) {
    let geometry;
    assert(Array.isArray(geometryOrExtent) || typeof geometryOrExtent.getSimplifiedGeometry === "function", 24);
    if (Array.isArray(geometryOrExtent)) {
      assert(!isEmpty(geometryOrExtent), 25);
      const extent2 = fromUserExtent(geometryOrExtent, this.getProjection());
      geometry = fromExtent(extent2);
    } else if (geometryOrExtent.getType() === "Circle") {
      const extent2 = fromUserExtent(geometryOrExtent.getExtent(), this.getProjection());
      geometry = fromExtent(extent2);
      geometry.rotate(this.getRotation(), getCenter(extent2));
    } else {
      {
        geometry = geometryOrExtent;
      }
    }
    this.fitInternal(geometry, options);
  }
  rotatedExtentForGeometry(geometry) {
    const rotation = this.getRotation();
    const cosAngle = Math.cos(rotation);
    const sinAngle = Math.sin(-rotation);
    const coords = geometry.getFlatCoordinates();
    const stride = geometry.getStride();
    let minRotX = Infinity;
    let minRotY = Infinity;
    let maxRotX = -Infinity;
    let maxRotY = -Infinity;
    for (let i2 = 0, ii = coords.length; i2 < ii; i2 += stride) {
      const rotX = coords[i2] * cosAngle - coords[i2 + 1] * sinAngle;
      const rotY = coords[i2] * sinAngle + coords[i2 + 1] * cosAngle;
      minRotX = Math.min(minRotX, rotX);
      minRotY = Math.min(minRotY, rotY);
      maxRotX = Math.max(maxRotX, rotX);
      maxRotY = Math.max(maxRotY, rotY);
    }
    return [minRotX, minRotY, maxRotX, maxRotY];
  }
  fitInternal(geometry, options) {
    options = options || {};
    let size = options.size;
    if (!size) {
      size = this.getViewportSizeMinusPadding_();
    }
    const padding = options.padding !== void 0 ? options.padding : [0, 0, 0, 0];
    const nearest = options.nearest !== void 0 ? options.nearest : false;
    let minResolution;
    if (options.minResolution !== void 0) {
      minResolution = options.minResolution;
    } else if (options.maxZoom !== void 0) {
      minResolution = this.getResolutionForZoom(options.maxZoom);
    } else {
      minResolution = 0;
    }
    const rotatedExtent = this.rotatedExtentForGeometry(geometry);
    let resolution = this.getResolutionForExtentInternal(rotatedExtent, [
      size[0] - padding[1] - padding[3],
      size[1] - padding[0] - padding[2]
    ]);
    resolution = isNaN(resolution) ? minResolution : Math.max(resolution, minResolution);
    resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1);
    const rotation = this.getRotation();
    const sinAngle = Math.sin(rotation);
    const cosAngle = Math.cos(rotation);
    const centerRot = getCenter(rotatedExtent);
    centerRot[0] += (padding[1] - padding[3]) / 2 * resolution;
    centerRot[1] += (padding[0] - padding[2]) / 2 * resolution;
    const centerX = centerRot[0] * cosAngle - centerRot[1] * sinAngle;
    const centerY = centerRot[1] * cosAngle + centerRot[0] * sinAngle;
    const center = this.getConstrainedCenter([centerX, centerY], resolution);
    const callback = options.callback ? options.callback : VOID;
    if (options.duration !== void 0) {
      this.animateInternal({
        resolution,
        center,
        duration: options.duration,
        easing: options.easing
      }, callback);
    } else {
      this.targetResolution_ = resolution;
      this.targetCenter_ = center;
      this.applyTargetState_(false, true);
      animationCallback(callback, true);
    }
  }
  centerOn(coordinate, size, position2) {
    this.centerOnInternal(fromUserCoordinate(coordinate, this.getProjection()), size, position2);
  }
  centerOnInternal(coordinate, size, position2) {
    this.setCenterInternal(calculateCenterOn(coordinate, size, position2, this.getResolution(), this.getRotation()));
  }
  calculateCenterShift(center, resolution, rotation, size) {
    let centerShift;
    const padding = this.padding_;
    if (padding && center) {
      const reducedSize = this.getViewportSizeMinusPadding_(-rotation);
      const shiftedCenter = calculateCenterOn(center, size, [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]], resolution, rotation);
      centerShift = [
        center[0] - shiftedCenter[0],
        center[1] - shiftedCenter[1]
      ];
    }
    return centerShift;
  }
  isDef() {
    return !!this.getCenterInternal() && this.getResolution() !== void 0;
  }
  adjustCenter(deltaCoordinates) {
    const center = toUserCoordinate(this.targetCenter_, this.getProjection());
    this.setCenter([
      center[0] + deltaCoordinates[0],
      center[1] + deltaCoordinates[1]
    ]);
  }
  adjustCenterInternal(deltaCoordinates) {
    const center = this.targetCenter_;
    this.setCenterInternal([
      center[0] + deltaCoordinates[0],
      center[1] + deltaCoordinates[1]
    ]);
  }
  adjustResolution(ratio, anchor) {
    anchor = anchor && fromUserCoordinate(anchor, this.getProjection());
    this.adjustResolutionInternal(ratio, anchor);
  }
  adjustResolutionInternal(ratio, anchor) {
    const isMoving = this.getAnimating() || this.getInteracting();
    const size = this.getViewportSize_(this.getRotation());
    const newResolution = this.constraints_.resolution(this.targetResolution_ * ratio, 0, size, isMoving);
    if (anchor) {
      this.targetCenter_ = this.calculateCenterZoom(newResolution, anchor);
    }
    this.targetResolution_ *= ratio;
    this.applyTargetState_();
  }
  adjustZoom(delta, anchor) {
    this.adjustResolution(Math.pow(this.zoomFactor_, -delta), anchor);
  }
  adjustRotation(delta, anchor) {
    if (anchor) {
      anchor = fromUserCoordinate(anchor, this.getProjection());
    }
    this.adjustRotationInternal(delta, anchor);
  }
  adjustRotationInternal(delta, anchor) {
    const isMoving = this.getAnimating() || this.getInteracting();
    const newRotation = this.constraints_.rotation(this.targetRotation_ + delta, isMoving);
    if (anchor) {
      this.targetCenter_ = this.calculateCenterRotate(newRotation, anchor);
    }
    this.targetRotation_ += delta;
    this.applyTargetState_();
  }
  setCenter(center) {
    this.setCenterInternal(center ? fromUserCoordinate(center, this.getProjection()) : center);
  }
  setCenterInternal(center) {
    this.targetCenter_ = center;
    this.applyTargetState_();
  }
  setHint(hint, delta) {
    this.hints_[hint] += delta;
    this.changed();
    return this.hints_[hint];
  }
  setResolution(resolution) {
    this.targetResolution_ = resolution;
    this.applyTargetState_();
  }
  setRotation(rotation) {
    this.targetRotation_ = rotation;
    this.applyTargetState_();
  }
  setZoom(zoom) {
    this.setResolution(this.getResolutionForZoom(zoom));
  }
  applyTargetState_(doNotCancelAnims, forceMoving) {
    const isMoving = this.getAnimating() || this.getInteracting() || forceMoving;
    const newRotation = this.constraints_.rotation(this.targetRotation_, isMoving);
    const size = this.getViewportSize_(newRotation);
    const newResolution = this.constraints_.resolution(this.targetResolution_, 0, size, isMoving);
    const newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, isMoving, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));
    if (this.get(ViewProperty.ROTATION) !== newRotation) {
      this.set(ViewProperty.ROTATION, newRotation);
    }
    if (this.get(ViewProperty.RESOLUTION) !== newResolution) {
      this.set(ViewProperty.RESOLUTION, newResolution);
      this.set("zoom", this.getZoom(), true);
    }
    if (!newCenter || !this.get(ViewProperty.CENTER) || !equals$1(this.get(ViewProperty.CENTER), newCenter)) {
      this.set(ViewProperty.CENTER, newCenter);
    }
    if (this.getAnimating() && !doNotCancelAnims) {
      this.cancelAnimations();
    }
    this.cancelAnchor_ = void 0;
  }
  resolveConstraints(duration2, resolutionDirection, anchor) {
    duration2 = duration2 !== void 0 ? duration2 : 200;
    const direction2 = resolutionDirection || 0;
    const newRotation = this.constraints_.rotation(this.targetRotation_);
    const size = this.getViewportSize_(newRotation);
    const newResolution = this.constraints_.resolution(this.targetResolution_, direction2, size);
    const newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, false, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));
    if (duration2 === 0 && !this.cancelAnchor_) {
      this.targetResolution_ = newResolution;
      this.targetRotation_ = newRotation;
      this.targetCenter_ = newCenter;
      this.applyTargetState_();
      return;
    }
    anchor = anchor || (duration2 === 0 ? this.cancelAnchor_ : void 0);
    this.cancelAnchor_ = void 0;
    if (this.getResolution() !== newResolution || this.getRotation() !== newRotation || !this.getCenterInternal() || !equals$1(this.getCenterInternal(), newCenter)) {
      if (this.getAnimating()) {
        this.cancelAnimations();
      }
      this.animateInternal({
        rotation: newRotation,
        center: newCenter,
        resolution: newResolution,
        duration: duration2,
        easing: easeOut,
        anchor
      });
    }
  }
  beginInteraction() {
    this.resolveConstraints(0);
    this.setHint(ViewHint.INTERACTING, 1);
  }
  endInteraction(duration2, resolutionDirection, anchor) {
    anchor = anchor && fromUserCoordinate(anchor, this.getProjection());
    this.endInteractionInternal(duration2, resolutionDirection, anchor);
  }
  endInteractionInternal(duration2, resolutionDirection, anchor) {
    this.setHint(ViewHint.INTERACTING, -1);
    this.resolveConstraints(duration2, resolutionDirection, anchor);
  }
  getConstrainedCenter(targetCenter, targetResolution) {
    const size = this.getViewportSize_(this.getRotation());
    return this.constraints_.center(targetCenter, targetResolution || this.getResolution(), size);
  }
  getConstrainedZoom(targetZoom, direction2) {
    const targetRes = this.getResolutionForZoom(targetZoom);
    return this.getZoomForResolution(this.getConstrainedResolution(targetRes, direction2));
  }
  getConstrainedResolution(targetResolution, direction2) {
    direction2 = direction2 || 0;
    const size = this.getViewportSize_(this.getRotation());
    return this.constraints_.resolution(targetResolution, direction2, size);
  }
}
function animationCallback(callback, returnValue) {
  setTimeout(function() {
    callback(returnValue);
  }, 0);
}
function createCenterConstraint(options) {
  if (options.extent !== void 0) {
    const smooth = options.smoothExtentConstraint !== void 0 ? options.smoothExtentConstraint : true;
    return createExtent(options.extent, options.constrainOnlyCenter, smooth);
  }
  const projection = createProjection(options.projection, "EPSG:3857");
  if (options.multiWorld !== true && projection.isGlobal()) {
    const extent2 = projection.getExtent().slice();
    extent2[0] = -Infinity;
    extent2[2] = Infinity;
    return createExtent(extent2, false, false);
  }
  return none$1;
}
function createResolutionConstraint(options) {
  let resolutionConstraint;
  let maxResolution;
  let minResolution;
  const defaultMaxZoom = 28;
  const defaultZoomFactor = 2;
  let minZoom = options.minZoom !== void 0 ? options.minZoom : DEFAULT_MIN_ZOOM;
  let maxZoom = options.maxZoom !== void 0 ? options.maxZoom : defaultMaxZoom;
  const zoomFactor = options.zoomFactor !== void 0 ? options.zoomFactor : defaultZoomFactor;
  const multiWorld = options.multiWorld !== void 0 ? options.multiWorld : false;
  const smooth = options.smoothResolutionConstraint !== void 0 ? options.smoothResolutionConstraint : true;
  const showFullExtent = options.showFullExtent !== void 0 ? options.showFullExtent : false;
  const projection = createProjection(options.projection, "EPSG:3857");
  const projExtent = projection.getExtent();
  let constrainOnlyCenter = options.constrainOnlyCenter;
  let extent2 = options.extent;
  if (!multiWorld && !extent2 && projection.isGlobal()) {
    constrainOnlyCenter = false;
    extent2 = projExtent;
  }
  if (options.resolutions !== void 0) {
    const resolutions = options.resolutions;
    maxResolution = resolutions[minZoom];
    minResolution = resolutions[maxZoom] !== void 0 ? resolutions[maxZoom] : resolutions[resolutions.length - 1];
    if (options.constrainResolution) {
      resolutionConstraint = createSnapToResolutions(resolutions, smooth, !constrainOnlyCenter && extent2, showFullExtent);
    } else {
      resolutionConstraint = createMinMaxResolution(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent2, showFullExtent);
    }
  } else {
    const size = !projExtent ? 360 * METERS_PER_UNIT$1.degrees / projection.getMetersPerUnit() : Math.max(getWidth(projExtent), getHeight(projExtent));
    const defaultMaxResolution = size / DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);
    const defaultMinResolution = defaultMaxResolution / Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);
    maxResolution = options.maxResolution;
    if (maxResolution !== void 0) {
      minZoom = 0;
    } else {
      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
    }
    minResolution = options.minResolution;
    if (minResolution === void 0) {
      if (options.maxZoom !== void 0) {
        if (options.maxResolution !== void 0) {
          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
        } else {
          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
        }
      } else {
        minResolution = defaultMinResolution;
      }
    }
    maxZoom = minZoom + Math.floor(Math.log(maxResolution / minResolution) / Math.log(zoomFactor));
    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);
    if (options.constrainResolution) {
      resolutionConstraint = createSnapToPower(zoomFactor, maxResolution, minResolution, smooth, !constrainOnlyCenter && extent2, showFullExtent);
    } else {
      resolutionConstraint = createMinMaxResolution(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent2, showFullExtent);
    }
  }
  return {
    constraint: resolutionConstraint,
    maxResolution,
    minResolution,
    minZoom,
    zoomFactor
  };
}
function createRotationConstraint(options) {
  const enableRotation = options.enableRotation !== void 0 ? options.enableRotation : true;
  if (enableRotation) {
    const constrainRotation = options.constrainRotation;
    if (constrainRotation === void 0 || constrainRotation === true) {
      return createSnapToZero();
    } else if (constrainRotation === false) {
      return none;
    } else if (typeof constrainRotation === "number") {
      return createSnapToN(constrainRotation);
    }
    return none;
  }
  return disable;
}
function isNoopAnimation(animation) {
  if (animation.sourceCenter && animation.targetCenter) {
    if (!equals$1(animation.sourceCenter, animation.targetCenter)) {
      return false;
    }
  }
  if (animation.sourceResolution !== animation.targetResolution) {
    return false;
  }
  if (animation.sourceRotation !== animation.targetRotation) {
    return false;
  }
  return true;
}
function calculateCenterOn(coordinate, size, position2, resolution, rotation) {
  const cosAngle = Math.cos(-rotation);
  let sinAngle = Math.sin(-rotation);
  let rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  let rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  rotX += (size[0] / 2 - position2[0]) * resolution;
  rotY += (position2[1] - size[1] / 2) * resolution;
  sinAngle = -sinAngle;
  const centerX = rotX * cosAngle - rotY * sinAngle;
  const centerY = rotY * cosAngle + rotX * sinAngle;
  return [centerX, centerY];
}
class Control$1 extends BaseObject {
  constructor(options) {
    super();
    const element = options.element;
    if (element && !options.target && !element.style.pointerEvents) {
      element.style.pointerEvents = "auto";
    }
    this.element = element ? element : null;
    this.target_ = null;
    this.map_ = null;
    this.listenerKeys = [];
    if (options.render) {
      this.render = options.render;
    }
    if (options.target) {
      this.setTarget(options.target);
    }
  }
  disposeInternal() {
    removeNode$1(this.element);
    super.disposeInternal();
  }
  getMap() {
    return this.map_;
  }
  setMap(map) {
    if (this.map_) {
      removeNode$1(this.element);
    }
    for (let i2 = 0, ii = this.listenerKeys.length; i2 < ii; ++i2) {
      unlistenByKey(this.listenerKeys[i2]);
    }
    this.listenerKeys.length = 0;
    this.map_ = map;
    if (map) {
      const target = this.target_ ? this.target_ : map.getOverlayContainerStopEvent();
      target.appendChild(this.element);
      if (this.render !== VOID) {
        this.listenerKeys.push(listen(map, MapEventType.POSTRENDER, this.render, this));
      }
      map.render();
    }
  }
  render(mapEvent) {
  }
  setTarget(target) {
    this.target_ = typeof target === "string" ? document.getElementById(target) : target;
  }
}
var Control$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": Control$1
}, Symbol.toStringTag, { value: "Module" }));
class Attribution extends Control$1 {
  constructor(options) {
    options = options ? options : {};
    super({
      element: document.createElement("div"),
      render: options.render,
      target: options.target
    });
    this.ulElement_ = document.createElement("ul");
    this.collapsed_ = options.collapsed !== void 0 ? options.collapsed : true;
    this.userCollapsed_ = this.collapsed_;
    this.overrideCollapsible_ = options.collapsible !== void 0;
    this.collapsible_ = options.collapsible !== void 0 ? options.collapsible : true;
    if (!this.collapsible_) {
      this.collapsed_ = false;
    }
    const className = options.className !== void 0 ? options.className : "ol-attribution";
    const tipLabel = options.tipLabel !== void 0 ? options.tipLabel : "Attributions";
    const expandClassName = options.expandClassName !== void 0 ? options.expandClassName : className + "-expand";
    const collapseLabel = options.collapseLabel !== void 0 ? options.collapseLabel : "\u203A";
    const collapseClassName = options.collapseClassName !== void 0 ? options.collapseClassName : className + "-collapse";
    if (typeof collapseLabel === "string") {
      this.collapseLabel_ = document.createElement("span");
      this.collapseLabel_.textContent = collapseLabel;
      this.collapseLabel_.className = collapseClassName;
    } else {
      this.collapseLabel_ = collapseLabel;
    }
    const label = options.label !== void 0 ? options.label : "i";
    if (typeof label === "string") {
      this.label_ = document.createElement("span");
      this.label_.textContent = label;
      this.label_.className = expandClassName;
    } else {
      this.label_ = label;
    }
    const activeLabel = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;
    this.toggleButton_ = document.createElement("button");
    this.toggleButton_.setAttribute("type", "button");
    this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
    this.toggleButton_.title = tipLabel;
    this.toggleButton_.appendChild(activeLabel);
    this.toggleButton_.addEventListener(EventType.CLICK, this.handleClick_.bind(this), false);
    const cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL + (this.collapsed_ && this.collapsible_ ? " " + CLASS_COLLAPSED : "") + (this.collapsible_ ? "" : " ol-uncollapsible");
    const element = this.element;
    element.className = cssClasses;
    element.appendChild(this.toggleButton_);
    element.appendChild(this.ulElement_);
    this.renderedAttributions_ = [];
    this.renderedVisible_ = true;
  }
  collectSourceAttributions_(frameState) {
    const lookup2 = {};
    const visibleAttributions = [];
    let collapsible = true;
    const layerStatesArray = frameState.layerStatesArray;
    for (let i2 = 0, ii = layerStatesArray.length; i2 < ii; ++i2) {
      const layerState = layerStatesArray[i2];
      if (!inView(layerState, frameState.viewState)) {
        continue;
      }
      const source = layerState.layer.getSource();
      if (!source) {
        continue;
      }
      const attributionGetter = source.getAttributions();
      if (!attributionGetter) {
        continue;
      }
      const attributions = attributionGetter(frameState);
      if (!attributions) {
        continue;
      }
      collapsible = collapsible && source.getAttributionsCollapsible() !== false;
      if (Array.isArray(attributions)) {
        for (let j2 = 0, jj = attributions.length; j2 < jj; ++j2) {
          if (!(attributions[j2] in lookup2)) {
            visibleAttributions.push(attributions[j2]);
            lookup2[attributions[j2]] = true;
          }
        }
      } else {
        if (!(attributions in lookup2)) {
          visibleAttributions.push(attributions);
          lookup2[attributions] = true;
        }
      }
    }
    if (!this.overrideCollapsible_) {
      this.setCollapsible(collapsible);
    }
    return visibleAttributions;
  }
  updateElement_(frameState) {
    if (!frameState) {
      if (this.renderedVisible_) {
        this.element.style.display = "none";
        this.renderedVisible_ = false;
      }
      return;
    }
    const attributions = this.collectSourceAttributions_(frameState);
    const visible = attributions.length > 0;
    if (this.renderedVisible_ != visible) {
      this.element.style.display = visible ? "" : "none";
      this.renderedVisible_ = visible;
    }
    if (equals$3(attributions, this.renderedAttributions_)) {
      return;
    }
    removeChildren(this.ulElement_);
    for (let i2 = 0, ii = attributions.length; i2 < ii; ++i2) {
      const element = document.createElement("li");
      element.innerHTML = attributions[i2];
      this.ulElement_.appendChild(element);
    }
    this.renderedAttributions_ = attributions;
  }
  handleClick_(event) {
    event.preventDefault();
    this.handleToggle_();
    this.userCollapsed_ = this.collapsed_;
  }
  handleToggle_() {
    this.element.classList.toggle(CLASS_COLLAPSED);
    if (this.collapsed_) {
      replaceNode(this.collapseLabel_, this.label_);
    } else {
      replaceNode(this.label_, this.collapseLabel_);
    }
    this.collapsed_ = !this.collapsed_;
    this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
  }
  getCollapsible() {
    return this.collapsible_;
  }
  setCollapsible(collapsible) {
    if (this.collapsible_ === collapsible) {
      return;
    }
    this.collapsible_ = collapsible;
    this.element.classList.toggle("ol-uncollapsible");
    if (this.userCollapsed_) {
      this.handleToggle_();
    }
  }
  setCollapsed(collapsed) {
    this.userCollapsed_ = collapsed;
    if (!this.collapsible_ || this.collapsed_ === collapsed) {
      return;
    }
    this.handleToggle_();
  }
  getCollapsed() {
    return this.collapsed_;
  }
  render(mapEvent) {
    this.updateElement_(mapEvent.frameState);
  }
}
class Rotate$1 extends Control$1 {
  constructor(options) {
    options = options ? options : {};
    super({
      element: document.createElement("div"),
      render: options.render,
      target: options.target
    });
    const className = options.className !== void 0 ? options.className : "ol-rotate";
    const label = options.label !== void 0 ? options.label : "\u21E7";
    const compassClassName = options.compassClassName !== void 0 ? options.compassClassName : "ol-compass";
    this.label_ = null;
    if (typeof label === "string") {
      this.label_ = document.createElement("span");
      this.label_.className = compassClassName;
      this.label_.textContent = label;
    } else {
      this.label_ = label;
      this.label_.classList.add(compassClassName);
    }
    const tipLabel = options.tipLabel ? options.tipLabel : "Reset rotation";
    const button = document.createElement("button");
    button.className = className + "-reset";
    button.setAttribute("type", "button");
    button.title = tipLabel;
    button.appendChild(this.label_);
    button.addEventListener(EventType.CLICK, this.handleClick_.bind(this), false);
    const cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL;
    const element = this.element;
    element.className = cssClasses;
    element.appendChild(button);
    this.callResetNorth_ = options.resetNorth ? options.resetNorth : void 0;
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
    this.autoHide_ = options.autoHide !== void 0 ? options.autoHide : true;
    this.rotation_ = void 0;
    if (this.autoHide_) {
      this.element.classList.add(CLASS_HIDDEN);
    }
  }
  handleClick_(event) {
    event.preventDefault();
    if (this.callResetNorth_ !== void 0) {
      this.callResetNorth_();
    } else {
      this.resetNorth_();
    }
  }
  resetNorth_() {
    const map = this.getMap();
    const view = map.getView();
    if (!view) {
      return;
    }
    const rotation = view.getRotation();
    if (rotation !== void 0) {
      if (this.duration_ > 0 && rotation % (2 * Math.PI) !== 0) {
        view.animate({
          rotation: 0,
          duration: this.duration_,
          easing: easeOut
        });
      } else {
        view.setRotation(0);
      }
    }
  }
  render(mapEvent) {
    const frameState = mapEvent.frameState;
    if (!frameState) {
      return;
    }
    const rotation = frameState.viewState.rotation;
    if (rotation != this.rotation_) {
      const transform2 = "rotate(" + rotation + "rad)";
      if (this.autoHide_) {
        const contains2 = this.element.classList.contains(CLASS_HIDDEN);
        if (!contains2 && rotation === 0) {
          this.element.classList.add(CLASS_HIDDEN);
        } else if (contains2 && rotation !== 0) {
          this.element.classList.remove(CLASS_HIDDEN);
        }
      }
      this.label_.style.transform = transform2;
    }
    this.rotation_ = rotation;
  }
}
class Zoom extends Control$1 {
  constructor(options) {
    options = options ? options : {};
    super({
      element: document.createElement("div"),
      target: options.target
    });
    const className = options.className !== void 0 ? options.className : "ol-zoom";
    const delta = options.delta !== void 0 ? options.delta : 1;
    const zoomInClassName = options.zoomInClassName !== void 0 ? options.zoomInClassName : className + "-in";
    const zoomOutClassName = options.zoomOutClassName !== void 0 ? options.zoomOutClassName : className + "-out";
    const zoomInLabel = options.zoomInLabel !== void 0 ? options.zoomInLabel : "+";
    const zoomOutLabel = options.zoomOutLabel !== void 0 ? options.zoomOutLabel : "\u2013";
    const zoomInTipLabel = options.zoomInTipLabel !== void 0 ? options.zoomInTipLabel : "Zoom in";
    const zoomOutTipLabel = options.zoomOutTipLabel !== void 0 ? options.zoomOutTipLabel : "Zoom out";
    const inElement = document.createElement("button");
    inElement.className = zoomInClassName;
    inElement.setAttribute("type", "button");
    inElement.title = zoomInTipLabel;
    inElement.appendChild(typeof zoomInLabel === "string" ? document.createTextNode(zoomInLabel) : zoomInLabel);
    inElement.addEventListener(EventType.CLICK, this.handleClick_.bind(this, delta), false);
    const outElement = document.createElement("button");
    outElement.className = zoomOutClassName;
    outElement.setAttribute("type", "button");
    outElement.title = zoomOutTipLabel;
    outElement.appendChild(typeof zoomOutLabel === "string" ? document.createTextNode(zoomOutLabel) : zoomOutLabel);
    outElement.addEventListener(EventType.CLICK, this.handleClick_.bind(this, -delta), false);
    const cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL;
    const element = this.element;
    element.className = cssClasses;
    element.appendChild(inElement);
    element.appendChild(outElement);
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
  }
  handleClick_(delta, event) {
    event.preventDefault();
    this.zoomByDelta_(delta);
  }
  zoomByDelta_(delta) {
    const map = this.getMap();
    const view = map.getView();
    if (!view) {
      return;
    }
    const currentZoom = view.getZoom();
    if (currentZoom !== void 0) {
      const newZoom = view.getConstrainedZoom(currentZoom + delta);
      if (this.duration_ > 0) {
        if (view.getAnimating()) {
          view.cancelAnimations();
        }
        view.animate({
          zoom: newZoom,
          duration: this.duration_,
          easing: easeOut
        });
      } else {
        view.setZoom(newZoom);
      }
    }
  }
}
function defaults$1(options) {
  options = options ? options : {};
  const controls = new Collection();
  const zoomControl = options.zoom !== void 0 ? options.zoom : true;
  if (zoomControl) {
    controls.push(new Zoom(options.zoomOptions));
  }
  const rotateControl = options.rotate !== void 0 ? options.rotate : true;
  if (rotateControl) {
    controls.push(new Rotate$1(options.rotateOptions));
  }
  const attributionControl = options.attribution !== void 0 ? options.attribution : true;
  if (attributionControl) {
    controls.push(new Attribution(options.attributionOptions));
  }
  return controls;
}
var InteractionProperty = {
  ACTIVE: "active"
};
class Interaction extends BaseObject {
  constructor(options) {
    super();
    this.on;
    this.once;
    this.un;
    if (options && options.handleEvent) {
      this.handleEvent = options.handleEvent;
    }
    this.map_ = null;
    this.setActive(true);
  }
  getActive() {
    return this.get(InteractionProperty.ACTIVE);
  }
  getMap() {
    return this.map_;
  }
  handleEvent(mapBrowserEvent) {
    return true;
  }
  setActive(active) {
    this.set(InteractionProperty.ACTIVE, active);
  }
  setMap(map) {
    this.map_ = map;
  }
}
function pan(view, delta, duration2) {
  const currentCenter = view.getCenterInternal();
  if (currentCenter) {
    const center = [currentCenter[0] + delta[0], currentCenter[1] + delta[1]];
    view.animateInternal({
      duration: duration2 !== void 0 ? duration2 : 250,
      easing: linear,
      center: view.getConstrainedCenter(center)
    });
  }
}
function zoomByDelta(view, delta, anchor, duration2) {
  const currentZoom = view.getZoom();
  if (currentZoom === void 0) {
    return;
  }
  const newZoom = view.getConstrainedZoom(currentZoom + delta);
  const newResolution = view.getResolutionForZoom(newZoom);
  if (view.getAnimating()) {
    view.cancelAnimations();
  }
  view.animate({
    resolution: newResolution,
    anchor,
    duration: duration2 !== void 0 ? duration2 : 250,
    easing: easeOut
  });
}
class DoubleClickZoom extends Interaction {
  constructor(options) {
    super();
    options = options ? options : {};
    this.delta_ = options.delta ? options.delta : 1;
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
  }
  handleEvent(mapBrowserEvent) {
    let stopEvent = false;
    if (mapBrowserEvent.type == MapBrowserEventType.DBLCLICK) {
      const browserEvent = mapBrowserEvent.originalEvent;
      const map = mapBrowserEvent.map;
      const anchor = mapBrowserEvent.coordinate;
      const delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;
      const view = map.getView();
      zoomByDelta(view, delta, anchor, this.duration_);
      browserEvent.preventDefault();
      stopEvent = true;
    }
    return !stopEvent;
  }
}
function getCanvasScale(el) {
  if (!(el instanceof HTMLCanvasElement)) {
    return [1, 1];
  }
  const scaleX = el.getBoundingClientRect().width * DEVICE_PIXEL_RATIO / el.offsetWidth;
  const scaleY = el.getBoundingClientRect().height * DEVICE_PIXEL_RATIO / el.offsetHeight;
  return [scaleX, scaleY];
}
class PointerInteraction extends Interaction {
  constructor(options) {
    options = options ? options : {};
    super(options);
    if (options.handleDownEvent) {
      this.handleDownEvent = options.handleDownEvent;
    }
    if (options.handleDragEvent) {
      this.handleDragEvent = options.handleDragEvent;
    }
    if (options.handleMoveEvent) {
      this.handleMoveEvent = options.handleMoveEvent;
    }
    if (options.handleUpEvent) {
      this.handleUpEvent = options.handleUpEvent;
    }
    if (options.stopDown) {
      this.stopDown = options.stopDown;
    }
    this.handlingDownUpSequence = false;
    this.targetPointers = [];
  }
  getPointerCount() {
    return this.targetPointers.length;
  }
  handleDownEvent(mapBrowserEvent) {
    return false;
  }
  handleDragEvent(mapBrowserEvent) {
  }
  handleEvent(mapBrowserEvent) {
    if (!mapBrowserEvent.originalEvent) {
      return true;
    }
    let stopEvent = false;
    this.updateTrackedPointers_(mapBrowserEvent);
    if (this.handlingDownUpSequence) {
      if (mapBrowserEvent.type == MapBrowserEventType.POINTERDRAG) {
        this.handleDragEvent(mapBrowserEvent);
        mapBrowserEvent.originalEvent.preventDefault();
      } else if (mapBrowserEvent.type == MapBrowserEventType.POINTERUP) {
        const handledUp = this.handleUpEvent(mapBrowserEvent);
        this.handlingDownUpSequence = handledUp && this.targetPointers.length > 0;
      }
    } else {
      if (mapBrowserEvent.type == MapBrowserEventType.POINTERDOWN) {
        const handled = this.handleDownEvent(mapBrowserEvent);
        this.handlingDownUpSequence = handled;
        stopEvent = this.stopDown(handled);
      } else if (mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE) {
        this.handleMoveEvent(mapBrowserEvent);
      }
    }
    return !stopEvent;
  }
  handleMoveEvent(mapBrowserEvent) {
  }
  handleUpEvent(mapBrowserEvent) {
    return false;
  }
  stopDown(handled) {
    return handled;
  }
  updateTrackedPointers_(mapBrowserEvent) {
    if (mapBrowserEvent.activePointers) {
      this.targetPointers = mapBrowserEvent.activePointers;
    }
  }
}
function centroid(pointerEvents) {
  const length = pointerEvents.length;
  let clientX = 0;
  let clientY = 0;
  const [scaleX, scaleY] = getCanvasScale(pointerEvents[0].target);
  for (let i2 = 0; i2 < length; i2++) {
    clientX += pointerEvents[i2].clientX / scaleX;
    clientY += pointerEvents[i2].clientY / scaleY;
  }
  return [clientX / length, clientY / length];
}
function all$1(var_args) {
  const conditions = arguments;
  return function(event) {
    let pass = true;
    for (let i2 = 0, ii = conditions.length; i2 < ii; ++i2) {
      pass = pass && conditions[i2](event);
      if (!pass) {
        break;
      }
    }
    return pass;
  };
}
const altKeyOnly = function(mapBrowserEvent) {
  const originalEvent = mapBrowserEvent.originalEvent;
  return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
const altShiftKeysOnly = function(mapBrowserEvent) {
  const originalEvent = mapBrowserEvent.originalEvent;
  return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
const focus = function(event) {
  const targetElement = event.map.getTargetElement();
  const activeElement = event.map.getOwnerDocument().activeElement;
  return targetElement.contains(activeElement);
};
const focusWithTabindex = function(event) {
  return event.map.getTargetElement().hasAttribute("tabindex") ? focus(event) : true;
};
const always = TRUE;
const click = function(mapBrowserEvent) {
  return mapBrowserEvent.type == MapBrowserEventType.CLICK;
};
const mouseActionButton = function(mapBrowserEvent) {
  const originalEvent = mapBrowserEvent.originalEvent;
  return originalEvent.button == 0 && !(WEBKIT && MAC && originalEvent.ctrlKey);
};
const never = FALSE;
const pointerMove = function(mapBrowserEvent) {
  return mapBrowserEvent.type == "pointermove";
};
const singleClick = function(mapBrowserEvent) {
  return mapBrowserEvent.type == MapBrowserEventType.SINGLECLICK;
};
const doubleClick = function(mapBrowserEvent) {
  return mapBrowserEvent.type == MapBrowserEventType.DBLCLICK;
};
const noModifierKeys = function(mapBrowserEvent) {
  const originalEvent = mapBrowserEvent.originalEvent;
  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
const platformModifierKeyOnly = function(mapBrowserEvent) {
  const originalEvent = mapBrowserEvent.originalEvent;
  return !originalEvent.altKey && (MAC ? originalEvent.metaKey : originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
const shiftKeyOnly = function(mapBrowserEvent) {
  const originalEvent = mapBrowserEvent.originalEvent;
  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
const targetNotEditable = function(mapBrowserEvent) {
  const originalEvent = mapBrowserEvent.originalEvent;
  const tagName = originalEvent.target.tagName;
  return tagName !== "INPUT" && tagName !== "SELECT" && tagName !== "TEXTAREA" && !originalEvent.target.isContentEditable;
};
const mouseOnly = function(mapBrowserEvent) {
  const pointerEvent = mapBrowserEvent.originalEvent;
  assert(pointerEvent !== void 0, 56);
  return pointerEvent.pointerType == "mouse";
};
const touchOnly = function(mapBrowserEvent) {
  const pointerEvt = mapBrowserEvent.originalEvent;
  assert(pointerEvt !== void 0, 56);
  return pointerEvt.pointerType === "touch";
};
const penOnly = function(mapBrowserEvent) {
  const pointerEvt = mapBrowserEvent.originalEvent;
  assert(pointerEvt !== void 0, 56);
  return pointerEvt.pointerType === "pen";
};
const primaryAction = function(mapBrowserEvent) {
  const pointerEvent = mapBrowserEvent.originalEvent;
  assert(pointerEvent !== void 0, 56);
  return pointerEvent.isPrimary && pointerEvent.button === 0;
};
var selectconditions = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  all: all$1,
  altKeyOnly,
  altShiftKeysOnly,
  focus,
  focusWithTabindex,
  always,
  click,
  mouseActionButton,
  never,
  pointerMove,
  singleClick,
  doubleClick,
  noModifierKeys,
  platformModifierKeyOnly,
  shiftKeyOnly,
  targetNotEditable,
  mouseOnly,
  touchOnly,
  penOnly,
  primaryAction
}, Symbol.toStringTag, { value: "Module" }));
class DragPan extends PointerInteraction {
  constructor(options) {
    super({
      stopDown: FALSE
    });
    options = options ? options : {};
    this.kinetic_ = options.kinetic;
    this.lastCentroid = null;
    this.lastPointersCount_;
    this.panning_ = false;
    const condition = options.condition ? options.condition : all$1(noModifierKeys, primaryAction);
    this.condition_ = options.onFocusOnly ? all$1(focusWithTabindex, condition) : condition;
    this.noKinetic_ = false;
  }
  handleDragEvent(mapBrowserEvent) {
    if (!this.panning_) {
      this.panning_ = true;
      this.getMap().getView().beginInteraction();
    }
    const targetPointers = this.targetPointers;
    const centroid$1 = centroid(targetPointers);
    if (targetPointers.length == this.lastPointersCount_) {
      if (this.kinetic_) {
        this.kinetic_.update(centroid$1[0], centroid$1[1]);
      }
      if (this.lastCentroid) {
        const delta = [
          this.lastCentroid[0] - centroid$1[0],
          centroid$1[1] - this.lastCentroid[1]
        ];
        const map = mapBrowserEvent.map;
        const view = map.getView();
        scale$2(delta, view.getResolution());
        rotate$1(delta, view.getRotation());
        view.adjustCenterInternal(delta);
      }
    } else if (this.kinetic_) {
      this.kinetic_.begin();
    }
    this.lastCentroid = centroid$1;
    this.lastPointersCount_ = targetPointers.length;
    mapBrowserEvent.originalEvent.preventDefault();
  }
  handleUpEvent(mapBrowserEvent) {
    const map = mapBrowserEvent.map;
    const view = map.getView();
    if (this.targetPointers.length === 0) {
      if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
        const distance2 = this.kinetic_.getDistance();
        const angle2 = this.kinetic_.getAngle();
        const center = view.getCenterInternal();
        const centerpx = map.getPixelFromCoordinateInternal(center);
        const dest = map.getCoordinateFromPixelInternal([
          centerpx[0] - distance2 * Math.cos(angle2),
          centerpx[1] - distance2 * Math.sin(angle2)
        ]);
        view.animateInternal({
          center: view.getConstrainedCenter(dest),
          duration: 500,
          easing: easeOut
        });
      }
      if (this.panning_) {
        this.panning_ = false;
        view.endInteraction();
      }
      return false;
    }
    if (this.kinetic_) {
      this.kinetic_.begin();
    }
    this.lastCentroid = null;
    return true;
  }
  handleDownEvent(mapBrowserEvent) {
    if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {
      const map = mapBrowserEvent.map;
      const view = map.getView();
      this.lastCentroid = null;
      if (view.getAnimating()) {
        view.cancelAnimations();
      }
      if (this.kinetic_) {
        this.kinetic_.begin();
      }
      this.noKinetic_ = this.targetPointers.length > 1;
      return true;
    }
    return false;
  }
}
class DragRotate extends PointerInteraction {
  constructor(options) {
    options = options ? options : {};
    super({
      stopDown: FALSE
    });
    this.condition_ = options.condition ? options.condition : altShiftKeysOnly;
    this.lastAngle_ = void 0;
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
  }
  handleDragEvent(mapBrowserEvent) {
    if (!mouseOnly(mapBrowserEvent)) {
      return;
    }
    const map = mapBrowserEvent.map;
    const view = map.getView();
    if (view.getConstraints().rotation === disable) {
      return;
    }
    const size = map.getSize();
    const offset2 = mapBrowserEvent.pixel;
    const theta = Math.atan2(size[1] / 2 - offset2[1], offset2[0] - size[0] / 2);
    if (this.lastAngle_ !== void 0) {
      const delta = theta - this.lastAngle_;
      view.adjustRotationInternal(-delta);
    }
    this.lastAngle_ = theta;
  }
  handleUpEvent(mapBrowserEvent) {
    if (!mouseOnly(mapBrowserEvent)) {
      return true;
    }
    const map = mapBrowserEvent.map;
    const view = map.getView();
    view.endInteraction(this.duration_);
    return false;
  }
  handleDownEvent(mapBrowserEvent) {
    if (!mouseOnly(mapBrowserEvent)) {
      return false;
    }
    if (mouseActionButton(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {
      const map = mapBrowserEvent.map;
      map.getView().beginInteraction();
      this.lastAngle_ = void 0;
      return true;
    }
    return false;
  }
}
class RenderBox extends Disposable {
  constructor(className) {
    super();
    this.geometry_ = null;
    this.element_ = document.createElement("div");
    this.element_.style.position = "absolute";
    this.element_.style.pointerEvents = "auto";
    this.element_.className = "ol-box " + className;
    this.map_ = null;
    this.startPixel_ = null;
    this.endPixel_ = null;
  }
  disposeInternal() {
    this.setMap(null);
  }
  render_() {
    const startPixel = this.startPixel_;
    const endPixel = this.endPixel_;
    const px = "px";
    const style2 = this.element_.style;
    style2.left = Math.min(startPixel[0], endPixel[0]) + px;
    style2.top = Math.min(startPixel[1], endPixel[1]) + px;
    style2.width = Math.abs(endPixel[0] - startPixel[0]) + px;
    style2.height = Math.abs(endPixel[1] - startPixel[1]) + px;
  }
  setMap(map) {
    if (this.map_) {
      this.map_.getOverlayContainer().removeChild(this.element_);
      const style2 = this.element_.style;
      style2.left = "inherit";
      style2.top = "inherit";
      style2.width = "inherit";
      style2.height = "inherit";
    }
    this.map_ = map;
    if (this.map_) {
      this.map_.getOverlayContainer().appendChild(this.element_);
    }
  }
  setPixels(startPixel, endPixel) {
    this.startPixel_ = startPixel;
    this.endPixel_ = endPixel;
    this.createOrUpdateGeometry();
    this.render_();
  }
  createOrUpdateGeometry() {
    const startPixel = this.startPixel_;
    const endPixel = this.endPixel_;
    const pixels = [
      startPixel,
      [startPixel[0], endPixel[1]],
      endPixel,
      [endPixel[0], startPixel[1]]
    ];
    const coordinates2 = pixels.map(this.map_.getCoordinateFromPixelInternal, this.map_);
    coordinates2[4] = coordinates2[0].slice();
    if (!this.geometry_) {
      this.geometry_ = new Polygon$1([coordinates2]);
    } else {
      this.geometry_.setCoordinates([coordinates2]);
    }
  }
  getGeometry() {
    return this.geometry_;
  }
}
const DragBoxEventType = {
  BOXSTART: "boxstart",
  BOXDRAG: "boxdrag",
  BOXEND: "boxend",
  BOXCANCEL: "boxcancel"
};
class DragBoxEvent extends BaseEvent {
  constructor(type, coordinate, mapBrowserEvent) {
    super(type);
    this.coordinate = coordinate;
    this.mapBrowserEvent = mapBrowserEvent;
  }
}
class DragBox extends PointerInteraction {
  constructor(options) {
    super();
    this.on;
    this.once;
    this.un;
    options = options ? options : {};
    this.box_ = new RenderBox(options.className || "ol-dragbox");
    this.minArea_ = options.minArea !== void 0 ? options.minArea : 64;
    if (options.onBoxEnd) {
      this.onBoxEnd = options.onBoxEnd;
    }
    this.startPixel_ = null;
    this.condition_ = options.condition ? options.condition : mouseActionButton;
    this.boxEndCondition_ = options.boxEndCondition ? options.boxEndCondition : this.defaultBoxEndCondition;
  }
  defaultBoxEndCondition(mapBrowserEvent, startPixel, endPixel) {
    const width = endPixel[0] - startPixel[0];
    const height = endPixel[1] - startPixel[1];
    return width * width + height * height >= this.minArea_;
  }
  getGeometry() {
    return this.box_.getGeometry();
  }
  handleDragEvent(mapBrowserEvent) {
    this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);
    this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXDRAG, mapBrowserEvent.coordinate, mapBrowserEvent));
  }
  handleUpEvent(mapBrowserEvent) {
    this.box_.setMap(null);
    const completeBox = this.boxEndCondition_(mapBrowserEvent, this.startPixel_, mapBrowserEvent.pixel);
    if (completeBox) {
      this.onBoxEnd(mapBrowserEvent);
    }
    this.dispatchEvent(new DragBoxEvent(completeBox ? DragBoxEventType.BOXEND : DragBoxEventType.BOXCANCEL, mapBrowserEvent.coordinate, mapBrowserEvent));
    return false;
  }
  handleDownEvent(mapBrowserEvent) {
    if (this.condition_(mapBrowserEvent)) {
      this.startPixel_ = mapBrowserEvent.pixel;
      this.box_.setMap(mapBrowserEvent.map);
      this.box_.setPixels(this.startPixel_, this.startPixel_);
      this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXSTART, mapBrowserEvent.coordinate, mapBrowserEvent));
      return true;
    }
    return false;
  }
  onBoxEnd(event) {
  }
}
class DragZoom extends DragBox {
  constructor(options) {
    options = options ? options : {};
    const condition = options.condition ? options.condition : shiftKeyOnly;
    super({
      condition,
      className: options.className || "ol-dragzoom",
      minArea: options.minArea
    });
    this.duration_ = options.duration !== void 0 ? options.duration : 200;
    this.out_ = options.out !== void 0 ? options.out : false;
  }
  onBoxEnd(event) {
    const map = this.getMap();
    const view = map.getView();
    let geometry = this.getGeometry();
    if (this.out_) {
      const rotatedExtent = view.rotatedExtentForGeometry(geometry);
      const resolution = view.getResolutionForExtentInternal(rotatedExtent);
      const factor = view.getResolution() / resolution;
      geometry = geometry.clone();
      geometry.scale(factor * factor);
    }
    view.fitInternal(geometry, {
      duration: this.duration_,
      easing: easeOut
    });
  }
}
var KeyCode = {
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40
};
class KeyboardPan extends Interaction {
  constructor(options) {
    super();
    options = options || {};
    this.defaultCondition_ = function(mapBrowserEvent) {
      return noModifierKeys(mapBrowserEvent) && targetNotEditable(mapBrowserEvent);
    };
    this.condition_ = options.condition !== void 0 ? options.condition : this.defaultCondition_;
    this.duration_ = options.duration !== void 0 ? options.duration : 100;
    this.pixelDelta_ = options.pixelDelta !== void 0 ? options.pixelDelta : 128;
  }
  handleEvent(mapBrowserEvent) {
    let stopEvent = false;
    if (mapBrowserEvent.type == EventType.KEYDOWN) {
      const keyEvent = mapBrowserEvent.originalEvent;
      const keyCode = keyEvent.keyCode;
      if (this.condition_(mapBrowserEvent) && (keyCode == KeyCode.DOWN || keyCode == KeyCode.LEFT || keyCode == KeyCode.RIGHT || keyCode == KeyCode.UP)) {
        const map = mapBrowserEvent.map;
        const view = map.getView();
        const mapUnitsDelta = view.getResolution() * this.pixelDelta_;
        let deltaX = 0, deltaY = 0;
        if (keyCode == KeyCode.DOWN) {
          deltaY = -mapUnitsDelta;
        } else if (keyCode == KeyCode.LEFT) {
          deltaX = -mapUnitsDelta;
        } else if (keyCode == KeyCode.RIGHT) {
          deltaX = mapUnitsDelta;
        } else {
          deltaY = mapUnitsDelta;
        }
        const delta = [deltaX, deltaY];
        rotate$1(delta, view.getRotation());
        pan(view, delta, this.duration_);
        keyEvent.preventDefault();
        stopEvent = true;
      }
    }
    return !stopEvent;
  }
}
class KeyboardZoom extends Interaction {
  constructor(options) {
    super();
    options = options ? options : {};
    this.condition_ = options.condition ? options.condition : targetNotEditable;
    this.delta_ = options.delta ? options.delta : 1;
    this.duration_ = options.duration !== void 0 ? options.duration : 100;
  }
  handleEvent(mapBrowserEvent) {
    let stopEvent = false;
    if (mapBrowserEvent.type == EventType.KEYDOWN || mapBrowserEvent.type == EventType.KEYPRESS) {
      const keyEvent = mapBrowserEvent.originalEvent;
      const charCode = keyEvent.charCode;
      if (this.condition_(mapBrowserEvent) && (charCode == "+".charCodeAt(0) || charCode == "-".charCodeAt(0))) {
        const map = mapBrowserEvent.map;
        const delta = charCode == "+".charCodeAt(0) ? this.delta_ : -this.delta_;
        const view = map.getView();
        zoomByDelta(view, delta, void 0, this.duration_);
        keyEvent.preventDefault();
        stopEvent = true;
      }
    }
    return !stopEvent;
  }
}
class Kinetic {
  constructor(decay, minVelocity, delay) {
    this.decay_ = decay;
    this.minVelocity_ = minVelocity;
    this.delay_ = delay;
    this.points_ = [];
    this.angle_ = 0;
    this.initialVelocity_ = 0;
  }
  begin() {
    this.points_.length = 0;
    this.angle_ = 0;
    this.initialVelocity_ = 0;
  }
  update(x2, y2) {
    this.points_.push(x2, y2, Date.now());
  }
  end() {
    if (this.points_.length < 6) {
      return false;
    }
    const delay = Date.now() - this.delay_;
    const lastIndex = this.points_.length - 3;
    if (this.points_[lastIndex + 2] < delay) {
      return false;
    }
    let firstIndex = lastIndex - 3;
    while (firstIndex > 0 && this.points_[firstIndex + 2] > delay) {
      firstIndex -= 3;
    }
    const duration2 = this.points_[lastIndex + 2] - this.points_[firstIndex + 2];
    if (duration2 < 1e3 / 60) {
      return false;
    }
    const dx = this.points_[lastIndex] - this.points_[firstIndex];
    const dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];
    this.angle_ = Math.atan2(dy, dx);
    this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration2;
    return this.initialVelocity_ > this.minVelocity_;
  }
  getDistance() {
    return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
  }
  getAngle() {
    return this.angle_;
  }
}
class MouseWheelZoom extends Interaction {
  constructor(options) {
    options = options ? options : {};
    super(options);
    this.totalDelta_ = 0;
    this.lastDelta_ = 0;
    this.maxDelta_ = options.maxDelta !== void 0 ? options.maxDelta : 1;
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
    this.timeout_ = options.timeout !== void 0 ? options.timeout : 80;
    this.useAnchor_ = options.useAnchor !== void 0 ? options.useAnchor : true;
    this.constrainResolution_ = options.constrainResolution !== void 0 ? options.constrainResolution : false;
    const condition = options.condition ? options.condition : always;
    this.condition_ = options.onFocusOnly ? all$1(focusWithTabindex, condition) : condition;
    this.lastAnchor_ = null;
    this.startTime_ = void 0;
    this.timeoutId_;
    this.mode_ = void 0;
    this.trackpadEventGap_ = 400;
    this.trackpadTimeoutId_;
    this.deltaPerZoom_ = 300;
  }
  endInteraction_() {
    this.trackpadTimeoutId_ = void 0;
    const map = this.getMap();
    if (!map) {
      return;
    }
    const view = map.getView();
    view.endInteraction(void 0, this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0, this.lastAnchor_);
  }
  handleEvent(mapBrowserEvent) {
    if (!this.condition_(mapBrowserEvent)) {
      return true;
    }
    const type = mapBrowserEvent.type;
    if (type !== EventType.WHEEL) {
      return true;
    }
    const map = mapBrowserEvent.map;
    const wheelEvent = mapBrowserEvent.originalEvent;
    wheelEvent.preventDefault();
    if (this.useAnchor_) {
      this.lastAnchor_ = mapBrowserEvent.coordinate;
    }
    let delta;
    if (mapBrowserEvent.type == EventType.WHEEL) {
      delta = wheelEvent.deltaY;
      if (FIREFOX && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
        delta /= DEVICE_PIXEL_RATIO;
      }
      if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {
        delta *= 40;
      }
    }
    if (delta === 0) {
      return false;
    }
    this.lastDelta_ = delta;
    const now2 = Date.now();
    if (this.startTime_ === void 0) {
      this.startTime_ = now2;
    }
    if (!this.mode_ || now2 - this.startTime_ > this.trackpadEventGap_) {
      this.mode_ = Math.abs(delta) < 4 ? "trackpad" : "wheel";
    }
    const view = map.getView();
    if (this.mode_ === "trackpad" && !(view.getConstrainResolution() || this.constrainResolution_)) {
      if (this.trackpadTimeoutId_) {
        clearTimeout(this.trackpadTimeoutId_);
      } else {
        if (view.getAnimating()) {
          view.cancelAnimations();
        }
        view.beginInteraction();
      }
      this.trackpadTimeoutId_ = setTimeout(this.endInteraction_.bind(this), this.timeout_);
      view.adjustZoom(-delta / this.deltaPerZoom_, this.lastAnchor_);
      this.startTime_ = now2;
      return false;
    }
    this.totalDelta_ += delta;
    const timeLeft = Math.max(this.timeout_ - (now2 - this.startTime_), 0);
    clearTimeout(this.timeoutId_);
    this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, map), timeLeft);
    return false;
  }
  handleWheelZoom_(map) {
    const view = map.getView();
    if (view.getAnimating()) {
      view.cancelAnimations();
    }
    let delta = -clamp(this.totalDelta_, -this.maxDelta_ * this.deltaPerZoom_, this.maxDelta_ * this.deltaPerZoom_) / this.deltaPerZoom_;
    if (view.getConstrainResolution() || this.constrainResolution_) {
      delta = delta ? delta > 0 ? 1 : -1 : 0;
    }
    zoomByDelta(view, delta, this.lastAnchor_, this.duration_);
    this.mode_ = void 0;
    this.totalDelta_ = 0;
    this.lastAnchor_ = null;
    this.startTime_ = void 0;
    this.timeoutId_ = void 0;
  }
  setMouseAnchor(useAnchor) {
    this.useAnchor_ = useAnchor;
    if (!useAnchor) {
      this.lastAnchor_ = null;
    }
  }
}
class PinchRotate extends PointerInteraction {
  constructor(options) {
    options = options ? options : {};
    const pointerOptions = options;
    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = FALSE;
    }
    super(pointerOptions);
    this.anchor_ = null;
    this.lastAngle_ = void 0;
    this.rotating_ = false;
    this.rotationDelta_ = 0;
    this.threshold_ = options.threshold !== void 0 ? options.threshold : 0.3;
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
  }
  handleDragEvent(mapBrowserEvent) {
    let rotationDelta = 0;
    const touch0 = this.targetPointers[0];
    const touch1 = this.targetPointers[1];
    const angle2 = Math.atan2(touch1.clientY - touch0.clientY, touch1.clientX - touch0.clientX);
    if (this.lastAngle_ !== void 0) {
      const delta = angle2 - this.lastAngle_;
      this.rotationDelta_ += delta;
      if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {
        this.rotating_ = true;
      }
      rotationDelta = delta;
    }
    this.lastAngle_ = angle2;
    const map = mapBrowserEvent.map;
    const view = map.getView();
    if (view.getConstraints().rotation === disable) {
      return;
    }
    const viewportPosition = map.getViewport().getBoundingClientRect();
    const centroid$1 = centroid(this.targetPointers);
    centroid$1[0] -= viewportPosition.left;
    centroid$1[1] -= viewportPosition.top;
    this.anchor_ = map.getCoordinateFromPixelInternal(centroid$1);
    if (this.rotating_) {
      map.render();
      view.adjustRotationInternal(rotationDelta, this.anchor_);
    }
  }
  handleUpEvent(mapBrowserEvent) {
    if (this.targetPointers.length < 2) {
      const map = mapBrowserEvent.map;
      const view = map.getView();
      view.endInteraction(this.duration_);
      return false;
    }
    return true;
  }
  handleDownEvent(mapBrowserEvent) {
    if (this.targetPointers.length >= 2) {
      const map = mapBrowserEvent.map;
      this.anchor_ = null;
      this.lastAngle_ = void 0;
      this.rotating_ = false;
      this.rotationDelta_ = 0;
      if (!this.handlingDownUpSequence) {
        map.getView().beginInteraction();
      }
      return true;
    }
    return false;
  }
}
class PinchZoom extends PointerInteraction {
  constructor(options) {
    options = options ? options : {};
    const pointerOptions = options;
    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = FALSE;
    }
    super(pointerOptions);
    this.anchor_ = null;
    this.duration_ = options.duration !== void 0 ? options.duration : 400;
    this.lastDistance_ = void 0;
    this.lastScaleDelta_ = 1;
  }
  handleDragEvent(mapBrowserEvent) {
    let scaleDelta = 1;
    const touch0 = this.targetPointers[0];
    const touch1 = this.targetPointers[1];
    const dx = touch0.clientX - touch1.clientX;
    const dy = touch0.clientY - touch1.clientY;
    const distance2 = Math.sqrt(dx * dx + dy * dy);
    if (this.lastDistance_ !== void 0) {
      scaleDelta = this.lastDistance_ / distance2;
    }
    this.lastDistance_ = distance2;
    const map = mapBrowserEvent.map;
    const view = map.getView();
    if (scaleDelta != 1) {
      this.lastScaleDelta_ = scaleDelta;
    }
    const viewportPosition = map.getViewport().getBoundingClientRect();
    const [scaleX, scaleY] = getCanvasScale(mapBrowserEvent.originalEvent.target);
    const centroid$1 = centroid(this.targetPointers);
    centroid$1[0] -= viewportPosition.left / scaleX;
    centroid$1[1] -= viewportPosition.top / scaleY;
    this.anchor_ = map.getCoordinateFromPixelInternal(centroid$1);
    map.render();
    view.adjustResolutionInternal(scaleDelta, this.anchor_);
  }
  handleUpEvent(mapBrowserEvent) {
    if (this.targetPointers.length < 2) {
      const map = mapBrowserEvent.map;
      const view = map.getView();
      const direction2 = this.lastScaleDelta_ > 1 ? 1 : -1;
      view.endInteraction(this.duration_, direction2);
      return false;
    }
    return true;
  }
  handleDownEvent(mapBrowserEvent) {
    if (this.targetPointers.length >= 2) {
      const map = mapBrowserEvent.map;
      this.anchor_ = null;
      this.lastDistance_ = void 0;
      this.lastScaleDelta_ = 1;
      if (!this.handlingDownUpSequence) {
        map.getView().beginInteraction();
      }
      return true;
    }
    return false;
  }
}
function defaults(options) {
  options = options ? options : {};
  const interactions = new Collection();
  const kinetic = new Kinetic(-5e-3, 0.05, 100);
  const altShiftDragRotate = options.altShiftDragRotate !== void 0 ? options.altShiftDragRotate : true;
  if (altShiftDragRotate) {
    interactions.push(new DragRotate());
  }
  const doubleClickZoom = options.doubleClickZoom !== void 0 ? options.doubleClickZoom : true;
  if (doubleClickZoom) {
    interactions.push(new DoubleClickZoom({
      delta: options.zoomDelta,
      duration: options.zoomDuration
    }));
  }
  const dragPan = options.dragPan !== void 0 ? options.dragPan : true;
  if (dragPan) {
    interactions.push(new DragPan({
      onFocusOnly: options.onFocusOnly,
      kinetic
    }));
  }
  const pinchRotate = options.pinchRotate !== void 0 ? options.pinchRotate : true;
  if (pinchRotate) {
    interactions.push(new PinchRotate());
  }
  const pinchZoom = options.pinchZoom !== void 0 ? options.pinchZoom : true;
  if (pinchZoom) {
    interactions.push(new PinchZoom({
      duration: options.zoomDuration
    }));
  }
  const keyboard = options.keyboard !== void 0 ? options.keyboard : true;
  if (keyboard) {
    interactions.push(new KeyboardPan());
    interactions.push(new KeyboardZoom({
      delta: options.zoomDelta,
      duration: options.zoomDuration
    }));
  }
  const mouseWheelZoom = options.mouseWheelZoom !== void 0 ? options.mouseWheelZoom : true;
  if (mouseWheelZoom) {
    interactions.push(new MouseWheelZoom({
      onFocusOnly: options.onFocusOnly,
      duration: options.zoomDuration
    }));
  }
  const shiftDragZoom = options.shiftDragZoom !== void 0 ? options.shiftDragZoom : true;
  if (shiftDragZoom) {
    interactions.push(new DragZoom({
      duration: options.zoomDuration
    }));
  }
  return interactions;
}
function buffer$1(size, num, dest) {
  if (dest === void 0) {
    dest = [0, 0];
  }
  dest[0] = size[0] + 2 * num;
  dest[1] = size[1] + 2 * num;
  return dest;
}
function hasArea(size) {
  return size[0] > 0 && size[1] > 0;
}
function scale(size, ratio, dest) {
  if (dest === void 0) {
    dest = [0, 0];
  }
  dest[0] = size[0] * ratio + 0.5 | 0;
  dest[1] = size[1] * ratio + 0.5 | 0;
  return dest;
}
function toSize(size, dest) {
  if (Array.isArray(size)) {
    return size;
  }
  if (dest === void 0) {
    dest = [size, size];
  } else {
    dest[0] = size;
    dest[1] = size;
  }
  return dest;
}
function removeLayerMapProperty(layer) {
  if (layer instanceof Layer) {
    layer.setMapInternal(null);
    return;
  }
  if (layer instanceof LayerGroup) {
    layer.getLayers().forEach(removeLayerMapProperty);
  }
}
function setLayerMapProperty(layer, map) {
  if (layer instanceof Layer) {
    layer.setMapInternal(map);
    return;
  }
  if (layer instanceof LayerGroup) {
    const layers = layer.getLayers().getArray();
    for (let i2 = 0, ii = layers.length; i2 < ii; ++i2) {
      setLayerMapProperty(layers[i2], map);
    }
  }
}
class Map$3 extends BaseObject {
  constructor(options) {
    super();
    options = options || {};
    this.on;
    this.once;
    this.un;
    const optionsInternal = createOptionsInternal(options);
    this.renderComplete_;
    this.loaded_ = true;
    this.boundHandleBrowserEvent_ = this.handleBrowserEvent.bind(this);
    this.maxTilesLoading_ = options.maxTilesLoading !== void 0 ? options.maxTilesLoading : 16;
    this.pixelRatio_ = options.pixelRatio !== void 0 ? options.pixelRatio : DEVICE_PIXEL_RATIO;
    this.postRenderTimeoutHandle_;
    this.animationDelayKey_;
    this.animationDelay_ = this.animationDelay_.bind(this);
    this.coordinateToPixelTransform_ = create$7();
    this.pixelToCoordinateTransform_ = create$7();
    this.frameIndex_ = 0;
    this.frameState_ = null;
    this.previousExtent_ = null;
    this.viewPropertyListenerKey_ = null;
    this.viewChangeListenerKey_ = null;
    this.layerGroupPropertyListenerKeys_ = null;
    this.viewport_ = document.createElement("div");
    this.viewport_.className = "ol-viewport" + ("ontouchstart" in window ? " ol-touch" : "");
    this.viewport_.style.position = "relative";
    this.viewport_.style.overflow = "hidden";
    this.viewport_.style.width = "100%";
    this.viewport_.style.height = "100%";
    this.overlayContainer_ = document.createElement("div");
    this.overlayContainer_.style.position = "absolute";
    this.overlayContainer_.style.zIndex = "0";
    this.overlayContainer_.style.width = "100%";
    this.overlayContainer_.style.height = "100%";
    this.overlayContainer_.style.pointerEvents = "none";
    this.overlayContainer_.className = "ol-overlaycontainer";
    this.viewport_.appendChild(this.overlayContainer_);
    this.overlayContainerStopEvent_ = document.createElement("div");
    this.overlayContainerStopEvent_.style.position = "absolute";
    this.overlayContainerStopEvent_.style.zIndex = "0";
    this.overlayContainerStopEvent_.style.width = "100%";
    this.overlayContainerStopEvent_.style.height = "100%";
    this.overlayContainerStopEvent_.style.pointerEvents = "none";
    this.overlayContainerStopEvent_.className = "ol-overlaycontainer-stopevent";
    this.viewport_.appendChild(this.overlayContainerStopEvent_);
    this.mapBrowserEventHandler_ = null;
    this.moveTolerance_ = options.moveTolerance;
    this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;
    this.targetChangeHandlerKeys_ = null;
    this.controls = optionsInternal.controls || defaults$1();
    this.interactions = optionsInternal.interactions || defaults({
      onFocusOnly: true
    });
    this.overlays_ = optionsInternal.overlays;
    this.overlayIdIndex_ = {};
    this.renderer_ = null;
    this.postRenderFunctions_ = [];
    this.tileQueue_ = new TileQueue(this.getTilePriority.bind(this), this.handleTileChange_.bind(this));
    this.addChangeListener(MapProperty.LAYERGROUP, this.handleLayerGroupChanged_);
    this.addChangeListener(MapProperty.VIEW, this.handleViewChanged_);
    this.addChangeListener(MapProperty.SIZE, this.handleSizeChanged_);
    this.addChangeListener(MapProperty.TARGET, this.handleTargetChanged_);
    this.setProperties(optionsInternal.values);
    const map = this;
    if (options.view && !(options.view instanceof View$1)) {
      options.view.then(function(viewOptions) {
        map.setView(new View$1(viewOptions));
      });
    }
    this.controls.addEventListener(CollectionEventType.ADD, (event) => {
      event.element.setMap(this);
    });
    this.controls.addEventListener(CollectionEventType.REMOVE, (event) => {
      event.element.setMap(null);
    });
    this.interactions.addEventListener(CollectionEventType.ADD, (event) => {
      event.element.setMap(this);
    });
    this.interactions.addEventListener(CollectionEventType.REMOVE, (event) => {
      event.element.setMap(null);
    });
    this.overlays_.addEventListener(CollectionEventType.ADD, (event) => {
      this.addOverlayInternal_(event.element);
    });
    this.overlays_.addEventListener(CollectionEventType.REMOVE, (event) => {
      const id = event.element.getId();
      if (id !== void 0) {
        delete this.overlayIdIndex_[id.toString()];
      }
      event.element.setMap(null);
    });
    this.controls.forEach((control) => {
      control.setMap(this);
    });
    this.interactions.forEach((interaction) => {
      interaction.setMap(this);
    });
    this.overlays_.forEach(this.addOverlayInternal_.bind(this));
  }
  addControl(control) {
    this.getControls().push(control);
  }
  addInteraction(interaction) {
    this.getInteractions().push(interaction);
  }
  addLayer(layer) {
    const layers = this.getLayerGroup().getLayers();
    layers.push(layer);
  }
  handleLayerAdd_(event) {
    setLayerMapProperty(event.layer, this);
  }
  addOverlay(overlay) {
    this.getOverlays().push(overlay);
  }
  addOverlayInternal_(overlay) {
    const id = overlay.getId();
    if (id !== void 0) {
      this.overlayIdIndex_[id.toString()] = overlay;
    }
    overlay.setMap(this);
  }
  disposeInternal() {
    this.controls.clear();
    this.interactions.clear();
    this.overlays_.clear();
    this.setTarget(null);
    super.disposeInternal();
  }
  forEachFeatureAtPixel(pixel, callback, options) {
    if (!this.frameState_ || !this.renderer_) {
      return;
    }
    const coordinate = this.getCoordinateFromPixelInternal(pixel);
    options = options !== void 0 ? options : {};
    const hitTolerance = options.hitTolerance !== void 0 ? options.hitTolerance : 0;
    const layerFilter = options.layerFilter !== void 0 ? options.layerFilter : TRUE;
    const checkWrapped = options.checkWrapped !== false;
    return this.renderer_.forEachFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, callback, null, layerFilter, null);
  }
  getFeaturesAtPixel(pixel, options) {
    const features = [];
    this.forEachFeatureAtPixel(pixel, function(feature) {
      features.push(feature);
    }, options);
    return features;
  }
  getAllLayers() {
    const layers = [];
    function addLayersFrom(layerGroup) {
      layerGroup.forEach(function(layer) {
        if (layer instanceof LayerGroup) {
          addLayersFrom(layer.getLayers());
        } else {
          layers.push(layer);
        }
      });
    }
    addLayersFrom(this.getLayers());
    return layers;
  }
  hasFeatureAtPixel(pixel, options) {
    if (!this.frameState_ || !this.renderer_) {
      return false;
    }
    const coordinate = this.getCoordinateFromPixelInternal(pixel);
    options = options !== void 0 ? options : {};
    const layerFilter = options.layerFilter !== void 0 ? options.layerFilter : TRUE;
    const hitTolerance = options.hitTolerance !== void 0 ? options.hitTolerance : 0;
    const checkWrapped = options.checkWrapped !== false;
    return this.renderer_.hasFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, layerFilter, null);
  }
  getEventCoordinate(event) {
    return this.getCoordinateFromPixel(this.getEventPixel(event));
  }
  getEventCoordinateInternal(event) {
    return this.getCoordinateFromPixelInternal(this.getEventPixel(event));
  }
  getEventPixel(event) {
    const [scaleX, scaleY] = getCanvasScale(event.target);
    const viewportPosition = this.viewport_.getBoundingClientRect();
    const eventPosition = "changedTouches" in event ? event.changedTouches[0] : event;
    return [
      (eventPosition.clientX - viewportPosition.left) / scaleX,
      (eventPosition.clientY - viewportPosition.top) / scaleY
    ];
  }
  getTarget() {
    return this.get(MapProperty.TARGET);
  }
  getTargetElement() {
    const target = this.getTarget();
    if (target !== void 0) {
      return typeof target === "string" ? document.getElementById(target) : target;
    }
    return null;
  }
  getCoordinateFromPixel(pixel) {
    return toUserCoordinate(this.getCoordinateFromPixelInternal(pixel), this.getView().getProjection());
  }
  getCoordinateFromPixelInternal(pixel) {
    const frameState = this.frameState_;
    if (!frameState) {
      return null;
    }
    return apply$5(frameState.pixelToCoordinateTransform, pixel.slice());
  }
  getControls() {
    return this.controls;
  }
  getOverlays() {
    return this.overlays_;
  }
  getOverlayById(id) {
    const overlay = this.overlayIdIndex_[id.toString()];
    return overlay !== void 0 ? overlay : null;
  }
  getInteractions() {
    return this.interactions;
  }
  getLayerGroup() {
    return this.get(MapProperty.LAYERGROUP);
  }
  setLayers(layers) {
    const group = this.getLayerGroup();
    if (layers instanceof Collection) {
      group.setLayers(layers);
      return;
    }
    const collection = group.getLayers();
    collection.clear();
    collection.extend(layers);
  }
  getLayers() {
    const layers = this.getLayerGroup().getLayers();
    return layers;
  }
  getLoadingOrNotReady() {
    const layerStatesArray = this.getLayerGroup().getLayerStatesArray();
    for (let i2 = 0, ii = layerStatesArray.length; i2 < ii; ++i2) {
      const state = layerStatesArray[i2];
      if (!state.visible) {
        continue;
      }
      const renderer = state.layer.getRenderer();
      if (renderer && !renderer.ready) {
        return true;
      }
      const source = state.layer.getSource();
      if (source && source.loading) {
        return true;
      }
    }
    return false;
  }
  getPixelFromCoordinate(coordinate) {
    const viewCoordinate = fromUserCoordinate(coordinate, this.getView().getProjection());
    return this.getPixelFromCoordinateInternal(viewCoordinate);
  }
  getPixelFromCoordinateInternal(coordinate) {
    const frameState = this.frameState_;
    if (!frameState) {
      return null;
    }
    return apply$5(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));
  }
  getRenderer() {
    return this.renderer_;
  }
  getSize() {
    return this.get(MapProperty.SIZE);
  }
  getView() {
    return this.get(MapProperty.VIEW);
  }
  getViewport() {
    return this.viewport_;
  }
  getOverlayContainer() {
    return this.overlayContainer_;
  }
  getOverlayContainerStopEvent() {
    return this.overlayContainerStopEvent_;
  }
  getOwnerDocument() {
    const targetElement = this.getTargetElement();
    return targetElement ? targetElement.ownerDocument : document;
  }
  getTilePriority(tile2, tileSourceKey, tileCenter, tileResolution) {
    return getTilePriority(this.frameState_, tile2, tileSourceKey, tileCenter, tileResolution);
  }
  handleBrowserEvent(browserEvent, type) {
    type = type || browserEvent.type;
    const mapBrowserEvent = new MapBrowserEvent(type, this, browserEvent);
    this.handleMapBrowserEvent(mapBrowserEvent);
  }
  handleMapBrowserEvent(mapBrowserEvent) {
    if (!this.frameState_) {
      return;
    }
    const originalEvent = mapBrowserEvent.originalEvent;
    const eventType = originalEvent.type;
    if (eventType === PointerEventType.POINTERDOWN || eventType === EventType.WHEEL || eventType === EventType.KEYDOWN) {
      const doc = this.getOwnerDocument();
      const rootNode = this.viewport_.getRootNode ? this.viewport_.getRootNode() : doc;
      const target = originalEvent.target;
      if (this.overlayContainerStopEvent_.contains(target) || !(rootNode === doc ? doc.documentElement : rootNode).contains(target)) {
        return;
      }
    }
    mapBrowserEvent.frameState = this.frameState_;
    if (this.dispatchEvent(mapBrowserEvent) !== false) {
      const interactionsArray = this.getInteractions().getArray().slice();
      for (let i2 = interactionsArray.length - 1; i2 >= 0; i2--) {
        const interaction = interactionsArray[i2];
        if (interaction.getMap() !== this || !interaction.getActive() || !this.getTargetElement()) {
          continue;
        }
        const cont = interaction.handleEvent(mapBrowserEvent);
        if (!cont || mapBrowserEvent.propagationStopped) {
          break;
        }
      }
    }
  }
  handlePostRender() {
    const frameState = this.frameState_;
    const tileQueue = this.tileQueue_;
    if (!tileQueue.isEmpty()) {
      let maxTotalLoading = this.maxTilesLoading_;
      let maxNewLoads = maxTotalLoading;
      if (frameState) {
        const hints = frameState.viewHints;
        if (hints[ViewHint.ANIMATING] || hints[ViewHint.INTERACTING]) {
          const lowOnFrameBudget = Date.now() - frameState.time > 8;
          maxTotalLoading = lowOnFrameBudget ? 0 : 8;
          maxNewLoads = lowOnFrameBudget ? 0 : 2;
        }
      }
      if (tileQueue.getTilesLoading() < maxTotalLoading) {
        tileQueue.reprioritize();
        tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);
      }
    }
    if (frameState && this.renderer_ && !frameState.animate) {
      if (this.renderComplete_ === true) {
        if (this.hasListener(RenderEventType.RENDERCOMPLETE)) {
          this.renderer_.dispatchRenderEvent(RenderEventType.RENDERCOMPLETE, frameState);
        }
        if (this.loaded_ === false) {
          this.loaded_ = true;
          this.dispatchEvent(new MapEvent(MapEventType.LOADEND, this, frameState));
        }
      } else if (this.loaded_ === true) {
        this.loaded_ = false;
        this.dispatchEvent(new MapEvent(MapEventType.LOADSTART, this, frameState));
      }
    }
    const postRenderFunctions = this.postRenderFunctions_;
    for (let i2 = 0, ii = postRenderFunctions.length; i2 < ii; ++i2) {
      postRenderFunctions[i2](this, frameState);
    }
    postRenderFunctions.length = 0;
  }
  handleSizeChanged_() {
    if (this.getView() && !this.getView().getAnimating()) {
      this.getView().resolveConstraints(0);
    }
    this.render();
  }
  handleTargetChanged_() {
    if (this.mapBrowserEventHandler_) {
      for (let i2 = 0, ii = this.targetChangeHandlerKeys_.length; i2 < ii; ++i2) {
        unlistenByKey(this.targetChangeHandlerKeys_[i2]);
      }
      this.targetChangeHandlerKeys_ = null;
      this.viewport_.removeEventListener(EventType.CONTEXTMENU, this.boundHandleBrowserEvent_);
      this.viewport_.removeEventListener(EventType.WHEEL, this.boundHandleBrowserEvent_);
      this.mapBrowserEventHandler_.dispose();
      this.mapBrowserEventHandler_ = null;
      removeNode$1(this.viewport_);
    }
    const targetElement = this.getTargetElement();
    if (!targetElement) {
      if (this.renderer_) {
        clearTimeout(this.postRenderTimeoutHandle_);
        this.postRenderTimeoutHandle_ = void 0;
        this.postRenderFunctions_.length = 0;
        this.renderer_.dispose();
        this.renderer_ = null;
      }
      if (this.animationDelayKey_) {
        cancelAnimationFrame(this.animationDelayKey_);
        this.animationDelayKey_ = void 0;
      }
    } else {
      targetElement.appendChild(this.viewport_);
      if (!this.renderer_) {
        this.renderer_ = new CompositeMapRenderer(this);
      }
      this.mapBrowserEventHandler_ = new MapBrowserEventHandler(this, this.moveTolerance_);
      for (const key in MapBrowserEventType) {
        this.mapBrowserEventHandler_.addEventListener(MapBrowserEventType[key], this.handleMapBrowserEvent.bind(this));
      }
      this.viewport_.addEventListener(EventType.CONTEXTMENU, this.boundHandleBrowserEvent_, false);
      this.viewport_.addEventListener(EventType.WHEEL, this.boundHandleBrowserEvent_, PASSIVE_EVENT_LISTENERS ? { passive: false } : false);
      const defaultView = this.getOwnerDocument().defaultView;
      const keyboardEventTarget = !this.keyboardEventTarget_ ? targetElement : this.keyboardEventTarget_;
      this.targetChangeHandlerKeys_ = [
        listen(keyboardEventTarget, EventType.KEYDOWN, this.handleBrowserEvent, this),
        listen(keyboardEventTarget, EventType.KEYPRESS, this.handleBrowserEvent, this),
        listen(defaultView, EventType.RESIZE, this.updateSize, this)
      ];
    }
    this.updateSize();
  }
  handleTileChange_() {
    this.render();
  }
  handleViewPropertyChanged_() {
    this.render();
  }
  handleViewChanged_() {
    if (this.viewPropertyListenerKey_) {
      unlistenByKey(this.viewPropertyListenerKey_);
      this.viewPropertyListenerKey_ = null;
    }
    if (this.viewChangeListenerKey_) {
      unlistenByKey(this.viewChangeListenerKey_);
      this.viewChangeListenerKey_ = null;
    }
    const view = this.getView();
    if (view) {
      this.updateViewportSize_();
      this.viewPropertyListenerKey_ = listen(view, ObjectEventType.PROPERTYCHANGE, this.handleViewPropertyChanged_, this);
      this.viewChangeListenerKey_ = listen(view, EventType.CHANGE, this.handleViewPropertyChanged_, this);
      view.resolveConstraints(0);
    }
    this.render();
  }
  handleLayerGroupChanged_() {
    if (this.layerGroupPropertyListenerKeys_) {
      this.layerGroupPropertyListenerKeys_.forEach(unlistenByKey);
      this.layerGroupPropertyListenerKeys_ = null;
    }
    const layerGroup = this.getLayerGroup();
    if (layerGroup) {
      this.handleLayerAdd_(new GroupEvent("addlayer", layerGroup));
      this.layerGroupPropertyListenerKeys_ = [
        listen(layerGroup, ObjectEventType.PROPERTYCHANGE, this.render, this),
        listen(layerGroup, EventType.CHANGE, this.render, this),
        listen(layerGroup, "addlayer", this.handleLayerAdd_, this),
        listen(layerGroup, "removelayer", this.handleLayerRemove_, this)
      ];
    }
    this.render();
  }
  isRendered() {
    return !!this.frameState_;
  }
  animationDelay_() {
    this.animationDelayKey_ = void 0;
    this.renderFrame_(Date.now());
  }
  renderSync() {
    if (this.animationDelayKey_) {
      cancelAnimationFrame(this.animationDelayKey_);
    }
    this.animationDelay_();
  }
  redrawText() {
    const layerStates = this.getLayerGroup().getLayerStatesArray();
    for (let i2 = 0, ii = layerStates.length; i2 < ii; ++i2) {
      const layer = layerStates[i2].layer;
      if (layer.hasRenderer()) {
        layer.getRenderer().handleFontsChanged();
      }
    }
  }
  render() {
    if (this.renderer_ && this.animationDelayKey_ === void 0) {
      this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);
    }
  }
  removeControl(control) {
    return this.getControls().remove(control);
  }
  removeInteraction(interaction) {
    return this.getInteractions().remove(interaction);
  }
  removeLayer(layer) {
    const layers = this.getLayerGroup().getLayers();
    return layers.remove(layer);
  }
  handleLayerRemove_(event) {
    removeLayerMapProperty(event.layer);
  }
  removeOverlay(overlay) {
    return this.getOverlays().remove(overlay);
  }
  renderFrame_(time2) {
    const size = this.getSize();
    const view = this.getView();
    const previousFrameState = this.frameState_;
    let frameState = null;
    if (size !== void 0 && hasArea(size) && view && view.isDef()) {
      const viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : void 0);
      const viewState = view.getState();
      frameState = {
        animate: false,
        coordinateToPixelTransform: this.coordinateToPixelTransform_,
        declutterTree: null,
        extent: getForViewAndSize(viewState.center, viewState.resolution, viewState.rotation, size),
        index: this.frameIndex_++,
        layerIndex: 0,
        layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
        pixelRatio: this.pixelRatio_,
        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
        postRenderFunctions: [],
        size,
        tileQueue: this.tileQueue_,
        time: time2,
        usedTiles: {},
        viewState,
        viewHints,
        wantedTiles: {},
        mapId: getUid(this),
        renderTargets: {}
      };
      if (viewState.nextCenter && viewState.nextResolution) {
        const rotation = isNaN(viewState.nextRotation) ? viewState.rotation : viewState.nextRotation;
        frameState.nextExtent = getForViewAndSize(viewState.nextCenter, viewState.nextResolution, rotation, size);
      }
    }
    this.frameState_ = frameState;
    this.renderer_.renderFrame(frameState);
    if (frameState) {
      if (frameState.animate) {
        this.render();
      }
      Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);
      if (previousFrameState) {
        const moveStart = !this.previousExtent_ || !isEmpty(this.previousExtent_) && !equals$2(frameState.extent, this.previousExtent_);
        if (moveStart) {
          this.dispatchEvent(new MapEvent(MapEventType.MOVESTART, this, previousFrameState));
          this.previousExtent_ = createOrUpdateEmpty(this.previousExtent_);
        }
      }
      const idle = this.previousExtent_ && !frameState.viewHints[ViewHint.ANIMATING] && !frameState.viewHints[ViewHint.INTERACTING] && !equals$2(frameState.extent, this.previousExtent_);
      if (idle) {
        this.dispatchEvent(new MapEvent(MapEventType.MOVEEND, this, frameState));
        clone$1(frameState.extent, this.previousExtent_);
      }
    }
    this.dispatchEvent(new MapEvent(MapEventType.POSTRENDER, this, frameState));
    this.renderComplete_ = this.hasListener(MapEventType.LOADSTART) || this.hasListener(MapEventType.LOADEND) || this.hasListener(RenderEventType.RENDERCOMPLETE) ? !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady() : void 0;
    if (!this.postRenderTimeoutHandle_) {
      this.postRenderTimeoutHandle_ = setTimeout(() => {
        this.postRenderTimeoutHandle_ = void 0;
        this.handlePostRender();
      }, 0);
    }
  }
  setLayerGroup(layerGroup) {
    const oldLayerGroup = this.getLayerGroup();
    if (oldLayerGroup) {
      this.handleLayerRemove_(new GroupEvent("removelayer", oldLayerGroup));
    }
    this.set(MapProperty.LAYERGROUP, layerGroup);
  }
  setSize(size) {
    this.set(MapProperty.SIZE, size);
  }
  setTarget(target) {
    this.set(MapProperty.TARGET, target);
  }
  setView(view) {
    if (!view || view instanceof View$1) {
      this.set(MapProperty.VIEW, view);
      return;
    }
    this.set(MapProperty.VIEW, new View$1());
    const map = this;
    view.then(function(viewOptions) {
      map.setView(new View$1(viewOptions));
    });
  }
  updateSize() {
    const targetElement = this.getTargetElement();
    let size = void 0;
    if (targetElement) {
      const computedStyle = getComputedStyle(targetElement);
      const width = targetElement.offsetWidth - parseFloat(computedStyle["borderLeftWidth"]) - parseFloat(computedStyle["paddingLeft"]) - parseFloat(computedStyle["paddingRight"]) - parseFloat(computedStyle["borderRightWidth"]);
      const height = targetElement.offsetHeight - parseFloat(computedStyle["borderTopWidth"]) - parseFloat(computedStyle["paddingTop"]) - parseFloat(computedStyle["paddingBottom"]) - parseFloat(computedStyle["borderBottomWidth"]);
      if (!isNaN(width) && !isNaN(height)) {
        size = [width, height];
        if (!hasArea(size) && !!(targetElement.offsetWidth || targetElement.offsetHeight || targetElement.getClientRects().length)) {
          console.warn("No map visible because the map container's width or height are 0.");
        }
      }
    }
    this.setSize(size);
    this.updateViewportSize_();
  }
  updateViewportSize_() {
    const view = this.getView();
    if (view) {
      let size = void 0;
      const computedStyle = getComputedStyle(this.viewport_);
      if (computedStyle.width && computedStyle.height) {
        size = [
          parseInt(computedStyle.width, 10),
          parseInt(computedStyle.height, 10)
        ];
      }
      view.setViewportSize(size);
    }
  }
}
function createOptionsInternal(options) {
  let keyboardEventTarget = null;
  if (options.keyboardEventTarget !== void 0) {
    keyboardEventTarget = typeof options.keyboardEventTarget === "string" ? document.getElementById(options.keyboardEventTarget) : options.keyboardEventTarget;
  }
  const values3 = {};
  const layerGroup = options.layers && typeof options.layers.getLayers === "function" ? options.layers : new LayerGroup({
    layers: options.layers
  });
  values3[MapProperty.LAYERGROUP] = layerGroup;
  values3[MapProperty.TARGET] = options.target;
  values3[MapProperty.VIEW] = options.view instanceof View$1 ? options.view : new View$1();
  let controls;
  if (options.controls !== void 0) {
    if (Array.isArray(options.controls)) {
      controls = new Collection(options.controls.slice());
    } else {
      assert(typeof options.controls.getArray === "function", 47);
      controls = options.controls;
    }
  }
  let interactions;
  if (options.interactions !== void 0) {
    if (Array.isArray(options.interactions)) {
      interactions = new Collection(options.interactions.slice());
    } else {
      assert(typeof options.interactions.getArray === "function", 48);
      interactions = options.interactions;
    }
  }
  let overlays;
  if (options.overlays !== void 0) {
    if (Array.isArray(options.overlays)) {
      overlays = new Collection(options.overlays.slice());
    } else {
      assert(typeof options.overlays.getArray === "function", 49);
      overlays = options.overlays;
    }
  } else {
    overlays = new Collection();
  }
  return {
    controls,
    interactions,
    keyboardEventTarget,
    overlays,
    values: values3
  };
}
function usePropsAsObjectProperties(props, ignoredKeys = []) {
  let options = toRefs(props);
  Object.keys(options).forEach((key) => {
    options[key] = options[key].value;
  });
  const properties = reactive(__spreadValues({}, options));
  watch(props, () => {
    options = toRefs(props);
    Object.keys(options).forEach((key) => {
      if (properties[key] != options[key].value && !ignoredKeys.includes(key)) {
        properties[key] = options[key].value;
      }
    });
  });
  return {
    properties
  };
}
var _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _sfc_main$16 = {
  name: "ol-map",
  setup(props, {
    emit
  }) {
    const {
      properties
    } = usePropsAsObjectProperties(props);
    const mapRef = ref(null);
    let map = new Map$3(properties);
    watch(properties, () => {
      map.setProperties(properties);
    });
    onMounted(() => {
      map.setTarget(mapRef.value);
    });
    onUnmounted(() => {
      map.setTarget(null);
      map = null;
    });
    provide("map", map);
    const focus2 = () => map.focus();
    const forEachFeatureAtPixel = (pixel, callback, options = {}) => map.forEachFeatureAtPixel(pixel, callback, options);
    const forEachLayerAtPixel = (pixel, callback, layerFilter) => map.forEachLayerAtPixel(pixel, callback, layerFilter);
    const getCoordinateFromPixel = (pixel) => map.getCoordinateFromPixel(pixel);
    const refresh = () => map.refresh();
    const render2 = () => map.render();
    const updateSize = () => map.updateSize();
    map.on("click", (event) => emit("click", event));
    map.on("dblclick", (event) => emit("dblclick", event));
    map.on("singleclick", (event) => emit("singleclick", event));
    map.on("pointerdrag", (event) => emit("pointerdrag", event));
    map.on("pointermove", (event) => emit("pointermove", event));
    map.on("movestart", (event) => emit("movestart", event));
    map.on("moveend", (event) => emit("moveend", event));
    map.on("postrender", (event) => emit("postrender", event));
    map.on("precompose", (event) => emit("precompose", event));
    map.on("postcompose", (event) => emit("postcompose", event));
    return {
      map,
      mapRef,
      focus: focus2,
      forEachFeatureAtPixel,
      forEachLayerAtPixel,
      getCoordinateFromPixel,
      refresh,
      render: render2,
      updateSize
    };
  },
  props: {
    loadTilesWhileAnimating: {
      type: Boolean,
      default: false
    },
    loadTilesWhileInteracting: {
      type: Boolean,
      default: false
    },
    moveTolerance: {
      type: Number,
      default: 1
    },
    pixelRatio: {
      type: Number,
      default: 1
    },
    controls: {
      type: Array,
      default: () => []
    }
  }
};
function _sfc_render$16(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: (el) => $setup.mapRef = el
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 512);
}
var Map$2 = /* @__PURE__ */ _export_sfc(_sfc_main$16, [["render", _sfc_render$16]]);
function useView(props, emit) {
  const map = inject("map");
  const {
    properties
  } = usePropsAsObjectProperties(props);
  const createProp = () => {
    return __spreadProps(__spreadValues({}, properties), {
      projection: typeof properties.projection == "string" ? properties.projection : new Projection$2(__spreadValues({}, properties.projection))
    });
  };
  let view = new View$1(createProp());
  onMounted(() => {
    map.setView(view);
  });
  view.on("change:center", () => {
    emit("centerChanged", getCenter2());
    emit("zoomChanged", getZoom());
  });
  view.on("change:resolution", () => emit("resolutionChanged", getResolution()));
  view.on("change:rotation", () => emit("rotationChanged", getRotation()));
  watch(properties, () => {
    let pr = createProp();
    view.setProperties(pr);
    view.applyOptions_(pr);
  });
  const adjustCenter = (deltaCoordinates) => view.adjustCenter(deltaCoordinates);
  const adjustResolution = (ratio, opt_anchor) => view.adjustResolution(ratio, opt_anchor);
  const adjustRotation = (delta, opt_anchor) => view.adjustRotation(delta, opt_anchor);
  const adjustZoom = (delta, opt_anchor) => view.adjustZoom(delta, opt_anchor);
  const animate = (var_args) => view.animate(var_args);
  const beginInteraction = () => view.beginInteraction();
  const calculateExtent = (opt_size) => view.calculateExtent(opt_size);
  const cancelAnimations = () => view.cancelAnimations();
  const centerOn = (coordinate, size, position2) => view.centerOn(coordinate, size, position2);
  const changed = () => view.changed();
  const dispatchEvent2 = (event) => view.dispatchEvent(event);
  const endInteraction = (opt_duration, opt_resolutionDirection, opt_anchor) => view.endInteraction(opt_duration, opt_resolutionDirection, opt_anchor);
  const fit = (geometryOrExtent, opt_options) => view.fit(geometryOrExtent, opt_options);
  const get2 = (key) => view.get(key);
  const getAnimating = () => view.getAnimating();
  const getCenter2 = () => view.getCenter();
  const getInteracting = () => view.getInteracting();
  const getKeys = () => view.getKeys();
  const getMaxResolution = () => view.getMaxResolution();
  const getMaxZoom = () => view.getMaxZoom();
  const getMinResolution = () => view.getMinResolution();
  const getMinZoom = () => view.getMinZoom();
  const getProjection2 = () => view.getProjection();
  const getProperties = () => view.getProperties();
  const getResolution = () => view.getResolution();
  const getResolutionForExtent = (extent2, opt_size) => view.getResolutionForExtent(extent2, opt_size);
  const getResolutionForZoom = (zoom) => view.getResolutionForZoom(zoom);
  const getResolutions2 = () => view.getResolutions();
  const getRevision = () => view.getRevision();
  const getRotation = () => view.getRotation();
  const getZoom = () => view.getZoom();
  const getZoomForResolution = (resolution) => view.getZoomForResolution(resolution);
  const setCenter = (center) => view.setCenter(center);
  const setConstrainResolution = (enabled) => view.setConstrainResolution(enabled);
  const setMaxZoom = (zoom) => view.setMaxZoom(zoom);
  const setMinZoom = (zoom) => view.setMinZoom(zoom);
  const setResolution = (resolution) => view.setResolution(resolution);
  const setRotation = (rotation) => view.setRotation(rotation);
  const setZoom = (zoom) => view.setZoom(zoom);
  return {
    view,
    adjustCenter,
    adjustResolution,
    adjustRotation,
    adjustZoom,
    animate,
    beginInteraction,
    calculateExtent,
    cancelAnimations,
    centerOn,
    changed,
    dispatchEvent: dispatchEvent2,
    endInteraction,
    fit,
    get: get2,
    getAnimating,
    getCenter: getCenter2,
    getInteracting,
    getKeys,
    getMaxResolution,
    getMaxZoom,
    getMinResolution,
    getMinZoom,
    getProjection: getProjection2,
    getProperties,
    getResolution,
    getResolutionForExtent,
    getResolutionForZoom,
    getResolutions: getResolutions2,
    getRevision,
    getRotation,
    getZoom,
    getZoomForResolution,
    setCenter,
    setConstrainResolution,
    setMaxZoom,
    setMinZoom,
    setResolution,
    setRotation,
    setZoom
  };
}
const _sfc_main$15 = {
  name: "ol-view",
  setup(props, {
    emit
  }) {
    const view = useView(props, emit);
    return __spreadValues({}, view);
  },
  props: {
    center: {
      type: Array,
      default: () => [0, 0]
    },
    constrainRotation: {
      type: Boolean,
      default: true
    },
    enableRotation: {
      type: Boolean,
      default: true
    },
    extent: {
      type: Array
    },
    constrainOnlyCenter: {
      type: Boolean,
      default: false
    },
    smoothExtentConstraint: {
      type: Boolean,
      default: true
    },
    maxResolution: {
      type: Number
    },
    minResolution: {
      type: Number
    },
    maxZoom: {
      type: Number,
      default: 28
    },
    minZoom: {
      type: Number,
      default: 0
    },
    multiWorld: {
      type: Boolean,
      default: false
    },
    constrainResolution: {
      type: Boolean,
      default: false
    },
    smoothResolutionConstraint: {
      type: Boolean,
      default: true
    },
    showFullExtent: {
      type: Boolean,
      default: false
    },
    projection: {
      type: [String, Object],
      default: "EPSG:3857"
    },
    resolution: {
      type: Number
    },
    resolutions: {
      type: Array
    },
    rotation: {
      type: Number
    },
    zoom: {
      type: Number,
      default: 0
    },
    zoomFactor: {
      type: Number,
      default: 2
    },
    padding: {
      type: Array,
      default: () => [0, 0, 0, 0]
    }
  }
};
function _sfc_render$15(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var View = /* @__PURE__ */ _export_sfc(_sfc_main$15, [["render", _sfc_render$15]]);
class Feature$1 extends BaseObject {
  constructor(geometryOrProperties) {
    super();
    this.on;
    this.once;
    this.un;
    this.id_ = void 0;
    this.geometryName_ = "geometry";
    this.style_ = null;
    this.styleFunction_ = void 0;
    this.geometryChangeKey_ = null;
    this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
    if (geometryOrProperties) {
      if (typeof geometryOrProperties.getSimplifiedGeometry === "function") {
        const geometry = geometryOrProperties;
        this.setGeometry(geometry);
      } else {
        const properties = geometryOrProperties;
        this.setProperties(properties);
      }
    }
  }
  clone() {
    const clone2 = new Feature$1(this.hasProperties() ? this.getProperties() : null);
    clone2.setGeometryName(this.getGeometryName());
    const geometry = this.getGeometry();
    if (geometry) {
      clone2.setGeometry(geometry.clone());
    }
    const style2 = this.getStyle();
    if (style2) {
      clone2.setStyle(style2);
    }
    return clone2;
  }
  getGeometry() {
    return this.get(this.geometryName_);
  }
  getId() {
    return this.id_;
  }
  getGeometryName() {
    return this.geometryName_;
  }
  getStyle() {
    return this.style_;
  }
  getStyleFunction() {
    return this.styleFunction_;
  }
  handleGeometryChange_() {
    this.changed();
  }
  handleGeometryChanged_() {
    if (this.geometryChangeKey_) {
      unlistenByKey(this.geometryChangeKey_);
      this.geometryChangeKey_ = null;
    }
    const geometry = this.getGeometry();
    if (geometry) {
      this.geometryChangeKey_ = listen(geometry, EventType.CHANGE, this.handleGeometryChange_, this);
    }
    this.changed();
  }
  setGeometry(geometry) {
    this.set(this.geometryName_, geometry);
  }
  setStyle(style2) {
    this.style_ = style2;
    this.styleFunction_ = !style2 ? void 0 : createStyleFunction(style2);
    this.changed();
  }
  setId(id) {
    this.id_ = id;
    this.changed();
  }
  setGeometryName(name) {
    this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_);
    this.geometryName_ = name;
    this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
    this.handleGeometryChanged_();
  }
}
function createStyleFunction(obj) {
  if (typeof obj === "function") {
    return obj;
  }
  let styles;
  if (Array.isArray(obj)) {
    styles = obj;
  } else {
    assert(typeof obj.getZIndex === "function", 41);
    const style2 = obj;
    styles = [style2];
  }
  return function() {
    return styles;
  };
}
const _sfc_main$14 = {
  name: "ol-feature",
  setup(props) {
    const vectorSource = inject("vectorSource");
    const vectorLayer = inject("vectorLayer");
    const animation = inject("animation", null);
    const {
      properties
    } = usePropsAsObjectProperties(props);
    let feature = computed(() => {
      let f2 = new Feature$1(__spreadValues({}, properties.properties));
      return f2;
    });
    watch(feature, (newVal, oldVal) => {
      vectorSource.value.removeFeature(oldVal);
      vectorSource.value.addFeature(newVal);
      vectorSource.value.changed();
    });
    watch(vectorSource, (newVal, oldVal) => {
      oldVal.removeFeature(feature.value);
      newVal.addFeature(feature.value);
      newVal.changed();
    });
    onMounted(() => {
      vectorSource.value.addFeature(feature.value);
      if (animation != null) {
        vectorLayer.value.animateFeature(feature.value, animation.value);
      }
    });
    onUnmounted(() => {
      vectorSource.value.removeFeature(feature.value);
    });
    provide("feature", feature);
    provide("stylable", feature);
    return {
      feature
    };
  },
  props: {
    properties: {
      type: [Geometry, Object, Array]
    }
  }
};
function _sfc_render$14(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}
var Feature = /* @__PURE__ */ _export_sfc(_sfc_main$14, [["render", _sfc_render$14]]);
const Property$4 = {
  ELEMENT: "element",
  MAP: "map",
  OFFSET: "offset",
  POSITION: "position",
  POSITIONING: "positioning"
};
class Overlay$1 extends BaseObject {
  constructor(options) {
    super();
    this.on;
    this.once;
    this.un;
    this.options = options;
    this.id = options.id;
    this.insertFirst = options.insertFirst !== void 0 ? options.insertFirst : true;
    this.stopEvent = options.stopEvent !== void 0 ? options.stopEvent : true;
    this.element = document.createElement("div");
    this.element.className = options.className !== void 0 ? options.className : "ol-overlay-container " + CLASS_SELECTABLE;
    this.element.style.position = "absolute";
    this.element.style.pointerEvents = "auto";
    this.autoPan = options.autoPan === true ? {} : options.autoPan || void 0;
    this.rendered = {
      transform_: "",
      visible: true
    };
    this.mapPostrenderListenerKey = null;
    this.addChangeListener(Property$4.ELEMENT, this.handleElementChanged);
    this.addChangeListener(Property$4.MAP, this.handleMapChanged);
    this.addChangeListener(Property$4.OFFSET, this.handleOffsetChanged);
    this.addChangeListener(Property$4.POSITION, this.handlePositionChanged);
    this.addChangeListener(Property$4.POSITIONING, this.handlePositioningChanged);
    if (options.element !== void 0) {
      this.setElement(options.element);
    }
    this.setOffset(options.offset !== void 0 ? options.offset : [0, 0]);
    this.setPositioning(options.positioning || "top-left");
    if (options.position !== void 0) {
      this.setPosition(options.position);
    }
  }
  getElement() {
    return this.get(Property$4.ELEMENT);
  }
  getId() {
    return this.id;
  }
  getMap() {
    return this.get(Property$4.MAP) || null;
  }
  getOffset() {
    return this.get(Property$4.OFFSET);
  }
  getPosition() {
    return this.get(Property$4.POSITION);
  }
  getPositioning() {
    return this.get(Property$4.POSITIONING);
  }
  handleElementChanged() {
    removeChildren(this.element);
    const element = this.getElement();
    if (element) {
      this.element.appendChild(element);
    }
  }
  handleMapChanged() {
    if (this.mapPostrenderListenerKey) {
      removeNode$1(this.element);
      unlistenByKey(this.mapPostrenderListenerKey);
      this.mapPostrenderListenerKey = null;
    }
    const map = this.getMap();
    if (map) {
      this.mapPostrenderListenerKey = listen(map, MapEventType.POSTRENDER, this.render, this);
      this.updatePixelPosition();
      const container = this.stopEvent ? map.getOverlayContainerStopEvent() : map.getOverlayContainer();
      if (this.insertFirst) {
        container.insertBefore(this.element, container.childNodes[0] || null);
      } else {
        container.appendChild(this.element);
      }
      this.performAutoPan();
    }
  }
  render() {
    this.updatePixelPosition();
  }
  handleOffsetChanged() {
    this.updatePixelPosition();
  }
  handlePositionChanged() {
    this.updatePixelPosition();
    this.performAutoPan();
  }
  handlePositioningChanged() {
    this.updatePixelPosition();
  }
  setElement(element) {
    this.set(Property$4.ELEMENT, element);
  }
  setMap(map) {
    this.set(Property$4.MAP, map);
  }
  setOffset(offset2) {
    this.set(Property$4.OFFSET, offset2);
  }
  setPosition(position2) {
    this.set(Property$4.POSITION, position2);
  }
  performAutoPan() {
    if (this.autoPan) {
      this.panIntoView(this.autoPan);
    }
  }
  panIntoView(panIntoViewOptions) {
    const map = this.getMap();
    if (!map || !map.getTargetElement() || !this.get(Property$4.POSITION)) {
      return;
    }
    const mapRect = this.getRect(map.getTargetElement(), map.getSize());
    const element = this.getElement();
    const overlayRect = this.getRect(element, [
      outerWidth(element),
      outerHeight(element)
    ]);
    panIntoViewOptions = panIntoViewOptions || {};
    const myMargin = panIntoViewOptions.margin === void 0 ? 20 : panIntoViewOptions.margin;
    if (!containsExtent(mapRect, overlayRect)) {
      const offsetLeft = overlayRect[0] - mapRect[0];
      const offsetRight = mapRect[2] - overlayRect[2];
      const offsetTop = overlayRect[1] - mapRect[1];
      const offsetBottom = mapRect[3] - overlayRect[3];
      const delta = [0, 0];
      if (offsetLeft < 0) {
        delta[0] = offsetLeft - myMargin;
      } else if (offsetRight < 0) {
        delta[0] = Math.abs(offsetRight) + myMargin;
      }
      if (offsetTop < 0) {
        delta[1] = offsetTop - myMargin;
      } else if (offsetBottom < 0) {
        delta[1] = Math.abs(offsetBottom) + myMargin;
      }
      if (delta[0] !== 0 || delta[1] !== 0) {
        const center = map.getView().getCenterInternal();
        const centerPx = map.getPixelFromCoordinateInternal(center);
        if (!centerPx) {
          return;
        }
        const newCenterPx = [centerPx[0] + delta[0], centerPx[1] + delta[1]];
        const panOptions = panIntoViewOptions.animation || {};
        map.getView().animateInternal({
          center: map.getCoordinateFromPixelInternal(newCenterPx),
          duration: panOptions.duration,
          easing: panOptions.easing
        });
      }
    }
  }
  getRect(element, size) {
    const box = element.getBoundingClientRect();
    const offsetX = box.left + window.pageXOffset;
    const offsetY = box.top + window.pageYOffset;
    return [offsetX, offsetY, offsetX + size[0], offsetY + size[1]];
  }
  setPositioning(positioning) {
    this.set(Property$4.POSITIONING, positioning);
  }
  setVisible(visible) {
    if (this.rendered.visible !== visible) {
      this.element.style.display = visible ? "" : "none";
      this.rendered.visible = visible;
    }
  }
  updatePixelPosition() {
    const map = this.getMap();
    const position2 = this.getPosition();
    if (!map || !map.isRendered() || !position2) {
      this.setVisible(false);
      return;
    }
    const pixel = map.getPixelFromCoordinate(position2);
    const mapSize = map.getSize();
    this.updateRenderedPosition(pixel, mapSize);
  }
  updateRenderedPosition(pixel, mapSize) {
    const style2 = this.element.style;
    const offset2 = this.getOffset();
    const positioning = this.getPositioning();
    this.setVisible(true);
    const x2 = Math.round(pixel[0] + offset2[0]) + "px";
    const y2 = Math.round(pixel[1] + offset2[1]) + "px";
    let posX = "0%";
    let posY = "0%";
    if (positioning == "bottom-right" || positioning == "center-right" || positioning == "top-right") {
      posX = "-100%";
    } else if (positioning == "bottom-center" || positioning == "center-center" || positioning == "top-center") {
      posX = "-50%";
    }
    if (positioning == "bottom-left" || positioning == "bottom-center" || positioning == "bottom-right") {
      posY = "-100%";
    } else if (positioning == "center-left" || positioning == "center-center" || positioning == "center-right") {
      posY = "-50%";
    }
    const transform2 = `translate(${posX}, ${posY}) translate(${x2}, ${y2})`;
    if (this.rendered.transform_ != transform2) {
      this.rendered.transform_ = transform2;
      style2.transform = transform2;
    }
  }
  getOptions() {
    return this.options;
  }
}
function useOverlay(props, emit) {
  const map = inject("map");
  const htmlContent = ref(null);
  const {
    properties
  } = usePropsAsObjectProperties(props);
  let overlay = computed(() => new Overlay$1(properties));
  onMounted(() => {
    map.addOverlay(overlay.value);
  });
  onUnmounted(() => {
    map.removeOverlay(overlay.value);
  });
  watch(overlay, (newVal, oldVal) => {
    map.removeOverlay(oldVal);
    map.addOverlay(newVal);
  });
  watchEffect(() => {
    setElement(htmlContent.value);
  }, {
    flush: "post"
  });
  overlay.value.on("change:element", () => emit("elementChanged", getElement()));
  overlay.value.on("change:offset", () => emit("offsetChanged", getOffset()));
  overlay.value.on("change:position", () => emit("positionChanged", getPosition()));
  overlay.value.on("change:positioning", () => emit("positioningChanged", getPositioning()));
  const getElement = () => overlay.value.getElement();
  const getOffset = () => overlay.value.getOffset();
  const getPosition = () => overlay.value.getPosition();
  const getPositioning = () => overlay.value.getPositioning();
  const panIntoView = (opt_panIntoViewOptions) => overlay.value.panIntoView(opt_panIntoViewOptions);
  const setElement = (element) => overlay.value.setElement(element);
  const setOffset = (offset2) => overlay.value.setOffset(offset2);
  const setPosition = (position2) => overlay.value.setPosition(position2);
  const setPositioning = (positioning) => overlay.value.setPositioning(positioning);
  return {
    overlay,
    htmlContent,
    getOffset,
    getPosition,
    getPositioning,
    panIntoView,
    setElement,
    setOffset,
    setPosition,
    setPositioning
  };
}
const _sfc_main$13 = {
  name: "ol-overlay",
  setup(props, { emit }) {
    const overlay = new useOverlay(props, emit);
    return __spreadValues({}, overlay);
  },
  props: {
    position: {
      type: Array
    },
    offset: {
      type: Array
    },
    positioning: {
      type: String
    },
    stopEvent: {
      type: Boolean,
      default: true
    },
    insertFirst: {
      type: Boolean,
      default: true
    },
    autoPan: {
      type: Boolean,
      default: false
    },
    autoPanMargin: {
      type: Number,
      default: 20
    },
    autoPanAnimation: {
      type: Object,
      default: void 0
    }
  }
};
const _hoisted_1 = { ref: "htmlContent" };
function _sfc_render$13(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1, [
    renderSlot(_ctx.$slots, "default", { position: $props.position })
  ], 512);
}
var Overlay = /* @__PURE__ */ _export_sfc(_sfc_main$13, [["render", _sfc_render$13]]);
const Property$3 = {
  ACCURACY: "accuracy",
  ACCURACY_GEOMETRY: "accuracyGeometry",
  ALTITUDE: "altitude",
  ALTITUDE_ACCURACY: "altitudeAccuracy",
  HEADING: "heading",
  POSITION: "position",
  PROJECTION: "projection",
  SPEED: "speed",
  TRACKING: "tracking",
  TRACKING_OPTIONS: "trackingOptions"
};
class GeolocationError extends BaseEvent {
  constructor(error) {
    super(EventType.ERROR);
    this.code = error.code;
    this.message = error.message;
  }
}
class Geolocation extends BaseObject {
  constructor(options) {
    super();
    this.on;
    this.once;
    this.un;
    options = options || {};
    this.position_ = null;
    this.transform_ = identityTransform;
    this.watchId_ = void 0;
    this.addChangeListener(Property$3.PROJECTION, this.handleProjectionChanged_);
    this.addChangeListener(Property$3.TRACKING, this.handleTrackingChanged_);
    if (options.projection !== void 0) {
      this.setProjection(options.projection);
    }
    if (options.trackingOptions !== void 0) {
      this.setTrackingOptions(options.trackingOptions);
    }
    this.setTracking(options.tracking !== void 0 ? options.tracking : false);
  }
  disposeInternal() {
    this.setTracking(false);
    super.disposeInternal();
  }
  handleProjectionChanged_() {
    const projection = this.getProjection();
    if (projection) {
      this.transform_ = getTransformFromProjections(get$4("EPSG:4326"), projection);
      if (this.position_) {
        this.set(Property$3.POSITION, this.transform_(this.position_));
      }
    }
  }
  handleTrackingChanged_() {
    if ("geolocation" in navigator) {
      const tracking = this.getTracking();
      if (tracking && this.watchId_ === void 0) {
        this.watchId_ = navigator.geolocation.watchPosition(this.positionChange_.bind(this), this.positionError_.bind(this), this.getTrackingOptions());
      } else if (!tracking && this.watchId_ !== void 0) {
        navigator.geolocation.clearWatch(this.watchId_);
        this.watchId_ = void 0;
      }
    }
  }
  positionChange_(position2) {
    const coords = position2.coords;
    this.set(Property$3.ACCURACY, coords.accuracy);
    this.set(Property$3.ALTITUDE, coords.altitude === null ? void 0 : coords.altitude);
    this.set(Property$3.ALTITUDE_ACCURACY, coords.altitudeAccuracy === null ? void 0 : coords.altitudeAccuracy);
    this.set(Property$3.HEADING, coords.heading === null ? void 0 : toRadians(coords.heading));
    if (!this.position_) {
      this.position_ = [coords.longitude, coords.latitude];
    } else {
      this.position_[0] = coords.longitude;
      this.position_[1] = coords.latitude;
    }
    const projectedPosition = this.transform_(this.position_);
    this.set(Property$3.POSITION, projectedPosition);
    this.set(Property$3.SPEED, coords.speed === null ? void 0 : coords.speed);
    const geometry = circular(this.position_, coords.accuracy);
    geometry.applyTransform(this.transform_);
    this.set(Property$3.ACCURACY_GEOMETRY, geometry);
    this.changed();
  }
  positionError_(error) {
    this.dispatchEvent(new GeolocationError(error));
  }
  getAccuracy() {
    return this.get(Property$3.ACCURACY);
  }
  getAccuracyGeometry() {
    return this.get(Property$3.ACCURACY_GEOMETRY) || null;
  }
  getAltitude() {
    return this.get(Property$3.ALTITUDE);
  }
  getAltitudeAccuracy() {
    return this.get(Property$3.ALTITUDE_ACCURACY);
  }
  getHeading() {
    return this.get(Property$3.HEADING);
  }
  getPosition() {
    return this.get(Property$3.POSITION);
  }
  getProjection() {
    return this.get(Property$3.PROJECTION);
  }
  getSpeed() {
    return this.get(Property$3.SPEED);
  }
  getTracking() {
    return this.get(Property$3.TRACKING);
  }
  getTrackingOptions() {
    return this.get(Property$3.TRACKING_OPTIONS);
  }
  setProjection(projection) {
    this.set(Property$3.PROJECTION, get$4(projection));
  }
  setTracking(tracking) {
    this.set(Property$3.TRACKING, tracking);
  }
  setTrackingOptions(options) {
    this.set(Property$3.TRACKING_OPTIONS, options);
  }
}
const _sfc_main$12 = {
  name: "ol-geolocation",
  emits: ["positionChanged", "speedChanged", "headingChanged", "altitudeChanged", "altitudeAccuracyChanged", "accuracyGeometryChanged"],
  setup(props, {
    emit
  }) {
    const {
      properties
    } = usePropsAsObjectProperties(props);
    let geoLoc = computed(() => {
      let g2 = new Geolocation(properties);
      g2.on("change", changeEvt);
      return g2;
    });
    const position2 = ref([]);
    const accuracy = ref(0);
    const altitude = ref(0);
    const altitudeAccuracy = ref(0);
    const speed = ref(0);
    const heading = ref(0);
    const accuracyGeometry = ref({});
    watch(position2, () => {
      emit("positionChanged", position2.value);
    });
    watch(speed, () => {
      emit("speedChanged", speed.value);
    });
    watch(heading, () => {
      emit("headingChanged", heading.value);
    });
    watch(altitude, () => {
      emit("altitudeChanged", altitude.value);
    });
    watch(altitudeAccuracy, () => {
      emit("altitudeAccuracyChanged", altitudeAccuracy.value);
    });
    watch(accuracyGeometry, () => {
      emit("accuracyGeometryChanged", accuracyGeometry.value);
    });
    const changeEvt = () => {
      position2.value = geoLoc.value.getPosition();
      speed.value = geoLoc.value.getSpeed();
      heading.value = geoLoc.value.getHeading();
      accuracy.value = geoLoc.value.getAccuracy();
      altitude.value = geoLoc.value.getAltitude();
      altitudeAccuracy.value = geoLoc.value.getAltitudeAccuracy();
      accuracyGeometry.value = geoLoc.value.getAccuracyGeometry();
    };
    watch(geoLoc, (newVal, oldVal) => {
      oldVal.un("change", changeEvt);
      newVal.on("change", changeEvt);
    });
    return {
      geoLoc,
      position: position2,
      accuracy,
      altitude,
      altitudeAccuracy,
      speed,
      heading,
      accuracyGeometry
    };
  },
  props: {
    projection: {
      type: [String, Object],
      default: "EPSG:3857"
    },
    tracking: {
      type: Boolean,
      default: true
    },
    trackingOptions: {
      type: Object,
      default: () => {
        return {
          enableHighAccuracy: true
        };
      }
    }
  }
};
function _sfc_render$12(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default", {
    position: $setup.position,
    speed: $setup.speed,
    heading: $setup.heading,
    accuracy: $setup.accuracy,
    altitude: $setup.altitude,
    altitudeAccuracy: $setup.altitudeAccuracy,
    accuracyGeometry: $setup.accuracyGeometry
  });
}
var GeoLocation = /* @__PURE__ */ _export_sfc(_sfc_main$12, [["render", _sfc_render$12]]);
function globals(defs2) {
  defs2("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
  defs2("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
  defs2("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");
  defs2.WGS84 = defs2["EPSG:4326"];
  defs2["EPSG:3785"] = defs2["EPSG:3857"];
  defs2.GOOGLE = defs2["EPSG:3857"];
  defs2["EPSG:900913"] = defs2["EPSG:3857"];
  defs2["EPSG:102113"] = defs2["EPSG:3857"];
}
var PJD_3PARAM = 1;
var PJD_7PARAM = 2;
var PJD_GRIDSHIFT = 3;
var PJD_WGS84 = 4;
var PJD_NODATUM = 5;
var SRS_WGS84_SEMIMAJOR = 6378137;
var SRS_WGS84_SEMIMINOR = 6356752314e-3;
var SRS_WGS84_ESQUARED = 0.0066943799901413165;
var SEC_TO_RAD = 484813681109536e-20;
var HALF_PI = Math.PI / 2;
var SIXTH = 0.16666666666666666;
var RA4 = 0.04722222222222222;
var RA6 = 0.022156084656084655;
var EPSLN = 1e-10;
var D2R$1 = 0.017453292519943295;
var R2D = 57.29577951308232;
var FORTPI = Math.PI / 4;
var TWO_PI = Math.PI * 2;
var SPI = 3.14159265359;
var exports$2 = {};
exports$2.greenwich = 0;
exports$2.lisbon = -9.131906111111;
exports$2.paris = 2.337229166667;
exports$2.bogota = -74.080916666667;
exports$2.madrid = -3.687938888889;
exports$2.rome = 12.452333333333;
exports$2.bern = 7.439583333333;
exports$2.jakarta = 106.807719444444;
exports$2.ferro = -17.666666666667;
exports$2.brussels = 4.367975;
exports$2.stockholm = 18.058277777778;
exports$2.athens = 23.7163375;
exports$2.oslo = 10.722916666667;
var units = {
  ft: { to_meter: 0.3048 },
  "us-ft": { to_meter: 1200 / 3937 }
};
var ignoredChar = /[\s_\-\/\(\)]/g;
function match$1(obj, key) {
  if (obj[key]) {
    return obj[key];
  }
  var keys3 = Object.keys(obj);
  var lkey = key.toLowerCase().replace(ignoredChar, "");
  var i2 = -1;
  var testkey, processedKey;
  while (++i2 < keys3.length) {
    testkey = keys3[i2];
    processedKey = testkey.toLowerCase().replace(ignoredChar, "");
    if (processedKey === lkey) {
      return obj[testkey];
    }
  }
}
function projStr(defData) {
  var self2 = {};
  var paramObj = defData.split("+").map(function(v2) {
    return v2.trim();
  }).filter(function(a2) {
    return a2;
  }).reduce(function(p5, a2) {
    var split2 = a2.split("=");
    split2.push(true);
    p5[split2[0].toLowerCase()] = split2[1];
    return p5;
  }, {});
  var paramName, paramVal, paramOutname;
  var params2 = {
    proj: "projName",
    datum: "datumCode",
    rf: function(v2) {
      self2.rf = parseFloat(v2);
    },
    lat_0: function(v2) {
      self2.lat0 = v2 * D2R$1;
    },
    lat_1: function(v2) {
      self2.lat1 = v2 * D2R$1;
    },
    lat_2: function(v2) {
      self2.lat2 = v2 * D2R$1;
    },
    lat_ts: function(v2) {
      self2.lat_ts = v2 * D2R$1;
    },
    lon_0: function(v2) {
      self2.long0 = v2 * D2R$1;
    },
    lon_1: function(v2) {
      self2.long1 = v2 * D2R$1;
    },
    lon_2: function(v2) {
      self2.long2 = v2 * D2R$1;
    },
    alpha: function(v2) {
      self2.alpha = parseFloat(v2) * D2R$1;
    },
    gamma: function(v2) {
      self2.rectified_grid_angle = parseFloat(v2);
    },
    lonc: function(v2) {
      self2.longc = v2 * D2R$1;
    },
    x_0: function(v2) {
      self2.x0 = parseFloat(v2);
    },
    y_0: function(v2) {
      self2.y0 = parseFloat(v2);
    },
    k_0: function(v2) {
      self2.k0 = parseFloat(v2);
    },
    k: function(v2) {
      self2.k0 = parseFloat(v2);
    },
    a: function(v2) {
      self2.a = parseFloat(v2);
    },
    b: function(v2) {
      self2.b = parseFloat(v2);
    },
    r_a: function() {
      self2.R_A = true;
    },
    zone: function(v2) {
      self2.zone = parseInt(v2, 10);
    },
    south: function() {
      self2.utmSouth = true;
    },
    towgs84: function(v2) {
      self2.datum_params = v2.split(",").map(function(a2) {
        return parseFloat(a2);
      });
    },
    to_meter: function(v2) {
      self2.to_meter = parseFloat(v2);
    },
    units: function(v2) {
      self2.units = v2;
      var unit = match$1(units, v2);
      if (unit) {
        self2.to_meter = unit.to_meter;
      }
    },
    from_greenwich: function(v2) {
      self2.from_greenwich = v2 * D2R$1;
    },
    pm: function(v2) {
      var pm = match$1(exports$2, v2);
      self2.from_greenwich = (pm ? pm : parseFloat(v2)) * D2R$1;
    },
    nadgrids: function(v2) {
      if (v2 === "@null") {
        self2.datumCode = "none";
      } else {
        self2.nadgrids = v2;
      }
    },
    axis: function(v2) {
      var legalAxis = "ewnsud";
      if (v2.length === 3 && legalAxis.indexOf(v2.substr(0, 1)) !== -1 && legalAxis.indexOf(v2.substr(1, 1)) !== -1 && legalAxis.indexOf(v2.substr(2, 1)) !== -1) {
        self2.axis = v2;
      }
    },
    approx: function() {
      self2.approx = true;
    }
  };
  for (paramName in paramObj) {
    paramVal = paramObj[paramName];
    if (paramName in params2) {
      paramOutname = params2[paramName];
      if (typeof paramOutname === "function") {
        paramOutname(paramVal);
      } else {
        self2[paramOutname] = paramVal;
      }
    } else {
      self2[paramName] = paramVal;
    }
  }
  if (typeof self2.datumCode === "string" && self2.datumCode !== "WGS84") {
    self2.datumCode = self2.datumCode.toLowerCase();
  }
  return self2;
}
var NEUTRAL = 1;
var KEYWORD = 2;
var NUMBER = 3;
var QUOTED = 4;
var AFTERQUOTE = 5;
var ENDED = -1;
var whitespace$1 = /\s/;
var latin = /[A-Za-z]/;
var keyword = /[A-Za-z84_]/;
var endThings = /[,\]]/;
var digets = /[\d\.E\-\+]/;
function Parser$3(text2) {
  if (typeof text2 !== "string") {
    throw new Error("not a string");
  }
  this.text = text2.trim();
  this.level = 0;
  this.place = 0;
  this.root = null;
  this.stack = [];
  this.currentObject = null;
  this.state = NEUTRAL;
}
Parser$3.prototype.readCharicter = function() {
  var char = this.text[this.place++];
  if (this.state !== QUOTED) {
    while (whitespace$1.test(char)) {
      if (this.place >= this.text.length) {
        return;
      }
      char = this.text[this.place++];
    }
  }
  switch (this.state) {
    case NEUTRAL:
      return this.neutral(char);
    case KEYWORD:
      return this.keyword(char);
    case QUOTED:
      return this.quoted(char);
    case AFTERQUOTE:
      return this.afterquote(char);
    case NUMBER:
      return this.number(char);
    case ENDED:
      return;
  }
};
Parser$3.prototype.afterquote = function(char) {
  if (char === '"') {
    this.word += '"';
    this.state = QUOTED;
    return;
  }
  if (endThings.test(char)) {
    this.word = this.word.trim();
    this.afterItem(char);
    return;
  }
  throw new Error(`havn't handled "` + char + '" in afterquote yet, index ' + this.place);
};
Parser$3.prototype.afterItem = function(char) {
  if (char === ",") {
    if (this.word !== null) {
      this.currentObject.push(this.word);
    }
    this.word = null;
    this.state = NEUTRAL;
    return;
  }
  if (char === "]") {
    this.level--;
    if (this.word !== null) {
      this.currentObject.push(this.word);
      this.word = null;
    }
    this.state = NEUTRAL;
    this.currentObject = this.stack.pop();
    if (!this.currentObject) {
      this.state = ENDED;
    }
    return;
  }
};
Parser$3.prototype.number = function(char) {
  if (digets.test(char)) {
    this.word += char;
    return;
  }
  if (endThings.test(char)) {
    this.word = parseFloat(this.word);
    this.afterItem(char);
    return;
  }
  throw new Error(`havn't handled "` + char + '" in number yet, index ' + this.place);
};
Parser$3.prototype.quoted = function(char) {
  if (char === '"') {
    this.state = AFTERQUOTE;
    return;
  }
  this.word += char;
  return;
};
Parser$3.prototype.keyword = function(char) {
  if (keyword.test(char)) {
    this.word += char;
    return;
  }
  if (char === "[") {
    var newObjects = [];
    newObjects.push(this.word);
    this.level++;
    if (this.root === null) {
      this.root = newObjects;
    } else {
      this.currentObject.push(newObjects);
    }
    this.stack.push(this.currentObject);
    this.currentObject = newObjects;
    this.state = NEUTRAL;
    return;
  }
  if (endThings.test(char)) {
    this.afterItem(char);
    return;
  }
  throw new Error(`havn't handled "` + char + '" in keyword yet, index ' + this.place);
};
Parser$3.prototype.neutral = function(char) {
  if (latin.test(char)) {
    this.word = char;
    this.state = KEYWORD;
    return;
  }
  if (char === '"') {
    this.word = "";
    this.state = QUOTED;
    return;
  }
  if (digets.test(char)) {
    this.word = char;
    this.state = NUMBER;
    return;
  }
  if (endThings.test(char)) {
    this.afterItem(char);
    return;
  }
  throw new Error(`havn't handled "` + char + '" in neutral yet, index ' + this.place);
};
Parser$3.prototype.output = function() {
  while (this.place < this.text.length) {
    this.readCharicter();
  }
  if (this.state === ENDED) {
    return this.root;
  }
  throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
};
function parseString(txt) {
  var parser = new Parser$3(txt);
  return parser.output();
}
function mapit(obj, key, value) {
  if (Array.isArray(key)) {
    value.unshift(key);
    key = null;
  }
  var thing = key ? {} : obj;
  var out = value.reduce(function(newObj, item) {
    sExpr(item, newObj);
    return newObj;
  }, thing);
  if (key) {
    obj[key] = out;
  }
}
function sExpr(v2, obj) {
  if (!Array.isArray(v2)) {
    obj[v2] = true;
    return;
  }
  var key = v2.shift();
  if (key === "PARAMETER") {
    key = v2.shift();
  }
  if (v2.length === 1) {
    if (Array.isArray(v2[0])) {
      obj[key] = {};
      sExpr(v2[0], obj[key]);
      return;
    }
    obj[key] = v2[0];
    return;
  }
  if (!v2.length) {
    obj[key] = true;
    return;
  }
  if (key === "TOWGS84") {
    obj[key] = v2;
    return;
  }
  if (key === "AXIS") {
    if (!(key in obj)) {
      obj[key] = [];
    }
    obj[key].push(v2);
    return;
  }
  if (!Array.isArray(key)) {
    obj[key] = {};
  }
  var i2;
  switch (key) {
    case "UNIT":
    case "PRIMEM":
    case "VERT_DATUM":
      obj[key] = {
        name: v2[0].toLowerCase(),
        convert: v2[1]
      };
      if (v2.length === 3) {
        sExpr(v2[2], obj[key]);
      }
      return;
    case "SPHEROID":
    case "ELLIPSOID":
      obj[key] = {
        name: v2[0],
        a: v2[1],
        rf: v2[2]
      };
      if (v2.length === 4) {
        sExpr(v2[3], obj[key]);
      }
      return;
    case "PROJECTEDCRS":
    case "PROJCRS":
    case "GEOGCS":
    case "GEOCCS":
    case "PROJCS":
    case "LOCAL_CS":
    case "GEODCRS":
    case "GEODETICCRS":
    case "GEODETICDATUM":
    case "EDATUM":
    case "ENGINEERINGDATUM":
    case "VERT_CS":
    case "VERTCRS":
    case "VERTICALCRS":
    case "COMPD_CS":
    case "COMPOUNDCRS":
    case "ENGINEERINGCRS":
    case "ENGCRS":
    case "FITTED_CS":
    case "LOCAL_DATUM":
    case "DATUM":
      v2[0] = ["name", v2[0]];
      mapit(obj, key, v2);
      return;
    default:
      i2 = -1;
      while (++i2 < v2.length) {
        if (!Array.isArray(v2[i2])) {
          return sExpr(v2, obj[key]);
        }
      }
      return mapit(obj, key, v2);
  }
}
var D2R = 0.017453292519943295;
function rename(obj, params2) {
  var outName = params2[0];
  var inName = params2[1];
  if (!(outName in obj) && inName in obj) {
    obj[outName] = obj[inName];
    if (params2.length === 3) {
      obj[outName] = params2[2](obj[outName]);
    }
  }
}
function d2r(input) {
  return input * D2R;
}
function cleanWKT(wkt2) {
  if (wkt2.type === "GEOGCS") {
    wkt2.projName = "longlat";
  } else if (wkt2.type === "LOCAL_CS") {
    wkt2.projName = "identity";
    wkt2.local = true;
  } else {
    if (typeof wkt2.PROJECTION === "object") {
      wkt2.projName = Object.keys(wkt2.PROJECTION)[0];
    } else {
      wkt2.projName = wkt2.PROJECTION;
    }
  }
  if (wkt2.AXIS) {
    var axisOrder = "";
    for (var i2 = 0, ii = wkt2.AXIS.length; i2 < ii; ++i2) {
      var axis = [wkt2.AXIS[i2][0].toLowerCase(), wkt2.AXIS[i2][1].toLowerCase()];
      if (axis[0].indexOf("north") !== -1 || (axis[0] === "y" || axis[0] === "lat") && axis[1] === "north") {
        axisOrder += "n";
      } else if (axis[0].indexOf("south") !== -1 || (axis[0] === "y" || axis[0] === "lat") && axis[1] === "south") {
        axisOrder += "s";
      } else if (axis[0].indexOf("east") !== -1 || (axis[0] === "x" || axis[0] === "lon") && axis[1] === "east") {
        axisOrder += "e";
      } else if (axis[0].indexOf("west") !== -1 || (axis[0] === "x" || axis[0] === "lon") && axis[1] === "west") {
        axisOrder += "w";
      }
    }
    if (axisOrder.length === 2) {
      axisOrder += "u";
    }
    if (axisOrder.length === 3) {
      wkt2.axis = axisOrder;
    }
  }
  if (wkt2.UNIT) {
    wkt2.units = wkt2.UNIT.name.toLowerCase();
    if (wkt2.units === "metre") {
      wkt2.units = "meter";
    }
    if (wkt2.UNIT.convert) {
      if (wkt2.type === "GEOGCS") {
        if (wkt2.DATUM && wkt2.DATUM.SPHEROID) {
          wkt2.to_meter = wkt2.UNIT.convert * wkt2.DATUM.SPHEROID.a;
        }
      } else {
        wkt2.to_meter = wkt2.UNIT.convert;
      }
    }
  }
  var geogcs = wkt2.GEOGCS;
  if (wkt2.type === "GEOGCS") {
    geogcs = wkt2;
  }
  if (geogcs) {
    if (geogcs.DATUM) {
      wkt2.datumCode = geogcs.DATUM.name.toLowerCase();
    } else {
      wkt2.datumCode = geogcs.name.toLowerCase();
    }
    if (wkt2.datumCode.slice(0, 2) === "d_") {
      wkt2.datumCode = wkt2.datumCode.slice(2);
    }
    if (wkt2.datumCode === "new_zealand_geodetic_datum_1949" || wkt2.datumCode === "new_zealand_1949") {
      wkt2.datumCode = "nzgd49";
    }
    if (wkt2.datumCode === "wgs_1984" || wkt2.datumCode === "world_geodetic_system_1984") {
      if (wkt2.PROJECTION === "Mercator_Auxiliary_Sphere") {
        wkt2.sphere = true;
      }
      wkt2.datumCode = "wgs84";
    }
    if (wkt2.datumCode.slice(-6) === "_ferro") {
      wkt2.datumCode = wkt2.datumCode.slice(0, -6);
    }
    if (wkt2.datumCode.slice(-8) === "_jakarta") {
      wkt2.datumCode = wkt2.datumCode.slice(0, -8);
    }
    if (~wkt2.datumCode.indexOf("belge")) {
      wkt2.datumCode = "rnb72";
    }
    if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
      wkt2.ellps = geogcs.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk");
      if (wkt2.ellps.toLowerCase().slice(0, 13) === "international") {
        wkt2.ellps = "intl";
      }
      wkt2.a = geogcs.DATUM.SPHEROID.a;
      wkt2.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
    }
    if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {
      wkt2.datum_params = geogcs.DATUM.TOWGS84;
    }
    if (~wkt2.datumCode.indexOf("osgb_1936")) {
      wkt2.datumCode = "osgb36";
    }
    if (~wkt2.datumCode.indexOf("osni_1952")) {
      wkt2.datumCode = "osni52";
    }
    if (~wkt2.datumCode.indexOf("tm65") || ~wkt2.datumCode.indexOf("geodetic_datum_of_1965")) {
      wkt2.datumCode = "ire65";
    }
    if (wkt2.datumCode === "ch1903+") {
      wkt2.datumCode = "ch1903";
    }
    if (~wkt2.datumCode.indexOf("israel")) {
      wkt2.datumCode = "isr93";
    }
  }
  if (wkt2.b && !isFinite(wkt2.b)) {
    wkt2.b = wkt2.a;
  }
  function toMeter(input) {
    var ratio = wkt2.to_meter || 1;
    return input * ratio;
  }
  var renamer = function(a2) {
    return rename(wkt2, a2);
  };
  var list = [
    ["standard_parallel_1", "Standard_Parallel_1"],
    ["standard_parallel_1", "Latitude of 1st standard parallel"],
    ["standard_parallel_2", "Standard_Parallel_2"],
    ["standard_parallel_2", "Latitude of 2nd standard parallel"],
    ["false_easting", "False_Easting"],
    ["false_easting", "False easting"],
    ["false-easting", "Easting at false origin"],
    ["false_northing", "False_Northing"],
    ["false_northing", "False northing"],
    ["false_northing", "Northing at false origin"],
    ["central_meridian", "Central_Meridian"],
    ["central_meridian", "Longitude of natural origin"],
    ["central_meridian", "Longitude of false origin"],
    ["latitude_of_origin", "Latitude_Of_Origin"],
    ["latitude_of_origin", "Central_Parallel"],
    ["latitude_of_origin", "Latitude of natural origin"],
    ["latitude_of_origin", "Latitude of false origin"],
    ["scale_factor", "Scale_Factor"],
    ["k0", "scale_factor"],
    ["latitude_of_center", "Latitude_Of_Center"],
    ["latitude_of_center", "Latitude_of_center"],
    ["lat0", "latitude_of_center", d2r],
    ["longitude_of_center", "Longitude_Of_Center"],
    ["longitude_of_center", "Longitude_of_center"],
    ["longc", "longitude_of_center", d2r],
    ["x0", "false_easting", toMeter],
    ["y0", "false_northing", toMeter],
    ["long0", "central_meridian", d2r],
    ["lat0", "latitude_of_origin", d2r],
    ["lat0", "standard_parallel_1", d2r],
    ["lat1", "standard_parallel_1", d2r],
    ["lat2", "standard_parallel_2", d2r],
    ["azimuth", "Azimuth"],
    ["alpha", "azimuth", d2r],
    ["srsCode", "name"]
  ];
  list.forEach(renamer);
  if (!wkt2.long0 && wkt2.longc && (wkt2.projName === "Albers_Conic_Equal_Area" || wkt2.projName === "Lambert_Azimuthal_Equal_Area")) {
    wkt2.long0 = wkt2.longc;
  }
  if (!wkt2.lat_ts && wkt2.lat1 && (wkt2.projName === "Stereographic_South_Pole" || wkt2.projName === "Polar Stereographic (variant B)")) {
    wkt2.lat0 = d2r(wkt2.lat1 > 0 ? 90 : -90);
    wkt2.lat_ts = wkt2.lat1;
  }
}
function wkt(wkt2) {
  var lisp = parseString(wkt2);
  var type = lisp.shift();
  var name = lisp.shift();
  lisp.unshift(["name", name]);
  lisp.unshift(["type", type]);
  var obj = {};
  sExpr(lisp, obj);
  cleanWKT(obj);
  return obj;
}
function defs(name) {
  var that = this;
  if (arguments.length === 2) {
    var def = arguments[1];
    if (typeof def === "string") {
      if (def.charAt(0) === "+") {
        defs[name] = projStr(arguments[1]);
      } else {
        defs[name] = wkt(arguments[1]);
      }
    } else {
      defs[name] = def;
    }
  } else if (arguments.length === 1) {
    if (Array.isArray(name)) {
      return name.map(function(v2) {
        if (Array.isArray(v2)) {
          defs.apply(that, v2);
        } else {
          defs(v2);
        }
      });
    } else if (typeof name === "string") {
      if (name in defs) {
        return defs[name];
      }
    } else if ("EPSG" in name) {
      defs["EPSG:" + name.EPSG] = name;
    } else if ("ESRI" in name) {
      defs["ESRI:" + name.ESRI] = name;
    } else if ("IAU2000" in name) {
      defs["IAU2000:" + name.IAU2000] = name;
    } else {
      console.log(name);
    }
    return;
  }
}
globals(defs);
function testObj(code) {
  return typeof code === "string";
}
function testDef(code) {
  return code in defs;
}
var codeWords = ["PROJECTEDCRS", "PROJCRS", "GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS", "GEODCRS", "GEODETICCRS", "GEODETICDATUM", "ENGCRS", "ENGINEERINGCRS"];
function testWKT(code) {
  return codeWords.some(function(word) {
    return code.indexOf(word) > -1;
  });
}
var codes = ["3857", "900913", "3785", "102113"];
function checkMercator(item) {
  var auth = match$1(item, "authority");
  if (!auth) {
    return;
  }
  var code = match$1(auth, "epsg");
  return code && codes.indexOf(code) > -1;
}
function checkProjStr(item) {
  var ext = match$1(item, "extension");
  if (!ext) {
    return;
  }
  return match$1(ext, "proj4");
}
function testProj(code) {
  return code[0] === "+";
}
function parse$2(code) {
  if (testObj(code)) {
    if (testDef(code)) {
      return defs[code];
    }
    if (testWKT(code)) {
      var out = wkt(code);
      if (checkMercator(out)) {
        return defs["EPSG:3857"];
      }
      var maybeProjStr = checkProjStr(out);
      if (maybeProjStr) {
        return projStr(maybeProjStr);
      }
      return out;
    }
    if (testProj(code)) {
      return projStr(code);
    }
  } else {
    return code;
  }
}
function extend$1(destination, source) {
  destination = destination || {};
  var value, property;
  if (!source) {
    return destination;
  }
  for (property in source) {
    value = source[property];
    if (value !== void 0) {
      destination[property] = value;
    }
  }
  return destination;
}
function msfnz(eccent, sinphi, cosphi) {
  var con = eccent * sinphi;
  return cosphi / Math.sqrt(1 - con * con);
}
function sign$1(x2) {
  return x2 < 0 ? -1 : 1;
}
function adjust_lon(x2) {
  return Math.abs(x2) <= SPI ? x2 : x2 - sign$1(x2) * TWO_PI;
}
function tsfnz(eccent, phi, sinphi) {
  var con = eccent * sinphi;
  var com = 0.5 * eccent;
  con = Math.pow((1 - con) / (1 + con), com);
  return Math.tan(0.5 * (HALF_PI - phi)) / con;
}
function phi2z(eccent, ts) {
  var eccnth = 0.5 * eccent;
  var con, dphi;
  var phi = HALF_PI - 2 * Math.atan(ts);
  for (var i2 = 0; i2 <= 15; i2++) {
    con = eccent * Math.sin(phi);
    dphi = HALF_PI - 2 * Math.atan(ts * Math.pow((1 - con) / (1 + con), eccnth)) - phi;
    phi += dphi;
    if (Math.abs(dphi) <= 1e-10) {
      return phi;
    }
  }
  return -9999;
}
function init$u() {
  var con = this.b / this.a;
  this.es = 1 - con * con;
  if (!("x0" in this)) {
    this.x0 = 0;
  }
  if (!("y0" in this)) {
    this.y0 = 0;
  }
  this.e = Math.sqrt(this.es);
  if (this.lat_ts) {
    if (this.sphere) {
      this.k0 = Math.cos(this.lat_ts);
    } else {
      this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
    }
  } else {
    if (!this.k0) {
      if (this.k) {
        this.k0 = this.k;
      } else {
        this.k0 = 1;
      }
    }
  }
}
function forward$t(p5) {
  var lon = p5.x;
  var lat = p5.y;
  if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
    return null;
  }
  var x2, y2;
  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
    return null;
  } else {
    if (this.sphere) {
      x2 = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
      y2 = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
    } else {
      var sinphi = Math.sin(lat);
      var ts = tsfnz(this.e, lat, sinphi);
      x2 = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
      y2 = this.y0 - this.a * this.k0 * Math.log(ts);
    }
    p5.x = x2;
    p5.y = y2;
    return p5;
  }
}
function inverse$t(p5) {
  var x2 = p5.x - this.x0;
  var y2 = p5.y - this.y0;
  var lon, lat;
  if (this.sphere) {
    lat = HALF_PI - 2 * Math.atan(Math.exp(-y2 / (this.a * this.k0)));
  } else {
    var ts = Math.exp(-y2 / (this.a * this.k0));
    lat = phi2z(this.e, ts);
    if (lat === -9999) {
      return null;
    }
  }
  lon = adjust_lon(this.long0 + x2 / (this.a * this.k0));
  p5.x = lon;
  p5.y = lat;
  return p5;
}
var names$v = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
var merc = {
  init: init$u,
  forward: forward$t,
  inverse: inverse$t,
  names: names$v
};
function init$t() {
}
function identity(pt2) {
  return pt2;
}
var names$u = ["longlat", "identity"];
var longlat = {
  init: init$t,
  forward: identity,
  inverse: identity,
  names: names$u
};
var projs = [merc, longlat];
var names$t = {};
var projStore = [];
function add(proj, i2) {
  var len = projStore.length;
  if (!proj.names) {
    console.log(i2);
    return true;
  }
  projStore[len] = proj;
  proj.names.forEach(function(n2) {
    names$t[n2.toLowerCase()] = len;
  });
  return this;
}
function get$3(name) {
  if (!name) {
    return false;
  }
  var n2 = name.toLowerCase();
  if (typeof names$t[n2] !== "undefined" && projStore[names$t[n2]]) {
    return projStore[names$t[n2]];
  }
}
function start() {
  projs.forEach(add);
}
var projections = {
  start,
  add,
  get: get$3
};
var exports$1 = {};
exports$1.MERIT = {
  a: 6378137,
  rf: 298.257,
  ellipseName: "MERIT 1983"
};
exports$1.SGS85 = {
  a: 6378136,
  rf: 298.257,
  ellipseName: "Soviet Geodetic System 85"
};
exports$1.GRS80 = {
  a: 6378137,
  rf: 298.257222101,
  ellipseName: "GRS 1980(IUGG, 1980)"
};
exports$1.IAU76 = {
  a: 6378140,
  rf: 298.257,
  ellipseName: "IAU 1976"
};
exports$1.airy = {
  a: 6377563396e-3,
  b: 635625691e-2,
  ellipseName: "Airy 1830"
};
exports$1.APL4 = {
  a: 6378137,
  rf: 298.25,
  ellipseName: "Appl. Physics. 1965"
};
exports$1.NWL9D = {
  a: 6378145,
  rf: 298.25,
  ellipseName: "Naval Weapons Lab., 1965"
};
exports$1.mod_airy = {
  a: 6377340189e-3,
  b: 6356034446e-3,
  ellipseName: "Modified Airy"
};
exports$1.andrae = {
  a: 637710443e-2,
  rf: 300,
  ellipseName: "Andrae 1876 (Den., Iclnd.)"
};
exports$1.aust_SA = {
  a: 6378160,
  rf: 298.25,
  ellipseName: "Australian Natl & S. Amer. 1969"
};
exports$1.GRS67 = {
  a: 6378160,
  rf: 298.247167427,
  ellipseName: "GRS 67(IUGG 1967)"
};
exports$1.bessel = {
  a: 6377397155e-3,
  rf: 299.1528128,
  ellipseName: "Bessel 1841"
};
exports$1.bess_nam = {
  a: 6377483865e-3,
  rf: 299.1528128,
  ellipseName: "Bessel 1841 (Namibia)"
};
exports$1.clrk66 = {
  a: 63782064e-1,
  b: 63565838e-1,
  ellipseName: "Clarke 1866"
};
exports$1.clrk80 = {
  a: 6378249145e-3,
  rf: 293.4663,
  ellipseName: "Clarke 1880 mod."
};
exports$1.clrk58 = {
  a: 6378293645208759e-9,
  rf: 294.2606763692654,
  ellipseName: "Clarke 1858"
};
exports$1.CPM = {
  a: 63757387e-1,
  rf: 334.29,
  ellipseName: "Comm. des Poids et Mesures 1799"
};
exports$1.delmbr = {
  a: 6376428,
  rf: 311.5,
  ellipseName: "Delambre 1810 (Belgium)"
};
exports$1.engelis = {
  a: 637813605e-2,
  rf: 298.2566,
  ellipseName: "Engelis 1985"
};
exports$1.evrst30 = {
  a: 6377276345e-3,
  rf: 300.8017,
  ellipseName: "Everest 1830"
};
exports$1.evrst48 = {
  a: 6377304063e-3,
  rf: 300.8017,
  ellipseName: "Everest 1948"
};
exports$1.evrst56 = {
  a: 6377301243e-3,
  rf: 300.8017,
  ellipseName: "Everest 1956"
};
exports$1.evrst69 = {
  a: 6377295664e-3,
  rf: 300.8017,
  ellipseName: "Everest 1969"
};
exports$1.evrstSS = {
  a: 6377298556e-3,
  rf: 300.8017,
  ellipseName: "Everest (Sabah & Sarawak)"
};
exports$1.fschr60 = {
  a: 6378166,
  rf: 298.3,
  ellipseName: "Fischer (Mercury Datum) 1960"
};
exports$1.fschr60m = {
  a: 6378155,
  rf: 298.3,
  ellipseName: "Fischer 1960"
};
exports$1.fschr68 = {
  a: 6378150,
  rf: 298.3,
  ellipseName: "Fischer 1968"
};
exports$1.helmert = {
  a: 6378200,
  rf: 298.3,
  ellipseName: "Helmert 1906"
};
exports$1.hough = {
  a: 6378270,
  rf: 297,
  ellipseName: "Hough"
};
exports$1.intl = {
  a: 6378388,
  rf: 297,
  ellipseName: "International 1909 (Hayford)"
};
exports$1.kaula = {
  a: 6378163,
  rf: 298.24,
  ellipseName: "Kaula 1961"
};
exports$1.lerch = {
  a: 6378139,
  rf: 298.257,
  ellipseName: "Lerch 1979"
};
exports$1.mprts = {
  a: 6397300,
  rf: 191,
  ellipseName: "Maupertius 1738"
};
exports$1.new_intl = {
  a: 63781575e-1,
  b: 63567722e-1,
  ellipseName: "New International 1967"
};
exports$1.plessis = {
  a: 6376523,
  rf: 6355863,
  ellipseName: "Plessis 1817 (France)"
};
exports$1.krass = {
  a: 6378245,
  rf: 298.3,
  ellipseName: "Krassovsky, 1942"
};
exports$1.SEasia = {
  a: 6378155,
  b: 63567733205e-4,
  ellipseName: "Southeast Asia"
};
exports$1.walbeck = {
  a: 6376896,
  b: 63558348467e-4,
  ellipseName: "Walbeck"
};
exports$1.WGS60 = {
  a: 6378165,
  rf: 298.3,
  ellipseName: "WGS 60"
};
exports$1.WGS66 = {
  a: 6378145,
  rf: 298.25,
  ellipseName: "WGS 66"
};
exports$1.WGS7 = {
  a: 6378135,
  rf: 298.26,
  ellipseName: "WGS 72"
};
var WGS84 = exports$1.WGS84 = {
  a: 6378137,
  rf: 298.257223563,
  ellipseName: "WGS 84"
};
exports$1.sphere = {
  a: 6370997,
  b: 6370997,
  ellipseName: "Normal Sphere (r=6370997)"
};
function eccentricity(a2, b2, rf, R_A) {
  var a22 = a2 * a2;
  var b22 = b2 * b2;
  var es = (a22 - b22) / a22;
  var e2 = 0;
  if (R_A) {
    a2 *= 1 - es * (SIXTH + es * (RA4 + es * RA6));
    a22 = a2 * a2;
    es = 0;
  } else {
    e2 = Math.sqrt(es);
  }
  var ep2 = (a22 - b22) / b22;
  return {
    es,
    e: e2,
    ep2
  };
}
function sphere(a2, b2, rf, ellps, sphere2) {
  if (!a2) {
    var ellipse = match$1(exports$1, ellps);
    if (!ellipse) {
      ellipse = WGS84;
    }
    a2 = ellipse.a;
    b2 = ellipse.b;
    rf = ellipse.rf;
  }
  if (rf && !b2) {
    b2 = (1 - 1 / rf) * a2;
  }
  if (rf === 0 || Math.abs(a2 - b2) < EPSLN) {
    sphere2 = true;
    b2 = a2;
  }
  return {
    a: a2,
    b: b2,
    rf,
    sphere: sphere2
  };
}
var exports = {};
exports.wgs84 = {
  towgs84: "0,0,0",
  ellipse: "WGS84",
  datumName: "WGS84"
};
exports.ch1903 = {
  towgs84: "674.374,15.056,405.346",
  ellipse: "bessel",
  datumName: "swiss"
};
exports.ggrs87 = {
  towgs84: "-199.87,74.79,246.62",
  ellipse: "GRS80",
  datumName: "Greek_Geodetic_Reference_System_1987"
};
exports.nad83 = {
  towgs84: "0,0,0",
  ellipse: "GRS80",
  datumName: "North_American_Datum_1983"
};
exports.nad27 = {
  nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
  ellipse: "clrk66",
  datumName: "North_American_Datum_1927"
};
exports.potsdam = {
  towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
  ellipse: "bessel",
  datumName: "Potsdam Rauenberg 1950 DHDN"
};
exports.carthage = {
  towgs84: "-263.0,6.0,431.0",
  ellipse: "clark80",
  datumName: "Carthage 1934 Tunisia"
};
exports.hermannskogel = {
  towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
  ellipse: "bessel",
  datumName: "Hermannskogel"
};
exports.osni52 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "airy",
  datumName: "Irish National"
};
exports.ire65 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "mod_airy",
  datumName: "Ireland 1965"
};
exports.rassadiran = {
  towgs84: "-133.63,-157.5,-158.62",
  ellipse: "intl",
  datumName: "Rassadiran"
};
exports.nzgd49 = {
  towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
  ellipse: "intl",
  datumName: "New Zealand Geodetic Datum 1949"
};
exports.osgb36 = {
  towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
  ellipse: "airy",
  datumName: "Airy 1830"
};
exports.s_jtsk = {
  towgs84: "589,76,480",
  ellipse: "bessel",
  datumName: "S-JTSK (Ferro)"
};
exports.beduaram = {
  towgs84: "-106,-87,188",
  ellipse: "clrk80",
  datumName: "Beduaram"
};
exports.gunung_segara = {
  towgs84: "-403,684,41",
  ellipse: "bessel",
  datumName: "Gunung Segara Jakarta"
};
exports.rnb72 = {
  towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
  ellipse: "intl",
  datumName: "Reseau National Belge 1972"
};
function datum(datumCode, datum_params, a2, b2, es, ep2, nadgrids) {
  var out = {};
  if (datumCode === void 0 || datumCode === "none") {
    out.datum_type = PJD_NODATUM;
  } else {
    out.datum_type = PJD_WGS84;
  }
  if (datum_params) {
    out.datum_params = datum_params.map(parseFloat);
    if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
      out.datum_type = PJD_3PARAM;
    }
    if (out.datum_params.length > 3) {
      if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
        out.datum_type = PJD_7PARAM;
        out.datum_params[3] *= SEC_TO_RAD;
        out.datum_params[4] *= SEC_TO_RAD;
        out.datum_params[5] *= SEC_TO_RAD;
        out.datum_params[6] = out.datum_params[6] / 1e6 + 1;
      }
    }
  }
  if (nadgrids) {
    out.datum_type = PJD_GRIDSHIFT;
    out.grids = nadgrids;
  }
  out.a = a2;
  out.b = b2;
  out.es = es;
  out.ep2 = ep2;
  return out;
}
var loadedNadgrids = {};
function nadgrid(key, data2) {
  var view = new DataView(data2);
  var isLittleEndian = detectLittleEndian(view);
  var header = readHeader(view, isLittleEndian);
  if (header.nSubgrids > 1) {
    console.log("Only single NTv2 subgrids are currently supported, subsequent sub grids are ignored");
  }
  var subgrids = readSubgrids(view, header, isLittleEndian);
  var nadgrid2 = { header, subgrids };
  loadedNadgrids[key] = nadgrid2;
  return nadgrid2;
}
function getNadgrids(nadgrids) {
  if (nadgrids === void 0) {
    return null;
  }
  var grids = nadgrids.split(",");
  return grids.map(parseNadgridString);
}
function parseNadgridString(value) {
  if (value.length === 0) {
    return null;
  }
  var optional = value[0] === "@";
  if (optional) {
    value = value.slice(1);
  }
  if (value === "null") {
    return { name: "null", mandatory: !optional, grid: null, isNull: true };
  }
  return {
    name: value,
    mandatory: !optional,
    grid: loadedNadgrids[value] || null,
    isNull: false
  };
}
function secondsToRadians(seconds) {
  return seconds / 3600 * Math.PI / 180;
}
function detectLittleEndian(view) {
  var nFields = view.getInt32(8, false);
  if (nFields === 11) {
    return false;
  }
  nFields = view.getInt32(8, true);
  if (nFields !== 11) {
    console.warn("Failed to detect nadgrid endian-ness, defaulting to little-endian");
  }
  return true;
}
function readHeader(view, isLittleEndian) {
  return {
    nFields: view.getInt32(8, isLittleEndian),
    nSubgridFields: view.getInt32(24, isLittleEndian),
    nSubgrids: view.getInt32(40, isLittleEndian),
    shiftType: decodeString(view, 56, 56 + 8).trim(),
    fromSemiMajorAxis: view.getFloat64(120, isLittleEndian),
    fromSemiMinorAxis: view.getFloat64(136, isLittleEndian),
    toSemiMajorAxis: view.getFloat64(152, isLittleEndian),
    toSemiMinorAxis: view.getFloat64(168, isLittleEndian)
  };
}
function decodeString(view, start2, end) {
  return String.fromCharCode.apply(null, new Uint8Array(view.buffer.slice(start2, end)));
}
function readSubgrids(view, header, isLittleEndian) {
  var gridOffset = 176;
  var grids = [];
  for (var i2 = 0; i2 < header.nSubgrids; i2++) {
    var subHeader = readGridHeader(view, gridOffset, isLittleEndian);
    var nodes = readGridNodes(view, gridOffset, subHeader, isLittleEndian);
    var lngColumnCount = Math.round(1 + (subHeader.upperLongitude - subHeader.lowerLongitude) / subHeader.longitudeInterval);
    var latColumnCount = Math.round(1 + (subHeader.upperLatitude - subHeader.lowerLatitude) / subHeader.latitudeInterval);
    grids.push({
      ll: [secondsToRadians(subHeader.lowerLongitude), secondsToRadians(subHeader.lowerLatitude)],
      del: [secondsToRadians(subHeader.longitudeInterval), secondsToRadians(subHeader.latitudeInterval)],
      lim: [lngColumnCount, latColumnCount],
      count: subHeader.gridNodeCount,
      cvs: mapNodes(nodes)
    });
  }
  return grids;
}
function mapNodes(nodes) {
  return nodes.map(function(r2) {
    return [secondsToRadians(r2.longitudeShift), secondsToRadians(r2.latitudeShift)];
  });
}
function readGridHeader(view, offset2, isLittleEndian) {
  return {
    name: decodeString(view, offset2 + 8, offset2 + 16).trim(),
    parent: decodeString(view, offset2 + 24, offset2 + 24 + 8).trim(),
    lowerLatitude: view.getFloat64(offset2 + 72, isLittleEndian),
    upperLatitude: view.getFloat64(offset2 + 88, isLittleEndian),
    lowerLongitude: view.getFloat64(offset2 + 104, isLittleEndian),
    upperLongitude: view.getFloat64(offset2 + 120, isLittleEndian),
    latitudeInterval: view.getFloat64(offset2 + 136, isLittleEndian),
    longitudeInterval: view.getFloat64(offset2 + 152, isLittleEndian),
    gridNodeCount: view.getInt32(offset2 + 168, isLittleEndian)
  };
}
function readGridNodes(view, offset2, gridHeader, isLittleEndian) {
  var nodesOffset = offset2 + 176;
  var gridRecordLength = 16;
  var gridShiftRecords = [];
  for (var i2 = 0; i2 < gridHeader.gridNodeCount; i2++) {
    var record = {
      latitudeShift: view.getFloat32(nodesOffset + i2 * gridRecordLength, isLittleEndian),
      longitudeShift: view.getFloat32(nodesOffset + i2 * gridRecordLength + 4, isLittleEndian),
      latitudeAccuracy: view.getFloat32(nodesOffset + i2 * gridRecordLength + 8, isLittleEndian),
      longitudeAccuracy: view.getFloat32(nodesOffset + i2 * gridRecordLength + 12, isLittleEndian)
    };
    gridShiftRecords.push(record);
  }
  return gridShiftRecords;
}
function Projection$1(srsCode, callback) {
  if (!(this instanceof Projection$1)) {
    return new Projection$1(srsCode);
  }
  callback = callback || function(error) {
    if (error) {
      throw error;
    }
  };
  var json = parse$2(srsCode);
  if (typeof json !== "object") {
    callback(srsCode);
    return;
  }
  var ourProj = Projection$1.projections.get(json.projName);
  if (!ourProj) {
    callback(srsCode);
    return;
  }
  if (json.datumCode && json.datumCode !== "none") {
    var datumDef = match$1(exports, json.datumCode);
    if (datumDef) {
      json.datum_params = json.datum_params || (datumDef.towgs84 ? datumDef.towgs84.split(",") : null);
      json.ellps = datumDef.ellipse;
      json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
    }
  }
  json.k0 = json.k0 || 1;
  json.axis = json.axis || "enu";
  json.ellps = json.ellps || "wgs84";
  json.lat1 = json.lat1 || json.lat0;
  var sphere_ = sphere(json.a, json.b, json.rf, json.ellps, json.sphere);
  var ecc = eccentricity(sphere_.a, sphere_.b, sphere_.rf, json.R_A);
  var nadgrids = getNadgrids(json.nadgrids);
  var datumObj = json.datum || datum(json.datumCode, json.datum_params, sphere_.a, sphere_.b, ecc.es, ecc.ep2, nadgrids);
  extend$1(this, json);
  extend$1(this, ourProj);
  this.a = sphere_.a;
  this.b = sphere_.b;
  this.rf = sphere_.rf;
  this.sphere = sphere_.sphere;
  this.es = ecc.es;
  this.e = ecc.e;
  this.ep2 = ecc.ep2;
  this.datum = datumObj;
  this.init();
  callback(null, this);
}
Projection$1.projections = projections;
Projection$1.projections.start();
function compareDatums(source, dest) {
  if (source.datum_type !== dest.datum_type) {
    return false;
  } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 5e-11) {
    return false;
  } else if (source.datum_type === PJD_3PARAM) {
    return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2];
  } else if (source.datum_type === PJD_7PARAM) {
    return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6];
  } else {
    return true;
  }
}
function geodeticToGeocentric(p5, es, a2) {
  var Longitude = p5.x;
  var Latitude = p5.y;
  var Height = p5.z ? p5.z : 0;
  var Rn;
  var Sin_Lat;
  var Sin2_Lat;
  var Cos_Lat;
  if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
    Latitude = -HALF_PI;
  } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
    Latitude = HALF_PI;
  } else if (Latitude < -HALF_PI) {
    return { x: -Infinity, y: -Infinity, z: p5.z };
  } else if (Latitude > HALF_PI) {
    return { x: Infinity, y: Infinity, z: p5.z };
  }
  if (Longitude > Math.PI) {
    Longitude -= 2 * Math.PI;
  }
  Sin_Lat = Math.sin(Latitude);
  Cos_Lat = Math.cos(Latitude);
  Sin2_Lat = Sin_Lat * Sin_Lat;
  Rn = a2 / Math.sqrt(1 - es * Sin2_Lat);
  return {
    x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),
    y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
    z: (Rn * (1 - es) + Height) * Sin_Lat
  };
}
function geocentricToGeodetic(p5, es, a2, b2) {
  var genau = 1e-12;
  var genau2 = genau * genau;
  var maxiter = 30;
  var P2;
  var RR;
  var CT;
  var ST;
  var RX;
  var RK;
  var RN;
  var CPHI0;
  var SPHI0;
  var CPHI;
  var SPHI;
  var SDPHI;
  var iter;
  var X2 = p5.x;
  var Y2 = p5.y;
  var Z2 = p5.z ? p5.z : 0;
  var Longitude;
  var Latitude;
  var Height;
  P2 = Math.sqrt(X2 * X2 + Y2 * Y2);
  RR = Math.sqrt(X2 * X2 + Y2 * Y2 + Z2 * Z2);
  if (P2 / a2 < genau) {
    Longitude = 0;
    if (RR / a2 < genau) {
      Latitude = HALF_PI;
      Height = -b2;
      return {
        x: p5.x,
        y: p5.y,
        z: p5.z
      };
    }
  } else {
    Longitude = Math.atan2(Y2, X2);
  }
  CT = Z2 / RR;
  ST = P2 / RR;
  RX = 1 / Math.sqrt(1 - es * (2 - es) * ST * ST);
  CPHI0 = ST * (1 - es) * RX;
  SPHI0 = CT * RX;
  iter = 0;
  do {
    iter++;
    RN = a2 / Math.sqrt(1 - es * SPHI0 * SPHI0);
    Height = P2 * CPHI0 + Z2 * SPHI0 - RN * (1 - es * SPHI0 * SPHI0);
    RK = es * RN / (RN + Height);
    RX = 1 / Math.sqrt(1 - RK * (2 - RK) * ST * ST);
    CPHI = ST * (1 - RK) * RX;
    SPHI = CT * RX;
    SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
    CPHI0 = CPHI;
    SPHI0 = SPHI;
  } while (SDPHI * SDPHI > genau2 && iter < maxiter);
  Latitude = Math.atan(SPHI / Math.abs(CPHI));
  return {
    x: Longitude,
    y: Latitude,
    z: Height
  };
}
function geocentricToWgs84(p5, datum_type, datum_params) {
  if (datum_type === PJD_3PARAM) {
    return {
      x: p5.x + datum_params[0],
      y: p5.y + datum_params[1],
      z: p5.z + datum_params[2]
    };
  } else if (datum_type === PJD_7PARAM) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6];
    return {
      x: M_BF * (p5.x - Rz_BF * p5.y + Ry_BF * p5.z) + Dx_BF,
      y: M_BF * (Rz_BF * p5.x + p5.y - Rx_BF * p5.z) + Dy_BF,
      z: M_BF * (-Ry_BF * p5.x + Rx_BF * p5.y + p5.z) + Dz_BF
    };
  }
}
function geocentricFromWgs84(p5, datum_type, datum_params) {
  if (datum_type === PJD_3PARAM) {
    return {
      x: p5.x - datum_params[0],
      y: p5.y - datum_params[1],
      z: p5.z - datum_params[2]
    };
  } else if (datum_type === PJD_7PARAM) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6];
    var x_tmp = (p5.x - Dx_BF) / M_BF;
    var y_tmp = (p5.y - Dy_BF) / M_BF;
    var z_tmp = (p5.z - Dz_BF) / M_BF;
    return {
      x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
      y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
      z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
    };
  }
}
function checkParams(type) {
  return type === PJD_3PARAM || type === PJD_7PARAM;
}
function datum_transform(source, dest, point) {
  if (compareDatums(source, dest)) {
    return point;
  }
  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
    return point;
  }
  var source_a = source.a;
  var source_es = source.es;
  if (source.datum_type === PJD_GRIDSHIFT) {
    var gridShiftCode = applyGridShift(source, false, point);
    if (gridShiftCode !== 0) {
      return void 0;
    }
    source_a = SRS_WGS84_SEMIMAJOR;
    source_es = SRS_WGS84_ESQUARED;
  }
  var dest_a = dest.a;
  var dest_b = dest.b;
  var dest_es = dest.es;
  if (dest.datum_type === PJD_GRIDSHIFT) {
    dest_a = SRS_WGS84_SEMIMAJOR;
    dest_b = SRS_WGS84_SEMIMINOR;
    dest_es = SRS_WGS84_ESQUARED;
  }
  if (source_es === dest_es && source_a === dest_a && !checkParams(source.datum_type) && !checkParams(dest.datum_type)) {
    return point;
  }
  point = geodeticToGeocentric(point, source_es, source_a);
  if (checkParams(source.datum_type)) {
    point = geocentricToWgs84(point, source.datum_type, source.datum_params);
  }
  if (checkParams(dest.datum_type)) {
    point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);
  }
  point = geocentricToGeodetic(point, dest_es, dest_a, dest_b);
  if (dest.datum_type === PJD_GRIDSHIFT) {
    var destGridShiftResult = applyGridShift(dest, true, point);
    if (destGridShiftResult !== 0) {
      return void 0;
    }
  }
  return point;
}
function applyGridShift(source, inverse2, point) {
  if (source.grids === null || source.grids.length === 0) {
    console.log("Grid shift grids not found");
    return -1;
  }
  var input = { x: -point.x, y: point.y };
  var output = { x: Number.NaN, y: Number.NaN };
  var attemptedGrids = [];
  for (var i2 = 0; i2 < source.grids.length; i2++) {
    var grid = source.grids[i2];
    attemptedGrids.push(grid.name);
    if (grid.isNull) {
      output = input;
      break;
    }
    if (grid.grid === null) {
      if (grid.mandatory) {
        console.log("Unable to find mandatory grid '" + grid.name + "'");
        return -1;
      }
      continue;
    }
    var subgrid = grid.grid.subgrids[0];
    var epsilon = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 1e4;
    var minX = subgrid.ll[0] - epsilon;
    var minY = subgrid.ll[1] - epsilon;
    var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon;
    var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon;
    if (minY > input.y || minX > input.x || maxY < input.y || maxX < input.x) {
      continue;
    }
    output = applySubgridShift(input, inverse2, subgrid);
    if (!isNaN(output.x)) {
      break;
    }
  }
  if (isNaN(output.x)) {
    console.log("Failed to find a grid shift table for location '" + -input.x * R2D + " " + input.y * R2D + " tried: '" + attemptedGrids + "'");
    return -1;
  }
  point.x = -output.x;
  point.y = output.y;
  return 0;
}
function applySubgridShift(pin, inverse2, ct2) {
  var val = { x: Number.NaN, y: Number.NaN };
  if (isNaN(pin.x)) {
    return val;
  }
  var tb = { x: pin.x, y: pin.y };
  tb.x -= ct2.ll[0];
  tb.y -= ct2.ll[1];
  tb.x = adjust_lon(tb.x - Math.PI) + Math.PI;
  var t3 = nadInterpolate(tb, ct2);
  if (inverse2) {
    if (isNaN(t3.x)) {
      return val;
    }
    t3.x = tb.x - t3.x;
    t3.y = tb.y - t3.y;
    var i2 = 9, tol = 1e-12;
    var dif, del2;
    do {
      del2 = nadInterpolate(t3, ct2);
      if (isNaN(del2.x)) {
        console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
        break;
      }
      dif = { x: tb.x - (del2.x + t3.x), y: tb.y - (del2.y + t3.y) };
      t3.x += dif.x;
      t3.y += dif.y;
    } while (i2-- && Math.abs(dif.x) > tol && Math.abs(dif.y) > tol);
    if (i2 < 0) {
      console.log("Inverse grid shift iterator failed to converge.");
      return val;
    }
    val.x = adjust_lon(t3.x + ct2.ll[0]);
    val.y = t3.y + ct2.ll[1];
  } else {
    if (!isNaN(t3.x)) {
      val.x = pin.x + t3.x;
      val.y = pin.y + t3.y;
    }
  }
  return val;
}
function nadInterpolate(pin, ct2) {
  var t3 = { x: pin.x / ct2.del[0], y: pin.y / ct2.del[1] };
  var indx = { x: Math.floor(t3.x), y: Math.floor(t3.y) };
  var frct = { x: t3.x - 1 * indx.x, y: t3.y - 1 * indx.y };
  var val = { x: Number.NaN, y: Number.NaN };
  var inx;
  if (indx.x < 0 || indx.x >= ct2.lim[0]) {
    return val;
  }
  if (indx.y < 0 || indx.y >= ct2.lim[1]) {
    return val;
  }
  inx = indx.y * ct2.lim[0] + indx.x;
  var f00 = { x: ct2.cvs[inx][0], y: ct2.cvs[inx][1] };
  inx++;
  var f10 = { x: ct2.cvs[inx][0], y: ct2.cvs[inx][1] };
  inx += ct2.lim[0];
  var f11 = { x: ct2.cvs[inx][0], y: ct2.cvs[inx][1] };
  inx--;
  var f01 = { x: ct2.cvs[inx][0], y: ct2.cvs[inx][1] };
  var m11 = frct.x * frct.y, m10 = frct.x * (1 - frct.y), m00 = (1 - frct.x) * (1 - frct.y), m01 = (1 - frct.x) * frct.y;
  val.x = m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x;
  val.y = m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y;
  return val;
}
function adjust_axis(crs, denorm, point) {
  var xin = point.x, yin = point.y, zin = point.z || 0;
  var v2, t3, i2;
  var out = {};
  for (i2 = 0; i2 < 3; i2++) {
    if (denorm && i2 === 2 && point.z === void 0) {
      continue;
    }
    if (i2 === 0) {
      v2 = xin;
      if ("ew".indexOf(crs.axis[i2]) !== -1) {
        t3 = "x";
      } else {
        t3 = "y";
      }
    } else if (i2 === 1) {
      v2 = yin;
      if ("ns".indexOf(crs.axis[i2]) !== -1) {
        t3 = "y";
      } else {
        t3 = "x";
      }
    } else {
      v2 = zin;
      t3 = "z";
    }
    switch (crs.axis[i2]) {
      case "e":
        out[t3] = v2;
        break;
      case "w":
        out[t3] = -v2;
        break;
      case "n":
        out[t3] = v2;
        break;
      case "s":
        out[t3] = -v2;
        break;
      case "u":
        if (point[t3] !== void 0) {
          out.z = v2;
        }
        break;
      case "d":
        if (point[t3] !== void 0) {
          out.z = -v2;
        }
        break;
      default:
        return null;
    }
  }
  return out;
}
function common$1(array) {
  var out = {
    x: array[0],
    y: array[1]
  };
  if (array.length > 2) {
    out.z = array[2];
  }
  if (array.length > 3) {
    out.m = array[3];
  }
  return out;
}
function checkSanity(point) {
  checkCoord(point.x);
  checkCoord(point.y);
}
function checkCoord(num) {
  if (typeof Number.isFinite === "function") {
    if (Number.isFinite(num)) {
      return;
    }
    throw new TypeError("coordinates must be finite numbers");
  }
  if (typeof num !== "number" || num !== num || !isFinite(num)) {
    throw new TypeError("coordinates must be finite numbers");
  }
}
function checkNotWGS(source, dest) {
  return (source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== "WGS84" || (dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM) && source.datumCode !== "WGS84";
}
function transform$2(source, dest, point, enforceAxis) {
  var wgs842;
  if (Array.isArray(point)) {
    point = common$1(point);
  }
  checkSanity(point);
  if (source.datum && dest.datum && checkNotWGS(source, dest)) {
    wgs842 = new Projection$1("WGS84");
    point = transform$2(source, wgs842, point, enforceAxis);
    source = wgs842;
  }
  if (enforceAxis && source.axis !== "enu") {
    point = adjust_axis(source, false, point);
  }
  if (source.projName === "longlat") {
    point = {
      x: point.x * D2R$1,
      y: point.y * D2R$1,
      z: point.z || 0
    };
  } else {
    if (source.to_meter) {
      point = {
        x: point.x * source.to_meter,
        y: point.y * source.to_meter,
        z: point.z || 0
      };
    }
    point = source.inverse(point);
    if (!point) {
      return;
    }
  }
  if (source.from_greenwich) {
    point.x += source.from_greenwich;
  }
  point = datum_transform(source.datum, dest.datum, point);
  if (!point) {
    return;
  }
  if (dest.from_greenwich) {
    point = {
      x: point.x - dest.from_greenwich,
      y: point.y,
      z: point.z || 0
    };
  }
  if (dest.projName === "longlat") {
    point = {
      x: point.x * R2D,
      y: point.y * R2D,
      z: point.z || 0
    };
  } else {
    point = dest.forward(point);
    if (dest.to_meter) {
      point = {
        x: point.x / dest.to_meter,
        y: point.y / dest.to_meter,
        z: point.z || 0
      };
    }
  }
  if (enforceAxis && dest.axis !== "enu") {
    return adjust_axis(dest, true, point);
  }
  return point;
}
var wgs84 = Projection$1("WGS84");
function transformer(from, to, coords, enforceAxis) {
  var transformedArray, out, keys3;
  if (Array.isArray(coords)) {
    transformedArray = transform$2(from, to, coords, enforceAxis) || { x: NaN, y: NaN };
    if (coords.length > 2) {
      if (typeof from.name !== "undefined" && from.name === "geocent" || typeof to.name !== "undefined" && to.name === "geocent") {
        if (typeof transformedArray.z === "number") {
          return [transformedArray.x, transformedArray.y, transformedArray.z].concat(coords.splice(3));
        } else {
          return [transformedArray.x, transformedArray.y, coords[2]].concat(coords.splice(3));
        }
      } else {
        return [transformedArray.x, transformedArray.y].concat(coords.splice(2));
      }
    } else {
      return [transformedArray.x, transformedArray.y];
    }
  } else {
    out = transform$2(from, to, coords, enforceAxis);
    keys3 = Object.keys(coords);
    if (keys3.length === 2) {
      return out;
    }
    keys3.forEach(function(key) {
      if (typeof from.name !== "undefined" && from.name === "geocent" || typeof to.name !== "undefined" && to.name === "geocent") {
        if (key === "x" || key === "y" || key === "z") {
          return;
        }
      } else {
        if (key === "x" || key === "y") {
          return;
        }
      }
      out[key] = coords[key];
    });
    return out;
  }
}
function checkProj(item) {
  if (item instanceof Projection$1) {
    return item;
  }
  if (item.oProj) {
    return item.oProj;
  }
  return Projection$1(item);
}
function proj4(fromProj, toProj, coord) {
  fromProj = checkProj(fromProj);
  var single = false;
  var obj;
  if (typeof toProj === "undefined") {
    toProj = fromProj;
    fromProj = wgs84;
    single = true;
  } else if (typeof toProj.x !== "undefined" || Array.isArray(toProj)) {
    coord = toProj;
    toProj = fromProj;
    fromProj = wgs84;
    single = true;
  }
  toProj = checkProj(toProj);
  if (coord) {
    return transformer(fromProj, toProj, coord);
  } else {
    obj = {
      forward: function(coords, enforceAxis) {
        return transformer(fromProj, toProj, coords, enforceAxis);
      },
      inverse: function(coords, enforceAxis) {
        return transformer(toProj, fromProj, coords, enforceAxis);
      }
    };
    if (single) {
      obj.oProj = toProj;
    }
    return obj;
  }
}
var NUM_100K_SETS = 6;
var SET_ORIGIN_COLUMN_LETTERS = "AJSAJS";
var SET_ORIGIN_ROW_LETTERS = "AFAFAF";
var A$2 = 65;
var I$1 = 73;
var O$2 = 79;
var V$2 = 86;
var Z$3 = 90;
var mgrs = {
  forward: forward$s,
  inverse: inverse$s,
  toPoint
};
function forward$s(ll, accuracy) {
  accuracy = accuracy || 5;
  return encode$1(LLtoUTM({
    lat: ll[1],
    lon: ll[0]
  }), accuracy);
}
function inverse$s(mgrs2) {
  var bbox2 = UTMtoLL(decode$2(mgrs2.toUpperCase()));
  if (bbox2.lat && bbox2.lon) {
    return [bbox2.lon, bbox2.lat, bbox2.lon, bbox2.lat];
  }
  return [bbox2.left, bbox2.bottom, bbox2.right, bbox2.top];
}
function toPoint(mgrs2) {
  var bbox2 = UTMtoLL(decode$2(mgrs2.toUpperCase()));
  if (bbox2.lat && bbox2.lon) {
    return [bbox2.lon, bbox2.lat];
  }
  return [(bbox2.left + bbox2.right) / 2, (bbox2.top + bbox2.bottom) / 2];
}
function degToRad(deg2) {
  return deg2 * (Math.PI / 180);
}
function radToDeg(rad) {
  return 180 * (rad / Math.PI);
}
function LLtoUTM(ll) {
  var Lat = ll.lat;
  var Long = ll.lon;
  var a2 = 6378137;
  var eccSquared = 669438e-8;
  var k0 = 0.9996;
  var LongOrigin;
  var eccPrimeSquared;
  var N2, T2, C2, A2, M2;
  var LatRad = degToRad(Lat);
  var LongRad = degToRad(Long);
  var LongOriginRad;
  var ZoneNumber;
  ZoneNumber = Math.floor((Long + 180) / 6) + 1;
  if (Long === 180) {
    ZoneNumber = 60;
  }
  if (Lat >= 56 && Lat < 64 && Long >= 3 && Long < 12) {
    ZoneNumber = 32;
  }
  if (Lat >= 72 && Lat < 84) {
    if (Long >= 0 && Long < 9) {
      ZoneNumber = 31;
    } else if (Long >= 9 && Long < 21) {
      ZoneNumber = 33;
    } else if (Long >= 21 && Long < 33) {
      ZoneNumber = 35;
    } else if (Long >= 33 && Long < 42) {
      ZoneNumber = 37;
    }
  }
  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3;
  LongOriginRad = degToRad(LongOrigin);
  eccPrimeSquared = eccSquared / (1 - eccSquared);
  N2 = a2 / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
  T2 = Math.tan(LatRad) * Math.tan(LatRad);
  C2 = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
  A2 = Math.cos(LatRad) * (LongRad - LongOriginRad);
  M2 = a2 * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - 35 * eccSquared * eccSquared * eccSquared / 3072 * Math.sin(6 * LatRad));
  var UTMEasting = k0 * N2 * (A2 + (1 - T2 + C2) * A2 * A2 * A2 / 6 + (5 - 18 * T2 + T2 * T2 + 72 * C2 - 58 * eccPrimeSquared) * A2 * A2 * A2 * A2 * A2 / 120) + 5e5;
  var UTMNorthing = k0 * (M2 + N2 * Math.tan(LatRad) * (A2 * A2 / 2 + (5 - T2 + 9 * C2 + 4 * C2 * C2) * A2 * A2 * A2 * A2 / 24 + (61 - 58 * T2 + T2 * T2 + 600 * C2 - 330 * eccPrimeSquared) * A2 * A2 * A2 * A2 * A2 * A2 / 720));
  if (Lat < 0) {
    UTMNorthing += 1e7;
  }
  return {
    northing: Math.round(UTMNorthing),
    easting: Math.round(UTMEasting),
    zoneNumber: ZoneNumber,
    zoneLetter: getLetterDesignator(Lat)
  };
}
function UTMtoLL(utm2) {
  var UTMNorthing = utm2.northing;
  var UTMEasting = utm2.easting;
  var zoneLetter = utm2.zoneLetter;
  var zoneNumber = utm2.zoneNumber;
  if (zoneNumber < 0 || zoneNumber > 60) {
    return null;
  }
  var k0 = 0.9996;
  var a2 = 6378137;
  var eccSquared = 669438e-8;
  var eccPrimeSquared;
  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
  var N1, T1, C12, R1, D2, M2;
  var LongOrigin;
  var mu, phi1Rad;
  var x2 = UTMEasting - 5e5;
  var y2 = UTMNorthing;
  if (zoneLetter < "N") {
    y2 -= 1e7;
  }
  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3;
  eccPrimeSquared = eccSquared / (1 - eccSquared);
  M2 = y2 / k0;
  mu = M2 / (a2 * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));
  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + 151 * e1 * e1 * e1 / 96 * Math.sin(6 * mu);
  N1 = a2 / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
  C12 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
  R1 = a2 * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
  D2 = x2 / (N1 * k0);
  var lat = phi1Rad - N1 * Math.tan(phi1Rad) / R1 * (D2 * D2 / 2 - (5 + 3 * T1 + 10 * C12 - 4 * C12 * C12 - 9 * eccPrimeSquared) * D2 * D2 * D2 * D2 / 24 + (61 + 90 * T1 + 298 * C12 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C12 * C12) * D2 * D2 * D2 * D2 * D2 * D2 / 720);
  lat = radToDeg(lat);
  var lon = (D2 - (1 + 2 * T1 + C12) * D2 * D2 * D2 / 6 + (5 - 2 * C12 + 28 * T1 - 3 * C12 * C12 + 8 * eccPrimeSquared + 24 * T1 * T1) * D2 * D2 * D2 * D2 * D2 / 120) / Math.cos(phi1Rad);
  lon = LongOrigin + radToDeg(lon);
  var result;
  if (utm2.accuracy) {
    var topRight = UTMtoLL({
      northing: utm2.northing + utm2.accuracy,
      easting: utm2.easting + utm2.accuracy,
      zoneLetter: utm2.zoneLetter,
      zoneNumber: utm2.zoneNumber
    });
    result = {
      top: topRight.lat,
      right: topRight.lon,
      bottom: lat,
      left: lon
    };
  } else {
    result = {
      lat,
      lon
    };
  }
  return result;
}
function getLetterDesignator(lat) {
  var LetterDesignator = "Z";
  if (84 >= lat && lat >= 72) {
    LetterDesignator = "X";
  } else if (72 > lat && lat >= 64) {
    LetterDesignator = "W";
  } else if (64 > lat && lat >= 56) {
    LetterDesignator = "V";
  } else if (56 > lat && lat >= 48) {
    LetterDesignator = "U";
  } else if (48 > lat && lat >= 40) {
    LetterDesignator = "T";
  } else if (40 > lat && lat >= 32) {
    LetterDesignator = "S";
  } else if (32 > lat && lat >= 24) {
    LetterDesignator = "R";
  } else if (24 > lat && lat >= 16) {
    LetterDesignator = "Q";
  } else if (16 > lat && lat >= 8) {
    LetterDesignator = "P";
  } else if (8 > lat && lat >= 0) {
    LetterDesignator = "N";
  } else if (0 > lat && lat >= -8) {
    LetterDesignator = "M";
  } else if (-8 > lat && lat >= -16) {
    LetterDesignator = "L";
  } else if (-16 > lat && lat >= -24) {
    LetterDesignator = "K";
  } else if (-24 > lat && lat >= -32) {
    LetterDesignator = "J";
  } else if (-32 > lat && lat >= -40) {
    LetterDesignator = "H";
  } else if (-40 > lat && lat >= -48) {
    LetterDesignator = "G";
  } else if (-48 > lat && lat >= -56) {
    LetterDesignator = "F";
  } else if (-56 > lat && lat >= -64) {
    LetterDesignator = "E";
  } else if (-64 > lat && lat >= -72) {
    LetterDesignator = "D";
  } else if (-72 > lat && lat >= -80) {
    LetterDesignator = "C";
  }
  return LetterDesignator;
}
function encode$1(utm2, accuracy) {
  var seasting = "00000" + utm2.easting, snorthing = "00000" + utm2.northing;
  return utm2.zoneNumber + utm2.zoneLetter + get100kID(utm2.easting, utm2.northing, utm2.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
}
function get100kID(easting, northing, zoneNumber) {
  var setParm = get100kSetForZone(zoneNumber);
  var setColumn = Math.floor(easting / 1e5);
  var setRow = Math.floor(northing / 1e5) % 20;
  return getLetter100kID(setColumn, setRow, setParm);
}
function get100kSetForZone(i2) {
  var setParm = i2 % NUM_100K_SETS;
  if (setParm === 0) {
    setParm = NUM_100K_SETS;
  }
  return setParm;
}
function getLetter100kID(column, row, parm) {
  var index2 = parm - 1;
  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index2);
  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index2);
  var colInt = colOrigin + column - 1;
  var rowInt = rowOrigin + row;
  var rollover = false;
  if (colInt > Z$3) {
    colInt = colInt - Z$3 + A$2 - 1;
    rollover = true;
  }
  if (colInt === I$1 || colOrigin < I$1 && colInt > I$1 || (colInt > I$1 || colOrigin < I$1) && rollover) {
    colInt++;
  }
  if (colInt === O$2 || colOrigin < O$2 && colInt > O$2 || (colInt > O$2 || colOrigin < O$2) && rollover) {
    colInt++;
    if (colInt === I$1) {
      colInt++;
    }
  }
  if (colInt > Z$3) {
    colInt = colInt - Z$3 + A$2 - 1;
  }
  if (rowInt > V$2) {
    rowInt = rowInt - V$2 + A$2 - 1;
    rollover = true;
  } else {
    rollover = false;
  }
  if (rowInt === I$1 || rowOrigin < I$1 && rowInt > I$1 || (rowInt > I$1 || rowOrigin < I$1) && rollover) {
    rowInt++;
  }
  if (rowInt === O$2 || rowOrigin < O$2 && rowInt > O$2 || (rowInt > O$2 || rowOrigin < O$2) && rollover) {
    rowInt++;
    if (rowInt === I$1) {
      rowInt++;
    }
  }
  if (rowInt > V$2) {
    rowInt = rowInt - V$2 + A$2 - 1;
  }
  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
  return twoLetter;
}
function decode$2(mgrsString) {
  if (mgrsString && mgrsString.length === 0) {
    throw "MGRSPoint coverting from nothing";
  }
  var length = mgrsString.length;
  var hunK = null;
  var sb = "";
  var testChar;
  var i2 = 0;
  while (!/[A-Z]/.test(testChar = mgrsString.charAt(i2))) {
    if (i2 >= 2) {
      throw "MGRSPoint bad conversion from: " + mgrsString;
    }
    sb += testChar;
    i2++;
  }
  var zoneNumber = parseInt(sb, 10);
  if (i2 === 0 || i2 + 3 > length) {
    throw "MGRSPoint bad conversion from: " + mgrsString;
  }
  var zoneLetter = mgrsString.charAt(i2++);
  if (zoneLetter <= "A" || zoneLetter === "B" || zoneLetter === "Y" || zoneLetter >= "Z" || zoneLetter === "I" || zoneLetter === "O") {
    throw "MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString;
  }
  hunK = mgrsString.substring(i2, i2 += 2);
  var set2 = get100kSetForZone(zoneNumber);
  var east100k = getEastingFromChar(hunK.charAt(0), set2);
  var north100k = getNorthingFromChar(hunK.charAt(1), set2);
  while (north100k < getMinNorthing(zoneLetter)) {
    north100k += 2e6;
  }
  var remainder = length - i2;
  if (remainder % 2 !== 0) {
    throw "MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString;
  }
  var sep = remainder / 2;
  var sepEasting = 0;
  var sepNorthing = 0;
  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
  if (sep > 0) {
    accuracyBonus = 1e5 / Math.pow(10, sep);
    sepEastingString = mgrsString.substring(i2, i2 + sep);
    sepEasting = parseFloat(sepEastingString) * accuracyBonus;
    sepNorthingString = mgrsString.substring(i2 + sep);
    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
  }
  easting = sepEasting + east100k;
  northing = sepNorthing + north100k;
  return {
    easting,
    northing,
    zoneLetter,
    zoneNumber,
    accuracy: accuracyBonus
  };
}
function getEastingFromChar(e2, set2) {
  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set2 - 1);
  var eastingValue = 1e5;
  var rewindMarker = false;
  while (curCol !== e2.charCodeAt(0)) {
    curCol++;
    if (curCol === I$1) {
      curCol++;
    }
    if (curCol === O$2) {
      curCol++;
    }
    if (curCol > Z$3) {
      if (rewindMarker) {
        throw "Bad character: " + e2;
      }
      curCol = A$2;
      rewindMarker = true;
    }
    eastingValue += 1e5;
  }
  return eastingValue;
}
function getNorthingFromChar(n2, set2) {
  if (n2 > "V") {
    throw "MGRSPoint given invalid Northing " + n2;
  }
  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set2 - 1);
  var northingValue = 0;
  var rewindMarker = false;
  while (curRow !== n2.charCodeAt(0)) {
    curRow++;
    if (curRow === I$1) {
      curRow++;
    }
    if (curRow === O$2) {
      curRow++;
    }
    if (curRow > V$2) {
      if (rewindMarker) {
        throw "Bad character: " + n2;
      }
      curRow = A$2;
      rewindMarker = true;
    }
    northingValue += 1e5;
  }
  return northingValue;
}
function getMinNorthing(zoneLetter) {
  var northing;
  switch (zoneLetter) {
    case "C":
      northing = 11e5;
      break;
    case "D":
      northing = 2e6;
      break;
    case "E":
      northing = 28e5;
      break;
    case "F":
      northing = 37e5;
      break;
    case "G":
      northing = 46e5;
      break;
    case "H":
      northing = 55e5;
      break;
    case "J":
      northing = 64e5;
      break;
    case "K":
      northing = 73e5;
      break;
    case "L":
      northing = 82e5;
      break;
    case "M":
      northing = 91e5;
      break;
    case "N":
      northing = 0;
      break;
    case "P":
      northing = 8e5;
      break;
    case "Q":
      northing = 17e5;
      break;
    case "R":
      northing = 26e5;
      break;
    case "S":
      northing = 35e5;
      break;
    case "T":
      northing = 44e5;
      break;
    case "U":
      northing = 53e5;
      break;
    case "V":
      northing = 62e5;
      break;
    case "W":
      northing = 7e6;
      break;
    case "X":
      northing = 79e5;
      break;
    default:
      northing = -1;
  }
  if (northing >= 0) {
    return northing;
  } else {
    throw "Invalid zone letter: " + zoneLetter;
  }
}
function Point$2(x2, y2, z2) {
  if (!(this instanceof Point$2)) {
    return new Point$2(x2, y2, z2);
  }
  if (Array.isArray(x2)) {
    this.x = x2[0];
    this.y = x2[1];
    this.z = x2[2] || 0;
  } else if (typeof x2 === "object") {
    this.x = x2.x;
    this.y = x2.y;
    this.z = x2.z || 0;
  } else if (typeof x2 === "string" && typeof y2 === "undefined") {
    var coords = x2.split(",");
    this.x = parseFloat(coords[0], 10);
    this.y = parseFloat(coords[1], 10);
    this.z = parseFloat(coords[2], 10) || 0;
  } else {
    this.x = x2;
    this.y = y2;
    this.z = z2 || 0;
  }
  console.warn("proj4.Point will be removed in version 3, use proj4.toPoint");
}
Point$2.fromMGRS = function(mgrsStr) {
  return new Point$2(toPoint(mgrsStr));
};
Point$2.prototype.toMGRS = function(accuracy) {
  return forward$s([this.x, this.y], accuracy);
};
var C00 = 1;
var C02 = 0.25;
var C04 = 0.046875;
var C06 = 0.01953125;
var C08 = 0.01068115234375;
var C22 = 0.75;
var C44 = 0.46875;
var C46 = 0.013020833333333334;
var C48 = 0.007120768229166667;
var C66 = 0.3645833333333333;
var C68 = 0.005696614583333333;
var C88 = 0.3076171875;
function pj_enfn(es) {
  var en = [];
  en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
  en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
  var t3 = es * es;
  en[2] = t3 * (C44 - es * (C46 + es * C48));
  t3 *= es;
  en[3] = t3 * (C66 - es * C68);
  en[4] = t3 * es * C88;
  return en;
}
function pj_mlfn(phi, sphi, cphi, en) {
  cphi *= sphi;
  sphi *= sphi;
  return en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4])));
}
var MAX_ITER$3 = 20;
function pj_inv_mlfn(arg, es, en) {
  var k2 = 1 / (1 - es);
  var phi = arg;
  for (var i2 = MAX_ITER$3; i2; --i2) {
    var s2 = Math.sin(phi);
    var t3 = 1 - es * s2 * s2;
    t3 = (pj_mlfn(phi, s2, Math.cos(phi), en) - arg) * (t3 * Math.sqrt(t3)) * k2;
    phi -= t3;
    if (Math.abs(t3) < EPSLN) {
      return phi;
    }
  }
  return phi;
}
function init$s() {
  this.x0 = this.x0 !== void 0 ? this.x0 : 0;
  this.y0 = this.y0 !== void 0 ? this.y0 : 0;
  this.long0 = this.long0 !== void 0 ? this.long0 : 0;
  this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0;
  if (this.es) {
    this.en = pj_enfn(this.es);
    this.ml0 = pj_mlfn(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);
  }
}
function forward$r(p5) {
  var lon = p5.x;
  var lat = p5.y;
  var delta_lon = adjust_lon(lon - this.long0);
  var con;
  var x2, y2;
  var sin_phi = Math.sin(lat);
  var cos_phi = Math.cos(lat);
  if (!this.es) {
    var b2 = cos_phi * Math.sin(delta_lon);
    if (Math.abs(Math.abs(b2) - 1) < EPSLN) {
      return 93;
    } else {
      x2 = 0.5 * this.a * this.k0 * Math.log((1 + b2) / (1 - b2)) + this.x0;
      y2 = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b2, 2));
      b2 = Math.abs(y2);
      if (b2 >= 1) {
        if (b2 - 1 > EPSLN) {
          return 93;
        } else {
          y2 = 0;
        }
      } else {
        y2 = Math.acos(y2);
      }
      if (lat < 0) {
        y2 = -y2;
      }
      y2 = this.a * this.k0 * (y2 - this.lat0) + this.y0;
    }
  } else {
    var al = cos_phi * delta_lon;
    var als = Math.pow(al, 2);
    var c2 = this.ep2 * Math.pow(cos_phi, 2);
    var cs = Math.pow(c2, 2);
    var tq = Math.abs(cos_phi) > EPSLN ? Math.tan(lat) : 0;
    var t3 = Math.pow(tq, 2);
    var ts = Math.pow(t3, 2);
    con = 1 - this.es * Math.pow(sin_phi, 2);
    al = al / Math.sqrt(con);
    var ml = pj_mlfn(lat, sin_phi, cos_phi, this.en);
    x2 = this.a * (this.k0 * al * (1 + als / 6 * (1 - t3 + c2 + als / 20 * (5 - 18 * t3 + ts + 14 * c2 - 58 * t3 * c2 + als / 42 * (61 + 179 * ts - ts * t3 - 479 * t3))))) + this.x0;
    y2 = this.a * (this.k0 * (ml - this.ml0 + sin_phi * delta_lon * al / 2 * (1 + als / 12 * (5 - t3 + 9 * c2 + 4 * cs + als / 30 * (61 + ts - 58 * t3 + 270 * c2 - 330 * t3 * c2 + als / 56 * (1385 + 543 * ts - ts * t3 - 3111 * t3)))))) + this.y0;
  }
  p5.x = x2;
  p5.y = y2;
  return p5;
}
function inverse$r(p5) {
  var con, phi;
  var lat, lon;
  var x2 = (p5.x - this.x0) * (1 / this.a);
  var y2 = (p5.y - this.y0) * (1 / this.a);
  if (!this.es) {
    var f2 = Math.exp(x2 / this.k0);
    var g2 = 0.5 * (f2 - 1 / f2);
    var temp = this.lat0 + y2 / this.k0;
    var h2 = Math.cos(temp);
    con = Math.sqrt((1 - Math.pow(h2, 2)) / (1 + Math.pow(g2, 2)));
    lat = Math.asin(con);
    if (y2 < 0) {
      lat = -lat;
    }
    if (g2 === 0 && h2 === 0) {
      lon = 0;
    } else {
      lon = adjust_lon(Math.atan2(g2, h2) + this.long0);
    }
  } else {
    con = this.ml0 + y2 / this.k0;
    phi = pj_inv_mlfn(con, this.es, this.en);
    if (Math.abs(phi) < HALF_PI) {
      var sin_phi = Math.sin(phi);
      var cos_phi = Math.cos(phi);
      var tan_phi = Math.abs(cos_phi) > EPSLN ? Math.tan(phi) : 0;
      var c2 = this.ep2 * Math.pow(cos_phi, 2);
      var cs = Math.pow(c2, 2);
      var t3 = Math.pow(tan_phi, 2);
      var ts = Math.pow(t3, 2);
      con = 1 - this.es * Math.pow(sin_phi, 2);
      var d2 = x2 * Math.sqrt(con) / this.k0;
      var ds = Math.pow(d2, 2);
      con = con * tan_phi;
      lat = phi - con * ds / (1 - this.es) * 0.5 * (1 - ds / 12 * (5 + 3 * t3 - 9 * c2 * t3 + c2 - 4 * cs - ds / 30 * (61 + 90 * t3 - 252 * c2 * t3 + 45 * ts + 46 * c2 - ds / 56 * (1385 + 3633 * t3 + 4095 * ts + 1574 * ts * t3))));
      lon = adjust_lon(this.long0 + d2 * (1 - ds / 6 * (1 + 2 * t3 + c2 - ds / 20 * (5 + 28 * t3 + 24 * ts + 8 * c2 * t3 + 6 * c2 - ds / 42 * (61 + 662 * t3 + 1320 * ts + 720 * ts * t3)))) / cos_phi);
    } else {
      lat = HALF_PI * sign$1(y2);
      lon = 0;
    }
  }
  p5.x = lon;
  p5.y = lat;
  return p5;
}
var names$s = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
var tmerc = {
  init: init$s,
  forward: forward$r,
  inverse: inverse$r,
  names: names$s
};
function sinh(x2) {
  var r2 = Math.exp(x2);
  r2 = (r2 - 1 / r2) / 2;
  return r2;
}
function hypot(x2, y2) {
  x2 = Math.abs(x2);
  y2 = Math.abs(y2);
  var a2 = Math.max(x2, y2);
  var b2 = Math.min(x2, y2) / (a2 ? a2 : 1);
  return a2 * Math.sqrt(1 + Math.pow(b2, 2));
}
function log1py(x2) {
  var y2 = 1 + x2;
  var z2 = y2 - 1;
  return z2 === 0 ? x2 : x2 * Math.log(y2) / z2;
}
function asinhy(x2) {
  var y2 = Math.abs(x2);
  y2 = log1py(y2 * (1 + y2 / (hypot(1, y2) + 1)));
  return x2 < 0 ? -y2 : y2;
}
function gatg(pp, B3) {
  var cos_2B = 2 * Math.cos(2 * B3);
  var i2 = pp.length - 1;
  var h1 = pp[i2];
  var h2 = 0;
  var h3;
  while (--i2 >= 0) {
    h3 = -h2 + cos_2B * h1 + pp[i2];
    h2 = h1;
    h1 = h3;
  }
  return B3 + h3 * Math.sin(2 * B3);
}
function clens(pp, arg_r) {
  var r2 = 2 * Math.cos(arg_r);
  var i2 = pp.length - 1;
  var hr1 = pp[i2];
  var hr2 = 0;
  var hr;
  while (--i2 >= 0) {
    hr = -hr2 + r2 * hr1 + pp[i2];
    hr2 = hr1;
    hr1 = hr;
  }
  return Math.sin(arg_r) * hr;
}
function cosh(x2) {
  var r2 = Math.exp(x2);
  r2 = (r2 + 1 / r2) / 2;
  return r2;
}
function clens_cmplx(pp, arg_r, arg_i) {
  var sin_arg_r = Math.sin(arg_r);
  var cos_arg_r = Math.cos(arg_r);
  var sinh_arg_i = sinh(arg_i);
  var cosh_arg_i = cosh(arg_i);
  var r2 = 2 * cos_arg_r * cosh_arg_i;
  var i2 = -2 * sin_arg_r * sinh_arg_i;
  var j2 = pp.length - 1;
  var hr = pp[j2];
  var hi1 = 0;
  var hr1 = 0;
  var hi = 0;
  var hr2;
  var hi2;
  while (--j2 >= 0) {
    hr2 = hr1;
    hi2 = hi1;
    hr1 = hr;
    hi1 = hi;
    hr = -hr2 + r2 * hr1 - i2 * hi1 + pp[j2];
    hi = -hi2 + i2 * hr1 + r2 * hi1;
  }
  r2 = sin_arg_r * cosh_arg_i;
  i2 = cos_arg_r * sinh_arg_i;
  return [r2 * hr - i2 * hi, r2 * hi + i2 * hr];
}
function init$r() {
  if (!this.approx && (isNaN(this.es) || this.es <= 0)) {
    throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
  }
  if (this.approx) {
    tmerc.init.apply(this);
    this.forward = tmerc.forward;
    this.inverse = tmerc.inverse;
  }
  this.x0 = this.x0 !== void 0 ? this.x0 : 0;
  this.y0 = this.y0 !== void 0 ? this.y0 : 0;
  this.long0 = this.long0 !== void 0 ? this.long0 : 0;
  this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0;
  this.cgb = [];
  this.cbg = [];
  this.utg = [];
  this.gtu = [];
  var f2 = this.es / (1 + Math.sqrt(1 - this.es));
  var n2 = f2 / (2 - f2);
  var np = n2;
  this.cgb[0] = n2 * (2 + n2 * (-2 / 3 + n2 * (-2 + n2 * (116 / 45 + n2 * (26 / 45 + n2 * (-2854 / 675))))));
  this.cbg[0] = n2 * (-2 + n2 * (2 / 3 + n2 * (4 / 3 + n2 * (-82 / 45 + n2 * (32 / 45 + n2 * (4642 / 4725))))));
  np = np * n2;
  this.cgb[1] = np * (7 / 3 + n2 * (-8 / 5 + n2 * (-227 / 45 + n2 * (2704 / 315 + n2 * (2323 / 945)))));
  this.cbg[1] = np * (5 / 3 + n2 * (-16 / 15 + n2 * (-13 / 9 + n2 * (904 / 315 + n2 * (-1522 / 945)))));
  np = np * n2;
  this.cgb[2] = np * (56 / 15 + n2 * (-136 / 35 + n2 * (-1262 / 105 + n2 * (73814 / 2835))));
  this.cbg[2] = np * (-26 / 15 + n2 * (34 / 21 + n2 * (8 / 5 + n2 * (-12686 / 2835))));
  np = np * n2;
  this.cgb[3] = np * (4279 / 630 + n2 * (-332 / 35 + n2 * (-399572 / 14175)));
  this.cbg[3] = np * (1237 / 630 + n2 * (-12 / 5 + n2 * (-24832 / 14175)));
  np = np * n2;
  this.cgb[4] = np * (4174 / 315 + n2 * (-144838 / 6237));
  this.cbg[4] = np * (-734 / 315 + n2 * (109598 / 31185));
  np = np * n2;
  this.cgb[5] = np * (601676 / 22275);
  this.cbg[5] = np * (444337 / 155925);
  np = Math.pow(n2, 2);
  this.Qn = this.k0 / (1 + n2) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));
  this.utg[0] = n2 * (-0.5 + n2 * (2 / 3 + n2 * (-37 / 96 + n2 * (1 / 360 + n2 * (81 / 512 + n2 * (-96199 / 604800))))));
  this.gtu[0] = n2 * (0.5 + n2 * (-2 / 3 + n2 * (5 / 16 + n2 * (41 / 180 + n2 * (-127 / 288 + n2 * (7891 / 37800))))));
  this.utg[1] = np * (-1 / 48 + n2 * (-1 / 15 + n2 * (437 / 1440 + n2 * (-46 / 105 + n2 * (1118711 / 3870720)))));
  this.gtu[1] = np * (13 / 48 + n2 * (-3 / 5 + n2 * (557 / 1440 + n2 * (281 / 630 + n2 * (-1983433 / 1935360)))));
  np = np * n2;
  this.utg[2] = np * (-17 / 480 + n2 * (37 / 840 + n2 * (209 / 4480 + n2 * (-5569 / 90720))));
  this.gtu[2] = np * (61 / 240 + n2 * (-103 / 140 + n2 * (15061 / 26880 + n2 * (167603 / 181440))));
  np = np * n2;
  this.utg[3] = np * (-4397 / 161280 + n2 * (11 / 504 + n2 * (830251 / 7257600)));
  this.gtu[3] = np * (49561 / 161280 + n2 * (-179 / 168 + n2 * (6601661 / 7257600)));
  np = np * n2;
  this.utg[4] = np * (-4583 / 161280 + n2 * (108847 / 3991680));
  this.gtu[4] = np * (34729 / 80640 + n2 * (-3418889 / 1995840));
  np = np * n2;
  this.utg[5] = np * (-20648693 / 638668800);
  this.gtu[5] = np * (212378941 / 319334400);
  var Z2 = gatg(this.cbg, this.lat0);
  this.Zb = -this.Qn * (Z2 + clens(this.gtu, 2 * Z2));
}
function forward$q(p5) {
  var Ce = adjust_lon(p5.x - this.long0);
  var Cn = p5.y;
  Cn = gatg(this.cbg, Cn);
  var sin_Cn = Math.sin(Cn);
  var cos_Cn = Math.cos(Cn);
  var sin_Ce = Math.sin(Ce);
  var cos_Ce = Math.cos(Ce);
  Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);
  Ce = Math.atan2(sin_Ce * cos_Cn, hypot(sin_Cn, cos_Cn * cos_Ce));
  Ce = asinhy(Math.tan(Ce));
  var tmp = clens_cmplx(this.gtu, 2 * Cn, 2 * Ce);
  Cn = Cn + tmp[0];
  Ce = Ce + tmp[1];
  var x2;
  var y2;
  if (Math.abs(Ce) <= 2.623395162778) {
    x2 = this.a * (this.Qn * Ce) + this.x0;
    y2 = this.a * (this.Qn * Cn + this.Zb) + this.y0;
  } else {
    x2 = Infinity;
    y2 = Infinity;
  }
  p5.x = x2;
  p5.y = y2;
  return p5;
}
function inverse$q(p5) {
  var Ce = (p5.x - this.x0) * (1 / this.a);
  var Cn = (p5.y - this.y0) * (1 / this.a);
  Cn = (Cn - this.Zb) / this.Qn;
  Ce = Ce / this.Qn;
  var lon;
  var lat;
  if (Math.abs(Ce) <= 2.623395162778) {
    var tmp = clens_cmplx(this.utg, 2 * Cn, 2 * Ce);
    Cn = Cn + tmp[0];
    Ce = Ce + tmp[1];
    Ce = Math.atan(sinh(Ce));
    var sin_Cn = Math.sin(Cn);
    var cos_Cn = Math.cos(Cn);
    var sin_Ce = Math.sin(Ce);
    var cos_Ce = Math.cos(Ce);
    Cn = Math.atan2(sin_Cn * cos_Ce, hypot(sin_Ce, cos_Ce * cos_Cn));
    Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);
    lon = adjust_lon(Ce + this.long0);
    lat = gatg(this.cgb, Cn);
  } else {
    lon = Infinity;
    lat = Infinity;
  }
  p5.x = lon;
  p5.y = lat;
  return p5;
}
var names$r = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "tmerc"];
var etmerc = {
  init: init$r,
  forward: forward$q,
  inverse: inverse$q,
  names: names$r
};
function adjust_zone(zone, lon) {
  if (zone === void 0) {
    zone = Math.floor((adjust_lon(lon) + Math.PI) * 30 / Math.PI) + 1;
    if (zone < 0) {
      return 0;
    } else if (zone > 60) {
      return 60;
    }
  }
  return zone;
}
var dependsOn = "etmerc";
function init$q() {
  var zone = adjust_zone(this.zone, this.long0);
  if (zone === void 0) {
    throw new Error("unknown utm zone");
  }
  this.lat0 = 0;
  this.long0 = (6 * Math.abs(zone) - 183) * D2R$1;
  this.x0 = 5e5;
  this.y0 = this.utmSouth ? 1e7 : 0;
  this.k0 = 0.9996;
  etmerc.init.apply(this);
  this.forward = etmerc.forward;
  this.inverse = etmerc.inverse;
}
var names$q = ["Universal Transverse Mercator System", "utm"];
var utm = {
  init: init$q,
  names: names$q,
  dependsOn
};
function srat(esinp, exp) {
  return Math.pow((1 - esinp) / (1 + esinp), exp);
}
var MAX_ITER$2 = 20;
function init$p() {
  var sphi = Math.sin(this.lat0);
  var cphi = Math.cos(this.lat0);
  cphi *= cphi;
  this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
  this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
  this.phic0 = Math.asin(sphi / this.C);
  this.ratexp = 0.5 * this.C * this.e;
  this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));
}
function forward$p(p5) {
  var lon = p5.x;
  var lat = p5.y;
  p5.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;
  p5.x = this.C * lon;
  return p5;
}
function inverse$p(p5) {
  var DEL_TOL = 1e-14;
  var lon = p5.x / this.C;
  var lat = p5.y;
  var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);
  for (var i2 = MAX_ITER$2; i2 > 0; --i2) {
    lat = 2 * Math.atan(num * srat(this.e * Math.sin(p5.y), -0.5 * this.e)) - HALF_PI;
    if (Math.abs(lat - p5.y) < DEL_TOL) {
      break;
    }
    p5.y = lat;
  }
  if (!i2) {
    return null;
  }
  p5.x = lon;
  p5.y = lat;
  return p5;
}
var names$p = ["gauss"];
var gauss = {
  init: init$p,
  forward: forward$p,
  inverse: inverse$p,
  names: names$p
};
function init$o() {
  gauss.init.apply(this);
  if (!this.rc) {
    return;
  }
  this.sinc0 = Math.sin(this.phic0);
  this.cosc0 = Math.cos(this.phic0);
  this.R2 = 2 * this.rc;
  if (!this.title) {
    this.title = "Oblique Stereographic Alternative";
  }
}
function forward$o(p5) {
  var sinc, cosc, cosl, k2;
  p5.x = adjust_lon(p5.x - this.long0);
  gauss.forward.apply(this, [p5]);
  sinc = Math.sin(p5.y);
  cosc = Math.cos(p5.y);
  cosl = Math.cos(p5.x);
  k2 = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
  p5.x = k2 * cosc * Math.sin(p5.x);
  p5.y = k2 * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
  p5.x = this.a * p5.x + this.x0;
  p5.y = this.a * p5.y + this.y0;
  return p5;
}
function inverse$o(p5) {
  var sinc, cosc, lon, lat, rho;
  p5.x = (p5.x - this.x0) / this.a;
  p5.y = (p5.y - this.y0) / this.a;
  p5.x /= this.k0;
  p5.y /= this.k0;
  if (rho = Math.sqrt(p5.x * p5.x + p5.y * p5.y)) {
    var c2 = 2 * Math.atan2(rho, this.R2);
    sinc = Math.sin(c2);
    cosc = Math.cos(c2);
    lat = Math.asin(cosc * this.sinc0 + p5.y * sinc * this.cosc0 / rho);
    lon = Math.atan2(p5.x * sinc, rho * this.cosc0 * cosc - p5.y * this.sinc0 * sinc);
  } else {
    lat = this.phic0;
    lon = 0;
  }
  p5.x = lon;
  p5.y = lat;
  gauss.inverse.apply(this, [p5]);
  p5.x = adjust_lon(p5.x + this.long0);
  return p5;
}
var names$o = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"];
var sterea = {
  init: init$o,
  forward: forward$o,
  inverse: inverse$o,
  names: names$o
};
function ssfn_(phit, sinphi, eccen) {
  sinphi *= eccen;
  return Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen);
}
function init$n() {
  this.coslat0 = Math.cos(this.lat0);
  this.sinlat0 = Math.sin(this.lat0);
  if (this.sphere) {
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
      this.k0 = 0.5 * (1 + sign$1(this.lat0) * Math.sin(this.lat_ts));
    }
  } else {
    if (Math.abs(this.coslat0) <= EPSLN) {
      if (this.lat0 > 0) {
        this.con = 1;
      } else {
        this.con = -1;
      }
    }
    this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
      this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
    }
    this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0);
    this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;
    this.cosX0 = Math.cos(this.X0);
    this.sinX0 = Math.sin(this.X0);
  }
}
function forward$n(p5) {
  var lon = p5.x;
  var lat = p5.y;
  var sinlat = Math.sin(lat);
  var coslat = Math.cos(lat);
  var A2, X2, sinX, cosX, ts, rh;
  var dlon = adjust_lon(lon - this.long0);
  if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {
    p5.x = NaN;
    p5.y = NaN;
    return p5;
  }
  if (this.sphere) {
    A2 = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
    p5.x = this.a * A2 * coslat * Math.sin(dlon) + this.x0;
    p5.y = this.a * A2 * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
    return p5;
  } else {
    X2 = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;
    cosX = Math.cos(X2);
    sinX = Math.sin(X2);
    if (Math.abs(this.coslat0) <= EPSLN) {
      ts = tsfnz(this.e, lat * this.con, this.con * sinlat);
      rh = 2 * this.a * this.k0 * ts / this.cons;
      p5.x = this.x0 + rh * Math.sin(lon - this.long0);
      p5.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
      return p5;
    } else if (Math.abs(this.sinlat0) < EPSLN) {
      A2 = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
      p5.y = A2 * sinX;
    } else {
      A2 = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
      p5.y = A2 * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
    }
    p5.x = A2 * cosX * Math.sin(dlon) + this.x0;
  }
  return p5;
}
function inverse$n(p5) {
  p5.x -= this.x0;
  p5.y -= this.y0;
  var lon, lat, ts, ce2, Chi;
  var rh = Math.sqrt(p5.x * p5.x + p5.y * p5.y);
  if (this.sphere) {
    var c2 = 2 * Math.atan(rh / (2 * this.a * this.k0));
    lon = this.long0;
    lat = this.lat0;
    if (rh <= EPSLN) {
      p5.x = lon;
      p5.y = lat;
      return p5;
    }
    lat = Math.asin(Math.cos(c2) * this.sinlat0 + p5.y * Math.sin(c2) * this.coslat0 / rh);
    if (Math.abs(this.coslat0) < EPSLN) {
      if (this.lat0 > 0) {
        lon = adjust_lon(this.long0 + Math.atan2(p5.x, -1 * p5.y));
      } else {
        lon = adjust_lon(this.long0 + Math.atan2(p5.x, p5.y));
      }
    } else {
      lon = adjust_lon(this.long0 + Math.atan2(p5.x * Math.sin(c2), rh * this.coslat0 * Math.cos(c2) - p5.y * this.sinlat0 * Math.sin(c2)));
    }
    p5.x = lon;
    p5.y = lat;
    return p5;
  } else {
    if (Math.abs(this.coslat0) <= EPSLN) {
      if (rh <= EPSLN) {
        lat = this.lat0;
        lon = this.long0;
        p5.x = lon;
        p5.y = lat;
        return p5;
      }
      p5.x *= this.con;
      p5.y *= this.con;
      ts = rh * this.cons / (2 * this.a * this.k0);
      lat = this.con * phi2z(this.e, ts);
      lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p5.x, -1 * p5.y));
    } else {
      ce2 = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
      lon = this.long0;
      if (rh <= EPSLN) {
        Chi = this.X0;
      } else {
        Chi = Math.asin(Math.cos(ce2) * this.sinX0 + p5.y * Math.sin(ce2) * this.cosX0 / rh);
        lon = adjust_lon(this.long0 + Math.atan2(p5.x * Math.sin(ce2), rh * this.cosX0 * Math.cos(ce2) - p5.y * this.sinX0 * Math.sin(ce2)));
      }
      lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi)));
    }
  }
  p5.x = lon;
  p5.y = lat;
  return p5;
}
var names$n = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];
var stere = {
  init: init$n,
  forward: forward$n,
  inverse: inverse$n,
  names: names$n,
  ssfn_
};
function init$m() {
  var phy0 = this.lat0;
  this.lambda0 = this.long0;
  var sinPhy0 = Math.sin(phy0);
  var semiMajorAxis = this.a;
  var invF = this.rf;
  var flattening = 1 / invF;
  var e2 = 2 * flattening - Math.pow(flattening, 2);
  var e3 = this.e = Math.sqrt(e2);
  this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
  this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
  this.b0 = Math.asin(sinPhy0 / this.alpha);
  var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
  var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
  var k3 = Math.log((1 + e3 * sinPhy0) / (1 - e3 * sinPhy0));
  this.K = k1 - this.alpha * k2 + this.alpha * e3 / 2 * k3;
}
function forward$m(p5) {
  var Sa1 = Math.log(Math.tan(Math.PI / 4 - p5.y / 2));
  var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p5.y)) / (1 - this.e * Math.sin(p5.y)));
  var S2 = -this.alpha * (Sa1 + Sa2) + this.K;
  var b2 = 2 * (Math.atan(Math.exp(S2)) - Math.PI / 4);
  var I2 = this.alpha * (p5.x - this.lambda0);
  var rotI = Math.atan(Math.sin(I2) / (Math.sin(this.b0) * Math.tan(b2) + Math.cos(this.b0) * Math.cos(I2)));
  var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b2) - Math.sin(this.b0) * Math.cos(b2) * Math.cos(I2));
  p5.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
  p5.x = this.R * rotI + this.x0;
  return p5;
}
function inverse$m(p5) {
  var Y2 = p5.x - this.x0;
  var X2 = p5.y - this.y0;
  var rotI = Y2 / this.R;
  var rotB = 2 * (Math.atan(Math.exp(X2 / this.R)) - Math.PI / 4);
  var b2 = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
  var I2 = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));
  var lambda = this.lambda0 + I2 / this.alpha;
  var S2 = 0;
  var phy = b2;
  var prevPhy = -1e3;
  var iteration = 0;
  while (Math.abs(phy - prevPhy) > 1e-7) {
    if (++iteration > 20) {
      return;
    }
    S2 = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b2 / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
    prevPhy = phy;
    phy = 2 * Math.atan(Math.exp(S2)) - Math.PI / 2;
  }
  p5.x = lambda;
  p5.y = phy;
  return p5;
}
var names$m = ["somerc"];
var somerc = {
  init: init$m,
  forward: forward$m,
  inverse: inverse$m,
  names: names$m
};
var TOL = 1e-7;
function isTypeA(P2) {
  var typeAProjections = ["Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin"];
  var projectionName = typeof P2.PROJECTION === "object" ? Object.keys(P2.PROJECTION)[0] : P2.PROJECTION;
  return "no_uoff" in P2 || "no_off" in P2 || typeAProjections.indexOf(projectionName) !== -1;
}
function init$l() {
  var con, com, cosph0, D2, F2, H4, L2, sinph0, p5, J2, gamma = 0, gamma0, lamc = 0, lam1 = 0, lam2 = 0, phi1 = 0, phi2 = 0, alpha_c = 0;
  this.no_off = isTypeA(this);
  this.no_rot = "no_rot" in this;
  var alp = false;
  if ("alpha" in this) {
    alp = true;
  }
  var gam = false;
  if ("rectified_grid_angle" in this) {
    gam = true;
  }
  if (alp) {
    alpha_c = this.alpha;
  }
  if (gam) {
    gamma = this.rectified_grid_angle * D2R$1;
  }
  if (alp || gam) {
    lamc = this.longc;
  } else {
    lam1 = this.long1;
    phi1 = this.lat1;
    lam2 = this.long2;
    phi2 = this.lat2;
    if (Math.abs(phi1 - phi2) <= TOL || (con = Math.abs(phi1)) <= TOL || Math.abs(con - HALF_PI) <= TOL || Math.abs(Math.abs(this.lat0) - HALF_PI) <= TOL || Math.abs(Math.abs(phi2) - HALF_PI) <= TOL) {
      throw new Error();
    }
  }
  var one_es = 1 - this.es;
  com = Math.sqrt(one_es);
  if (Math.abs(this.lat0) > EPSLN) {
    sinph0 = Math.sin(this.lat0);
    cosph0 = Math.cos(this.lat0);
    con = 1 - this.es * sinph0 * sinph0;
    this.B = cosph0 * cosph0;
    this.B = Math.sqrt(1 + this.es * this.B * this.B / one_es);
    this.A = this.B * this.k0 * com / con;
    D2 = this.B * com / (cosph0 * Math.sqrt(con));
    F2 = D2 * D2 - 1;
    if (F2 <= 0) {
      F2 = 0;
    } else {
      F2 = Math.sqrt(F2);
      if (this.lat0 < 0) {
        F2 = -F2;
      }
    }
    this.E = F2 += D2;
    this.E *= Math.pow(tsfnz(this.e, this.lat0, sinph0), this.B);
  } else {
    this.B = 1 / com;
    this.A = this.k0;
    this.E = D2 = F2 = 1;
  }
  if (alp || gam) {
    if (alp) {
      gamma0 = Math.asin(Math.sin(alpha_c) / D2);
      if (!gam) {
        gamma = alpha_c;
      }
    } else {
      gamma0 = gamma;
      alpha_c = Math.asin(D2 * Math.sin(gamma0));
    }
    this.lam0 = lamc - Math.asin(0.5 * (F2 - 1 / F2) * Math.tan(gamma0)) / this.B;
  } else {
    H4 = Math.pow(tsfnz(this.e, phi1, Math.sin(phi1)), this.B);
    L2 = Math.pow(tsfnz(this.e, phi2, Math.sin(phi2)), this.B);
    F2 = this.E / H4;
    p5 = (L2 - H4) / (L2 + H4);
    J2 = this.E * this.E;
    J2 = (J2 - L2 * H4) / (J2 + L2 * H4);
    con = lam1 - lam2;
    if (con < -Math.pi) {
      lam2 -= TWO_PI;
    } else if (con > Math.pi) {
      lam2 += TWO_PI;
    }
    this.lam0 = adjust_lon(0.5 * (lam1 + lam2) - Math.atan(J2 * Math.tan(0.5 * this.B * (lam1 - lam2)) / p5) / this.B);
    gamma0 = Math.atan(2 * Math.sin(this.B * adjust_lon(lam1 - this.lam0)) / (F2 - 1 / F2));
    gamma = alpha_c = Math.asin(D2 * Math.sin(gamma0));
  }
  this.singam = Math.sin(gamma0);
  this.cosgam = Math.cos(gamma0);
  this.sinrot = Math.sin(gamma);
  this.cosrot = Math.cos(gamma);
  this.rB = 1 / this.B;
  this.ArB = this.A * this.rB;
  this.BrA = 1 / this.ArB;
  this.A * this.B;
  if (this.no_off) {
    this.u_0 = 0;
  } else {
    this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(D2 * D2 - 1) / Math.cos(alpha_c)));
    if (this.lat0 < 0) {
      this.u_0 = -this.u_0;
    }
  }
  F2 = 0.5 * gamma0;
  this.v_pole_n = this.ArB * Math.log(Math.tan(FORTPI - F2));
  this.v_pole_s = this.ArB * Math.log(Math.tan(FORTPI + F2));
}
function forward$l(p5) {
  var coords = {};
  var S2, T2, U2, V2, W2, temp, u2, v2;
  p5.x = p5.x - this.lam0;
  if (Math.abs(Math.abs(p5.y) - HALF_PI) > EPSLN) {
    W2 = this.E / Math.pow(tsfnz(this.e, p5.y, Math.sin(p5.y)), this.B);
    temp = 1 / W2;
    S2 = 0.5 * (W2 - temp);
    T2 = 0.5 * (W2 + temp);
    V2 = Math.sin(this.B * p5.x);
    U2 = (S2 * this.singam - V2 * this.cosgam) / T2;
    if (Math.abs(Math.abs(U2) - 1) < EPSLN) {
      throw new Error();
    }
    v2 = 0.5 * this.ArB * Math.log((1 - U2) / (1 + U2));
    temp = Math.cos(this.B * p5.x);
    if (Math.abs(temp) < TOL) {
      u2 = this.A * p5.x;
    } else {
      u2 = this.ArB * Math.atan2(S2 * this.cosgam + V2 * this.singam, temp);
    }
  } else {
    v2 = p5.y > 0 ? this.v_pole_n : this.v_pole_s;
    u2 = this.ArB * p5.y;
  }
  if (this.no_rot) {
    coords.x = u2;
    coords.y = v2;
  } else {
    u2 -= this.u_0;
    coords.x = v2 * this.cosrot + u2 * this.sinrot;
    coords.y = u2 * this.cosrot - v2 * this.sinrot;
  }
  coords.x = this.a * coords.x + this.x0;
  coords.y = this.a * coords.y + this.y0;
  return coords;
}
function inverse$l(p5) {
  var u2, v2, Qp, Sp, Tp, Vp, Up;
  var coords = {};
  p5.x = (p5.x - this.x0) * (1 / this.a);
  p5.y = (p5.y - this.y0) * (1 / this.a);
  if (this.no_rot) {
    v2 = p5.y;
    u2 = p5.x;
  } else {
    v2 = p5.x * this.cosrot - p5.y * this.sinrot;
    u2 = p5.y * this.cosrot + p5.x * this.sinrot + this.u_0;
  }
  Qp = Math.exp(-this.BrA * v2);
  Sp = 0.5 * (Qp - 1 / Qp);
  Tp = 0.5 * (Qp + 1 / Qp);
  Vp = Math.sin(this.BrA * u2);
  Up = (Vp * this.cosgam + Sp * this.singam) / Tp;
  if (Math.abs(Math.abs(Up) - 1) < EPSLN) {
    coords.x = 0;
    coords.y = Up < 0 ? -HALF_PI : HALF_PI;
  } else {
    coords.y = this.E / Math.sqrt((1 + Up) / (1 - Up));
    coords.y = phi2z(this.e, Math.pow(coords.y, 1 / this.B));
    if (coords.y === Infinity) {
      throw new Error();
    }
    coords.x = -this.rB * Math.atan2(Sp * this.cosgam - Vp * this.singam, Math.cos(this.BrA * u2));
  }
  coords.x += this.lam0;
  return coords;
}
var names$l = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
var omerc = {
  init: init$l,
  forward: forward$l,
  inverse: inverse$l,
  names: names$l
};
function init$k() {
  if (!this.lat2) {
    this.lat2 = this.lat1;
  }
  if (!this.k0) {
    this.k0 = 1;
  }
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  var temp = this.b / this.a;
  this.e = Math.sqrt(1 - temp * temp);
  var sin1 = Math.sin(this.lat1);
  var cos1 = Math.cos(this.lat1);
  var ms1 = msfnz(this.e, sin1, cos1);
  var ts1 = tsfnz(this.e, this.lat1, sin1);
  var sin2 = Math.sin(this.lat2);
  var cos2 = Math.cos(this.lat2);
  var ms2 = msfnz(this.e, sin2, cos2);
  var ts2 = tsfnz(this.e, this.lat2, sin2);
  var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));
  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
    this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
  } else {
    this.ns = sin1;
  }
  if (isNaN(this.ns)) {
    this.ns = sin1;
  }
  this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
  this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
  if (!this.title) {
    this.title = "Lambert Conformal Conic";
  }
}
function forward$k(p5) {
  var lon = p5.x;
  var lat = p5.y;
  if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {
    lat = sign$1(lat) * (HALF_PI - 2 * EPSLN);
  }
  var con = Math.abs(Math.abs(lat) - HALF_PI);
  var ts, rh1;
  if (con > EPSLN) {
    ts = tsfnz(this.e, lat, Math.sin(lat));
    rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
  } else {
    con = lat * this.ns;
    if (con <= 0) {
      return null;
    }
    rh1 = 0;
  }
  var theta = this.ns * adjust_lon(lon - this.long0);
  p5.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
  p5.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;
  return p5;
}
function inverse$k(p5) {
  var rh1, con, ts;
  var lat, lon;
  var x2 = (p5.x - this.x0) / this.k0;
  var y2 = this.rh - (p5.y - this.y0) / this.k0;
  if (this.ns > 0) {
    rh1 = Math.sqrt(x2 * x2 + y2 * y2);
    con = 1;
  } else {
    rh1 = -Math.sqrt(x2 * x2 + y2 * y2);
    con = -1;
  }
  var theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * x2, con * y2);
  }
  if (rh1 !== 0 || this.ns > 0) {
    con = 1 / this.ns;
    ts = Math.pow(rh1 / (this.a * this.f0), con);
    lat = phi2z(this.e, ts);
    if (lat === -9999) {
      return null;
    }
  } else {
    lat = -HALF_PI;
  }
  lon = adjust_lon(theta / this.ns + this.long0);
  p5.x = lon;
  p5.y = lat;
  return p5;
}
var names$k = [
  "Lambert Tangential Conformal Conic Projection",
  "Lambert_Conformal_Conic",
  "Lambert_Conformal_Conic_1SP",
  "Lambert_Conformal_Conic_2SP",
  "lcc"
];
var lcc = {
  init: init$k,
  forward: forward$k,
  inverse: inverse$k,
  names: names$k
};
function init$j() {
  this.a = 6377397155e-3;
  this.es = 0.006674372230614;
  this.e = Math.sqrt(this.es);
  if (!this.lat0) {
    this.lat0 = 0.863937979737193;
  }
  if (!this.long0) {
    this.long0 = 0.7417649320975901 - 0.308341501185665;
  }
  if (!this.k0) {
    this.k0 = 0.9999;
  }
  this.s45 = 0.785398163397448;
  this.s90 = 2 * this.s45;
  this.fi0 = this.lat0;
  this.e2 = this.es;
  this.e = Math.sqrt(this.e2);
  this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2));
  this.uq = 1.04216856380474;
  this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
  this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
  this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
  this.k1 = this.k0;
  this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
  this.s0 = 1.37008346281555;
  this.n = Math.sin(this.s0);
  this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
  this.ad = this.s90 - this.uq;
}
function forward$j(p5) {
  var gfi, u2, deltav, s2, d2, eps, ro;
  var lon = p5.x;
  var lat = p5.y;
  var delta_lon = adjust_lon(lon - this.long0);
  gfi = Math.pow((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat)), this.alfa * this.e / 2);
  u2 = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
  deltav = -delta_lon * this.alfa;
  s2 = Math.asin(Math.cos(this.ad) * Math.sin(u2) + Math.sin(this.ad) * Math.cos(u2) * Math.cos(deltav));
  d2 = Math.asin(Math.cos(u2) * Math.sin(deltav) / Math.cos(s2));
  eps = this.n * d2;
  ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s2 / 2 + this.s45), this.n);
  p5.y = ro * Math.cos(eps) / 1;
  p5.x = ro * Math.sin(eps) / 1;
  if (!this.czech) {
    p5.y *= -1;
    p5.x *= -1;
  }
  return p5;
}
function inverse$j(p5) {
  var u2, deltav, s2, d2, eps, ro, fi1;
  var ok;
  var tmp = p5.x;
  p5.x = p5.y;
  p5.y = tmp;
  if (!this.czech) {
    p5.y *= -1;
    p5.x *= -1;
  }
  ro = Math.sqrt(p5.x * p5.x + p5.y * p5.y);
  eps = Math.atan2(p5.y, p5.x);
  d2 = eps / Math.sin(this.s0);
  s2 = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
  u2 = Math.asin(Math.cos(this.ad) * Math.sin(s2) - Math.sin(this.ad) * Math.cos(s2) * Math.cos(d2));
  deltav = Math.asin(Math.cos(s2) * Math.sin(d2) / Math.cos(u2));
  p5.x = this.long0 - deltav / this.alfa;
  fi1 = u2;
  ok = 0;
  var iter = 0;
  do {
    p5.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(u2 / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
    if (Math.abs(fi1 - p5.y) < 1e-10) {
      ok = 1;
    }
    fi1 = p5.y;
    iter += 1;
  } while (ok === 0 && iter < 15);
  if (iter >= 15) {
    return null;
  }
  return p5;
}
var names$j = ["Krovak", "krovak"];
var krovak = {
  init: init$j,
  forward: forward$j,
  inverse: inverse$j,
  names: names$j
};
function mlfn(e0, e1, e2, e3, phi) {
  return e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi);
}
function e0fn(x2) {
  return 1 - 0.25 * x2 * (1 + x2 / 16 * (3 + 1.25 * x2));
}
function e1fn(x2) {
  return 0.375 * x2 * (1 + 0.25 * x2 * (1 + 0.46875 * x2));
}
function e2fn(x2) {
  return 0.05859375 * x2 * x2 * (1 + 0.75 * x2);
}
function e3fn(x2) {
  return x2 * x2 * x2 * (35 / 3072);
}
function gN(a2, e2, sinphi) {
  var temp = e2 * sinphi;
  return a2 / Math.sqrt(1 - temp * temp);
}
function adjust_lat(x2) {
  return Math.abs(x2) < HALF_PI ? x2 : x2 - sign$1(x2) * Math.PI;
}
function imlfn(ml, e0, e1, e2, e3) {
  var phi;
  var dphi;
  phi = ml / e0;
  for (var i2 = 0; i2 < 15; i2++) {
    dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
    phi += dphi;
    if (Math.abs(dphi) <= 1e-10) {
      return phi;
    }
  }
  return NaN;
}
function init$i() {
  if (!this.sphere) {
    this.e0 = e0fn(this.es);
    this.e1 = e1fn(this.es);
    this.e2 = e2fn(this.es);
    this.e3 = e3fn(this.es);
    this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
  }
}
function forward$i(p5) {
  var x2, y2;
  var lam = p5.x;
  var phi = p5.y;
  lam = adjust_lon(lam - this.long0);
  if (this.sphere) {
    x2 = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
    y2 = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
  } else {
    var sinphi = Math.sin(phi);
    var cosphi = Math.cos(phi);
    var nl = gN(this.a, this.e, sinphi);
    var tl = Math.tan(phi) * Math.tan(phi);
    var al = lam * Math.cos(phi);
    var asq = al * al;
    var cl = this.es * cosphi * cosphi / (1 - this.es);
    var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
    x2 = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
    y2 = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);
  }
  p5.x = x2 + this.x0;
  p5.y = y2 + this.y0;
  return p5;
}
function inverse$i(p5) {
  p5.x -= this.x0;
  p5.y -= this.y0;
  var x2 = p5.x / this.a;
  var y2 = p5.y / this.a;
  var phi, lam;
  if (this.sphere) {
    var dd = y2 + this.lat0;
    phi = Math.asin(Math.sin(dd) * Math.cos(x2));
    lam = Math.atan2(Math.tan(x2), Math.cos(dd));
  } else {
    var ml1 = this.ml0 / this.a + y2;
    var phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);
    if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {
      p5.x = this.long0;
      p5.y = HALF_PI;
      if (y2 < 0) {
        p5.y *= -1;
      }
      return p5;
    }
    var nl1 = gN(this.a, this.e, Math.sin(phi1));
    var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
    var tl1 = Math.pow(Math.tan(phi1), 2);
    var dl = x2 * this.a / nl1;
    var dsq = dl * dl;
    phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
    lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);
  }
  p5.x = adjust_lon(lam + this.long0);
  p5.y = adjust_lat(phi);
  return p5;
}
var names$i = ["Cassini", "Cassini_Soldner", "cass"];
var cass = {
  init: init$i,
  forward: forward$i,
  inverse: inverse$i,
  names: names$i
};
function qsfnz(eccent, sinphi) {
  var con;
  if (eccent > 1e-7) {
    con = eccent * sinphi;
    return (1 - eccent * eccent) * (sinphi / (1 - con * con) - 0.5 / eccent * Math.log((1 - con) / (1 + con)));
  } else {
    return 2 * sinphi;
  }
}
var S_POLE = 1;
var N_POLE = 2;
var EQUIT = 3;
var OBLIQ = 4;
function init$h() {
  var t3 = Math.abs(this.lat0);
  if (Math.abs(t3 - HALF_PI) < EPSLN) {
    this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;
  } else if (Math.abs(t3) < EPSLN) {
    this.mode = this.EQUIT;
  } else {
    this.mode = this.OBLIQ;
  }
  if (this.es > 0) {
    var sinphi;
    this.qp = qsfnz(this.e, 1);
    this.mmf = 0.5 / (1 - this.es);
    this.apa = authset(this.es);
    switch (this.mode) {
      case this.N_POLE:
        this.dd = 1;
        break;
      case this.S_POLE:
        this.dd = 1;
        break;
      case this.EQUIT:
        this.rq = Math.sqrt(0.5 * this.qp);
        this.dd = 1 / this.rq;
        this.xmf = 1;
        this.ymf = 0.5 * this.qp;
        break;
      case this.OBLIQ:
        this.rq = Math.sqrt(0.5 * this.qp);
        sinphi = Math.sin(this.lat0);
        this.sinb1 = qsfnz(this.e, sinphi) / this.qp;
        this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
        this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
        this.ymf = (this.xmf = this.rq) / this.dd;
        this.xmf *= this.dd;
        break;
    }
  } else {
    if (this.mode === this.OBLIQ) {
      this.sinph0 = Math.sin(this.lat0);
      this.cosph0 = Math.cos(this.lat0);
    }
  }
}
function forward$h(p5) {
  var x2, y2, coslam, sinlam, sinphi, q2, sinb, cosb, b2, cosphi;
  var lam = p5.x;
  var phi = p5.y;
  lam = adjust_lon(lam - this.long0);
  if (this.sphere) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    coslam = Math.cos(lam);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      y2 = this.mode === this.EQUIT ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
      if (y2 <= EPSLN) {
        return null;
      }
      y2 = Math.sqrt(2 / y2);
      x2 = y2 * cosphi * Math.sin(lam);
      y2 *= this.mode === this.EQUIT ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        coslam = -coslam;
      }
      if (Math.abs(phi + this.lat0) < EPSLN) {
        return null;
      }
      y2 = FORTPI - phi * 0.5;
      y2 = 2 * (this.mode === this.S_POLE ? Math.cos(y2) : Math.sin(y2));
      x2 = y2 * Math.sin(lam);
      y2 *= coslam;
    }
  } else {
    sinb = 0;
    cosb = 0;
    b2 = 0;
    coslam = Math.cos(lam);
    sinlam = Math.sin(lam);
    sinphi = Math.sin(phi);
    q2 = qsfnz(this.e, sinphi);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinb = q2 / this.qp;
      cosb = Math.sqrt(1 - sinb * sinb);
    }
    switch (this.mode) {
      case this.OBLIQ:
        b2 = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
        break;
      case this.EQUIT:
        b2 = 1 + cosb * coslam;
        break;
      case this.N_POLE:
        b2 = HALF_PI + phi;
        q2 = this.qp - q2;
        break;
      case this.S_POLE:
        b2 = phi - HALF_PI;
        q2 = this.qp + q2;
        break;
    }
    if (Math.abs(b2) < EPSLN) {
      return null;
    }
    switch (this.mode) {
      case this.OBLIQ:
      case this.EQUIT:
        b2 = Math.sqrt(2 / b2);
        if (this.mode === this.OBLIQ) {
          y2 = this.ymf * b2 * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
        } else {
          y2 = (b2 = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
        }
        x2 = this.xmf * b2 * cosb * sinlam;
        break;
      case this.N_POLE:
      case this.S_POLE:
        if (q2 >= 0) {
          x2 = (b2 = Math.sqrt(q2)) * sinlam;
          y2 = coslam * (this.mode === this.S_POLE ? b2 : -b2);
        } else {
          x2 = y2 = 0;
        }
        break;
    }
  }
  p5.x = this.a * x2 + this.x0;
  p5.y = this.a * y2 + this.y0;
  return p5;
}
function inverse$h(p5) {
  p5.x -= this.x0;
  p5.y -= this.y0;
  var x2 = p5.x / this.a;
  var y2 = p5.y / this.a;
  var lam, phi, cCe, sCe, q2, rho, ab;
  if (this.sphere) {
    var cosz = 0, rh, sinz = 0;
    rh = Math.sqrt(x2 * x2 + y2 * y2);
    phi = rh * 0.5;
    if (phi > 1) {
      return null;
    }
    phi = 2 * Math.asin(phi);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinz = Math.sin(phi);
      cosz = Math.cos(phi);
    }
    switch (this.mode) {
      case this.EQUIT:
        phi = Math.abs(rh) <= EPSLN ? 0 : Math.asin(y2 * sinz / rh);
        x2 *= sinz;
        y2 = cosz * rh;
        break;
      case this.OBLIQ:
        phi = Math.abs(rh) <= EPSLN ? this.lat0 : Math.asin(cosz * this.sinph0 + y2 * sinz * this.cosph0 / rh);
        x2 *= sinz * this.cosph0;
        y2 = (cosz - Math.sin(phi) * this.sinph0) * rh;
        break;
      case this.N_POLE:
        y2 = -y2;
        phi = HALF_PI - phi;
        break;
      case this.S_POLE:
        phi -= HALF_PI;
        break;
    }
    lam = y2 === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(x2, y2);
  } else {
    ab = 0;
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      x2 /= this.dd;
      y2 *= this.dd;
      rho = Math.sqrt(x2 * x2 + y2 * y2);
      if (rho < EPSLN) {
        p5.x = this.long0;
        p5.y = this.lat0;
        return p5;
      }
      sCe = 2 * Math.asin(0.5 * rho / this.rq);
      cCe = Math.cos(sCe);
      x2 *= sCe = Math.sin(sCe);
      if (this.mode === this.OBLIQ) {
        ab = cCe * this.sinb1 + y2 * sCe * this.cosb1 / rho;
        q2 = this.qp * ab;
        y2 = rho * this.cosb1 * cCe - y2 * this.sinb1 * sCe;
      } else {
        ab = y2 * sCe / rho;
        q2 = this.qp * ab;
        y2 = rho * cCe;
      }
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        y2 = -y2;
      }
      q2 = x2 * x2 + y2 * y2;
      if (!q2) {
        p5.x = this.long0;
        p5.y = this.lat0;
        return p5;
      }
      ab = 1 - q2 / this.qp;
      if (this.mode === this.S_POLE) {
        ab = -ab;
      }
    }
    lam = Math.atan2(x2, y2);
    phi = authlat(Math.asin(ab), this.apa);
  }
  p5.x = adjust_lon(this.long0 + lam);
  p5.y = phi;
  return p5;
}
var P00 = 0.3333333333333333;
var P01 = 0.17222222222222222;
var P02 = 0.10257936507936508;
var P10 = 0.06388888888888888;
var P11 = 0.0664021164021164;
var P20 = 0.016415012942191543;
function authset(es) {
  var t3;
  var APA = [];
  APA[0] = es * P00;
  t3 = es * es;
  APA[0] += t3 * P01;
  APA[1] = t3 * P10;
  t3 *= es;
  APA[0] += t3 * P02;
  APA[1] += t3 * P11;
  APA[2] = t3 * P20;
  return APA;
}
function authlat(beta, APA) {
  var t3 = beta + beta;
  return beta + APA[0] * Math.sin(t3) + APA[1] * Math.sin(t3 + t3) + APA[2] * Math.sin(t3 + t3 + t3);
}
var names$h = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
var laea = {
  init: init$h,
  forward: forward$h,
  inverse: inverse$h,
  names: names$h,
  S_POLE,
  N_POLE,
  EQUIT,
  OBLIQ
};
function asinz(x2) {
  if (Math.abs(x2) > 1) {
    x2 = x2 > 1 ? 1 : -1;
  }
  return Math.asin(x2);
}
function init$g() {
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e3 = Math.sqrt(this.es);
  this.sin_po = Math.sin(this.lat1);
  this.cos_po = Math.cos(this.lat1);
  this.t1 = this.sin_po;
  this.con = this.sin_po;
  this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po);
  this.qs1 = qsfnz(this.e3, this.sin_po, this.cos_po);
  this.sin_po = Math.sin(this.lat2);
  this.cos_po = Math.cos(this.lat2);
  this.t2 = this.sin_po;
  this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po);
  this.qs2 = qsfnz(this.e3, this.sin_po, this.cos_po);
  this.sin_po = Math.sin(this.lat0);
  this.cos_po = Math.cos(this.lat0);
  this.t3 = this.sin_po;
  this.qs0 = qsfnz(this.e3, this.sin_po, this.cos_po);
  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
    this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
  } else {
    this.ns0 = this.con;
  }
  this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
  this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
}
function forward$g(p5) {
  var lon = p5.x;
  var lat = p5.y;
  this.sin_phi = Math.sin(lat);
  this.cos_phi = Math.cos(lat);
  var qs = qsfnz(this.e3, this.sin_phi, this.cos_phi);
  var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
  var theta = this.ns0 * adjust_lon(lon - this.long0);
  var x2 = rh1 * Math.sin(theta) + this.x0;
  var y2 = this.rh - rh1 * Math.cos(theta) + this.y0;
  p5.x = x2;
  p5.y = y2;
  return p5;
}
function inverse$g(p5) {
  var rh1, qs, con, theta, lon, lat;
  p5.x -= this.x0;
  p5.y = this.rh - p5.y + this.y0;
  if (this.ns0 >= 0) {
    rh1 = Math.sqrt(p5.x * p5.x + p5.y * p5.y);
    con = 1;
  } else {
    rh1 = -Math.sqrt(p5.x * p5.x + p5.y * p5.y);
    con = -1;
  }
  theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * p5.x, con * p5.y);
  }
  con = rh1 * this.ns0 / this.a;
  if (this.sphere) {
    lat = Math.asin((this.c - con * con) / (2 * this.ns0));
  } else {
    qs = (this.c - con * con) / this.ns0;
    lat = this.phi1z(this.e3, qs);
  }
  lon = adjust_lon(theta / this.ns0 + this.long0);
  p5.x = lon;
  p5.y = lat;
  return p5;
}
function phi1z(eccent, qs) {
  var sinphi, cosphi, con, com, dphi;
  var phi = asinz(0.5 * qs);
  if (eccent < EPSLN) {
    return phi;
  }
  var eccnts = eccent * eccent;
  for (var i2 = 1; i2 <= 25; i2++) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    con = eccent * sinphi;
    com = 1 - con * con;
    dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi = phi + dphi;
    if (Math.abs(dphi) <= 1e-7) {
      return phi;
    }
  }
  return null;
}
var names$g = ["Albers_Conic_Equal_Area", "Albers", "aea"];
var aea = {
  init: init$g,
  forward: forward$g,
  inverse: inverse$g,
  names: names$g,
  phi1z
};
function init$f() {
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0);
  this.infinity_dist = 1e3 * this.a;
  this.rc = 1;
}
function forward$f(p5) {
  var sinphi, cosphi;
  var dlon;
  var coslon;
  var ksp;
  var g2;
  var x2, y2;
  var lon = p5.x;
  var lat = p5.y;
  dlon = adjust_lon(lon - this.long0);
  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);
  coslon = Math.cos(dlon);
  g2 = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;
  if (g2 > 0 || Math.abs(g2) <= EPSLN) {
    x2 = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g2;
    y2 = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g2;
  } else {
    x2 = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
    y2 = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
  }
  p5.x = x2;
  p5.y = y2;
  return p5;
}
function inverse$f(p5) {
  var rh;
  var sinc, cosc;
  var c2;
  var lon, lat;
  p5.x = (p5.x - this.x0) / this.a;
  p5.y = (p5.y - this.y0) / this.a;
  p5.x /= this.k0;
  p5.y /= this.k0;
  if (rh = Math.sqrt(p5.x * p5.x + p5.y * p5.y)) {
    c2 = Math.atan2(rh, this.rc);
    sinc = Math.sin(c2);
    cosc = Math.cos(c2);
    lat = asinz(cosc * this.sin_p14 + p5.y * sinc * this.cos_p14 / rh);
    lon = Math.atan2(p5.x * sinc, rh * this.cos_p14 * cosc - p5.y * this.sin_p14 * sinc);
    lon = adjust_lon(this.long0 + lon);
  } else {
    lat = this.phic0;
    lon = 0;
  }
  p5.x = lon;
  p5.y = lat;
  return p5;
}
var names$f = ["gnom"];
var gnom = {
  init: init$f,
  forward: forward$f,
  inverse: inverse$f,
  names: names$f
};
function iqsfnz(eccent, q2) {
  var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
  if (Math.abs(Math.abs(q2) - temp) < 1e-6) {
    if (q2 < 0) {
      return -1 * HALF_PI;
    } else {
      return HALF_PI;
    }
  }
  var phi = Math.asin(0.5 * q2);
  var dphi;
  var sin_phi;
  var cos_phi;
  var con;
  for (var i2 = 0; i2 < 30; i2++) {
    sin_phi = Math.sin(phi);
    cos_phi = Math.cos(phi);
    con = eccent * sin_phi;
    dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q2 / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi += dphi;
    if (Math.abs(dphi) <= 1e-10) {
      return phi;
    }
  }
  return NaN;
}
function init$e() {
  if (!this.sphere) {
    this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
  }
}
function forward$e(p5) {
  var lon = p5.x;
  var lat = p5.y;
  var x2, y2;
  var dlon = adjust_lon(lon - this.long0);
  if (this.sphere) {
    x2 = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
    y2 = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
  } else {
    var qs = qsfnz(this.e, Math.sin(lat));
    x2 = this.x0 + this.a * this.k0 * dlon;
    y2 = this.y0 + this.a * qs * 0.5 / this.k0;
  }
  p5.x = x2;
  p5.y = y2;
  return p5;
}
function inverse$e(p5) {
  p5.x -= this.x0;
  p5.y -= this.y0;
  var lon, lat;
  if (this.sphere) {
    lon = adjust_lon(this.long0 + p5.x / this.a / Math.cos(this.lat_ts));
    lat = Math.asin(p5.y / this.a * Math.cos(this.lat_ts));
  } else {
    lat = iqsfnz(this.e, 2 * p5.y * this.k0 / this.a);
    lon = adjust_lon(this.long0 + p5.x / (this.a * this.k0));
  }
  p5.x = lon;
  p5.y = lat;
  return p5;
}
var names$e = ["cea"];
var cea = {
  init: init$e,
  forward: forward$e,
  inverse: inverse$e,
  names: names$e
};
function init$d() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || "Equidistant Cylindrical (Plate Carre)";
  this.rc = Math.cos(this.lat_ts);
}
function forward$d(p5) {
  var lon = p5.x;
  var lat = p5.y;
  var dlon = adjust_lon(lon - this.long0);
  var dlat = adjust_lat(lat - this.lat0);
  p5.x = this.x0 + this.a * dlon * this.rc;
  p5.y = this.y0 + this.a * dlat;
  return p5;
}
function inverse$d(p5) {
  var x2 = p5.x;
  var y2 = p5.y;
  p5.x = adjust_lon(this.long0 + (x2 - this.x0) / (this.a * this.rc));
  p5.y = adjust_lat(this.lat0 + (y2 - this.y0) / this.a);
  return p5;
}
var names$d = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
var eqc = {
  init: init$d,
  forward: forward$d,
  inverse: inverse$d,
  names: names$d
};
var MAX_ITER$1 = 20;
function init$c() {
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e = Math.sqrt(this.es);
  this.e0 = e0fn(this.es);
  this.e1 = e1fn(this.es);
  this.e2 = e2fn(this.es);
  this.e3 = e3fn(this.es);
  this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
}
function forward$c(p5) {
  var lon = p5.x;
  var lat = p5.y;
  var x2, y2, el;
  var dlon = adjust_lon(lon - this.long0);
  el = dlon * Math.sin(lat);
  if (this.sphere) {
    if (Math.abs(lat) <= EPSLN) {
      x2 = this.a * dlon;
      y2 = -1 * this.a * this.lat0;
    } else {
      x2 = this.a * Math.sin(el) / Math.tan(lat);
      y2 = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
    }
  } else {
    if (Math.abs(lat) <= EPSLN) {
      x2 = this.a * dlon;
      y2 = -1 * this.ml0;
    } else {
      var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
      x2 = nl * Math.sin(el);
      y2 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
    }
  }
  p5.x = x2 + this.x0;
  p5.y = y2 + this.y0;
  return p5;
}
function inverse$c(p5) {
  var lon, lat, x2, y2, i2;
  var al, bl;
  var phi, dphi;
  x2 = p5.x - this.x0;
  y2 = p5.y - this.y0;
  if (this.sphere) {
    if (Math.abs(y2 + this.a * this.lat0) <= EPSLN) {
      lon = adjust_lon(x2 / this.a + this.long0);
      lat = 0;
    } else {
      al = this.lat0 + y2 / this.a;
      bl = x2 * x2 / this.a / this.a + al * al;
      phi = al;
      var tanphi;
      for (i2 = MAX_ITER$1; i2; --i2) {
        tanphi = Math.tan(phi);
        dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
        phi += dphi;
        if (Math.abs(dphi) <= EPSLN) {
          lat = phi;
          break;
        }
      }
      lon = adjust_lon(this.long0 + Math.asin(x2 * Math.tan(phi) / this.a) / Math.sin(lat));
    }
  } else {
    if (Math.abs(y2 + this.ml0) <= EPSLN) {
      lat = 0;
      lon = adjust_lon(this.long0 + x2 / this.a);
    } else {
      al = (this.ml0 + y2) / this.a;
      bl = x2 * x2 / this.a / this.a + al * al;
      phi = al;
      var cl, mln, mlnp, ma;
      var con;
      for (i2 = MAX_ITER$1; i2; --i2) {
        con = this.e * Math.sin(phi);
        cl = Math.sqrt(1 - con * con) * Math.tan(phi);
        mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
        mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
        ma = mln / this.a;
        dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
        phi -= dphi;
        if (Math.abs(dphi) <= EPSLN) {
          lat = phi;
          break;
        }
      }
      cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
      lon = adjust_lon(this.long0 + Math.asin(x2 * cl / this.a) / Math.sin(lat));
    }
  }
  p5.x = lon;
  p5.y = lat;
  return p5;
}
var names$c = ["Polyconic", "poly"];
var poly = {
  init: init$c,
  forward: forward$c,
  inverse: inverse$c,
  names: names$c
};
function init$b() {
  this.A = [];
  this.A[1] = 0.6399175073;
  this.A[2] = -0.1358797613;
  this.A[3] = 0.063294409;
  this.A[4] = -0.02526853;
  this.A[5] = 0.0117879;
  this.A[6] = -55161e-7;
  this.A[7] = 26906e-7;
  this.A[8] = -1333e-6;
  this.A[9] = 67e-5;
  this.A[10] = -34e-5;
  this.B_re = [];
  this.B_im = [];
  this.B_re[1] = 0.7557853228;
  this.B_im[1] = 0;
  this.B_re[2] = 0.249204646;
  this.B_im[2] = 3371507e-9;
  this.B_re[3] = -1541739e-9;
  this.B_im[3] = 0.04105856;
  this.B_re[4] = -0.10162907;
  this.B_im[4] = 0.01727609;
  this.B_re[5] = -0.26623489;
  this.B_im[5] = -0.36249218;
  this.B_re[6] = -0.6870983;
  this.B_im[6] = -1.1651967;
  this.C_re = [];
  this.C_im = [];
  this.C_re[1] = 1.3231270439;
  this.C_im[1] = 0;
  this.C_re[2] = -0.577245789;
  this.C_im[2] = -7809598e-9;
  this.C_re[3] = 0.508307513;
  this.C_im[3] = -0.112208952;
  this.C_re[4] = -0.15094762;
  this.C_im[4] = 0.18200602;
  this.C_re[5] = 1.01418179;
  this.C_im[5] = 1.64497696;
  this.C_re[6] = 1.9660549;
  this.C_im[6] = 2.5127645;
  this.D = [];
  this.D[1] = 1.5627014243;
  this.D[2] = 0.5185406398;
  this.D[3] = -0.03333098;
  this.D[4] = -0.1052906;
  this.D[5] = -0.0368594;
  this.D[6] = 7317e-6;
  this.D[7] = 0.0122;
  this.D[8] = 394e-5;
  this.D[9] = -13e-4;
}
function forward$b(p5) {
  var n2;
  var lon = p5.x;
  var lat = p5.y;
  var delta_lat = lat - this.lat0;
  var delta_lon = lon - this.long0;
  var d_phi = delta_lat / SEC_TO_RAD * 1e-5;
  var d_lambda = delta_lon;
  var d_phi_n = 1;
  var d_psi = 0;
  for (n2 = 1; n2 <= 10; n2++) {
    d_phi_n = d_phi_n * d_phi;
    d_psi = d_psi + this.A[n2] * d_phi_n;
  }
  var th_re = d_psi;
  var th_im = d_lambda;
  var th_n_re = 1;
  var th_n_im = 0;
  var th_n_re1;
  var th_n_im1;
  var z_re = 0;
  var z_im = 0;
  for (n2 = 1; n2 <= 6; n2++) {
    th_n_re1 = th_n_re * th_re - th_n_im * th_im;
    th_n_im1 = th_n_im * th_re + th_n_re * th_im;
    th_n_re = th_n_re1;
    th_n_im = th_n_im1;
    z_re = z_re + this.B_re[n2] * th_n_re - this.B_im[n2] * th_n_im;
    z_im = z_im + this.B_im[n2] * th_n_re + this.B_re[n2] * th_n_im;
  }
  p5.x = z_im * this.a + this.x0;
  p5.y = z_re * this.a + this.y0;
  return p5;
}
function inverse$b(p5) {
  var n2;
  var x2 = p5.x;
  var y2 = p5.y;
  var delta_x = x2 - this.x0;
  var delta_y = y2 - this.y0;
  var z_re = delta_y / this.a;
  var z_im = delta_x / this.a;
  var z_n_re = 1;
  var z_n_im = 0;
  var z_n_re1;
  var z_n_im1;
  var th_re = 0;
  var th_im = 0;
  for (n2 = 1; n2 <= 6; n2++) {
    z_n_re1 = z_n_re * z_re - z_n_im * z_im;
    z_n_im1 = z_n_im * z_re + z_n_re * z_im;
    z_n_re = z_n_re1;
    z_n_im = z_n_im1;
    th_re = th_re + this.C_re[n2] * z_n_re - this.C_im[n2] * z_n_im;
    th_im = th_im + this.C_im[n2] * z_n_re + this.C_re[n2] * z_n_im;
  }
  for (var i2 = 0; i2 < this.iterations; i2++) {
    var th_n_re = th_re;
    var th_n_im = th_im;
    var th_n_re1;
    var th_n_im1;
    var num_re = z_re;
    var num_im = z_im;
    for (n2 = 2; n2 <= 6; n2++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      num_re = num_re + (n2 - 1) * (this.B_re[n2] * th_n_re - this.B_im[n2] * th_n_im);
      num_im = num_im + (n2 - 1) * (this.B_im[n2] * th_n_re + this.B_re[n2] * th_n_im);
    }
    th_n_re = 1;
    th_n_im = 0;
    var den_re = this.B_re[1];
    var den_im = this.B_im[1];
    for (n2 = 2; n2 <= 6; n2++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      den_re = den_re + n2 * (this.B_re[n2] * th_n_re - this.B_im[n2] * th_n_im);
      den_im = den_im + n2 * (this.B_im[n2] * th_n_re + this.B_re[n2] * th_n_im);
    }
    var den2 = den_re * den_re + den_im * den_im;
    th_re = (num_re * den_re + num_im * den_im) / den2;
    th_im = (num_im * den_re - num_re * den_im) / den2;
  }
  var d_psi = th_re;
  var d_lambda = th_im;
  var d_psi_n = 1;
  var d_phi = 0;
  for (n2 = 1; n2 <= 9; n2++) {
    d_psi_n = d_psi_n * d_psi;
    d_phi = d_phi + this.D[n2] * d_psi_n;
  }
  var lat = this.lat0 + d_phi * SEC_TO_RAD * 1e5;
  var lon = this.long0 + d_lambda;
  p5.x = lon;
  p5.y = lat;
  return p5;
}
var names$b = ["New_Zealand_Map_Grid", "nzmg"];
var nzmg = {
  init: init$b,
  forward: forward$b,
  inverse: inverse$b,
  names: names$b
};
function init$a() {
}
function forward$a(p5) {
  var lon = p5.x;
  var lat = p5.y;
  var dlon = adjust_lon(lon - this.long0);
  var x2 = this.x0 + this.a * dlon;
  var y2 = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + lat / 2.5)) * 1.25;
  p5.x = x2;
  p5.y = y2;
  return p5;
}
function inverse$a(p5) {
  p5.x -= this.x0;
  p5.y -= this.y0;
  var lon = adjust_lon(this.long0 + p5.x / this.a);
  var lat = 2.5 * (Math.atan(Math.exp(0.8 * p5.y / this.a)) - Math.PI / 4);
  p5.x = lon;
  p5.y = lat;
  return p5;
}
var names$a = ["Miller_Cylindrical", "mill"];
var mill = {
  init: init$a,
  forward: forward$a,
  inverse: inverse$a,
  names: names$a
};
var MAX_ITER = 20;
function init$9() {
  if (!this.sphere) {
    this.en = pj_enfn(this.es);
  } else {
    this.n = 1;
    this.m = 0;
    this.es = 0;
    this.C_y = Math.sqrt((this.m + 1) / this.n);
    this.C_x = this.C_y / (this.m + 1);
  }
}
function forward$9(p5) {
  var x2, y2;
  var lon = p5.x;
  var lat = p5.y;
  lon = adjust_lon(lon - this.long0);
  if (this.sphere) {
    if (!this.m) {
      lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
    } else {
      var k2 = this.n * Math.sin(lat);
      for (var i2 = MAX_ITER; i2; --i2) {
        var V2 = (this.m * lat + Math.sin(lat) - k2) / (this.m + Math.cos(lat));
        lat -= V2;
        if (Math.abs(V2) < EPSLN) {
          break;
        }
      }
    }
    x2 = this.a * this.C_x * lon * (this.m + Math.cos(lat));
    y2 = this.a * this.C_y * lat;
  } else {
    var s2 = Math.sin(lat);
    var c2 = Math.cos(lat);
    y2 = this.a * pj_mlfn(lat, s2, c2, this.en);
    x2 = this.a * lon * c2 / Math.sqrt(1 - this.es * s2 * s2);
  }
  p5.x = x2;
  p5.y = y2;
  return p5;
}
function inverse$9(p5) {
  var lat, temp, lon, s2;
  p5.x -= this.x0;
  lon = p5.x / this.a;
  p5.y -= this.y0;
  lat = p5.y / this.a;
  if (this.sphere) {
    lat /= this.C_y;
    lon = lon / (this.C_x * (this.m + Math.cos(lat)));
    if (this.m) {
      lat = asinz((this.m * lat + Math.sin(lat)) / this.n);
    } else if (this.n !== 1) {
      lat = asinz(Math.sin(lat) / this.n);
    }
    lon = adjust_lon(lon + this.long0);
    lat = adjust_lat(lat);
  } else {
    lat = pj_inv_mlfn(p5.y / this.a, this.es, this.en);
    s2 = Math.abs(lat);
    if (s2 < HALF_PI) {
      s2 = Math.sin(lat);
      temp = this.long0 + p5.x * Math.sqrt(1 - this.es * s2 * s2) / (this.a * Math.cos(lat));
      lon = adjust_lon(temp);
    } else if (s2 - EPSLN < HALF_PI) {
      lon = this.long0;
    }
  }
  p5.x = lon;
  p5.y = lat;
  return p5;
}
var names$9 = ["Sinusoidal", "sinu"];
var sinu = {
  init: init$9,
  forward: forward$9,
  inverse: inverse$9,
  names: names$9
};
function init$8() {
}
function forward$8(p5) {
  var lon = p5.x;
  var lat = p5.y;
  var delta_lon = adjust_lon(lon - this.long0);
  var theta = lat;
  var con = Math.PI * Math.sin(lat);
  while (true) {
    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
    theta += delta_theta;
    if (Math.abs(delta_theta) < EPSLN) {
      break;
    }
  }
  theta /= 2;
  if (Math.PI / 2 - Math.abs(lat) < EPSLN) {
    delta_lon = 0;
  }
  var x2 = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
  var y2 = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;
  p5.x = x2;
  p5.y = y2;
  return p5;
}
function inverse$8(p5) {
  var theta;
  var arg;
  p5.x -= this.x0;
  p5.y -= this.y0;
  arg = p5.y / (1.4142135623731 * this.a);
  if (Math.abs(arg) > 0.999999999999) {
    arg = 0.999999999999;
  }
  theta = Math.asin(arg);
  var lon = adjust_lon(this.long0 + p5.x / (0.900316316158 * this.a * Math.cos(theta)));
  if (lon < -Math.PI) {
    lon = -Math.PI;
  }
  if (lon > Math.PI) {
    lon = Math.PI;
  }
  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
  if (Math.abs(arg) > 1) {
    arg = 1;
  }
  var lat = Math.asin(arg);
  p5.x = lon;
  p5.y = lat;
  return p5;
}
var names$8 = ["Mollweide", "moll"];
var moll = {
  init: init$8,
  forward: forward$8,
  inverse: inverse$8,
  names: names$8
};
function init$7() {
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  this.lat2 = this.lat2 || this.lat1;
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e = Math.sqrt(this.es);
  this.e0 = e0fn(this.es);
  this.e1 = e1fn(this.es);
  this.e2 = e2fn(this.es);
  this.e3 = e3fn(this.es);
  this.sinphi = Math.sin(this.lat1);
  this.cosphi = Math.cos(this.lat1);
  this.ms1 = msfnz(this.e, this.sinphi, this.cosphi);
  this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1);
  if (Math.abs(this.lat1 - this.lat2) < EPSLN) {
    this.ns = this.sinphi;
  } else {
    this.sinphi = Math.sin(this.lat2);
    this.cosphi = Math.cos(this.lat2);
    this.ms2 = msfnz(this.e, this.sinphi, this.cosphi);
    this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2);
    this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
  }
  this.g = this.ml1 + this.ms1 / this.ns;
  this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
  this.rh = this.a * (this.g - this.ml0);
}
function forward$7(p5) {
  var lon = p5.x;
  var lat = p5.y;
  var rh1;
  if (this.sphere) {
    rh1 = this.a * (this.g - lat);
  } else {
    var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);
    rh1 = this.a * (this.g - ml);
  }
  var theta = this.ns * adjust_lon(lon - this.long0);
  var x2 = this.x0 + rh1 * Math.sin(theta);
  var y2 = this.y0 + this.rh - rh1 * Math.cos(theta);
  p5.x = x2;
  p5.y = y2;
  return p5;
}
function inverse$7(p5) {
  p5.x -= this.x0;
  p5.y = this.rh - p5.y + this.y0;
  var con, rh1, lat, lon;
  if (this.ns >= 0) {
    rh1 = Math.sqrt(p5.x * p5.x + p5.y * p5.y);
    con = 1;
  } else {
    rh1 = -Math.sqrt(p5.x * p5.x + p5.y * p5.y);
    con = -1;
  }
  var theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * p5.x, con * p5.y);
  }
  if (this.sphere) {
    lon = adjust_lon(this.long0 + theta / this.ns);
    lat = adjust_lat(this.g - rh1 / this.a);
    p5.x = lon;
    p5.y = lat;
    return p5;
  } else {
    var ml = this.g - rh1 / this.a;
    lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3);
    lon = adjust_lon(this.long0 + theta / this.ns);
    p5.x = lon;
    p5.y = lat;
    return p5;
  }
}
var names$7 = ["Equidistant_Conic", "eqdc"];
var eqdc = {
  init: init$7,
  forward: forward$7,
  inverse: inverse$7,
  names: names$7
};
function init$6() {
  this.R = this.a;
}
function forward$6(p5) {
  var lon = p5.x;
  var lat = p5.y;
  var dlon = adjust_lon(lon - this.long0);
  var x2, y2;
  if (Math.abs(lat) <= EPSLN) {
    x2 = this.x0 + this.R * dlon;
    y2 = this.y0;
  }
  var theta = asinz(2 * Math.abs(lat / Math.PI));
  if (Math.abs(dlon) <= EPSLN || Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
    x2 = this.x0;
    if (lat >= 0) {
      y2 = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
    } else {
      y2 = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
    }
  }
  var al = 0.5 * Math.abs(Math.PI / dlon - dlon / Math.PI);
  var asq = al * al;
  var sinth = Math.sin(theta);
  var costh = Math.cos(theta);
  var g2 = costh / (sinth + costh - 1);
  var gsq = g2 * g2;
  var m2 = g2 * (2 / sinth - 1);
  var msq = m2 * m2;
  var con = Math.PI * this.R * (al * (g2 - msq) + Math.sqrt(asq * (g2 - msq) * (g2 - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
  if (dlon < 0) {
    con = -con;
  }
  x2 = this.x0 + con;
  var q2 = asq + g2;
  con = Math.PI * this.R * (m2 * q2 - al * Math.sqrt((msq + asq) * (asq + 1) - q2 * q2)) / (msq + asq);
  if (lat >= 0) {
    y2 = this.y0 + con;
  } else {
    y2 = this.y0 - con;
  }
  p5.x = x2;
  p5.y = y2;
  return p5;
}
function inverse$6(p5) {
  var lon, lat;
  var xx, yy, xys, c1, c2, c3;
  var a1;
  var m1;
  var con;
  var th1;
  var d2;
  p5.x -= this.x0;
  p5.y -= this.y0;
  con = Math.PI * this.R;
  xx = p5.x / con;
  yy = p5.y / con;
  xys = xx * xx + yy * yy;
  c1 = -Math.abs(yy) * (1 + xys);
  c2 = c1 - 2 * yy * yy + xx * xx;
  c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
  d2 = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
  a1 = (c1 - c2 * c2 / 3 / c3) / c3;
  m1 = 2 * Math.sqrt(-a1 / 3);
  con = 3 * d2 / a1 / m1;
  if (Math.abs(con) > 1) {
    if (con >= 0) {
      con = 1;
    } else {
      con = -1;
    }
  }
  th1 = Math.acos(con) / 3;
  if (p5.y >= 0) {
    lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  } else {
    lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  }
  if (Math.abs(xx) < EPSLN) {
    lon = this.long0;
  } else {
    lon = adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
  }
  p5.x = lon;
  p5.y = lat;
  return p5;
}
var names$6 = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
var vandg = {
  init: init$6,
  forward: forward$6,
  inverse: inverse$6,
  names: names$6
};
function init$5() {
  this.sin_p12 = Math.sin(this.lat0);
  this.cos_p12 = Math.cos(this.lat0);
}
function forward$5(p5) {
  var lon = p5.x;
  var lat = p5.y;
  var sinphi = Math.sin(p5.y);
  var cosphi = Math.cos(p5.y);
  var dlon = adjust_lon(lon - this.long0);
  var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G2, H4, GH, Hs, c2, kp, cos_c, s2, s22, s3, s4, s5;
  if (this.sphere) {
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      p5.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);
      p5.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);
      return p5;
    } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      p5.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);
      p5.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);
      return p5;
    } else {
      cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
      c2 = Math.acos(cos_c);
      kp = c2 ? c2 / Math.sin(c2) : 1;
      p5.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
      p5.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
      return p5;
    }
  } else {
    e0 = e0fn(this.es);
    e1 = e1fn(this.es);
    e2 = e2fn(this.es);
    e3 = e3fn(this.es);
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      Ml = this.a * mlfn(e0, e1, e2, e3, lat);
      p5.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
      p5.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
      return p5;
    } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      Ml = this.a * mlfn(e0, e1, e2, e3, lat);
      p5.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
      p5.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
      return p5;
    } else {
      tanphi = sinphi / cosphi;
      Nl1 = gN(this.a, this.e, this.sin_p12);
      Nl = gN(this.a, this.e, sinphi);
      psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));
      Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));
      if (Az === 0) {
        s2 = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
      } else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {
        s2 = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
      } else {
        s2 = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));
      }
      G2 = this.e * this.sin_p12 / Math.sqrt(1 - this.es);
      H4 = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);
      GH = G2 * H4;
      Hs = H4 * H4;
      s22 = s2 * s2;
      s3 = s22 * s2;
      s4 = s3 * s2;
      s5 = s4 * s2;
      c2 = Nl1 * s2 * (1 - s22 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G2 * G2 * (1 - 7 * Hs)) - s5 / 48 * GH);
      p5.x = this.x0 + c2 * Math.sin(Az);
      p5.y = this.y0 + c2 * Math.cos(Az);
      return p5;
    }
  }
}
function inverse$5(p5) {
  p5.x -= this.x0;
  p5.y -= this.y0;
  var rh, z2, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M2, N1, psi, Az, cosAz, tmp, A2, B3, D2, Ee, F2, sinpsi;
  if (this.sphere) {
    rh = Math.sqrt(p5.x * p5.x + p5.y * p5.y);
    if (rh > 2 * HALF_PI * this.a) {
      return;
    }
    z2 = rh / this.a;
    sinz = Math.sin(z2);
    cosz = Math.cos(z2);
    lon = this.long0;
    if (Math.abs(rh) <= EPSLN) {
      lat = this.lat0;
    } else {
      lat = asinz(cosz * this.sin_p12 + p5.y * sinz * this.cos_p12 / rh);
      con = Math.abs(this.lat0) - HALF_PI;
      if (Math.abs(con) <= EPSLN) {
        if (this.lat0 >= 0) {
          lon = adjust_lon(this.long0 + Math.atan2(p5.x, -p5.y));
        } else {
          lon = adjust_lon(this.long0 - Math.atan2(-p5.x, p5.y));
        }
      } else {
        lon = adjust_lon(this.long0 + Math.atan2(p5.x * sinz, rh * this.cos_p12 * cosz - p5.y * this.sin_p12 * sinz));
      }
    }
    p5.x = lon;
    p5.y = lat;
    return p5;
  } else {
    e0 = e0fn(this.es);
    e1 = e1fn(this.es);
    e2 = e2fn(this.es);
    e3 = e3fn(this.es);
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      rh = Math.sqrt(p5.x * p5.x + p5.y * p5.y);
      M2 = Mlp - rh;
      lat = imlfn(M2 / this.a, e0, e1, e2, e3);
      lon = adjust_lon(this.long0 + Math.atan2(p5.x, -1 * p5.y));
      p5.x = lon;
      p5.y = lat;
      return p5;
    } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      rh = Math.sqrt(p5.x * p5.x + p5.y * p5.y);
      M2 = rh - Mlp;
      lat = imlfn(M2 / this.a, e0, e1, e2, e3);
      lon = adjust_lon(this.long0 + Math.atan2(p5.x, p5.y));
      p5.x = lon;
      p5.y = lat;
      return p5;
    } else {
      rh = Math.sqrt(p5.x * p5.x + p5.y * p5.y);
      Az = Math.atan2(p5.x, p5.y);
      N1 = gN(this.a, this.e, this.sin_p12);
      cosAz = Math.cos(Az);
      tmp = this.e * this.cos_p12 * cosAz;
      A2 = -tmp * tmp / (1 - this.es);
      B3 = 3 * this.es * (1 - A2) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);
      D2 = rh / N1;
      Ee = D2 - A2 * (1 + A2) * Math.pow(D2, 3) / 6 - B3 * (1 + 3 * A2) * Math.pow(D2, 4) / 24;
      F2 = 1 - A2 * Ee * Ee / 2 - D2 * Ee * Ee * Ee / 6;
      psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);
      lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));
      sinpsi = Math.sin(psi);
      lat = Math.atan2((sinpsi - this.es * F2 * this.sin_p12) * Math.tan(psi), sinpsi * (1 - this.es));
      p5.x = lon;
      p5.y = lat;
      return p5;
    }
  }
}
var names$5 = ["Azimuthal_Equidistant", "aeqd"];
var aeqd = {
  init: init$5,
  forward: forward$5,
  inverse: inverse$5,
  names: names$5
};
function init$4() {
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0);
}
function forward$4(p5) {
  var sinphi, cosphi;
  var dlon;
  var coslon;
  var ksp;
  var g2, x2, y2;
  var lon = p5.x;
  var lat = p5.y;
  dlon = adjust_lon(lon - this.long0);
  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);
  coslon = Math.cos(dlon);
  g2 = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;
  if (g2 > 0 || Math.abs(g2) <= EPSLN) {
    x2 = this.a * ksp * cosphi * Math.sin(dlon);
    y2 = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
  }
  p5.x = x2;
  p5.y = y2;
  return p5;
}
function inverse$4(p5) {
  var rh;
  var z2;
  var sinz, cosz;
  var con;
  var lon, lat;
  p5.x -= this.x0;
  p5.y -= this.y0;
  rh = Math.sqrt(p5.x * p5.x + p5.y * p5.y);
  z2 = asinz(rh / this.a);
  sinz = Math.sin(z2);
  cosz = Math.cos(z2);
  lon = this.long0;
  if (Math.abs(rh) <= EPSLN) {
    lat = this.lat0;
    p5.x = lon;
    p5.y = lat;
    return p5;
  }
  lat = asinz(cosz * this.sin_p14 + p5.y * sinz * this.cos_p14 / rh);
  con = Math.abs(this.lat0) - HALF_PI;
  if (Math.abs(con) <= EPSLN) {
    if (this.lat0 >= 0) {
      lon = adjust_lon(this.long0 + Math.atan2(p5.x, -p5.y));
    } else {
      lon = adjust_lon(this.long0 - Math.atan2(-p5.x, p5.y));
    }
    p5.x = lon;
    p5.y = lat;
    return p5;
  }
  lon = adjust_lon(this.long0 + Math.atan2(p5.x * sinz, rh * this.cos_p14 * cosz - p5.y * this.sin_p14 * sinz));
  p5.x = lon;
  p5.y = lat;
  return p5;
}
var names$4 = ["ortho"];
var ortho = {
  init: init$4,
  forward: forward$4,
  inverse: inverse$4,
  names: names$4
};
var FACE_ENUM = {
  FRONT: 1,
  RIGHT: 2,
  BACK: 3,
  LEFT: 4,
  TOP: 5,
  BOTTOM: 6
};
var AREA_ENUM = {
  AREA_0: 1,
  AREA_1: 2,
  AREA_2: 3,
  AREA_3: 4
};
function init$3() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || "Quadrilateralized Spherical Cube";
  if (this.lat0 >= HALF_PI - FORTPI / 2) {
    this.face = FACE_ENUM.TOP;
  } else if (this.lat0 <= -(HALF_PI - FORTPI / 2)) {
    this.face = FACE_ENUM.BOTTOM;
  } else if (Math.abs(this.long0) <= FORTPI) {
    this.face = FACE_ENUM.FRONT;
  } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {
    this.face = this.long0 > 0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;
  } else {
    this.face = FACE_ENUM.BACK;
  }
  if (this.es !== 0) {
    this.one_minus_f = 1 - (this.a - this.b) / this.a;
    this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;
  }
}
function forward$3(p5) {
  var xy = { x: 0, y: 0 };
  var lat, lon;
  var theta, phi;
  var t3, mu;
  var area2 = { value: 0 };
  p5.x -= this.long0;
  if (this.es !== 0) {
    lat = Math.atan(this.one_minus_f_squared * Math.tan(p5.y));
  } else {
    lat = p5.y;
  }
  lon = p5.x;
  if (this.face === FACE_ENUM.TOP) {
    phi = HALF_PI - lat;
    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
      area2.value = AREA_ENUM.AREA_0;
      theta = lon - HALF_PI;
    } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {
      area2.value = AREA_ENUM.AREA_1;
      theta = lon > 0 ? lon - SPI : lon + SPI;
    } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {
      area2.value = AREA_ENUM.AREA_2;
      theta = lon + HALF_PI;
    } else {
      area2.value = AREA_ENUM.AREA_3;
      theta = lon;
    }
  } else if (this.face === FACE_ENUM.BOTTOM) {
    phi = HALF_PI + lat;
    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
      area2.value = AREA_ENUM.AREA_0;
      theta = -lon + HALF_PI;
    } else if (lon < FORTPI && lon >= -FORTPI) {
      area2.value = AREA_ENUM.AREA_1;
      theta = -lon;
    } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {
      area2.value = AREA_ENUM.AREA_2;
      theta = -lon - HALF_PI;
    } else {
      area2.value = AREA_ENUM.AREA_3;
      theta = lon > 0 ? -lon + SPI : -lon - SPI;
    }
  } else {
    var q2, r2, s2;
    var sinlat, coslat;
    var sinlon, coslon;
    if (this.face === FACE_ENUM.RIGHT) {
      lon = qsc_shift_lon_origin(lon, +HALF_PI);
    } else if (this.face === FACE_ENUM.BACK) {
      lon = qsc_shift_lon_origin(lon, +SPI);
    } else if (this.face === FACE_ENUM.LEFT) {
      lon = qsc_shift_lon_origin(lon, -HALF_PI);
    }
    sinlat = Math.sin(lat);
    coslat = Math.cos(lat);
    sinlon = Math.sin(lon);
    coslon = Math.cos(lon);
    q2 = coslat * coslon;
    r2 = coslat * sinlon;
    s2 = sinlat;
    if (this.face === FACE_ENUM.FRONT) {
      phi = Math.acos(q2);
      theta = qsc_fwd_equat_face_theta(phi, s2, r2, area2);
    } else if (this.face === FACE_ENUM.RIGHT) {
      phi = Math.acos(r2);
      theta = qsc_fwd_equat_face_theta(phi, s2, -q2, area2);
    } else if (this.face === FACE_ENUM.BACK) {
      phi = Math.acos(-q2);
      theta = qsc_fwd_equat_face_theta(phi, s2, -r2, area2);
    } else if (this.face === FACE_ENUM.LEFT) {
      phi = Math.acos(-r2);
      theta = qsc_fwd_equat_face_theta(phi, s2, q2, area2);
    } else {
      phi = theta = 0;
      area2.value = AREA_ENUM.AREA_0;
    }
  }
  mu = Math.atan(12 / SPI * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));
  t3 = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));
  if (area2.value === AREA_ENUM.AREA_1) {
    mu += HALF_PI;
  } else if (area2.value === AREA_ENUM.AREA_2) {
    mu += SPI;
  } else if (area2.value === AREA_ENUM.AREA_3) {
    mu += 1.5 * SPI;
  }
  xy.x = t3 * Math.cos(mu);
  xy.y = t3 * Math.sin(mu);
  xy.x = xy.x * this.a + this.x0;
  xy.y = xy.y * this.a + this.y0;
  p5.x = xy.x;
  p5.y = xy.y;
  return p5;
}
function inverse$3(p5) {
  var lp = { lam: 0, phi: 0 };
  var mu, nu, cosmu, tannu;
  var tantheta, theta, cosphi, phi;
  var t3;
  var area2 = { value: 0 };
  p5.x = (p5.x - this.x0) / this.a;
  p5.y = (p5.y - this.y0) / this.a;
  nu = Math.atan(Math.sqrt(p5.x * p5.x + p5.y * p5.y));
  mu = Math.atan2(p5.y, p5.x);
  if (p5.x >= 0 && p5.x >= Math.abs(p5.y)) {
    area2.value = AREA_ENUM.AREA_0;
  } else if (p5.y >= 0 && p5.y >= Math.abs(p5.x)) {
    area2.value = AREA_ENUM.AREA_1;
    mu -= HALF_PI;
  } else if (p5.x < 0 && -p5.x >= Math.abs(p5.y)) {
    area2.value = AREA_ENUM.AREA_2;
    mu = mu < 0 ? mu + SPI : mu - SPI;
  } else {
    area2.value = AREA_ENUM.AREA_3;
    mu += HALF_PI;
  }
  t3 = SPI / 12 * Math.tan(mu);
  tantheta = Math.sin(t3) / (Math.cos(t3) - 1 / Math.sqrt(2));
  theta = Math.atan(tantheta);
  cosmu = Math.cos(mu);
  tannu = Math.tan(nu);
  cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));
  if (cosphi < -1) {
    cosphi = -1;
  } else if (cosphi > 1) {
    cosphi = 1;
  }
  if (this.face === FACE_ENUM.TOP) {
    phi = Math.acos(cosphi);
    lp.phi = HALF_PI - phi;
    if (area2.value === AREA_ENUM.AREA_0) {
      lp.lam = theta + HALF_PI;
    } else if (area2.value === AREA_ENUM.AREA_1) {
      lp.lam = theta < 0 ? theta + SPI : theta - SPI;
    } else if (area2.value === AREA_ENUM.AREA_2) {
      lp.lam = theta - HALF_PI;
    } else {
      lp.lam = theta;
    }
  } else if (this.face === FACE_ENUM.BOTTOM) {
    phi = Math.acos(cosphi);
    lp.phi = phi - HALF_PI;
    if (area2.value === AREA_ENUM.AREA_0) {
      lp.lam = -theta + HALF_PI;
    } else if (area2.value === AREA_ENUM.AREA_1) {
      lp.lam = -theta;
    } else if (area2.value === AREA_ENUM.AREA_2) {
      lp.lam = -theta - HALF_PI;
    } else {
      lp.lam = theta < 0 ? -theta - SPI : -theta + SPI;
    }
  } else {
    var q2, r2, s2;
    q2 = cosphi;
    t3 = q2 * q2;
    if (t3 >= 1) {
      s2 = 0;
    } else {
      s2 = Math.sqrt(1 - t3) * Math.sin(theta);
    }
    t3 += s2 * s2;
    if (t3 >= 1) {
      r2 = 0;
    } else {
      r2 = Math.sqrt(1 - t3);
    }
    if (area2.value === AREA_ENUM.AREA_1) {
      t3 = r2;
      r2 = -s2;
      s2 = t3;
    } else if (area2.value === AREA_ENUM.AREA_2) {
      r2 = -r2;
      s2 = -s2;
    } else if (area2.value === AREA_ENUM.AREA_3) {
      t3 = r2;
      r2 = s2;
      s2 = -t3;
    }
    if (this.face === FACE_ENUM.RIGHT) {
      t3 = q2;
      q2 = -r2;
      r2 = t3;
    } else if (this.face === FACE_ENUM.BACK) {
      q2 = -q2;
      r2 = -r2;
    } else if (this.face === FACE_ENUM.LEFT) {
      t3 = q2;
      q2 = r2;
      r2 = -t3;
    }
    lp.phi = Math.acos(-s2) - HALF_PI;
    lp.lam = Math.atan2(r2, q2);
    if (this.face === FACE_ENUM.RIGHT) {
      lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);
    } else if (this.face === FACE_ENUM.BACK) {
      lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);
    } else if (this.face === FACE_ENUM.LEFT) {
      lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);
    }
  }
  if (this.es !== 0) {
    var invert_sign;
    var tanphi, xa;
    invert_sign = lp.phi < 0 ? 1 : 0;
    tanphi = Math.tan(lp.phi);
    xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);
    lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));
    if (invert_sign) {
      lp.phi = -lp.phi;
    }
  }
  lp.lam += this.long0;
  p5.x = lp.lam;
  p5.y = lp.phi;
  return p5;
}
function qsc_fwd_equat_face_theta(phi, y2, x2, area2) {
  var theta;
  if (phi < EPSLN) {
    area2.value = AREA_ENUM.AREA_0;
    theta = 0;
  } else {
    theta = Math.atan2(y2, x2);
    if (Math.abs(theta) <= FORTPI) {
      area2.value = AREA_ENUM.AREA_0;
    } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {
      area2.value = AREA_ENUM.AREA_1;
      theta -= HALF_PI;
    } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {
      area2.value = AREA_ENUM.AREA_2;
      theta = theta >= 0 ? theta - SPI : theta + SPI;
    } else {
      area2.value = AREA_ENUM.AREA_3;
      theta += HALF_PI;
    }
  }
  return theta;
}
function qsc_shift_lon_origin(lon, offset2) {
  var slon = lon + offset2;
  if (slon < -SPI) {
    slon += TWO_PI;
  } else if (slon > +SPI) {
    slon -= TWO_PI;
  }
  return slon;
}
var names$3 = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
var qsc = {
  init: init$3,
  forward: forward$3,
  inverse: inverse$3,
  names: names$3
};
var COEFS_X = [
  [1, 22199e-21, -715515e-10, 31103e-10],
  [0.9986, -482243e-9, -24897e-9, -13309e-10],
  [0.9954, -83103e-8, -448605e-10, -986701e-12],
  [0.99, -135364e-8, -59661e-9, 36777e-10],
  [0.9822, -167442e-8, -449547e-11, -572411e-11],
  [0.973, -214868e-8, -903571e-10, 18736e-12],
  [0.96, -305085e-8, -900761e-10, 164917e-11],
  [0.9427, -382792e-8, -653386e-10, -26154e-10],
  [0.9216, -467746e-8, -10457e-8, 481243e-11],
  [0.8962, -536223e-8, -323831e-10, -543432e-11],
  [0.8679, -609363e-8, -113898e-9, 332484e-11],
  [0.835, -698325e-8, -640253e-10, 934959e-12],
  [0.7986, -755338e-8, -500009e-10, 935324e-12],
  [0.7597, -798324e-8, -35971e-9, -227626e-11],
  [0.7186, -851367e-8, -701149e-10, -86303e-10],
  [0.6732, -986209e-8, -199569e-9, 191974e-10],
  [0.6213, -0.010418, 883923e-10, 624051e-11],
  [0.5722, -906601e-8, 182e-6, 624051e-11],
  [0.5322, -677797e-8, 275608e-9, 624051e-11]
];
var COEFS_Y = [
  [-520417e-23, 0.0124, 121431e-23, -845284e-16],
  [0.062, 0.0124, -126793e-14, 422642e-15],
  [0.124, 0.0124, 507171e-14, -160604e-14],
  [0.186, 0.0123999, -190189e-13, 600152e-14],
  [0.248, 0.0124002, 710039e-13, -224e-10],
  [0.31, 0.0123992, -264997e-12, 835986e-13],
  [0.372, 0.0124029, 988983e-12, -311994e-12],
  [0.434, 0.0123893, -369093e-11, -435621e-12],
  [0.4958, 0.0123198, -102252e-10, -345523e-12],
  [0.5571, 0.0121916, -154081e-10, -582288e-12],
  [0.6176, 0.0119938, -241424e-10, -525327e-12],
  [0.6769, 0.011713, -320223e-10, -516405e-12],
  [0.7346, 0.0113541, -397684e-10, -609052e-12],
  [0.7903, 0.0109107, -489042e-10, -104739e-11],
  [0.8435, 0.0103431, -64615e-9, -140374e-14],
  [0.8936, 969686e-8, -64636e-9, -8547e-9],
  [0.9394, 840947e-8, -192841e-9, -42106e-10],
  [0.9761, 616527e-8, -256e-6, -42106e-10],
  [1, 328947e-8, -319159e-9, -42106e-10]
];
var FXC = 0.8487;
var FYC = 1.3523;
var C1 = R2D / 5;
var RC1 = 1 / C1;
var NODES = 18;
var poly3_val = function(coefs, x2) {
  return coefs[0] + x2 * (coefs[1] + x2 * (coefs[2] + x2 * coefs[3]));
};
var poly3_der = function(coefs, x2) {
  return coefs[1] + x2 * (2 * coefs[2] + x2 * 3 * coefs[3]);
};
function newton_rapshon(f_df, start2, max_err, iters) {
  var x2 = start2;
  for (; iters; --iters) {
    var upd = f_df(x2);
    x2 -= upd;
    if (Math.abs(upd) < max_err) {
      break;
    }
  }
  return x2;
}
function init$2() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.long0 = this.long0 || 0;
  this.es = 0;
  this.title = this.title || "Robinson";
}
function forward$2(ll) {
  var lon = adjust_lon(ll.x - this.long0);
  var dphi = Math.abs(ll.y);
  var i2 = Math.floor(dphi * C1);
  if (i2 < 0) {
    i2 = 0;
  } else if (i2 >= NODES) {
    i2 = NODES - 1;
  }
  dphi = R2D * (dphi - RC1 * i2);
  var xy = {
    x: poly3_val(COEFS_X[i2], dphi) * lon,
    y: poly3_val(COEFS_Y[i2], dphi)
  };
  if (ll.y < 0) {
    xy.y = -xy.y;
  }
  xy.x = xy.x * this.a * FXC + this.x0;
  xy.y = xy.y * this.a * FYC + this.y0;
  return xy;
}
function inverse$2(xy) {
  var ll = {
    x: (xy.x - this.x0) / (this.a * FXC),
    y: Math.abs(xy.y - this.y0) / (this.a * FYC)
  };
  if (ll.y >= 1) {
    ll.x /= COEFS_X[NODES][0];
    ll.y = xy.y < 0 ? -HALF_PI : HALF_PI;
  } else {
    var i2 = Math.floor(ll.y * NODES);
    if (i2 < 0) {
      i2 = 0;
    } else if (i2 >= NODES) {
      i2 = NODES - 1;
    }
    for (; ; ) {
      if (COEFS_Y[i2][0] > ll.y) {
        --i2;
      } else if (COEFS_Y[i2 + 1][0] <= ll.y) {
        ++i2;
      } else {
        break;
      }
    }
    var coefs = COEFS_Y[i2];
    var t3 = 5 * (ll.y - coefs[0]) / (COEFS_Y[i2 + 1][0] - coefs[0]);
    t3 = newton_rapshon(function(x2) {
      return (poly3_val(coefs, x2) - ll.y) / poly3_der(coefs, x2);
    }, t3, EPSLN, 100);
    ll.x /= poly3_val(COEFS_X[i2], t3);
    ll.y = (5 * i2 + t3) * D2R$1;
    if (xy.y < 0) {
      ll.y = -ll.y;
    }
  }
  ll.x = adjust_lon(ll.x + this.long0);
  return ll;
}
var names$2 = ["Robinson", "robin"];
var robin = {
  init: init$2,
  forward: forward$2,
  inverse: inverse$2,
  names: names$2
};
function init$1() {
  this.name = "geocent";
}
function forward$1(p5) {
  var point = geodeticToGeocentric(p5, this.es, this.a);
  return point;
}
function inverse$1(p5) {
  var point = geocentricToGeodetic(p5, this.es, this.a, this.b);
  return point;
}
var names$1 = ["Geocentric", "geocentric", "geocent", "Geocent"];
var geocent = {
  init: init$1,
  forward: forward$1,
  inverse: inverse$1,
  names: names$1
};
var mode = {
  N_POLE: 0,
  S_POLE: 1,
  EQUIT: 2,
  OBLIQ: 3
};
var params = {
  h: { def: 1e5, num: true },
  azi: { def: 0, num: true, degrees: true },
  tilt: { def: 0, num: true, degrees: true },
  long0: { def: 0, num: true },
  lat0: { def: 0, num: true }
};
function init() {
  Object.keys(params).forEach(function(p5) {
    if (typeof this[p5] === "undefined") {
      this[p5] = params[p5].def;
    } else if (params[p5].num && isNaN(this[p5])) {
      throw new Error("Invalid parameter value, must be numeric " + p5 + " = " + this[p5]);
    } else if (params[p5].num) {
      this[p5] = parseFloat(this[p5]);
    }
    if (params[p5].degrees) {
      this[p5] = this[p5] * D2R$1;
    }
  }.bind(this));
  if (Math.abs(Math.abs(this.lat0) - HALF_PI) < EPSLN) {
    this.mode = this.lat0 < 0 ? mode.S_POLE : mode.N_POLE;
  } else if (Math.abs(this.lat0) < EPSLN) {
    this.mode = mode.EQUIT;
  } else {
    this.mode = mode.OBLIQ;
    this.sinph0 = Math.sin(this.lat0);
    this.cosph0 = Math.cos(this.lat0);
  }
  this.pn1 = this.h / this.a;
  if (this.pn1 <= 0 || this.pn1 > 1e10) {
    throw new Error("Invalid height");
  }
  this.p = 1 + this.pn1;
  this.rp = 1 / this.p;
  this.h1 = 1 / this.pn1;
  this.pfact = (this.p + 1) * this.h1;
  this.es = 0;
  var omega = this.tilt;
  var gamma = this.azi;
  this.cg = Math.cos(gamma);
  this.sg = Math.sin(gamma);
  this.cw = Math.cos(omega);
  this.sw = Math.sin(omega);
}
function forward(p5) {
  p5.x -= this.long0;
  var sinphi = Math.sin(p5.y);
  var cosphi = Math.cos(p5.y);
  var coslam = Math.cos(p5.x);
  var x2, y2;
  switch (this.mode) {
    case mode.OBLIQ:
      y2 = this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
      break;
    case mode.EQUIT:
      y2 = cosphi * coslam;
      break;
    case mode.S_POLE:
      y2 = -sinphi;
      break;
    case mode.N_POLE:
      y2 = sinphi;
      break;
  }
  y2 = this.pn1 / (this.p - y2);
  x2 = y2 * cosphi * Math.sin(p5.x);
  switch (this.mode) {
    case mode.OBLIQ:
      y2 *= this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
      break;
    case mode.EQUIT:
      y2 *= sinphi;
      break;
    case mode.N_POLE:
      y2 *= -(cosphi * coslam);
      break;
    case mode.S_POLE:
      y2 *= cosphi * coslam;
      break;
  }
  var yt2, ba;
  yt2 = y2 * this.cg + x2 * this.sg;
  ba = 1 / (yt2 * this.sw * this.h1 + this.cw);
  x2 = (x2 * this.cg - y2 * this.sg) * this.cw * ba;
  y2 = yt2 * ba;
  p5.x = x2 * this.a;
  p5.y = y2 * this.a;
  return p5;
}
function inverse(p5) {
  p5.x /= this.a;
  p5.y /= this.a;
  var r2 = { x: p5.x, y: p5.y };
  var bm, bq, yt2;
  yt2 = 1 / (this.pn1 - p5.y * this.sw);
  bm = this.pn1 * p5.x * yt2;
  bq = this.pn1 * p5.y * this.cw * yt2;
  p5.x = bm * this.cg + bq * this.sg;
  p5.y = bq * this.cg - bm * this.sg;
  var rh = hypot(p5.x, p5.y);
  if (Math.abs(rh) < EPSLN) {
    r2.x = 0;
    r2.y = p5.y;
  } else {
    var cosz, sinz;
    sinz = 1 - rh * rh * this.pfact;
    sinz = (this.p - Math.sqrt(sinz)) / (this.pn1 / rh + rh / this.pn1);
    cosz = Math.sqrt(1 - sinz * sinz);
    switch (this.mode) {
      case mode.OBLIQ:
        r2.y = Math.asin(cosz * this.sinph0 + p5.y * sinz * this.cosph0 / rh);
        p5.y = (cosz - this.sinph0 * Math.sin(r2.y)) * rh;
        p5.x *= sinz * this.cosph0;
        break;
      case mode.EQUIT:
        r2.y = Math.asin(p5.y * sinz / rh);
        p5.y = cosz * rh;
        p5.x *= sinz;
        break;
      case mode.N_POLE:
        r2.y = Math.asin(cosz);
        p5.y = -p5.y;
        break;
      case mode.S_POLE:
        r2.y = -Math.asin(cosz);
        break;
    }
    r2.x = Math.atan2(p5.x, p5.y);
  }
  p5.x = r2.x + this.long0;
  p5.y = r2.y;
  return p5;
}
var names = ["Tilted_Perspective", "tpers"];
var tpers = {
  init,
  forward,
  inverse,
  names
};
function includedProjections(proj42) {
  proj42.Proj.projections.add(tmerc);
  proj42.Proj.projections.add(etmerc);
  proj42.Proj.projections.add(utm);
  proj42.Proj.projections.add(sterea);
  proj42.Proj.projections.add(stere);
  proj42.Proj.projections.add(somerc);
  proj42.Proj.projections.add(omerc);
  proj42.Proj.projections.add(lcc);
  proj42.Proj.projections.add(krovak);
  proj42.Proj.projections.add(cass);
  proj42.Proj.projections.add(laea);
  proj42.Proj.projections.add(aea);
  proj42.Proj.projections.add(gnom);
  proj42.Proj.projections.add(cea);
  proj42.Proj.projections.add(eqc);
  proj42.Proj.projections.add(poly);
  proj42.Proj.projections.add(nzmg);
  proj42.Proj.projections.add(mill);
  proj42.Proj.projections.add(sinu);
  proj42.Proj.projections.add(moll);
  proj42.Proj.projections.add(eqdc);
  proj42.Proj.projections.add(vandg);
  proj42.Proj.projections.add(aeqd);
  proj42.Proj.projections.add(ortho);
  proj42.Proj.projections.add(qsc);
  proj42.Proj.projections.add(robin);
  proj42.Proj.projections.add(geocent);
  proj42.Proj.projections.add(tpers);
}
proj4.defaultDatum = "WGS84";
proj4.Proj = Projection$1;
proj4.WGS84 = new proj4.Proj("WGS84");
proj4.Point = Point$2;
proj4.toPoint = common$1;
proj4.defs = defs;
proj4.nadgrid = nadgrid;
proj4.transform = transform$2;
proj4.mgrs = mgrs;
proj4.version = "__VERSION__";
includedProjections(proj4);
function register(proj42) {
  const projCodes = Object.keys(proj42.defs);
  const len = projCodes.length;
  let i2, j2;
  for (i2 = 0; i2 < len; ++i2) {
    const code = projCodes[i2];
    if (!get$4(code)) {
      const def = proj42.defs(code);
      let units2 = def.units;
      if (!units2 && def.projName === "longlat") {
        units2 = "degrees";
      }
      addProjection(new Projection$2({
        code,
        axisOrientation: def.axis,
        metersPerUnit: def.to_meter,
        units: units2
      }));
    }
  }
  for (i2 = 0; i2 < len; ++i2) {
    const code1 = projCodes[i2];
    const proj1 = get$4(code1);
    for (j2 = 0; j2 < len; ++j2) {
      const code2 = projCodes[j2];
      const proj2 = get$4(code2);
      if (!get$5(code1, code2)) {
        if (proj42.defs[code1] === proj42.defs[code2]) {
          addEquivalentProjections([proj1, proj2]);
        } else {
          const transform2 = proj42(code1, code2);
          addCoordinateTransforms(proj1, proj2, createSafeCoordinateTransform(proj1, proj2, transform2.forward), createSafeCoordinateTransform(proj2, proj1, transform2.inverse));
        }
      }
    }
  }
}
const _sfc_main$11 = {
  name: "ol-projection-register",
  setup(props) {
    const {
      projectionName,
      projectionDef,
      projectionExtent
    } = toRefs(props);
    proj4.defs(projectionName.value, projectionDef.value);
    register(proj4);
    const projection = new Projection$2({
      code: projectionName.value,
      extent: projectionExtent.value
    });
    return {
      projection
    };
  },
  props: {
    projectionName: {
      type: String
    },
    projectionDef: {
      type: String
    },
    projectionExtent: {
      type: Array
    }
  }
};
function _sfc_render$11(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var Projection = /* @__PURE__ */ _export_sfc(_sfc_main$11, [["render", _sfc_render$11]]);
function install$8(app) {
  if (install$8.installed) {
    return;
  }
  install$8.installed = true;
  app.component(Map$2.name, Map$2);
  app.component(View.name, View);
  app.component(Feature.name, Feature);
  app.component(Overlay.name, Overlay);
  app.component(GeoLocation.name, GeoLocation);
  app.component(Projection.name, Projection);
}
var Map$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": install$8,
  install: install$8,
  Map: Map$2,
  View,
  Feature,
  Overlay,
  GeoLocation,
  Projection
}, Symbol.toStringTag, { value: "Module" }));
var TileProperty = {
  PRELOAD: "preload",
  USE_INTERIM_TILES_ON_ERROR: "useInterimTilesOnError"
};
class BaseTileLayer extends Layer {
  constructor(options) {
    options = options ? options : {};
    const baseOptions = Object.assign({}, options);
    delete baseOptions.preload;
    delete baseOptions.useInterimTilesOnError;
    super(baseOptions);
    this.on;
    this.once;
    this.un;
    this.setPreload(options.preload !== void 0 ? options.preload : 0);
    this.setUseInterimTilesOnError(options.useInterimTilesOnError !== void 0 ? options.useInterimTilesOnError : true);
  }
  getPreload() {
    return this.get(TileProperty.PRELOAD);
  }
  setPreload(preload) {
    this.set(TileProperty.PRELOAD, preload);
  }
  getUseInterimTilesOnError() {
    return this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR);
  }
  setUseInterimTilesOnError(useInterimTilesOnError) {
    this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
  }
  getData(pixel) {
    return super.getData(pixel);
  }
}
var ImageState = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3,
  EMPTY: 4
};
class LayerRenderer extends Observable {
  constructor(layer) {
    super();
    this.ready = true;
    this.boundHandleImageChange_ = this.handleImageChange_.bind(this);
    this.layer_ = layer;
    this.declutterExecutorGroup = null;
  }
  getFeatures(pixel) {
    return abstract();
  }
  getData(pixel) {
    return null;
  }
  prepareFrame(frameState) {
    return abstract();
  }
  renderFrame(frameState, target) {
    return abstract();
  }
  loadedTileCallback(tiles, zoom, tile2) {
    if (!tiles[zoom]) {
      tiles[zoom] = {};
    }
    tiles[zoom][tile2.tileCoord.toString()] = tile2;
    return void 0;
  }
  createLoadedTileFinder(source, projection, tiles) {
    return (zoom, tileRange) => {
      const callback = this.loadedTileCallback.bind(this, tiles, zoom);
      return source.forEachLoadedTile(projection, zoom, tileRange, callback);
    };
  }
  forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {
    return void 0;
  }
  getLayer() {
    return this.layer_;
  }
  handleFontsChanged() {
  }
  handleImageChange_(event) {
    const image2 = event.target;
    if (image2.getState() === ImageState.LOADED) {
      this.renderIfReadyAndVisible();
    }
  }
  loadImage(image2) {
    let imageState = image2.getState();
    if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {
      image2.addEventListener(EventType.CHANGE, this.boundHandleImageChange_);
    }
    if (imageState == ImageState.IDLE) {
      image2.load();
      imageState = image2.getState();
    }
    return imageState == ImageState.LOADED;
  }
  renderIfReadyAndVisible() {
    const layer = this.getLayer();
    if (layer && layer.getVisible() && layer.getSourceState() === "ready") {
      layer.changed();
    }
  }
  disposeInternal() {
    delete this.layer_;
    super.disposeInternal();
  }
}
const canvasPool$1 = [];
let pixelContext$1 = null;
function createPixelContext$1() {
  const canvas = document.createElement("canvas");
  canvas.width = 1;
  canvas.height = 1;
  pixelContext$1 = canvas.getContext("2d");
}
class CanvasLayerRenderer extends LayerRenderer {
  constructor(layer) {
    super(layer);
    this.container = null;
    this.renderedResolution;
    this.tempTransform = create$7();
    this.pixelTransform = create$7();
    this.inversePixelTransform = create$7();
    this.context = null;
    this.containerReused = false;
    this.pixelContext_ = null;
    this.frameState = null;
  }
  getImageData(image2, col, row) {
    if (!pixelContext$1) {
      createPixelContext$1();
    }
    pixelContext$1.clearRect(0, 0, 1, 1);
    let data2;
    try {
      pixelContext$1.drawImage(image2, col, row, 1, 1, 0, 0, 1, 1);
      data2 = pixelContext$1.getImageData(0, 0, 1, 1).data;
    } catch (err2) {
      pixelContext$1 = null;
      return null;
    }
    return data2;
  }
  getBackground(frameState) {
    const layer = this.getLayer();
    let background = layer.getBackground();
    if (typeof background === "function") {
      background = background(frameState.viewState.resolution);
    }
    return background || void 0;
  }
  useContainer(target, transform2, backgroundColor2) {
    const layerClassName = this.getLayer().getClassName();
    let container, context2;
    if (target && target.className === layerClassName && (!backgroundColor2 || target && target.style.backgroundColor && equals$3(asArray(target.style.backgroundColor), asArray(backgroundColor2)))) {
      const canvas = target.firstElementChild;
      if (canvas instanceof HTMLCanvasElement) {
        context2 = canvas.getContext("2d");
      }
    }
    if (context2 && context2.canvas.style.transform === transform2) {
      this.container = target;
      this.context = context2;
      this.containerReused = true;
    } else if (this.containerReused) {
      this.container = null;
      this.context = null;
      this.containerReused = false;
    }
    if (!this.container) {
      container = document.createElement("div");
      container.className = layerClassName;
      let style2 = container.style;
      style2.position = "absolute";
      style2.width = "100%";
      style2.height = "100%";
      context2 = createCanvasContext2D();
      const canvas = context2.canvas;
      container.appendChild(canvas);
      style2 = canvas.style;
      style2.position = "absolute";
      style2.left = "0";
      style2.transformOrigin = "top left";
      this.container = container;
      this.context = context2;
    }
    if (!this.containerReused && backgroundColor2 && !this.container.style.backgroundColor) {
      this.container.style.backgroundColor = backgroundColor2;
    }
  }
  clipUnrotated(context2, frameState, extent2) {
    const topLeft = getTopLeft(extent2);
    const topRight = getTopRight(extent2);
    const bottomRight = getBottomRight(extent2);
    const bottomLeft = getBottomLeft(extent2);
    apply$5(frameState.coordinateToPixelTransform, topLeft);
    apply$5(frameState.coordinateToPixelTransform, topRight);
    apply$5(frameState.coordinateToPixelTransform, bottomRight);
    apply$5(frameState.coordinateToPixelTransform, bottomLeft);
    const inverted = this.inversePixelTransform;
    apply$5(inverted, topLeft);
    apply$5(inverted, topRight);
    apply$5(inverted, bottomRight);
    apply$5(inverted, bottomLeft);
    context2.save();
    context2.beginPath();
    context2.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));
    context2.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));
    context2.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));
    context2.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));
    context2.clip();
  }
  dispatchRenderEvent_(type, context2, frameState) {
    const layer = this.getLayer();
    if (layer.hasListener(type)) {
      const event = new RenderEvent(type, this.inversePixelTransform, frameState, context2);
      layer.dispatchEvent(event);
    }
  }
  preRender(context2, frameState) {
    this.frameState = frameState;
    this.dispatchRenderEvent_(RenderEventType.PRERENDER, context2, frameState);
  }
  postRender(context2, frameState) {
    this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context2, frameState);
  }
  getRenderTransform(center, resolution, rotation, pixelRatio, width, height, offsetX) {
    const dx1 = width / 2;
    const dy1 = height / 2;
    const sx = pixelRatio / resolution;
    const sy = -sx;
    const dx2 = -center[0] + offsetX;
    const dy2 = -center[1];
    return compose(this.tempTransform, dx1, dy1, sx, sy, -rotation, dx2, dy2);
  }
  disposeInternal() {
    delete this.frameState;
    super.disposeInternal();
  }
}
class Tile extends Target {
  constructor(tileCoord, state, options) {
    super();
    options = options ? options : {};
    this.tileCoord = tileCoord;
    this.state = state;
    this.interimTile = null;
    this.key = "";
    this.transition_ = options.transition === void 0 ? 250 : options.transition;
    this.transitionStarts_ = {};
    this.interpolate = !!options.interpolate;
  }
  changed() {
    this.dispatchEvent(EventType.CHANGE);
  }
  release() {
    if (this.state === TileState.ERROR) {
      this.setState(TileState.EMPTY);
    }
  }
  getKey() {
    return this.key + "/" + this.tileCoord;
  }
  getInterimTile() {
    if (!this.interimTile) {
      return this;
    }
    let tile2 = this.interimTile;
    do {
      if (tile2.getState() == TileState.LOADED) {
        this.transition_ = 0;
        return tile2;
      }
      tile2 = tile2.interimTile;
    } while (tile2);
    return this;
  }
  refreshInterimChain() {
    if (!this.interimTile) {
      return;
    }
    let tile2 = this.interimTile;
    let prev = this;
    do {
      if (tile2.getState() == TileState.LOADED) {
        tile2.interimTile = null;
        break;
      } else if (tile2.getState() == TileState.LOADING) {
        prev = tile2;
      } else if (tile2.getState() == TileState.IDLE) {
        prev.interimTile = tile2.interimTile;
      } else {
        prev = tile2;
      }
      tile2 = prev.interimTile;
    } while (tile2);
  }
  getTileCoord() {
    return this.tileCoord;
  }
  getState() {
    return this.state;
  }
  setState(state) {
    if (this.state !== TileState.ERROR && this.state > state) {
      throw new Error("Tile load sequence violation");
    }
    this.state = state;
    this.changed();
  }
  load() {
    abstract();
  }
  getAlpha(id, time2) {
    if (!this.transition_) {
      return 1;
    }
    let start2 = this.transitionStarts_[id];
    if (!start2) {
      start2 = time2;
      this.transitionStarts_[id] = start2;
    } else if (start2 === -1) {
      return 1;
    }
    const delta = time2 - start2 + 1e3 / 60;
    if (delta >= this.transition_) {
      return 1;
    }
    return easeIn(delta / this.transition_);
  }
  inTransition(id) {
    if (!this.transition_) {
      return false;
    }
    return this.transitionStarts_[id] !== -1;
  }
  endTransition(id) {
    if (this.transition_) {
      this.transitionStarts_[id] = -1;
    }
  }
}
class ImageBase extends Target {
  constructor(extent2, resolution, pixelRatio, state) {
    super();
    this.extent = extent2;
    this.pixelRatio_ = pixelRatio;
    this.resolution = resolution;
    this.state = state;
  }
  changed() {
    this.dispatchEvent(EventType.CHANGE);
  }
  getExtent() {
    return this.extent;
  }
  getImage() {
    return abstract();
  }
  getPixelRatio() {
    return this.pixelRatio_;
  }
  getResolution() {
    return this.resolution;
  }
  getState() {
    return this.state;
  }
  load() {
    abstract();
  }
}
class ImageWrapper extends ImageBase {
  constructor(extent2, resolution, pixelRatio, src, crossOrigin, imageLoadFunction) {
    super(extent2, resolution, pixelRatio, ImageState.IDLE);
    this.src_ = src;
    this.image_ = new Image();
    if (crossOrigin !== null) {
      this.image_.crossOrigin = crossOrigin;
    }
    this.unlisten_ = null;
    this.state = ImageState.IDLE;
    this.imageLoadFunction_ = imageLoadFunction;
  }
  getImage() {
    return this.image_;
  }
  handleImageError_() {
    this.state = ImageState.ERROR;
    this.unlistenImage_();
    this.changed();
  }
  handleImageLoad_() {
    if (this.resolution === void 0) {
      this.resolution = getHeight(this.extent) / this.image_.height;
    }
    this.state = ImageState.LOADED;
    this.unlistenImage_();
    this.changed();
  }
  load() {
    if (this.state == ImageState.IDLE || this.state == ImageState.ERROR) {
      this.state = ImageState.LOADING;
      this.changed();
      this.imageLoadFunction_(this, this.src_);
      this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
    }
  }
  setImage(image2) {
    this.image_ = image2;
    this.resolution = getHeight(this.extent) / this.image_.height;
  }
  unlistenImage_() {
    if (this.unlisten_) {
      this.unlisten_();
      this.unlisten_ = null;
    }
  }
}
function listenImage(image2, loadHandler, errorHandler) {
  const img = image2;
  let listening = true;
  let decoding = false;
  let loaded = false;
  const listenerKeys = [
    listenOnce(img, EventType.LOAD, function() {
      loaded = true;
      if (!decoding) {
        loadHandler();
      }
    })
  ];
  if (img.src && IMAGE_DECODE) {
    decoding = true;
    img.decode().then(function() {
      if (listening) {
        loadHandler();
      }
    }).catch(function(error) {
      if (listening) {
        if (loaded) {
          loadHandler();
        } else {
          errorHandler();
        }
      }
    });
  } else {
    listenerKeys.push(listenOnce(img, EventType.ERROR, errorHandler));
  }
  return function unlisten() {
    listening = false;
    listenerKeys.forEach(unlistenByKey);
  };
}
class ImageTile extends Tile {
  constructor(tileCoord, state, src, crossOrigin, tileLoadFunction, options) {
    super(tileCoord, state, options);
    this.crossOrigin_ = crossOrigin;
    this.src_ = src;
    this.key = src;
    this.image_ = new Image();
    if (crossOrigin !== null) {
      this.image_.crossOrigin = crossOrigin;
    }
    this.unlisten_ = null;
    this.tileLoadFunction_ = tileLoadFunction;
  }
  getImage() {
    return this.image_;
  }
  setImage(element) {
    this.image_ = element;
    this.state = TileState.LOADED;
    this.unlistenImage_();
    this.changed();
  }
  handleImageError_() {
    this.state = TileState.ERROR;
    this.unlistenImage_();
    this.image_ = getBlankImage();
    this.changed();
  }
  handleImageLoad_() {
    const image2 = this.image_;
    if (image2.naturalWidth && image2.naturalHeight) {
      this.state = TileState.LOADED;
    } else {
      this.state = TileState.EMPTY;
    }
    this.unlistenImage_();
    this.changed();
  }
  load() {
    if (this.state == TileState.ERROR) {
      this.state = TileState.IDLE;
      this.image_ = new Image();
      if (this.crossOrigin_ !== null) {
        this.image_.crossOrigin = this.crossOrigin_;
      }
    }
    if (this.state == TileState.IDLE) {
      this.state = TileState.LOADING;
      this.changed();
      this.tileLoadFunction_(this, this.src_);
      this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
    }
  }
  unlistenImage_() {
    if (this.unlisten_) {
      this.unlisten_();
      this.unlisten_ = null;
    }
  }
}
function getBlankImage() {
  const ctx = createCanvasContext2D(1, 1);
  ctx.fillStyle = "rgba(0,0,0,0)";
  ctx.fillRect(0, 0, 1, 1);
  return ctx.canvas;
}
const ERROR_THRESHOLD = 0.5;
const MAX_SUBDIVISION = 10;
const MAX_TRIANGLE_WIDTH = 0.25;
class Triangulation {
  constructor(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold, destinationResolution) {
    this.sourceProj_ = sourceProj;
    this.targetProj_ = targetProj;
    let transformInvCache = {};
    const transformInv = getTransform(this.targetProj_, this.sourceProj_);
    this.transformInv_ = function(c2) {
      const key = c2[0] + "/" + c2[1];
      if (!transformInvCache[key]) {
        transformInvCache[key] = transformInv(c2);
      }
      return transformInvCache[key];
    };
    this.maxSourceExtent_ = maxSourceExtent;
    this.errorThresholdSquared_ = errorThreshold * errorThreshold;
    this.triangles_ = [];
    this.wrapsXInSource_ = false;
    this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && getWidth(maxSourceExtent) == getWidth(this.sourceProj_.getExtent());
    this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? getWidth(this.sourceProj_.getExtent()) : null;
    this.targetWorldWidth_ = this.targetProj_.getExtent() ? getWidth(this.targetProj_.getExtent()) : null;
    const destinationTopLeft = getTopLeft(targetExtent);
    const destinationTopRight = getTopRight(targetExtent);
    const destinationBottomRight = getBottomRight(targetExtent);
    const destinationBottomLeft = getBottomLeft(targetExtent);
    const sourceTopLeft = this.transformInv_(destinationTopLeft);
    const sourceTopRight = this.transformInv_(destinationTopRight);
    const sourceBottomRight = this.transformInv_(destinationBottomRight);
    const sourceBottomLeft = this.transformInv_(destinationBottomLeft);
    const maxSubdivision = MAX_SUBDIVISION + (destinationResolution ? Math.max(0, Math.ceil(Math.log2(getArea(targetExtent) / (destinationResolution * destinationResolution * 256 * 256)))) : 0);
    this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, maxSubdivision);
    if (this.wrapsXInSource_) {
      let leftBound = Infinity;
      this.triangles_.forEach(function(triangle, i2, arr) {
        leftBound = Math.min(leftBound, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);
      });
      this.triangles_.forEach((triangle) => {
        if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) - leftBound > this.sourceWorldWidth_ / 2) {
          const newTriangle = [
            [triangle.source[0][0], triangle.source[0][1]],
            [triangle.source[1][0], triangle.source[1][1]],
            [triangle.source[2][0], triangle.source[2][1]]
          ];
          if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {
            newTriangle[0][0] -= this.sourceWorldWidth_;
          }
          if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {
            newTriangle[1][0] -= this.sourceWorldWidth_;
          }
          if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {
            newTriangle[2][0] -= this.sourceWorldWidth_;
          }
          const minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
          const maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
          if (maxX - minX < this.sourceWorldWidth_ / 2) {
            triangle.source = newTriangle;
          }
        }
      });
    }
    transformInvCache = {};
  }
  addTriangle_(a2, b2, c2, aSrc, bSrc, cSrc) {
    this.triangles_.push({
      source: [aSrc, bSrc, cSrc],
      target: [a2, b2, c2]
    });
  }
  addQuad_(a2, b2, c2, d2, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {
    const sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);
    const sourceCoverageX = this.sourceWorldWidth_ ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_ : null;
    const sourceWorldWidth = this.sourceWorldWidth_;
    const wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;
    let needsSubdivision = false;
    if (maxSubdivision > 0) {
      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
        const targetQuadExtent = boundingExtent([a2, b2, c2, d2]);
        const targetCoverageX = getWidth(targetQuadExtent) / this.targetWorldWidth_;
        needsSubdivision = targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
      }
      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {
        needsSubdivision = sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
      }
    }
    if (!needsSubdivision && this.maxSourceExtent_) {
      if (isFinite(sourceQuadExtent[0]) && isFinite(sourceQuadExtent[1]) && isFinite(sourceQuadExtent[2]) && isFinite(sourceQuadExtent[3])) {
        if (!intersects$2(sourceQuadExtent, this.maxSourceExtent_)) {
          return;
        }
      }
    }
    let isNotFinite = 0;
    if (!needsSubdivision) {
      if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {
        if (maxSubdivision > 0) {
          needsSubdivision = true;
        } else {
          isNotFinite = (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) + (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) + (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) + (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);
          if (isNotFinite != 1 && isNotFinite != 2 && isNotFinite != 4 && isNotFinite != 8) {
            return;
          }
        }
      }
    }
    if (maxSubdivision > 0) {
      if (!needsSubdivision) {
        const center = [(a2[0] + c2[0]) / 2, (a2[1] + c2[1]) / 2];
        const centerSrc = this.transformInv_(center);
        let dx;
        if (wrapsX) {
          const centerSrcEstimX = (modulo(aSrc[0], sourceWorldWidth) + modulo(cSrc[0], sourceWorldWidth)) / 2;
          dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);
        } else {
          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];
        }
        const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];
        const centerSrcErrorSquared = dx * dx + dy * dy;
        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;
      }
      if (needsSubdivision) {
        if (Math.abs(a2[0] - c2[0]) <= Math.abs(a2[1] - c2[1])) {
          const bc = [(b2[0] + c2[0]) / 2, (b2[1] + c2[1]) / 2];
          const bcSrc = this.transformInv_(bc);
          const da = [(d2[0] + a2[0]) / 2, (d2[1] + a2[1]) / 2];
          const daSrc = this.transformInv_(da);
          this.addQuad_(a2, b2, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);
          this.addQuad_(da, bc, c2, d2, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);
        } else {
          const ab = [(a2[0] + b2[0]) / 2, (a2[1] + b2[1]) / 2];
          const abSrc = this.transformInv_(ab);
          const cd = [(c2[0] + d2[0]) / 2, (c2[1] + d2[1]) / 2];
          const cdSrc = this.transformInv_(cd);
          this.addQuad_(a2, ab, cd, d2, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);
          this.addQuad_(ab, b2, c2, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);
        }
        return;
      }
    }
    if (wrapsX) {
      if (!this.canWrapXInSource_) {
        return;
      }
      this.wrapsXInSource_ = true;
    }
    if ((isNotFinite & 11) == 0) {
      this.addTriangle_(a2, c2, d2, aSrc, cSrc, dSrc);
    }
    if ((isNotFinite & 14) == 0) {
      this.addTriangle_(a2, c2, b2, aSrc, cSrc, bSrc);
    }
    if (isNotFinite) {
      if ((isNotFinite & 13) == 0) {
        this.addTriangle_(b2, d2, a2, bSrc, dSrc, aSrc);
      }
      if ((isNotFinite & 7) == 0) {
        this.addTriangle_(b2, d2, c2, bSrc, dSrc, cSrc);
      }
    }
  }
  calculateSourceExtent() {
    const extent2 = createEmpty();
    this.triangles_.forEach(function(triangle, i2, arr) {
      const src = triangle.source;
      extendCoordinate(extent2, src[0]);
      extendCoordinate(extent2, src[1]);
      extendCoordinate(extent2, src[2]);
    });
    return extent2;
  }
  getTriangles() {
    return this.triangles_;
  }
}
let brokenDiagonalRendering_;
const canvasPool = [];
function drawTestTriangle(ctx, u1, v1, u2, v2) {
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(u1, v1);
  ctx.lineTo(u2, v2);
  ctx.closePath();
  ctx.save();
  ctx.clip();
  ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));
  ctx.restore();
}
function verifyBrokenDiagonalRendering(data2, offset2) {
  return Math.abs(data2[offset2 * 4] - 210) > 2 || Math.abs(data2[offset2 * 4 + 3] - 0.75 * 255) > 2;
}
function isBrokenDiagonalRendering() {
  if (brokenDiagonalRendering_ === void 0) {
    const ctx = createCanvasContext2D(6, 6, canvasPool);
    ctx.globalCompositeOperation = "lighter";
    ctx.fillStyle = "rgba(210, 0, 0, 0.75)";
    drawTestTriangle(ctx, 4, 5, 4, 0);
    drawTestTriangle(ctx, 4, 5, 0, 5);
    const data2 = ctx.getImageData(0, 0, 3, 3).data;
    brokenDiagonalRendering_ = verifyBrokenDiagonalRendering(data2, 0) || verifyBrokenDiagonalRendering(data2, 4) || verifyBrokenDiagonalRendering(data2, 8);
    releaseCanvas$1(ctx);
    canvasPool.push(ctx.canvas);
  }
  return brokenDiagonalRendering_;
}
function calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution) {
  const sourceCenter = transform$3(targetCenter, targetProj, sourceProj);
  let sourceResolution = getPointResolution(targetProj, targetResolution, targetCenter);
  const targetMetersPerUnit = targetProj.getMetersPerUnit();
  if (targetMetersPerUnit !== void 0) {
    sourceResolution *= targetMetersPerUnit;
  }
  const sourceMetersPerUnit = sourceProj.getMetersPerUnit();
  if (sourceMetersPerUnit !== void 0) {
    sourceResolution /= sourceMetersPerUnit;
  }
  const sourceExtent = sourceProj.getExtent();
  if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {
    const compensationFactor = getPointResolution(sourceProj, sourceResolution, sourceCenter) / sourceResolution;
    if (isFinite(compensationFactor) && compensationFactor > 0) {
      sourceResolution /= compensationFactor;
    }
  }
  return sourceResolution;
}
function calculateSourceExtentResolution(sourceProj, targetProj, targetExtent, targetResolution) {
  const targetCenter = getCenter(targetExtent);
  let sourceResolution = calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);
  if (!isFinite(sourceResolution) || sourceResolution <= 0) {
    forEachCorner(targetExtent, function(corner) {
      sourceResolution = calculateSourceResolution(sourceProj, targetProj, corner, targetResolution);
      return isFinite(sourceResolution) && sourceResolution > 0;
    });
  }
  return sourceResolution;
}
function render(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, renderEdges, interpolate) {
  const context2 = createCanvasContext2D(Math.round(pixelRatio * width), Math.round(pixelRatio * height), canvasPool);
  if (!interpolate) {
    context2.imageSmoothingEnabled = false;
  }
  if (sources.length === 0) {
    return context2.canvas;
  }
  context2.scale(pixelRatio, pixelRatio);
  function pixelRound(value) {
    return Math.round(value * pixelRatio) / pixelRatio;
  }
  context2.globalCompositeOperation = "lighter";
  const sourceDataExtent = createEmpty();
  sources.forEach(function(src, i2, arr) {
    extend$2(sourceDataExtent, src.extent);
  });
  const canvasWidthInUnits = getWidth(sourceDataExtent);
  const canvasHeightInUnits = getHeight(sourceDataExtent);
  const stitchContext = createCanvasContext2D(Math.round(pixelRatio * canvasWidthInUnits / sourceResolution), Math.round(pixelRatio * canvasHeightInUnits / sourceResolution), canvasPool);
  if (!interpolate) {
    stitchContext.imageSmoothingEnabled = false;
  }
  const stitchScale = pixelRatio / sourceResolution;
  sources.forEach(function(src, i2, arr) {
    const xPos = src.extent[0] - sourceDataExtent[0];
    const yPos = -(src.extent[3] - sourceDataExtent[3]);
    const srcWidth = getWidth(src.extent);
    const srcHeight = getHeight(src.extent);
    if (src.image.width > 0 && src.image.height > 0) {
      stitchContext.drawImage(src.image, gutter, gutter, src.image.width - 2 * gutter, src.image.height - 2 * gutter, xPos * stitchScale, yPos * stitchScale, srcWidth * stitchScale, srcHeight * stitchScale);
    }
  });
  const targetTopLeft = getTopLeft(targetExtent);
  triangulation.getTriangles().forEach(function(triangle, i2, arr) {
    const source = triangle.source;
    const target = triangle.target;
    let x0 = source[0][0], y0 = source[0][1];
    let x1 = source[1][0], y1 = source[1][1];
    let x2 = source[2][0], y2 = source[2][1];
    const u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);
    const v0 = pixelRound(-(target[0][1] - targetTopLeft[1]) / targetResolution);
    const u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);
    const v1 = pixelRound(-(target[1][1] - targetTopLeft[1]) / targetResolution);
    const u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);
    const v2 = pixelRound(-(target[2][1] - targetTopLeft[1]) / targetResolution);
    const sourceNumericalShiftX = x0;
    const sourceNumericalShiftY = y0;
    x0 = 0;
    y0 = 0;
    x1 -= sourceNumericalShiftX;
    y1 -= sourceNumericalShiftY;
    x2 -= sourceNumericalShiftX;
    y2 -= sourceNumericalShiftY;
    const augmentedMatrix = [
      [x1, y1, 0, 0, u1 - u0],
      [x2, y2, 0, 0, u2 - u0],
      [0, 0, x1, y1, v1 - v0],
      [0, 0, x2, y2, v2 - v0]
    ];
    const affineCoefs = solveLinearSystem(augmentedMatrix);
    if (!affineCoefs) {
      return;
    }
    context2.save();
    context2.beginPath();
    if (isBrokenDiagonalRendering() || !interpolate) {
      context2.moveTo(u1, v1);
      const steps = 4;
      const ud = u0 - u1;
      const vd = v0 - v1;
      for (let step = 0; step < steps; step++) {
        context2.lineTo(u1 + pixelRound((step + 1) * ud / steps), v1 + pixelRound(step * vd / (steps - 1)));
        if (step != steps - 1) {
          context2.lineTo(u1 + pixelRound((step + 1) * ud / steps), v1 + pixelRound((step + 1) * vd / (steps - 1)));
        }
      }
      context2.lineTo(u2, v2);
    } else {
      context2.moveTo(u1, v1);
      context2.lineTo(u0, v0);
      context2.lineTo(u2, v2);
    }
    context2.clip();
    context2.transform(affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);
    context2.translate(sourceDataExtent[0] - sourceNumericalShiftX, sourceDataExtent[3] - sourceNumericalShiftY);
    context2.scale(sourceResolution / pixelRatio, -sourceResolution / pixelRatio);
    context2.drawImage(stitchContext.canvas, 0, 0);
    context2.restore();
  });
  releaseCanvas$1(stitchContext);
  canvasPool.push(stitchContext.canvas);
  if (renderEdges) {
    context2.save();
    context2.globalCompositeOperation = "source-over";
    context2.strokeStyle = "black";
    context2.lineWidth = 1;
    triangulation.getTriangles().forEach(function(triangle, i2, arr) {
      const target = triangle.target;
      const u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
      const v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
      const u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
      const v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
      const u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
      const v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;
      context2.beginPath();
      context2.moveTo(u1, v1);
      context2.lineTo(u0, v0);
      context2.lineTo(u2, v2);
      context2.closePath();
      context2.stroke();
    });
    context2.restore();
  }
  return context2.canvas;
}
class ReprojTile extends Tile {
  constructor(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, errorThreshold, renderEdges, interpolate) {
    super(tileCoord, TileState.IDLE, { interpolate: !!interpolate });
    this.renderEdges_ = renderEdges !== void 0 ? renderEdges : false;
    this.pixelRatio_ = pixelRatio;
    this.gutter_ = gutter;
    this.canvas_ = null;
    this.sourceTileGrid_ = sourceTileGrid;
    this.targetTileGrid_ = targetTileGrid;
    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;
    this.sourceTiles_ = [];
    this.sourcesListenerKeys_ = null;
    this.sourceZ_ = 0;
    const targetExtent = targetTileGrid.getTileCoordExtent(this.wrappedTileCoord_);
    const maxTargetExtent = this.targetTileGrid_.getExtent();
    let maxSourceExtent = this.sourceTileGrid_.getExtent();
    const limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;
    if (getArea(limitedTargetExtent) === 0) {
      this.state = TileState.EMPTY;
      return;
    }
    const sourceProjExtent = sourceProj.getExtent();
    if (sourceProjExtent) {
      if (!maxSourceExtent) {
        maxSourceExtent = sourceProjExtent;
      } else {
        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);
      }
    }
    const targetResolution = targetTileGrid.getResolution(this.wrappedTileCoord_[0]);
    const sourceResolution = calculateSourceExtentResolution(sourceProj, targetProj, limitedTargetExtent, targetResolution);
    if (!isFinite(sourceResolution) || sourceResolution <= 0) {
      this.state = TileState.EMPTY;
      return;
    }
    const errorThresholdInPixels = errorThreshold !== void 0 ? errorThreshold : ERROR_THRESHOLD;
    this.triangulation_ = new Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);
    if (this.triangulation_.getTriangles().length === 0) {
      this.state = TileState.EMPTY;
      return;
    }
    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);
    let sourceExtent = this.triangulation_.calculateSourceExtent();
    if (maxSourceExtent) {
      if (sourceProj.canWrapX()) {
        sourceExtent[1] = clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);
        sourceExtent[3] = clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);
      } else {
        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);
      }
    }
    if (!getArea(sourceExtent)) {
      this.state = TileState.EMPTY;
    } else {
      const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, this.sourceZ_);
      for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
        for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
          const tile2 = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);
          if (tile2) {
            this.sourceTiles_.push(tile2);
          }
        }
      }
      if (this.sourceTiles_.length === 0) {
        this.state = TileState.EMPTY;
      }
    }
  }
  getImage() {
    return this.canvas_;
  }
  reproject_() {
    const sources = [];
    this.sourceTiles_.forEach((tile2) => {
      if (tile2 && tile2.getState() == TileState.LOADED) {
        sources.push({
          extent: this.sourceTileGrid_.getTileCoordExtent(tile2.tileCoord),
          image: tile2.getImage()
        });
      }
    });
    this.sourceTiles_.length = 0;
    if (sources.length === 0) {
      this.state = TileState.ERROR;
    } else {
      const z2 = this.wrappedTileCoord_[0];
      const size = this.targetTileGrid_.getTileSize(z2);
      const width = typeof size === "number" ? size : size[0];
      const height = typeof size === "number" ? size : size[1];
      const targetResolution = this.targetTileGrid_.getResolution(z2);
      const sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);
      const targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);
      this.canvas_ = render(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_, this.interpolate);
      this.state = TileState.LOADED;
    }
    this.changed();
  }
  load() {
    if (this.state == TileState.IDLE) {
      this.state = TileState.LOADING;
      this.changed();
      let leftToLoad = 0;
      this.sourcesListenerKeys_ = [];
      this.sourceTiles_.forEach((tile2) => {
        const state = tile2.getState();
        if (state == TileState.IDLE || state == TileState.LOADING) {
          leftToLoad++;
          const sourceListenKey = listen(tile2, EventType.CHANGE, function(e2) {
            const state2 = tile2.getState();
            if (state2 == TileState.LOADED || state2 == TileState.ERROR || state2 == TileState.EMPTY) {
              unlistenByKey(sourceListenKey);
              leftToLoad--;
              if (leftToLoad === 0) {
                this.unlistenSources_();
                this.reproject_();
              }
            }
          }, this);
          this.sourcesListenerKeys_.push(sourceListenKey);
        }
      });
      if (leftToLoad === 0) {
        setTimeout(this.reproject_.bind(this), 0);
      } else {
        this.sourceTiles_.forEach(function(tile2, i2, arr) {
          const state = tile2.getState();
          if (state == TileState.IDLE) {
            tile2.load();
          }
        });
      }
    }
  }
  unlistenSources_() {
    this.sourcesListenerKeys_.forEach(unlistenByKey);
    this.sourcesListenerKeys_ = null;
  }
  release() {
    if (this.canvas_) {
      releaseCanvas$1(this.canvas_.getContext("2d"));
      canvasPool.push(this.canvas_);
      this.canvas_ = null;
    }
    super.release();
  }
}
class TileRange {
  constructor(minX, maxX, minY, maxY) {
    this.minX = minX;
    this.maxX = maxX;
    this.minY = minY;
    this.maxY = maxY;
  }
  contains(tileCoord) {
    return this.containsXY(tileCoord[1], tileCoord[2]);
  }
  containsTileRange(tileRange) {
    return this.minX <= tileRange.minX && tileRange.maxX <= this.maxX && this.minY <= tileRange.minY && tileRange.maxY <= this.maxY;
  }
  containsXY(x2, y2) {
    return this.minX <= x2 && x2 <= this.maxX && this.minY <= y2 && y2 <= this.maxY;
  }
  equals(tileRange) {
    return this.minX == tileRange.minX && this.minY == tileRange.minY && this.maxX == tileRange.maxX && this.maxY == tileRange.maxY;
  }
  extend(tileRange) {
    if (tileRange.minX < this.minX) {
      this.minX = tileRange.minX;
    }
    if (tileRange.maxX > this.maxX) {
      this.maxX = tileRange.maxX;
    }
    if (tileRange.minY < this.minY) {
      this.minY = tileRange.minY;
    }
    if (tileRange.maxY > this.maxY) {
      this.maxY = tileRange.maxY;
    }
  }
  getHeight() {
    return this.maxY - this.minY + 1;
  }
  getSize() {
    return [this.getWidth(), this.getHeight()];
  }
  getWidth() {
    return this.maxX - this.minX + 1;
  }
  intersects(tileRange) {
    return this.minX <= tileRange.maxX && this.maxX >= tileRange.minX && this.minY <= tileRange.maxY && this.maxY >= tileRange.minY;
  }
}
function createOrUpdate$1(minX, maxX, minY, maxY, tileRange) {
  if (tileRange !== void 0) {
    tileRange.minX = minX;
    tileRange.maxX = maxX;
    tileRange.minY = minY;
    tileRange.maxY = maxY;
    return tileRange;
  }
  return new TileRange(minX, maxX, minY, maxY);
}
class CanvasTileLayerRenderer extends CanvasLayerRenderer {
  constructor(tileLayer) {
    super(tileLayer);
    this.extentChanged = true;
    this.renderedExtent_ = null;
    this.renderedPixelRatio;
    this.renderedProjection = null;
    this.renderedRevision;
    this.renderedTiles = [];
    this.newTiles_ = false;
    this.tmpExtent = createEmpty();
    this.tmpTileRange_ = new TileRange(0, 0, 0, 0);
  }
  isDrawableTile(tile2) {
    const tileLayer = this.getLayer();
    const tileState = tile2.getState();
    const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();
    return tileState == TileState.LOADED || tileState == TileState.EMPTY || tileState == TileState.ERROR && !useInterimTilesOnError;
  }
  getTile(z2, x2, y2, frameState) {
    const pixelRatio = frameState.pixelRatio;
    const projection = frameState.viewState.projection;
    const tileLayer = this.getLayer();
    const tileSource = tileLayer.getSource();
    let tile2 = tileSource.getTile(z2, x2, y2, pixelRatio, projection);
    if (tile2.getState() == TileState.ERROR) {
      if (tileLayer.getUseInterimTilesOnError() && tileLayer.getPreload() > 0) {
        this.newTiles_ = true;
      }
    }
    if (!this.isDrawableTile(tile2)) {
      tile2 = tile2.getInterimTile();
    }
    return tile2;
  }
  getData(pixel) {
    const frameState = this.frameState;
    if (!frameState) {
      return null;
    }
    const layer = this.getLayer();
    const coordinate = apply$5(frameState.pixelToCoordinateTransform, pixel.slice());
    const layerExtent = layer.getExtent();
    if (layerExtent) {
      if (!containsCoordinate(layerExtent, coordinate)) {
        return null;
      }
    }
    const pixelRatio = frameState.pixelRatio;
    const projection = frameState.viewState.projection;
    const viewState = frameState.viewState;
    const source = layer.getRenderSource();
    const tileGrid = source.getTileGridForProjection(viewState.projection);
    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);
    for (let z2 = tileGrid.getZForResolution(viewState.resolution); z2 >= tileGrid.getMinZoom(); --z2) {
      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z2);
      const tile2 = source.getTile(z2, tileCoord[1], tileCoord[2], pixelRatio, projection);
      if (!(tile2 instanceof ImageTile || tile2 instanceof ReprojTile) || tile2 instanceof ReprojTile && tile2.getState() === TileState.EMPTY) {
        return null;
      }
      if (tile2.getState() !== TileState.LOADED) {
        continue;
      }
      const tileOrigin = tileGrid.getOrigin(z2);
      const tileSize = toSize(tileGrid.getTileSize(z2));
      const tileResolution = tileGrid.getResolution(z2);
      const col = Math.floor(tilePixelRatio * ((coordinate[0] - tileOrigin[0]) / tileResolution - tileCoord[1] * tileSize[0]));
      const row = Math.floor(tilePixelRatio * ((tileOrigin[1] - coordinate[1]) / tileResolution - tileCoord[2] * tileSize[1]));
      const gutter = Math.round(tilePixelRatio * source.getGutterForProjection(viewState.projection));
      return this.getImageData(tile2.getImage(), col + gutter, row + gutter);
    }
    return null;
  }
  loadedTileCallback(tiles, zoom, tile2) {
    if (this.isDrawableTile(tile2)) {
      return super.loadedTileCallback(tiles, zoom, tile2);
    }
    return false;
  }
  prepareFrame(frameState) {
    return !!this.getLayer().getSource();
  }
  renderFrame(frameState, target) {
    const layerState = frameState.layerStatesArray[frameState.layerIndex];
    const viewState = frameState.viewState;
    const projection = viewState.projection;
    const viewResolution = viewState.resolution;
    const viewCenter = viewState.center;
    const rotation = viewState.rotation;
    const pixelRatio = frameState.pixelRatio;
    const tileLayer = this.getLayer();
    const tileSource = tileLayer.getSource();
    const sourceRevision = tileSource.getRevision();
    const tileGrid = tileSource.getTileGridForProjection(projection);
    const z2 = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);
    const tileResolution = tileGrid.getResolution(z2);
    let extent2 = frameState.extent;
    const resolution = frameState.viewState.resolution;
    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);
    const width = Math.round(getWidth(extent2) / resolution * pixelRatio);
    const height = Math.round(getHeight(extent2) / resolution * pixelRatio);
    const layerExtent = layerState.extent && fromUserExtent(layerState.extent);
    if (layerExtent) {
      extent2 = getIntersection(extent2, fromUserExtent(layerState.extent));
    }
    const dx = tileResolution * width / 2 / tilePixelRatio;
    const dy = tileResolution * height / 2 / tilePixelRatio;
    const canvasExtent = [
      viewCenter[0] - dx,
      viewCenter[1] - dy,
      viewCenter[0] + dx,
      viewCenter[1] + dy
    ];
    const tileRange = tileGrid.getTileRangeForExtentAndZ(extent2, z2);
    const tilesToDrawByZ = {};
    tilesToDrawByZ[z2] = {};
    const findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);
    const tmpExtent2 = this.tmpExtent;
    const tmpTileRange = this.tmpTileRange_;
    this.newTiles_ = false;
    const viewport = rotation ? getRotatedViewport(viewState.center, resolution, rotation, frameState.size) : void 0;
    for (let x2 = tileRange.minX; x2 <= tileRange.maxX; ++x2) {
      for (let y2 = tileRange.minY; y2 <= tileRange.maxY; ++y2) {
        if (rotation && !tileGrid.tileCoordIntersectsViewport([z2, x2, y2], viewport)) {
          continue;
        }
        const tile2 = this.getTile(z2, x2, y2, frameState);
        if (this.isDrawableTile(tile2)) {
          const uid2 = getUid(this);
          if (tile2.getState() == TileState.LOADED) {
            tilesToDrawByZ[z2][tile2.tileCoord.toString()] = tile2;
            let inTransition = tile2.inTransition(uid2);
            if (inTransition && layerState.opacity !== 1) {
              tile2.endTransition(uid2);
              inTransition = false;
            }
            if (!this.newTiles_ && (inTransition || !this.renderedTiles.includes(tile2))) {
              this.newTiles_ = true;
            }
          }
          if (tile2.getAlpha(uid2, frameState.time) === 1) {
            continue;
          }
        }
        const childTileRange = tileGrid.getTileCoordChildTileRange(tile2.tileCoord, tmpTileRange, tmpExtent2);
        let covered = false;
        if (childTileRange) {
          covered = findLoadedTiles(z2 + 1, childTileRange);
        }
        if (!covered) {
          tileGrid.forEachTileCoordParentTileRange(tile2.tileCoord, findLoadedTiles, tmpTileRange, tmpExtent2);
        }
      }
    }
    const canvasScale = tileResolution / viewResolution * pixelRatio / tilePixelRatio;
    compose(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / pixelRatio, 1 / pixelRatio, rotation, -width / 2, -height / 2);
    const canvasTransform = toString$e(this.pixelTransform);
    this.useContainer(target, canvasTransform, this.getBackground(frameState));
    const context2 = this.context;
    const canvas = context2.canvas;
    makeInverse(this.inversePixelTransform, this.pixelTransform);
    compose(this.tempTransform, width / 2, height / 2, canvasScale, canvasScale, 0, -width / 2, -height / 2);
    if (canvas.width != width || canvas.height != height) {
      canvas.width = width;
      canvas.height = height;
    } else if (!this.containerReused) {
      context2.clearRect(0, 0, width, height);
    }
    if (layerExtent) {
      this.clipUnrotated(context2, frameState, layerExtent);
    }
    if (!tileSource.getInterpolate()) {
      context2.imageSmoothingEnabled = false;
    }
    this.preRender(context2, frameState);
    this.renderedTiles.length = 0;
    let zs = Object.keys(tilesToDrawByZ).map(Number);
    zs.sort(numberSafeCompareFunction);
    let clips, clipZs, currentClip;
    if (layerState.opacity === 1 && (!this.containerReused || tileSource.getOpaque(frameState.viewState.projection))) {
      zs = zs.reverse();
    } else {
      clips = [];
      clipZs = [];
    }
    for (let i2 = zs.length - 1; i2 >= 0; --i2) {
      const currentZ = zs[i2];
      const currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);
      const currentResolution = tileGrid.getResolution(currentZ);
      const currentScale = currentResolution / tileResolution;
      const dx2 = currentTilePixelSize[0] * currentScale * canvasScale;
      const dy2 = currentTilePixelSize[1] * currentScale * canvasScale;
      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(getTopLeft(canvasExtent), currentZ);
      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);
      const origin = apply$5(this.tempTransform, [
        tilePixelRatio * (originTileExtent[0] - canvasExtent[0]) / tileResolution,
        tilePixelRatio * (canvasExtent[3] - originTileExtent[3]) / tileResolution
      ]);
      const tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);
      const tilesToDraw = tilesToDrawByZ[currentZ];
      for (const tileCoordKey in tilesToDraw) {
        const tile2 = tilesToDraw[tileCoordKey];
        const tileCoord = tile2.tileCoord;
        const xIndex = originTileCoord[1] - tileCoord[1];
        const nextX = Math.round(origin[0] - (xIndex - 1) * dx2);
        const yIndex = originTileCoord[2] - tileCoord[2];
        const nextY = Math.round(origin[1] - (yIndex - 1) * dy2);
        const x2 = Math.round(origin[0] - xIndex * dx2);
        const y2 = Math.round(origin[1] - yIndex * dy2);
        const w2 = nextX - x2;
        const h2 = nextY - y2;
        const transition = z2 === currentZ;
        const inTransition = transition && tile2.getAlpha(getUid(this), frameState.time) !== 1;
        let contextSaved = false;
        if (!inTransition) {
          if (clips) {
            currentClip = [x2, y2, x2 + w2, y2, x2 + w2, y2 + h2, x2, y2 + h2];
            for (let i3 = 0, ii = clips.length; i3 < ii; ++i3) {
              if (z2 !== currentZ && currentZ < clipZs[i3]) {
                const clip = clips[i3];
                if (intersects$2([x2, y2, x2 + w2, y2 + h2], [clip[0], clip[3], clip[4], clip[7]])) {
                  if (!contextSaved) {
                    context2.save();
                    contextSaved = true;
                  }
                  context2.beginPath();
                  context2.moveTo(currentClip[0], currentClip[1]);
                  context2.lineTo(currentClip[2], currentClip[3]);
                  context2.lineTo(currentClip[4], currentClip[5]);
                  context2.lineTo(currentClip[6], currentClip[7]);
                  context2.moveTo(clip[6], clip[7]);
                  context2.lineTo(clip[4], clip[5]);
                  context2.lineTo(clip[2], clip[3]);
                  context2.lineTo(clip[0], clip[1]);
                  context2.clip();
                }
              }
            }
            clips.push(currentClip);
            clipZs.push(currentZ);
          } else {
            context2.clearRect(x2, y2, w2, h2);
          }
        }
        this.drawTileImage(tile2, frameState, x2, y2, w2, h2, tileGutter, transition);
        if (clips && !inTransition) {
          if (contextSaved) {
            context2.restore();
          }
          this.renderedTiles.unshift(tile2);
        } else {
          this.renderedTiles.push(tile2);
        }
        this.updateUsedTiles(frameState.usedTiles, tileSource, tile2);
      }
    }
    this.renderedRevision = sourceRevision;
    this.renderedResolution = tileResolution;
    this.extentChanged = !this.renderedExtent_ || !equals$2(this.renderedExtent_, canvasExtent);
    this.renderedExtent_ = canvasExtent;
    this.renderedPixelRatio = pixelRatio;
    this.renderedProjection = projection;
    this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent2, z2, tileLayer.getPreload());
    this.scheduleExpireCache(frameState, tileSource);
    this.postRender(context2, frameState);
    if (layerState.extent) {
      context2.restore();
    }
    context2.imageSmoothingEnabled = true;
    if (canvasTransform !== canvas.style.transform) {
      canvas.style.transform = canvasTransform;
    }
    return this.container;
  }
  drawTileImage(tile2, frameState, x2, y2, w2, h2, gutter, transition) {
    const image2 = this.getTileImage(tile2);
    if (!image2) {
      return;
    }
    const uid2 = getUid(this);
    const layerState = frameState.layerStatesArray[frameState.layerIndex];
    const alpha = layerState.opacity * (transition ? tile2.getAlpha(uid2, frameState.time) : 1);
    const alphaChanged = alpha !== this.context.globalAlpha;
    if (alphaChanged) {
      this.context.save();
      this.context.globalAlpha = alpha;
    }
    this.context.drawImage(image2, gutter, gutter, image2.width - 2 * gutter, image2.height - 2 * gutter, x2, y2, w2, h2);
    if (alphaChanged) {
      this.context.restore();
    }
    if (alpha !== layerState.opacity) {
      frameState.animate = true;
    } else if (transition) {
      tile2.endTransition(uid2);
    }
  }
  getImage() {
    const context2 = this.context;
    return context2 ? context2.canvas : null;
  }
  getTileImage(tile2) {
    return tile2.getImage();
  }
  scheduleExpireCache(frameState, tileSource) {
    if (tileSource.canExpireCache()) {
      const postRenderFunction = function(tileSource2, map, frameState2) {
        const tileSourceKey = getUid(tileSource2);
        if (tileSourceKey in frameState2.usedTiles) {
          tileSource2.expireCache(frameState2.viewState.projection, frameState2.usedTiles[tileSourceKey]);
        }
      }.bind(null, tileSource);
      frameState.postRenderFunctions.push(postRenderFunction);
    }
  }
  updateUsedTiles(usedTiles, tileSource, tile2) {
    const tileSourceKey = getUid(tileSource);
    if (!(tileSourceKey in usedTiles)) {
      usedTiles[tileSourceKey] = {};
    }
    usedTiles[tileSourceKey][tile2.getKey()] = true;
  }
  manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent2, currentZ, preload, tileCallback) {
    const tileSourceKey = getUid(tileSource);
    if (!(tileSourceKey in frameState.wantedTiles)) {
      frameState.wantedTiles[tileSourceKey] = {};
    }
    const wantedTiles = frameState.wantedTiles[tileSourceKey];
    const tileQueue = frameState.tileQueue;
    const minZoom = tileGrid.getMinZoom();
    const rotation = frameState.viewState.rotation;
    const viewport = rotation ? getRotatedViewport(frameState.viewState.center, frameState.viewState.resolution, rotation, frameState.size) : void 0;
    let tileCount = 0;
    let tile2, tileRange, tileResolution, x2, y2, z2;
    for (z2 = minZoom; z2 <= currentZ; ++z2) {
      tileRange = tileGrid.getTileRangeForExtentAndZ(extent2, z2, tileRange);
      tileResolution = tileGrid.getResolution(z2);
      for (x2 = tileRange.minX; x2 <= tileRange.maxX; ++x2) {
        for (y2 = tileRange.minY; y2 <= tileRange.maxY; ++y2) {
          if (rotation && !tileGrid.tileCoordIntersectsViewport([z2, x2, y2], viewport)) {
            continue;
          }
          if (currentZ - z2 <= preload) {
            ++tileCount;
            tile2 = tileSource.getTile(z2, x2, y2, pixelRatio, projection);
            if (tile2.getState() == TileState.IDLE) {
              wantedTiles[tile2.getKey()] = true;
              if (!tileQueue.isKeyQueued(tile2.getKey())) {
                tileQueue.enqueue([
                  tile2,
                  tileSourceKey,
                  tileGrid.getTileCoordCenter(tile2.tileCoord),
                  tileResolution
                ]);
              }
            }
            if (tileCallback !== void 0) {
              tileCallback(tile2);
            }
          } else {
            tileSource.useTile(z2, x2, y2, projection);
          }
        }
      }
    }
    tileSource.updateCacheSize(tileCount, projection);
  }
}
class TileLayer$1 extends BaseTileLayer {
  constructor(options) {
    super(options);
  }
  createRenderer() {
    return new CanvasTileLayerRenderer(this);
  }
}
const _sfc_main$10 = {
  props: {
    className: {
      type: String,
      default: "ol-layer"
    },
    opacity: {
      type: Number,
      default: 1
    },
    visible: {
      type: Boolean,
      default: true
    },
    extent: {
      type: Array
    },
    zIndex: {
      type: Number
    },
    minResolution: {
      type: Number
    },
    maxResolution: {
      type: Number
    },
    minZoom: {
      type: Number
    },
    maxZoom: {
      type: Number
    },
    title: {
      type: String
    },
    name: {
      type: String
    },
    preview: {
      type: String
    },
    baseLayer: {
      type: Boolean
    },
    properties: {
      type: Object,
      default: () => {
      }
    }
  }
};
function _sfc_render$10(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div");
}
var BaseLayer = /* @__PURE__ */ _export_sfc(_sfc_main$10, [["render", _sfc_render$10]]);
const _sfc_main$$ = {
  extends: BaseLayer,
  name: "ol-tile-layer",
  setup(props) {
    const map = inject("map");
    const overViewMap = inject("overviewMap", null);
    const {
      properties
    } = usePropsAsObjectProperties(props);
    const tileLayer = computed(() => new TileLayer$1(properties));
    const applyTileLayer = () => {
      if (overViewMap != null) {
        overViewMap.value.getOverviewMap().addLayer(tileLayer.value);
        overViewMap.value.changed();
      } else {
        map.addLayer(tileLayer.value);
      }
    };
    const removeTileLayer = () => {
      if (overViewMap != null) {
        overViewMap.value.getOverviewMap().removeLayer(tileLayer.value);
        overViewMap.value.changed();
      } else {
        map.removeLayer(tileLayer.value);
      }
    };
    if (overViewMap != null) {
      watch(overViewMap, () => {
        removeTileLayer();
        applyTileLayer();
      });
    }
    onMounted(() => {
      applyTileLayer();
    });
    onUnmounted(() => {
      removeTileLayer();
    });
    provide("tileLayer", tileLayer);
    return {
      tileLayer
    };
  },
  props: {
    preload: {
      type: Number,
      default: 1
    }
  }
};
function _sfc_render$$(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var TileLayer = /* @__PURE__ */ _export_sfc(_sfc_main$$, [["render", _sfc_render$$]]);
class LRUCache$1 {
  constructor(highWaterMark) {
    this.highWaterMark = highWaterMark !== void 0 ? highWaterMark : 2048;
    this.count_ = 0;
    this.entries_ = {};
    this.oldest_ = null;
    this.newest_ = null;
  }
  canExpireCache() {
    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
  }
  expireCache(keep) {
    while (this.canExpireCache()) {
      this.pop();
    }
  }
  clear() {
    this.count_ = 0;
    this.entries_ = {};
    this.oldest_ = null;
    this.newest_ = null;
  }
  containsKey(key) {
    return this.entries_.hasOwnProperty(key);
  }
  forEach(f2) {
    let entry = this.oldest_;
    while (entry) {
      f2(entry.value_, entry.key_, this);
      entry = entry.newer;
    }
  }
  get(key, options) {
    const entry = this.entries_[key];
    assert(entry !== void 0, 15);
    if (entry === this.newest_) {
      return entry.value_;
    } else if (entry === this.oldest_) {
      this.oldest_ = this.oldest_.newer;
      this.oldest_.older = null;
    } else {
      entry.newer.older = entry.older;
      entry.older.newer = entry.newer;
    }
    entry.newer = null;
    entry.older = this.newest_;
    this.newest_.newer = entry;
    this.newest_ = entry;
    return entry.value_;
  }
  remove(key) {
    const entry = this.entries_[key];
    assert(entry !== void 0, 15);
    if (entry === this.newest_) {
      this.newest_ = entry.older;
      if (this.newest_) {
        this.newest_.newer = null;
      }
    } else if (entry === this.oldest_) {
      this.oldest_ = entry.newer;
      if (this.oldest_) {
        this.oldest_.older = null;
      }
    } else {
      entry.newer.older = entry.older;
      entry.older.newer = entry.newer;
    }
    delete this.entries_[key];
    --this.count_;
    return entry.value_;
  }
  getCount() {
    return this.count_;
  }
  getKeys() {
    const keys3 = new Array(this.count_);
    let i2 = 0;
    let entry;
    for (entry = this.newest_; entry; entry = entry.older) {
      keys3[i2++] = entry.key_;
    }
    return keys3;
  }
  getValues() {
    const values3 = new Array(this.count_);
    let i2 = 0;
    let entry;
    for (entry = this.newest_; entry; entry = entry.older) {
      values3[i2++] = entry.value_;
    }
    return values3;
  }
  peekLast() {
    return this.oldest_.value_;
  }
  peekLastKey() {
    return this.oldest_.key_;
  }
  peekFirstKey() {
    return this.newest_.key_;
  }
  peek(key) {
    if (!this.containsKey(key)) {
      return void 0;
    }
    return this.entries_[key].value_;
  }
  pop() {
    const entry = this.oldest_;
    delete this.entries_[entry.key_];
    if (entry.newer) {
      entry.newer.older = null;
    }
    this.oldest_ = entry.newer;
    if (!this.oldest_) {
      this.newest_ = null;
    }
    --this.count_;
    return entry.value_;
  }
  replace(key, value) {
    this.get(key);
    this.entries_[key].value_ = value;
  }
  set(key, value) {
    assert(!(key in this.entries_), 16);
    const entry = {
      key_: key,
      newer: null,
      older: this.newest_,
      value_: value
    };
    if (!this.newest_) {
      this.oldest_ = entry;
    } else {
      this.newest_.newer = entry;
    }
    this.newest_ = entry;
    this.entries_[key] = entry;
    ++this.count_;
  }
  setSize(size) {
    this.highWaterMark = size;
  }
}
class DataTile extends Tile {
  constructor(options) {
    const state = TileState.IDLE;
    super(options.tileCoord, state, {
      transition: options.transition,
      interpolate: options.interpolate
    });
    this.loader_ = options.loader;
    this.data_ = null;
    this.error_ = null;
    this.size_ = options.size || [256, 256];
  }
  getSize() {
    return this.size_;
  }
  getData() {
    return this.data_;
  }
  getError() {
    return this.error_;
  }
  load() {
    if (this.state !== TileState.IDLE && this.state !== TileState.ERROR) {
      return;
    }
    this.state = TileState.LOADING;
    this.changed();
    const self2 = this;
    this.loader_().then(function(data2) {
      self2.data_ = data2;
      self2.state = TileState.LOADED;
      self2.changed();
    }).catch(function(error) {
      self2.error_ = error;
      self2.state = TileState.ERROR;
      self2.changed();
    });
  }
}
class ReprojDataTile extends DataTile {
  constructor(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, interpolate, errorThreshold) {
    super({
      tileCoord,
      loader: function() {
        return toPromise(function() {
          return new Uint8Array(4);
        });
      },
      interpolate
    });
    this.pixelRatio_ = pixelRatio;
    this.gutter_ = gutter;
    this.reprojData_ = null;
    this.reprojError_ = null;
    this.reprojSize_ = void 0;
    this.sourceTileGrid_ = sourceTileGrid;
    this.targetTileGrid_ = targetTileGrid;
    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;
    this.sourceTiles_ = [];
    this.sourcesListenerKeys_ = null;
    this.sourceZ_ = 0;
    const targetExtent = targetTileGrid.getTileCoordExtent(this.wrappedTileCoord_);
    const maxTargetExtent = this.targetTileGrid_.getExtent();
    let maxSourceExtent = this.sourceTileGrid_.getExtent();
    const limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;
    if (getArea(limitedTargetExtent) === 0) {
      this.state = TileState.EMPTY;
      return;
    }
    const sourceProjExtent = sourceProj.getExtent();
    if (sourceProjExtent) {
      if (!maxSourceExtent) {
        maxSourceExtent = sourceProjExtent;
      } else {
        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);
      }
    }
    const targetResolution = targetTileGrid.getResolution(this.wrappedTileCoord_[0]);
    const sourceResolution = calculateSourceExtentResolution(sourceProj, targetProj, limitedTargetExtent, targetResolution);
    if (!isFinite(sourceResolution) || sourceResolution <= 0) {
      this.state = TileState.EMPTY;
      return;
    }
    const errorThresholdInPixels = errorThreshold !== void 0 ? errorThreshold : ERROR_THRESHOLD;
    this.triangulation_ = new Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);
    if (this.triangulation_.getTriangles().length === 0) {
      this.state = TileState.EMPTY;
      return;
    }
    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);
    let sourceExtent = this.triangulation_.calculateSourceExtent();
    if (maxSourceExtent) {
      if (sourceProj.canWrapX()) {
        sourceExtent[1] = clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);
        sourceExtent[3] = clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);
      } else {
        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);
      }
    }
    if (!getArea(sourceExtent)) {
      this.state = TileState.EMPTY;
    } else {
      const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, this.sourceZ_);
      for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
        for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
          const tile2 = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);
          if (tile2) {
            this.sourceTiles_.push(tile2);
          }
        }
      }
      if (this.sourceTiles_.length === 0) {
        this.state = TileState.EMPTY;
      }
    }
  }
  getSize() {
    return this.reprojSize_;
  }
  getData() {
    return this.reprojData_;
  }
  getError() {
    return this.reprojError_;
  }
  reproject_() {
    const dataSources = [];
    this.sourceTiles_.forEach((tile2) => {
      if (!tile2 || tile2.getState() !== TileState.LOADED) {
        return;
      }
      const size = tile2.getSize();
      const gutter = this.gutter_;
      const tileData = tile2.getData();
      const pixelSize = [size[0] + 2 * gutter, size[1] + 2 * gutter];
      const isFloat = tileData instanceof Float32Array;
      const pixelCount = pixelSize[0] * pixelSize[1];
      const DataType = isFloat ? Float32Array : Uint8Array;
      const tileDataR = new DataType(tileData.buffer);
      const bytesPerElement = DataType.BYTES_PER_ELEMENT;
      const bytesPerPixel = bytesPerElement * tileDataR.length / pixelCount;
      const bytesPerRow = tileDataR.byteLength / pixelSize[1];
      const bandCount = Math.floor(bytesPerRow / bytesPerElement / pixelSize[0]);
      const packedLength = pixelCount * bandCount;
      let packedData = tileDataR;
      if (tileDataR.length !== packedLength) {
        packedData = new DataType(packedLength);
        let dataIndex = 0;
        let rowOffset = 0;
        const colCount = pixelSize[0] * bandCount;
        for (let rowIndex = 0; rowIndex < pixelSize[1]; ++rowIndex) {
          for (let colIndex = 0; colIndex < colCount; ++colIndex) {
            packedData[dataIndex++] = tileDataR[rowOffset + colIndex];
          }
          rowOffset += bytesPerRow / bytesPerElement;
        }
      }
      dataSources.push({
        extent: this.sourceTileGrid_.getTileCoordExtent(tile2.tileCoord),
        data: new Uint8Array(packedData.buffer),
        dataType: DataType,
        bytesPerPixel,
        pixelSize
      });
    });
    this.sourceTiles_.length = 0;
    if (dataSources.length === 0) {
      this.state = TileState.ERROR;
    } else {
      const z2 = this.wrappedTileCoord_[0];
      const size = this.targetTileGrid_.getTileSize(z2);
      const targetWidth = typeof size === "number" ? size : size[0];
      const targetHeight = typeof size === "number" ? size : size[1];
      const targetResolution = this.targetTileGrid_.getResolution(z2);
      const sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);
      const targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);
      let dataR, dataU;
      const bytesPerPixel = dataSources[0].bytesPerPixel;
      const reprojs = Math.ceil(bytesPerPixel / 3);
      for (let reproj = reprojs - 1; reproj >= 0; --reproj) {
        const sources = [];
        for (let i2 = 0, len = dataSources.length; i2 < len; ++i2) {
          const dataSource = dataSources[i2];
          const buffer2 = dataSource.data;
          const pixelSize = dataSource.pixelSize;
          const width = pixelSize[0];
          const height = pixelSize[1];
          const context3 = createCanvasContext2D(width, height, canvasPool);
          const imageData2 = context3.getImageData(0, 0, width, height);
          const data3 = imageData2.data;
          let offset3 = reproj * 3;
          for (let j2 = 0, len2 = data3.length; j2 < len2; j2 += 4) {
            data3[j2] = buffer2[offset3];
            data3[j2 + 1] = buffer2[offset3 + 1];
            data3[j2 + 2] = buffer2[offset3 + 2];
            data3[j2 + 3] = 255;
            offset3 += bytesPerPixel;
          }
          context3.putImageData(imageData2, 0, 0);
          sources.push({
            extent: dataSource.extent,
            image: context3.canvas
          });
        }
        const canvas = render(targetWidth, targetHeight, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, false, false);
        for (let i2 = 0, len = sources.length; i2 < len; ++i2) {
          const canvas2 = sources[i2].image;
          const context3 = canvas2.getContext("2d");
          releaseCanvas$1(context3);
          canvasPool.push(context3.canvas);
        }
        const context2 = canvas.getContext("2d");
        const imageData = context2.getImageData(0, 0, canvas.width, canvas.height);
        releaseCanvas$1(context2);
        canvasPool.push(canvas);
        if (!dataR) {
          dataU = new Uint8Array(bytesPerPixel * imageData.width * imageData.height);
          dataR = new dataSources[0].dataType(dataU.buffer);
        }
        const data2 = imageData.data;
        let offset2 = reproj * 3;
        for (let i2 = 0, len = data2.length; i2 < len; i2 += 4) {
          if (data2[i2 + 3] === 255) {
            dataU[offset2] = data2[i2];
            dataU[offset2 + 1] = data2[i2 + 1];
            dataU[offset2 + 2] = data2[i2 + 2];
          } else {
            dataU[offset2] = 0;
            dataU[offset2 + 1] = 0;
            dataU[offset2 + 2] = 0;
          }
          offset2 += bytesPerPixel;
        }
      }
      this.reprojData_ = dataR;
      this.reprojSize_ = [
        Math.round(targetWidth * this.pixelRatio_),
        Math.round(targetHeight * this.pixelRatio_)
      ];
      this.state = TileState.LOADED;
    }
    this.changed();
  }
  load() {
    if (this.state !== TileState.IDLE && this.state !== TileState.ERROR) {
      return;
    }
    this.state = TileState.LOADING;
    this.changed();
    let leftToLoad = 0;
    this.sourcesListenerKeys_ = [];
    this.sourceTiles_.forEach((tile2) => {
      const state = tile2.getState();
      if (state !== TileState.IDLE && state !== TileState.LOADING) {
        return;
      }
      leftToLoad++;
      const sourceListenKey = listen(tile2, EventType.CHANGE, function() {
        const state2 = tile2.getState();
        if (state2 == TileState.LOADED || state2 == TileState.ERROR || state2 == TileState.EMPTY) {
          unlistenByKey(sourceListenKey);
          leftToLoad--;
          if (leftToLoad === 0) {
            this.unlistenSources_();
            this.reproject_();
          }
        }
      }, this);
      this.sourcesListenerKeys_.push(sourceListenKey);
    });
    if (leftToLoad === 0) {
      setTimeout(this.reproject_.bind(this), 0);
    } else {
      this.sourceTiles_.forEach(function(tile2) {
        const state = tile2.getState();
        if (state == TileState.IDLE) {
          tile2.load();
        }
      });
    }
  }
  unlistenSources_() {
    this.sourcesListenerKeys_.forEach(unlistenByKey);
    this.sourcesListenerKeys_ = null;
  }
}
const ARRAY_BUFFER = 34962;
const ELEMENT_ARRAY_BUFFER = 34963;
const STREAM_DRAW = 35040;
const STATIC_DRAW = 35044;
const DYNAMIC_DRAW = 35048;
const UNSIGNED_BYTE = 5121;
const UNSIGNED_SHORT = 5123;
const UNSIGNED_INT = 5125;
const FLOAT = 5126;
const CONTEXT_IDS = ["experimental-webgl", "webgl", "webkit-3d", "moz-webgl"];
function getContext(canvas, attributes) {
  attributes = Object.assign({
    preserveDrawingBuffer: true,
    antialias: SAFARI_BUG_237906 ? false : true
  }, attributes);
  const ii = CONTEXT_IDS.length;
  for (let i2 = 0; i2 < ii; ++i2) {
    try {
      const context2 = canvas.getContext(CONTEXT_IDS[i2], attributes);
      if (context2) {
        return context2;
      }
    } catch (e2) {
    }
  }
  return null;
}
const BufferUsage = {
  STATIC_DRAW,
  STREAM_DRAW,
  DYNAMIC_DRAW
};
class WebGLArrayBuffer {
  constructor(type, usage) {
    this.array = null;
    this.type = type;
    assert(type === ARRAY_BUFFER || type === ELEMENT_ARRAY_BUFFER, 62);
    this.usage = usage !== void 0 ? usage : BufferUsage.STATIC_DRAW;
  }
  ofSize(size) {
    this.array = new (getArrayClassForType(this.type))(size);
  }
  fromArray(array) {
    this.array = getArrayClassForType(this.type).from(array);
  }
  fromArrayBuffer(buffer2) {
    this.array = new (getArrayClassForType(this.type))(buffer2);
  }
  getType() {
    return this.type;
  }
  getArray() {
    return this.array;
  }
  getUsage() {
    return this.usage;
  }
  getSize() {
    return this.array ? this.array.length : 0;
  }
}
function getArrayClassForType(type) {
  switch (type) {
    case ARRAY_BUFFER:
      return Float32Array;
    case ELEMENT_ARRAY_BUFFER:
      return Uint32Array;
    default:
      return Float32Array;
  }
}
function bindAndConfigure(gl, texture, interpolate) {
  const resampleFilter = interpolate ? gl.LINEAR : gl.NEAREST;
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, resampleFilter);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, resampleFilter);
}
function uploadImageTexture(gl, texture, image2, interpolate) {
  bindAndConfigure(gl, texture, interpolate);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image2);
}
function uploadDataTexture(helper, texture, data2, size, bandCount, interpolate) {
  const gl = helper.getGL();
  let textureType;
  let canInterpolate;
  if (data2 instanceof Float32Array) {
    textureType = gl.FLOAT;
    helper.getExtension("OES_texture_float");
    const extension = helper.getExtension("OES_texture_float_linear");
    canInterpolate = extension !== null;
  } else {
    textureType = gl.UNSIGNED_BYTE;
    canInterpolate = true;
  }
  bindAndConfigure(gl, texture, interpolate && canInterpolate);
  const bytesPerRow = data2.byteLength / size[1];
  let unpackAlignment = 1;
  if (bytesPerRow % 8 === 0) {
    unpackAlignment = 8;
  } else if (bytesPerRow % 4 === 0) {
    unpackAlignment = 4;
  } else if (bytesPerRow % 2 === 0) {
    unpackAlignment = 2;
  }
  let format2;
  switch (bandCount) {
    case 1: {
      format2 = gl.LUMINANCE;
      break;
    }
    case 2: {
      format2 = gl.LUMINANCE_ALPHA;
      break;
    }
    case 3: {
      format2 = gl.RGB;
      break;
    }
    case 4: {
      format2 = gl.RGBA;
      break;
    }
    default: {
      throw new Error(`Unsupported number of bands: ${bandCount}`);
    }
  }
  const oldUnpackAlignment = gl.getParameter(gl.UNPACK_ALIGNMENT);
  gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);
  gl.texImage2D(gl.TEXTURE_2D, 0, format2, size[0], size[1], 0, format2, textureType, data2);
  gl.pixelStorei(gl.UNPACK_ALIGNMENT, oldUnpackAlignment);
}
let pixelContext = null;
function createPixelContext() {
  const canvas = document.createElement("canvas");
  canvas.width = 1;
  canvas.height = 1;
  pixelContext = canvas.getContext("2d");
}
class TileTexture extends Target {
  constructor(options) {
    super();
    this.tile;
    this.textures = [];
    this.handleTileChange_ = this.handleTileChange_.bind(this);
    this.renderSize_ = toSize(options.grid.getTileSize(options.tile.tileCoord[0]));
    this.gutter_ = options.gutter || 0;
    this.bandCount = NaN;
    this.helper_ = options.helper;
    const coords = new WebGLArrayBuffer(ARRAY_BUFFER, STATIC_DRAW);
    coords.fromArray([
      0,
      1,
      1,
      1,
      1,
      0,
      0,
      0
    ]);
    this.helper_.flushBufferData(coords);
    this.coords = coords;
    this.setTile(options.tile);
  }
  setTile(tile2) {
    if (tile2 !== this.tile) {
      if (this.tile) {
        this.tile.removeEventListener(EventType.CHANGE, this.handleTileChange_);
      }
      this.tile = tile2;
      this.textures.length = 0;
      this.loaded = tile2.getState() === TileState.LOADED;
      if (this.loaded) {
        this.uploadTile_();
      } else {
        if (tile2 instanceof ImageTile) {
          const image2 = tile2.getImage();
          if (image2 instanceof Image && !image2.crossOrigin) {
            image2.crossOrigin = "anonymous";
          }
        }
        tile2.addEventListener(EventType.CHANGE, this.handleTileChange_);
      }
    }
  }
  uploadTile_() {
    const helper = this.helper_;
    const gl = helper.getGL();
    const tile2 = this.tile;
    if (tile2 instanceof ImageTile || tile2 instanceof ReprojTile) {
      const texture = gl.createTexture();
      this.textures.push(texture);
      this.bandCount = 4;
      uploadImageTexture(gl, texture, tile2.getImage(), tile2.interpolate);
      return;
    }
    const sourceTileSize = tile2.getSize();
    const pixelSize = [
      sourceTileSize[0] + 2 * this.gutter_,
      sourceTileSize[1] + 2 * this.gutter_
    ];
    const data2 = tile2.getData();
    const isFloat = data2 instanceof Float32Array;
    const pixelCount = pixelSize[0] * pixelSize[1];
    const DataType = isFloat ? Float32Array : Uint8Array;
    const bytesPerElement = DataType.BYTES_PER_ELEMENT;
    const bytesPerRow = data2.byteLength / pixelSize[1];
    this.bandCount = Math.floor(bytesPerRow / bytesPerElement / pixelSize[0]);
    const textureCount = Math.ceil(this.bandCount / 4);
    if (textureCount === 1) {
      const texture = gl.createTexture();
      this.textures.push(texture);
      uploadDataTexture(helper, texture, data2, pixelSize, this.bandCount, tile2.interpolate);
      return;
    }
    const textureDataArrays = new Array(textureCount);
    for (let textureIndex = 0; textureIndex < textureCount; ++textureIndex) {
      const texture = gl.createTexture();
      this.textures.push(texture);
      const bandCount = textureIndex < textureCount - 1 ? 4 : (this.bandCount - 1) % 4 + 1;
      textureDataArrays[textureIndex] = new DataType(pixelCount * bandCount);
    }
    let dataIndex = 0;
    let rowOffset = 0;
    const colCount = pixelSize[0] * this.bandCount;
    for (let rowIndex = 0; rowIndex < pixelSize[1]; ++rowIndex) {
      for (let colIndex = 0; colIndex < colCount; ++colIndex) {
        const dataValue = data2[rowOffset + colIndex];
        const pixelIndex = Math.floor(dataIndex / this.bandCount);
        const bandIndex = colIndex % this.bandCount;
        const textureIndex = Math.floor(bandIndex / 4);
        const textureData = textureDataArrays[textureIndex];
        const bandCount = textureData.length / pixelCount;
        const textureBandIndex = bandIndex % 4;
        textureData[pixelIndex * bandCount + textureBandIndex] = dataValue;
        ++dataIndex;
      }
      rowOffset += bytesPerRow / bytesPerElement;
    }
    for (let textureIndex = 0; textureIndex < textureCount; ++textureIndex) {
      const texture = this.textures[textureIndex];
      const textureData = textureDataArrays[textureIndex];
      const bandCount = textureData.length / pixelCount;
      uploadDataTexture(helper, texture, textureData, pixelSize, bandCount, tile2.interpolate);
    }
  }
  handleTileChange_() {
    if (this.tile.getState() === TileState.LOADED) {
      this.loaded = true;
      this.uploadTile_();
      this.dispatchEvent(EventType.CHANGE);
    }
  }
  disposeInternal() {
    const gl = this.helper_.getGL();
    this.helper_.deleteBuffer(this.coords);
    for (let i2 = 0; i2 < this.textures.length; ++i2) {
      gl.deleteTexture(this.textures[i2]);
    }
    this.tile.removeEventListener(EventType.CHANGE, this.handleTileChange_);
  }
  getPixelData(renderCol, renderRow) {
    if (!this.loaded) {
      return null;
    }
    const renderWidth = this.renderSize_[0];
    const renderHeight = this.renderSize_[1];
    const gutter = this.gutter_;
    if (this.tile instanceof DataTile) {
      const sourceSize = this.tile.getSize();
      const sourceWidthWithoutGutter2 = sourceSize[0];
      const sourceHeightWithoutGutter2 = sourceSize[1];
      const sourceWidth2 = sourceWidthWithoutGutter2 + 2 * gutter;
      const sourceHeight2 = sourceHeightWithoutGutter2 + 2 * gutter;
      const sourceCol2 = gutter + Math.floor(sourceWidthWithoutGutter2 * (renderCol / renderWidth));
      const sourceRow2 = gutter + Math.floor(sourceHeightWithoutGutter2 * (renderRow / renderHeight));
      const data3 = this.tile.getData();
      if (data3 instanceof DataView) {
        const bytesPerPixel = data3.byteLength / (sourceWidth2 * sourceHeight2);
        const offset3 = bytesPerPixel * (sourceRow2 * sourceWidth2 + sourceCol2);
        const buffer2 = data3.buffer.slice(offset3, offset3 + bytesPerPixel);
        return new DataView(buffer2);
      }
      const offset2 = this.bandCount * (sourceRow2 * sourceWidth2 + sourceCol2);
      return data3.slice(offset2, offset2 + this.bandCount);
    }
    if (!pixelContext) {
      createPixelContext();
    }
    pixelContext.clearRect(0, 0, 1, 1);
    const image2 = this.tile.getImage();
    const sourceWidth = image2.width;
    const sourceHeight = image2.height;
    const sourceWidthWithoutGutter = sourceWidth - 2 * gutter;
    const sourceHeightWithoutGutter = sourceHeight - 2 * gutter;
    const sourceCol = gutter + Math.floor(sourceWidthWithoutGutter * (renderCol / renderWidth));
    const sourceRow = gutter + Math.floor(sourceHeightWithoutGutter * (renderRow / renderHeight));
    let data2;
    try {
      pixelContext.drawImage(image2, sourceCol, sourceRow, 1, 1, 0, 0, 1, 1);
      data2 = pixelContext.getImageData(0, 0, 1, 1).data;
    } catch (err2) {
      pixelContext = null;
      return null;
    }
    return data2;
  }
}
var ContextEventType = {
  LOST: "webglcontextlost",
  RESTORED: "webglcontextrestored"
};
const DEFAULT_VERTEX_SHADER = `
  precision mediump float;
  
  attribute vec2 a_position;
  varying vec2 v_texCoord;
  varying vec2 v_screenCoord;
  
  uniform vec2 u_screenSize;
   
  void main() {
    v_texCoord = a_position * 0.5 + 0.5;
    v_screenCoord = v_texCoord * u_screenSize;
    gl_Position = vec4(a_position, 0.0, 1.0);
  }
`;
const DEFAULT_FRAGMENT_SHADER = `
  precision mediump float;
   
  uniform sampler2D u_image;
  uniform float u_opacity;
   
  varying vec2 v_texCoord;
   
  void main() {
    gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;
  }
`;
class WebGLPostProcessingPass {
  constructor(options) {
    this.gl_ = options.webGlContext;
    const gl = this.gl_;
    this.scaleRatio_ = options.scaleRatio || 1;
    this.renderTargetTexture_ = gl.createTexture();
    this.renderTargetTextureSize_ = null;
    this.frameBuffer_ = gl.createFramebuffer();
    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, options.vertexShader || DEFAULT_VERTEX_SHADER);
    gl.compileShader(vertexShader);
    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, options.fragmentShader || DEFAULT_FRAGMENT_SHADER);
    gl.compileShader(fragmentShader);
    this.renderTargetProgram_ = gl.createProgram();
    gl.attachShader(this.renderTargetProgram_, vertexShader);
    gl.attachShader(this.renderTargetProgram_, fragmentShader);
    gl.linkProgram(this.renderTargetProgram_);
    this.renderTargetVerticesBuffer_ = gl.createBuffer();
    const verticesArray = [-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1];
    gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesArray), gl.STATIC_DRAW);
    this.renderTargetAttribLocation_ = gl.getAttribLocation(this.renderTargetProgram_, "a_position");
    this.renderTargetUniformLocation_ = gl.getUniformLocation(this.renderTargetProgram_, "u_screenSize");
    this.renderTargetOpacityLocation_ = gl.getUniformLocation(this.renderTargetProgram_, "u_opacity");
    this.renderTargetTextureLocation_ = gl.getUniformLocation(this.renderTargetProgram_, "u_image");
    this.uniforms_ = [];
    options.uniforms && Object.keys(options.uniforms).forEach((name) => {
      this.uniforms_.push({
        value: options.uniforms[name],
        location: gl.getUniformLocation(this.renderTargetProgram_, name)
      });
    });
  }
  getGL() {
    return this.gl_;
  }
  init(frameState) {
    const gl = this.getGL();
    const textureSize = [
      gl.drawingBufferWidth * this.scaleRatio_,
      gl.drawingBufferHeight * this.scaleRatio_
    ];
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.getFrameBuffer());
    gl.viewport(0, 0, textureSize[0], textureSize[1]);
    if (!this.renderTargetTextureSize_ || this.renderTargetTextureSize_[0] !== textureSize[0] || this.renderTargetTextureSize_[1] !== textureSize[1]) {
      this.renderTargetTextureSize_ = textureSize;
      const level = 0;
      const internalFormat = gl.RGBA;
      const border = 0;
      const format2 = gl.RGBA;
      const type = gl.UNSIGNED_BYTE;
      const data2 = null;
      gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);
      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, textureSize[0], textureSize[1], border, format2, type, data2);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.renderTargetTexture_, 0);
    }
  }
  apply(frameState, nextPass, preCompose, postCompose) {
    const gl = this.getGL();
    const size = frameState.size;
    gl.bindFramebuffer(gl.FRAMEBUFFER, nextPass ? nextPass.getFrameBuffer() : null);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);
    if (!nextPass) {
      const canvasId = getUid(gl.canvas);
      if (!frameState.renderTargets[canvasId]) {
        const attributes = gl.getContextAttributes();
        if (attributes && attributes.preserveDrawingBuffer) {
          gl.clearColor(0, 0, 0, 0);
          gl.clear(gl.COLOR_BUFFER_BIT);
        }
        frameState.renderTargets[canvasId] = true;
      }
    }
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);
    gl.useProgram(this.renderTargetProgram_);
    gl.enableVertexAttribArray(this.renderTargetAttribLocation_);
    gl.vertexAttribPointer(this.renderTargetAttribLocation_, 2, gl.FLOAT, false, 0, 0);
    gl.uniform2f(this.renderTargetUniformLocation_, size[0], size[1]);
    gl.uniform1i(this.renderTargetTextureLocation_, 0);
    const opacity2 = frameState.layerStatesArray[frameState.layerIndex].opacity;
    gl.uniform1f(this.renderTargetOpacityLocation_, opacity2);
    this.applyUniforms(frameState);
    if (preCompose) {
      preCompose(gl, frameState);
    }
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    if (postCompose) {
      postCompose(gl, frameState);
    }
  }
  getFrameBuffer() {
    return this.frameBuffer_;
  }
  applyUniforms(frameState) {
    const gl = this.getGL();
    let value;
    let textureSlot = 1;
    this.uniforms_.forEach(function(uniform) {
      value = typeof uniform.value === "function" ? uniform.value(frameState) : uniform.value;
      if (value instanceof HTMLCanvasElement || value instanceof ImageData) {
        if (!uniform.texture) {
          uniform.texture = gl.createTexture();
        }
        gl.activeTexture(gl[`TEXTURE${textureSlot}`]);
        gl.bindTexture(gl.TEXTURE_2D, uniform.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        if (value instanceof ImageData) {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, value.width, value.height, 0, gl.UNSIGNED_BYTE, new Uint8Array(value.data));
        } else {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, value);
        }
        gl.uniform1i(uniform.location, textureSlot++);
      } else if (Array.isArray(value)) {
        switch (value.length) {
          case 2:
            gl.uniform2f(uniform.location, value[0], value[1]);
            return;
          case 3:
            gl.uniform3f(uniform.location, value[0], value[1], value[2]);
            return;
          case 4:
            gl.uniform4f(uniform.location, value[0], value[1], value[2], value[3]);
            return;
          default:
            return;
        }
      } else if (typeof value === "number") {
        gl.uniform1f(uniform.location, value);
      }
    });
  }
}
function create$6() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function fromTransform(mat4, transform2) {
  mat4[0] = transform2[0];
  mat4[1] = transform2[1];
  mat4[4] = transform2[2];
  mat4[5] = transform2[3];
  mat4[12] = transform2[4];
  mat4[13] = transform2[5];
  return mat4;
}
const DefaultUniform = {
  PROJECTION_MATRIX: "u_projectionMatrix",
  OFFSET_SCALE_MATRIX: "u_offsetScaleMatrix",
  OFFSET_ROTATION_MATRIX: "u_offsetRotateMatrix",
  TIME: "u_time",
  ZOOM: "u_zoom",
  RESOLUTION: "u_resolution",
  SIZE_PX: "u_sizePx",
  PIXEL_RATIO: "u_pixelRatio"
};
const AttributeType = {
  UNSIGNED_BYTE,
  UNSIGNED_SHORT,
  UNSIGNED_INT,
  FLOAT
};
const canvasCache = {};
function getSharedCanvasCacheKey(key) {
  return "shared/" + key;
}
let uniqueCanvasCacheKeyCount = 0;
function getUniqueCanvasCacheKey() {
  const key = "unique/" + uniqueCanvasCacheKeyCount;
  uniqueCanvasCacheKeyCount += 1;
  return key;
}
function getCanvas(key) {
  let cacheItem = canvasCache[key];
  if (!cacheItem) {
    const canvas = document.createElement("canvas");
    canvas.style.position = "absolute";
    canvas.style.left = "0";
    cacheItem = { users: 0, canvas };
    canvasCache[key] = cacheItem;
  }
  cacheItem.users += 1;
  return cacheItem.canvas;
}
function releaseCanvas(key) {
  const cacheItem = canvasCache[key];
  if (!cacheItem) {
    return;
  }
  cacheItem.users -= 1;
  if (cacheItem.users > 0) {
    return;
  }
  const canvas = cacheItem.canvas;
  const gl = getContext(canvas);
  const extension = gl.getExtension("WEBGL_lose_context");
  if (extension) {
    extension.loseContext();
  }
  delete canvasCache[key];
}
class WebGLHelper extends Disposable {
  constructor(options) {
    super();
    options = options || {};
    this.boundHandleWebGLContextLost_ = this.handleWebGLContextLost.bind(this);
    this.boundHandleWebGLContextRestored_ = this.handleWebGLContextRestored.bind(this);
    this.canvasCacheKey_ = options.canvasCacheKey ? getSharedCanvasCacheKey(options.canvasCacheKey) : getUniqueCanvasCacheKey();
    this.canvas_ = getCanvas(this.canvasCacheKey_);
    this.gl_ = getContext(this.canvas_);
    this.bufferCache_ = {};
    this.extensionCache_ = {};
    this.currentProgram_ = null;
    this.canvas_.addEventListener(ContextEventType.LOST, this.boundHandleWebGLContextLost_);
    this.canvas_.addEventListener(ContextEventType.RESTORED, this.boundHandleWebGLContextRestored_);
    this.offsetRotateMatrix_ = create$7();
    this.offsetScaleMatrix_ = create$7();
    this.tmpMat4_ = create$6();
    this.uniformLocations_ = {};
    this.attribLocations_ = {};
    this.uniforms_ = [];
    if (options.uniforms) {
      this.setUniforms(options.uniforms);
    }
    const gl = this.getGL();
    this.postProcessPasses_ = options.postProcesses ? options.postProcesses.map(function(options2) {
      return new WebGLPostProcessingPass({
        webGlContext: gl,
        scaleRatio: options2.scaleRatio,
        vertexShader: options2.vertexShader,
        fragmentShader: options2.fragmentShader,
        uniforms: options2.uniforms
      });
    }) : [new WebGLPostProcessingPass({ webGlContext: gl })];
    this.shaderCompileErrors_ = null;
    this.startTime_ = Date.now();
  }
  setUniforms(uniforms) {
    this.uniforms_ = [];
    for (const name in uniforms) {
      this.uniforms_.push({
        name,
        value: uniforms[name]
      });
    }
    this.uniformLocations_ = {};
  }
  canvasCacheKeyMatches(canvasCacheKey) {
    return this.canvasCacheKey_ === getSharedCanvasCacheKey(canvasCacheKey);
  }
  getExtension(name) {
    if (name in this.extensionCache_) {
      return this.extensionCache_[name];
    }
    const extension = this.gl_.getExtension(name);
    this.extensionCache_[name] = extension;
    return extension;
  }
  bindBuffer(buffer2) {
    const gl = this.getGL();
    const bufferKey = getUid(buffer2);
    let bufferCache = this.bufferCache_[bufferKey];
    if (!bufferCache) {
      const webGlBuffer = gl.createBuffer();
      bufferCache = {
        buffer: buffer2,
        webGlBuffer
      };
      this.bufferCache_[bufferKey] = bufferCache;
    }
    gl.bindBuffer(buffer2.getType(), bufferCache.webGlBuffer);
  }
  flushBufferData(buffer2) {
    const gl = this.getGL();
    this.bindBuffer(buffer2);
    gl.bufferData(buffer2.getType(), buffer2.getArray(), buffer2.getUsage());
  }
  deleteBuffer(buf) {
    const gl = this.getGL();
    const bufferKey = getUid(buf);
    const bufferCacheEntry = this.bufferCache_[bufferKey];
    if (bufferCacheEntry && !gl.isContextLost()) {
      gl.deleteBuffer(bufferCacheEntry.webGlBuffer);
    }
    delete this.bufferCache_[bufferKey];
  }
  disposeInternal() {
    this.canvas_.removeEventListener(ContextEventType.LOST, this.boundHandleWebGLContextLost_);
    this.canvas_.removeEventListener(ContextEventType.RESTORED, this.boundHandleWebGLContextRestored_);
    releaseCanvas(this.canvasCacheKey_);
    delete this.gl_;
    delete this.canvas_;
  }
  prepareDraw(frameState, disableAlphaBlend) {
    const gl = this.getGL();
    const canvas = this.getCanvas();
    const size = frameState.size;
    const pixelRatio = frameState.pixelRatio;
    canvas.width = size[0] * pixelRatio;
    canvas.height = size[1] * pixelRatio;
    canvas.style.width = size[0] + "px";
    canvas.style.height = size[1] + "px";
    for (let i2 = this.postProcessPasses_.length - 1; i2 >= 0; i2--) {
      this.postProcessPasses_[i2].init(frameState);
    }
    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE, disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);
  }
  prepareDrawToRenderTarget(frameState, renderTarget, disableAlphaBlend) {
    const gl = this.getGL();
    const size = renderTarget.getSize();
    gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget.getFramebuffer());
    gl.viewport(0, 0, size[0], size[1]);
    gl.bindTexture(gl.TEXTURE_2D, renderTarget.getTexture());
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE, disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);
  }
  drawElements(start2, end) {
    const gl = this.getGL();
    this.getExtension("OES_element_index_uint");
    const elementType = gl.UNSIGNED_INT;
    const elementSize = 4;
    const numItems = end - start2;
    const offsetInBytes = start2 * elementSize;
    gl.drawElements(gl.TRIANGLES, numItems, elementType, offsetInBytes);
  }
  finalizeDraw(frameState, preCompose, postCompose) {
    for (let i2 = 0, ii = this.postProcessPasses_.length; i2 < ii; i2++) {
      if (i2 === ii - 1) {
        this.postProcessPasses_[i2].apply(frameState, null, preCompose, postCompose);
      } else {
        this.postProcessPasses_[i2].apply(frameState, this.postProcessPasses_[i2 + 1]);
      }
    }
  }
  getCanvas() {
    return this.canvas_;
  }
  getGL() {
    return this.gl_;
  }
  applyFrameState(frameState) {
    const size = frameState.size;
    const rotation = frameState.viewState.rotation;
    const pixelRatio = frameState.pixelRatio;
    const offsetScaleMatrix = reset(this.offsetScaleMatrix_);
    scale$3(offsetScaleMatrix, 2 / size[0], 2 / size[1]);
    const offsetRotateMatrix = reset(this.offsetRotateMatrix_);
    if (rotation !== 0) {
      rotate$2(offsetRotateMatrix, -rotation);
    }
    this.setUniformMatrixValue(DefaultUniform.OFFSET_SCALE_MATRIX, fromTransform(this.tmpMat4_, offsetScaleMatrix));
    this.setUniformMatrixValue(DefaultUniform.OFFSET_ROTATION_MATRIX, fromTransform(this.tmpMat4_, offsetRotateMatrix));
    this.setUniformFloatValue(DefaultUniform.TIME, (Date.now() - this.startTime_) * 1e-3);
    this.setUniformFloatValue(DefaultUniform.ZOOM, frameState.viewState.zoom);
    this.setUniformFloatValue(DefaultUniform.RESOLUTION, frameState.viewState.resolution);
    this.setUniformFloatValue(DefaultUniform.PIXEL_RATIO, pixelRatio);
    this.setUniformFloatVec2(DefaultUniform.SIZE_PX, [size[0], size[1]]);
  }
  applyUniforms(frameState) {
    const gl = this.getGL();
    let value;
    let textureSlot = 0;
    this.uniforms_.forEach((uniform) => {
      value = typeof uniform.value === "function" ? uniform.value(frameState) : uniform.value;
      if (value instanceof HTMLCanvasElement || value instanceof HTMLImageElement || value instanceof ImageData) {
        if (!uniform.texture) {
          uniform.prevValue = void 0;
          uniform.texture = gl.createTexture();
        }
        gl.activeTexture(gl[`TEXTURE${textureSlot}`]);
        gl.bindTexture(gl.TEXTURE_2D, uniform.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        const imageReady2 = !(value instanceof HTMLImageElement) || value.complete;
        if (imageReady2 && uniform.prevValue !== value) {
          uniform.prevValue = value;
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, value);
        }
        gl.uniform1i(this.getUniformLocation(uniform.name), textureSlot++);
      } else if (Array.isArray(value) && value.length === 6) {
        this.setUniformMatrixValue(uniform.name, fromTransform(this.tmpMat4_, value));
      } else if (Array.isArray(value) && value.length <= 4) {
        switch (value.length) {
          case 2:
            gl.uniform2f(this.getUniformLocation(uniform.name), value[0], value[1]);
            return;
          case 3:
            gl.uniform3f(this.getUniformLocation(uniform.name), value[0], value[1], value[2]);
            return;
          case 4:
            gl.uniform4f(this.getUniformLocation(uniform.name), value[0], value[1], value[2], value[3]);
            return;
          default:
            return;
        }
      } else if (typeof value === "number") {
        gl.uniform1f(this.getUniformLocation(uniform.name), value);
      }
    });
  }
  useProgram(program, frameState) {
    const gl = this.getGL();
    gl.useProgram(program);
    this.currentProgram_ = program;
    this.uniformLocations_ = {};
    this.attribLocations_ = {};
    this.applyFrameState(frameState);
    this.applyUniforms(frameState);
  }
  compileShader(source, type) {
    const gl = this.getGL();
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    return shader;
  }
  getProgram(fragmentShaderSource, vertexShaderSource) {
    const gl = this.getGL();
    const fragmentShader = this.compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);
    const vertexShader = this.compileShader(vertexShaderSource, gl.VERTEX_SHADER);
    const program = gl.createProgram();
    gl.attachShader(program, fragmentShader);
    gl.attachShader(program, vertexShader);
    gl.linkProgram(program);
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      const message = `Fragment shader compliation failed: ${gl.getShaderInfoLog(fragmentShader)}`;
      throw new Error(message);
    }
    gl.deleteShader(fragmentShader);
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      const message = `Vertex shader compilation failed: ${gl.getShaderInfoLog(vertexShader)}`;
      throw new Error(message);
    }
    gl.deleteShader(vertexShader);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      const message = `GL program linking failed: ${gl.getShaderInfoLog(vertexShader)}`;
      throw new Error(message);
    }
    return program;
  }
  getUniformLocation(name) {
    if (this.uniformLocations_[name] === void 0) {
      this.uniformLocations_[name] = this.getGL().getUniformLocation(this.currentProgram_, name);
    }
    return this.uniformLocations_[name];
  }
  getAttributeLocation(name) {
    if (this.attribLocations_[name] === void 0) {
      this.attribLocations_[name] = this.getGL().getAttribLocation(this.currentProgram_, name);
    }
    return this.attribLocations_[name];
  }
  makeProjectionTransform(frameState, transform2) {
    const size = frameState.size;
    const rotation = frameState.viewState.rotation;
    const resolution = frameState.viewState.resolution;
    const center = frameState.viewState.center;
    reset(transform2);
    compose(transform2, 0, 0, 2 / (resolution * size[0]), 2 / (resolution * size[1]), -rotation, -center[0], -center[1]);
    return transform2;
  }
  setUniformFloatValue(uniform, value) {
    this.getGL().uniform1f(this.getUniformLocation(uniform), value);
  }
  setUniformFloatVec2(uniform, value) {
    this.getGL().uniform2fv(this.getUniformLocation(uniform), value);
  }
  setUniformFloatVec4(uniform, value) {
    this.getGL().uniform4fv(this.getUniformLocation(uniform), value);
  }
  setUniformMatrixValue(uniform, value) {
    this.getGL().uniformMatrix4fv(this.getUniformLocation(uniform), false, value);
  }
  enableAttributeArray_(attribName, size, type, stride, offset2) {
    const location2 = this.getAttributeLocation(attribName);
    if (location2 < 0) {
      return;
    }
    this.getGL().enableVertexAttribArray(location2);
    this.getGL().vertexAttribPointer(location2, size, type, false, stride, offset2);
  }
  enableAttributes(attributes) {
    const stride = computeAttributesStride(attributes);
    let offset2 = 0;
    for (let i2 = 0; i2 < attributes.length; i2++) {
      const attr = attributes[i2];
      this.enableAttributeArray_(attr.name, attr.size, attr.type || FLOAT, stride, offset2);
      offset2 += attr.size * getByteSizeFromType(attr.type);
    }
  }
  handleWebGLContextLost() {
    clear$1(this.bufferCache_);
    this.currentProgram_ = null;
  }
  handleWebGLContextRestored() {
  }
  createTexture(size, data2, texture) {
    const gl = this.getGL();
    texture = texture || gl.createTexture();
    const level = 0;
    const internalFormat = gl.RGBA;
    const border = 0;
    const format2 = gl.RGBA;
    const type = gl.UNSIGNED_BYTE;
    gl.bindTexture(gl.TEXTURE_2D, texture);
    if (data2) {
      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, format2, type, data2);
    } else {
      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, size[0], size[1], border, format2, type, null);
    }
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    return texture;
  }
}
function computeAttributesStride(attributes) {
  let stride = 0;
  for (let i2 = 0; i2 < attributes.length; i2++) {
    const attr = attributes[i2];
    stride += attr.size * getByteSizeFromType(attr.type);
  }
  return stride;
}
function getByteSizeFromType(type) {
  switch (type) {
    case AttributeType.UNSIGNED_BYTE:
      return Uint8Array.BYTES_PER_ELEMENT;
    case AttributeType.UNSIGNED_SHORT:
      return Uint16Array.BYTES_PER_ELEMENT;
    case AttributeType.UNSIGNED_INT:
      return Uint32Array.BYTES_PER_ELEMENT;
    case AttributeType.FLOAT:
    default:
      return Float32Array.BYTES_PER_ELEMENT;
  }
}
class WebGLLayerRenderer extends LayerRenderer {
  constructor(layer, options) {
    super(layer);
    options = options || {};
    this.inversePixelTransform_ = create$7();
    this.pixelContext_ = null;
    this.postProcesses_ = options.postProcesses;
    this.uniforms_ = options.uniforms;
    this.helper;
    layer.addChangeListener(LayerProperty.MAP, this.removeHelper.bind(this));
    this.dispatchPreComposeEvent = this.dispatchPreComposeEvent.bind(this);
    this.dispatchPostComposeEvent = this.dispatchPostComposeEvent.bind(this);
  }
  dispatchPreComposeEvent(context2, frameState) {
    const layer = this.getLayer();
    if (layer.hasListener(RenderEventType.PRECOMPOSE)) {
      const event = new RenderEvent(RenderEventType.PRECOMPOSE, void 0, frameState, context2);
      layer.dispatchEvent(event);
    }
  }
  dispatchPostComposeEvent(context2, frameState) {
    const layer = this.getLayer();
    if (layer.hasListener(RenderEventType.POSTCOMPOSE)) {
      const event = new RenderEvent(RenderEventType.POSTCOMPOSE, void 0, frameState, context2);
      layer.dispatchEvent(event);
    }
  }
  reset(options) {
    this.uniforms_ = options.uniforms;
    if (this.helper) {
      this.helper.setUniforms(this.uniforms_);
    }
  }
  removeHelper() {
    if (this.helper) {
      this.helper.dispose();
      delete this.helper;
    }
  }
  prepareFrame(frameState) {
    if (this.getLayer().getRenderSource()) {
      let incrementGroup = true;
      let groupNumber = -1;
      let className;
      for (let i2 = 0, ii = frameState.layerStatesArray.length; i2 < ii; i2++) {
        const layer = frameState.layerStatesArray[i2].layer;
        const renderer = layer.getRenderer();
        if (!(renderer instanceof WebGLLayerRenderer)) {
          incrementGroup = true;
          continue;
        }
        const layerClassName = layer.getClassName();
        if (incrementGroup || layerClassName !== className) {
          groupNumber += 1;
          incrementGroup = false;
        }
        className = layerClassName;
        if (renderer === this) {
          break;
        }
      }
      const canvasCacheKey = "map/" + frameState.mapId + "/group/" + groupNumber;
      if (!this.helper || !this.helper.canvasCacheKeyMatches(canvasCacheKey)) {
        this.removeHelper();
        this.helper = new WebGLHelper({
          postProcesses: this.postProcesses_,
          uniforms: this.uniforms_,
          canvasCacheKey
        });
        if (className) {
          this.helper.getCanvas().className = className;
        }
        this.afterHelperCreated();
      }
    }
    return this.prepareFrameInternal(frameState);
  }
  afterHelperCreated() {
  }
  prepareFrameInternal(frameState) {
    return true;
  }
  disposeInternal() {
    this.removeHelper();
    super.disposeInternal();
  }
  dispatchRenderEvent_(type, context2, frameState) {
    const layer = this.getLayer();
    if (layer.hasListener(type)) {
      compose(this.inversePixelTransform_, 0, 0, frameState.pixelRatio, -frameState.pixelRatio, 0, 0, -frameState.size[1]);
      const event = new RenderEvent(type, this.inversePixelTransform_, frameState, context2);
      layer.dispatchEvent(event);
    }
  }
  preRender(context2, frameState) {
    this.dispatchRenderEvent_(RenderEventType.PRERENDER, context2, frameState);
  }
  postRender(context2, frameState) {
    this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context2, frameState);
  }
}
function createOrUpdate(z2, x2, y2, tileCoord) {
  if (tileCoord !== void 0) {
    tileCoord[0] = z2;
    tileCoord[1] = x2;
    tileCoord[2] = y2;
    return tileCoord;
  }
  return [z2, x2, y2];
}
function getKeyZXY(z2, x2, y2) {
  return z2 + "/" + x2 + "/" + y2;
}
function getKey(tileCoord) {
  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
}
function fromKey(key) {
  return key.split("/").map(Number);
}
function hash(tileCoord) {
  return (tileCoord[1] << tileCoord[0]) + tileCoord[2];
}
function withinExtentAndZ(tileCoord, tileGrid) {
  const z2 = tileCoord[0];
  const x2 = tileCoord[1];
  const y2 = tileCoord[2];
  if (tileGrid.getMinZoom() > z2 || z2 > tileGrid.getMaxZoom()) {
    return false;
  }
  const tileRange = tileGrid.getFullTileRange(z2);
  if (!tileRange) {
    return true;
  }
  return tileRange.containsXY(x2, y2);
}
const Uniforms = {
  TILE_TEXTURE_ARRAY: "u_tileTextures",
  TILE_TRANSFORM: "u_tileTransform",
  TRANSITION_ALPHA: "u_transitionAlpha",
  DEPTH: "u_depth",
  TEXTURE_PIXEL_WIDTH: "u_texturePixelWidth",
  TEXTURE_PIXEL_HEIGHT: "u_texturePixelHeight",
  TEXTURE_RESOLUTION: "u_textureResolution",
  TEXTURE_ORIGIN_X: "u_textureOriginX",
  TEXTURE_ORIGIN_Y: "u_textureOriginY",
  RENDER_EXTENT: "u_renderExtent",
  RESOLUTION: "u_resolution",
  ZOOM: "u_zoom"
};
const Attributes = {
  TEXTURE_COORD: "a_textureCoord"
};
const attributeDescriptions = [
  {
    name: Attributes.TEXTURE_COORD,
    size: 2,
    type: AttributeType.FLOAT
  }
];
const empty$1 = {};
function depthForZ(z2) {
  return 2 * (1 - 1 / (z2 + 1)) - 1;
}
function addTileTextureToLookup(tileTexturesByZ, tileTexture, z2) {
  if (!(z2 in tileTexturesByZ)) {
    tileTexturesByZ[z2] = [];
  }
  tileTexturesByZ[z2].push(tileTexture);
}
function getRenderExtent(frameState, extent2) {
  const layerState = frameState.layerStatesArray[frameState.layerIndex];
  if (layerState.extent) {
    extent2 = getIntersection(extent2, fromUserExtent(layerState.extent, frameState.viewState.projection));
  }
  const source = layerState.layer.getRenderSource();
  if (!source.getWrapX()) {
    const gridExtent = source.getTileGridForProjection(frameState.viewState.projection).getExtent();
    if (gridExtent) {
      extent2 = getIntersection(extent2, gridExtent);
    }
  }
  return extent2;
}
function getCacheKey(source, tileCoord) {
  return `${source.getKey()},${getKey(tileCoord)}`;
}
class WebGLTileLayerRenderer extends WebGLLayerRenderer {
  constructor(tileLayer, options) {
    super(tileLayer, {
      uniforms: options.uniforms
    });
    this.renderComplete = false;
    this.tileTransform_ = create$7();
    this.tempMat4_ = create$6();
    this.tempTileRange_ = new TileRange(0, 0, 0, 0);
    this.tempTileCoord_ = createOrUpdate(0, 0, 0);
    this.tempSize_ = [0, 0];
    this.program_;
    this.vertexShader_ = options.vertexShader;
    this.fragmentShader_ = options.fragmentShader;
    this.indices_ = new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER, STATIC_DRAW);
    this.indices_.fromArray([0, 1, 3, 1, 2, 3]);
    const cacheSize = options.cacheSize !== void 0 ? options.cacheSize : 512;
    this.tileTextureCache_ = new LRUCache$1(cacheSize);
    this.paletteTextures_ = options.paletteTextures || [];
    this.frameState_ = null;
    this.projection_ = void 0;
  }
  reset(options) {
    super.reset({
      uniforms: options.uniforms
    });
    this.vertexShader_ = options.vertexShader;
    this.fragmentShader_ = options.fragmentShader;
    this.paletteTextures_ = options.paletteTextures || [];
    if (this.helper) {
      this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);
    }
  }
  afterHelperCreated() {
    this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);
    this.helper.flushBufferData(this.indices_);
  }
  isDrawableTile_(tile2) {
    const tileLayer = this.getLayer();
    const tileState = tile2.getState();
    const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();
    return tileState == TileState.LOADED || tileState == TileState.EMPTY || tileState == TileState.ERROR && !useInterimTilesOnError;
  }
  prepareFrameInternal(frameState) {
    if (!this.projection_) {
      this.projection_ = frameState.viewState.projection;
    } else if (frameState.viewState.projection !== this.projection_) {
      this.clearCache();
      this.projection_ = frameState.viewState.projection;
    }
    const layer = this.getLayer();
    const source = layer.getRenderSource();
    if (!source) {
      return false;
    }
    if (isEmpty(getRenderExtent(frameState, frameState.extent))) {
      return false;
    }
    return source.getState() === "ready";
  }
  enqueueTiles(frameState, extent2, initialZ, tileTexturesByZ, preload) {
    const viewState = frameState.viewState;
    const tileLayer = this.getLayer();
    const tileSource = tileLayer.getRenderSource();
    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);
    const gutter = tileSource.getGutterForProjection(viewState.projection);
    const tileSourceKey = getUid(tileSource);
    if (!(tileSourceKey in frameState.wantedTiles)) {
      frameState.wantedTiles[tileSourceKey] = {};
    }
    const wantedTiles = frameState.wantedTiles[tileSourceKey];
    const tileTextureCache = this.tileTextureCache_;
    const map = tileLayer.getMapInternal();
    const minZ = Math.max(initialZ - preload, tileGrid.getMinZoom(), tileGrid.getZForResolution(Math.min(tileLayer.getMaxResolution(), map ? map.getView().getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0)) : tileGrid.getResolution(0)), tileSource.zDirection));
    for (let z2 = initialZ; z2 >= minZ; --z2) {
      const tileRange = tileGrid.getTileRangeForExtentAndZ(extent2, z2, this.tempTileRange_);
      const tileResolution = tileGrid.getResolution(z2);
      for (let x2 = tileRange.minX; x2 <= tileRange.maxX; ++x2) {
        for (let y2 = tileRange.minY; y2 <= tileRange.maxY; ++y2) {
          const tileCoord = createOrUpdate(z2, x2, y2, this.tempTileCoord_);
          const cacheKey = getCacheKey(tileSource, tileCoord);
          let tileTexture;
          let tile2;
          if (tileTextureCache.containsKey(cacheKey)) {
            tileTexture = tileTextureCache.get(cacheKey);
            tile2 = tileTexture.tile;
          }
          if (!tileTexture || tileTexture.tile.key !== tileSource.getKey()) {
            tile2 = tileSource.getTile(z2, x2, y2, frameState.pixelRatio, viewState.projection);
            if (!tileTexture) {
              tileTexture = new TileTexture({
                tile: tile2,
                grid: tileGrid,
                helper: this.helper,
                gutter
              });
              tileTextureCache.set(cacheKey, tileTexture);
            } else {
              if (this.isDrawableTile_(tile2)) {
                tileTexture.setTile(tile2);
              } else {
                const interimTile = tile2.getInterimTile();
                tileTexture.setTile(interimTile);
              }
            }
          }
          addTileTextureToLookup(tileTexturesByZ, tileTexture, z2);
          const tileQueueKey = tile2.getKey();
          wantedTiles[tileQueueKey] = true;
          if (tile2.getState() === TileState.IDLE) {
            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {
              frameState.tileQueue.enqueue([
                tile2,
                tileSourceKey,
                tileGrid.getTileCoordCenter(tileCoord),
                tileResolution
              ]);
            }
          }
        }
      }
    }
  }
  renderFrame(frameState) {
    this.frameState_ = frameState;
    this.renderComplete = true;
    const gl = this.helper.getGL();
    this.preRender(gl, frameState);
    const viewState = frameState.viewState;
    const tileLayer = this.getLayer();
    const tileSource = tileLayer.getRenderSource();
    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);
    const gutter = tileSource.getGutterForProjection(viewState.projection);
    const extent2 = getRenderExtent(frameState, frameState.extent);
    const z2 = tileGrid.getZForResolution(viewState.resolution, tileSource.zDirection);
    const tileTexturesByZ = {};
    const preload = tileLayer.getPreload();
    if (frameState.nextExtent) {
      const targetZ = tileGrid.getZForResolution(viewState.nextResolution, tileSource.zDirection);
      const nextExtent = getRenderExtent(frameState, frameState.nextExtent);
      this.enqueueTiles(frameState, nextExtent, targetZ, tileTexturesByZ, preload);
    }
    this.enqueueTiles(frameState, extent2, z2, tileTexturesByZ, 0);
    if (preload > 0) {
      setTimeout(() => {
        this.enqueueTiles(frameState, extent2, z2 - 1, tileTexturesByZ, preload - 1);
      }, 0);
    }
    const alphaLookup = {};
    const uid2 = getUid(this);
    const time2 = frameState.time;
    let blend = false;
    const tileTextures = tileTexturesByZ[z2];
    for (let i2 = 0, ii = tileTextures.length; i2 < ii; ++i2) {
      const tileTexture = tileTextures[i2];
      const tile2 = tileTexture.tile;
      if ((tile2 instanceof ReprojTile || tile2 instanceof ReprojDataTile) && tile2.getState() === TileState.EMPTY) {
        continue;
      }
      const tileCoord = tile2.tileCoord;
      if (tileTexture.loaded) {
        const alpha = tile2.getAlpha(uid2, time2);
        if (alpha === 1) {
          tile2.endTransition(uid2);
          continue;
        }
        blend = true;
        const tileCoordKey = getKey(tileCoord);
        alphaLookup[tileCoordKey] = alpha;
      }
      this.renderComplete = false;
      const coveredByChildren = this.findAltTiles_(tileGrid, tileCoord, z2 + 1, tileTexturesByZ);
      if (coveredByChildren) {
        continue;
      }
      const minZoom = tileGrid.getMinZoom();
      for (let parentZ = z2 - 1; parentZ >= minZoom; --parentZ) {
        const coveredByParent = this.findAltTiles_(tileGrid, tileCoord, parentZ, tileTexturesByZ);
        if (coveredByParent) {
          break;
        }
      }
    }
    this.helper.useProgram(this.program_, frameState);
    this.helper.prepareDraw(frameState, !blend);
    const zs = Object.keys(tileTexturesByZ).map(Number).sort(numberSafeCompareFunction);
    const centerX = viewState.center[0];
    const centerY = viewState.center[1];
    for (let j2 = 0, jj = zs.length; j2 < jj; ++j2) {
      const tileZ = zs[j2];
      const tileResolution = tileGrid.getResolution(tileZ);
      const tileSize = toSize(tileGrid.getTileSize(tileZ), this.tempSize_);
      const tileOrigin = tileGrid.getOrigin(tileZ);
      const tileWidthWithGutter = tileSize[0] + 2 * gutter;
      const tileHeightWithGutter = tileSize[1] + 2 * gutter;
      const aspectRatio = tileWidthWithGutter / tileHeightWithGutter;
      const centerI = (centerX - tileOrigin[0]) / (tileSize[0] * tileResolution);
      const centerJ = (tileOrigin[1] - centerY) / (tileSize[1] * tileResolution);
      const tileScale = viewState.resolution / tileResolution;
      const depth = depthForZ(tileZ);
      const tileTextures2 = tileTexturesByZ[tileZ];
      for (let i2 = 0, ii = tileTextures2.length; i2 < ii; ++i2) {
        const tileTexture = tileTextures2[i2];
        if (!tileTexture.loaded) {
          continue;
        }
        const tile2 = tileTexture.tile;
        const tileCoord = tile2.tileCoord;
        const tileCoordKey = getKey(tileCoord);
        const tileCenterI = tileCoord[1];
        const tileCenterJ = tileCoord[2];
        reset(this.tileTransform_);
        scale$3(this.tileTransform_, 2 / (frameState.size[0] * tileScale / tileWidthWithGutter), -2 / (frameState.size[1] * tileScale / tileWidthWithGutter));
        rotate$2(this.tileTransform_, viewState.rotation);
        scale$3(this.tileTransform_, 1, 1 / aspectRatio);
        translate$1(this.tileTransform_, (tileSize[0] * (tileCenterI - centerI) - gutter) / tileWidthWithGutter, (tileSize[1] * (tileCenterJ - centerJ) - gutter) / tileHeightWithGutter);
        this.helper.setUniformMatrixValue(Uniforms.TILE_TRANSFORM, fromTransform(this.tempMat4_, this.tileTransform_));
        this.helper.bindBuffer(tileTexture.coords);
        this.helper.bindBuffer(this.indices_);
        this.helper.enableAttributes(attributeDescriptions);
        let textureSlot = 0;
        while (textureSlot < tileTexture.textures.length) {
          const textureProperty = "TEXTURE" + textureSlot;
          const uniformName = `${Uniforms.TILE_TEXTURE_ARRAY}[${textureSlot}]`;
          gl.activeTexture(gl[textureProperty]);
          gl.bindTexture(gl.TEXTURE_2D, tileTexture.textures[textureSlot]);
          gl.uniform1i(this.helper.getUniformLocation(uniformName), textureSlot);
          ++textureSlot;
        }
        for (let paletteIndex = 0; paletteIndex < this.paletteTextures_.length; ++paletteIndex) {
          const paletteTexture = this.paletteTextures_[paletteIndex];
          gl.activeTexture(gl["TEXTURE" + textureSlot]);
          const texture = paletteTexture.getTexture(gl);
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.uniform1i(this.helper.getUniformLocation(paletteTexture.name), textureSlot);
          ++textureSlot;
        }
        const alpha = tileCoordKey in alphaLookup ? alphaLookup[tileCoordKey] : 1;
        if (alpha < 1) {
          frameState.animate = true;
        }
        this.helper.setUniformFloatValue(Uniforms.TRANSITION_ALPHA, alpha);
        this.helper.setUniformFloatValue(Uniforms.DEPTH, depth);
        this.helper.setUniformFloatValue(Uniforms.TEXTURE_PIXEL_WIDTH, tileWidthWithGutter);
        this.helper.setUniformFloatValue(Uniforms.TEXTURE_PIXEL_HEIGHT, tileHeightWithGutter);
        this.helper.setUniformFloatValue(Uniforms.TEXTURE_RESOLUTION, tileResolution);
        this.helper.setUniformFloatValue(Uniforms.TEXTURE_ORIGIN_X, tileOrigin[0] + tileCenterI * tileSize[0] * tileResolution - gutter * tileResolution);
        this.helper.setUniformFloatValue(Uniforms.TEXTURE_ORIGIN_Y, tileOrigin[1] - tileCenterJ * tileSize[1] * tileResolution + gutter * tileResolution);
        let gutterExtent = extent2;
        if (gutter > 0) {
          gutterExtent = tileGrid.getTileCoordExtent(tileCoord);
          getIntersection(gutterExtent, extent2, gutterExtent);
        }
        this.helper.setUniformFloatVec4(Uniforms.RENDER_EXTENT, gutterExtent);
        this.helper.setUniformFloatValue(Uniforms.RESOLUTION, viewState.resolution);
        this.helper.setUniformFloatValue(Uniforms.ZOOM, viewState.zoom);
        this.helper.drawElements(0, this.indices_.getSize());
      }
    }
    this.helper.finalizeDraw(frameState, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent);
    const canvas = this.helper.getCanvas();
    const tileTextureCache = this.tileTextureCache_;
    while (tileTextureCache.canExpireCache()) {
      const tileTexture = tileTextureCache.pop();
      tileTexture.dispose();
    }
    const postRenderFunction = function(map, frameState2) {
      tileSource.updateCacheSize(0.1, frameState2.viewState.projection);
      tileSource.expireCache(frameState2.viewState.projection, empty$1);
    };
    frameState.postRenderFunctions.push(postRenderFunction);
    this.postRender(gl, frameState);
    return canvas;
  }
  getData(pixel) {
    const gl = this.helper.getGL();
    if (!gl) {
      return null;
    }
    const frameState = this.frameState_;
    if (!frameState) {
      return null;
    }
    const layer = this.getLayer();
    const coordinate = apply$5(frameState.pixelToCoordinateTransform, pixel.slice());
    const viewState = frameState.viewState;
    const layerExtent = layer.getExtent();
    if (layerExtent) {
      if (!containsCoordinate(fromUserExtent(layerExtent, viewState.projection), coordinate)) {
        return null;
      }
    }
    const sources = layer.getSources(boundingExtent([coordinate]), viewState.resolution);
    let i2, source, tileGrid;
    for (i2 = sources.length - 1; i2 >= 0; --i2) {
      source = sources[i2];
      if (source.getState() === "ready") {
        tileGrid = source.getTileGridForProjection(viewState.projection);
        if (source.getWrapX()) {
          break;
        }
        const gridExtent = tileGrid.getExtent();
        if (!gridExtent || containsCoordinate(gridExtent, coordinate)) {
          break;
        }
      }
    }
    if (i2 < 0) {
      return null;
    }
    const tileTextureCache = this.tileTextureCache_;
    for (let z2 = tileGrid.getZForResolution(viewState.resolution); z2 >= tileGrid.getMinZoom(); --z2) {
      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z2);
      const cacheKey = getCacheKey(source, tileCoord);
      if (!tileTextureCache.containsKey(cacheKey)) {
        continue;
      }
      const tileTexture = tileTextureCache.get(cacheKey);
      const tile2 = tileTexture.tile;
      if ((tile2 instanceof ReprojTile || tile2 instanceof ReprojDataTile) && tile2.getState() === TileState.EMPTY) {
        return null;
      }
      if (!tileTexture.loaded) {
        continue;
      }
      const tileOrigin = tileGrid.getOrigin(z2);
      const tileSize = toSize(tileGrid.getTileSize(z2));
      const tileResolution = tileGrid.getResolution(z2);
      const col = (coordinate[0] - tileOrigin[0]) / tileResolution - tileCoord[1] * tileSize[0];
      const row = (tileOrigin[1] - coordinate[1]) / tileResolution - tileCoord[2] * tileSize[1];
      return tileTexture.getPixelData(col, row);
    }
    return null;
  }
  findAltTiles_(tileGrid, tileCoord, altZ, tileTexturesByZ) {
    const tileRange = tileGrid.getTileRangeForTileCoordAndZ(tileCoord, altZ, this.tempTileRange_);
    if (!tileRange) {
      return false;
    }
    let covered = true;
    const tileTextureCache = this.tileTextureCache_;
    const source = this.getLayer().getRenderSource();
    for (let x2 = tileRange.minX; x2 <= tileRange.maxX; ++x2) {
      for (let y2 = tileRange.minY; y2 <= tileRange.maxY; ++y2) {
        const cacheKey = getCacheKey(source, [altZ, x2, y2]);
        let loaded = false;
        if (tileTextureCache.containsKey(cacheKey)) {
          const tileTexture = tileTextureCache.get(cacheKey);
          if (tileTexture.loaded) {
            addTileTextureToLookup(tileTexturesByZ, tileTexture, altZ);
            loaded = true;
          }
        }
        if (!loaded) {
          covered = false;
        }
      }
    }
    return covered;
  }
  clearCache() {
    const tileTextureCache = this.tileTextureCache_;
    tileTextureCache.forEach((tileTexture) => tileTexture.dispose());
    tileTextureCache.clear();
  }
  removeHelper() {
    if (this.helper) {
      this.clearCache();
    }
    super.removeHelper();
  }
  disposeInternal() {
    const helper = this.helper;
    if (helper) {
      const gl = helper.getGL();
      gl.deleteProgram(this.program_);
      delete this.program_;
      helper.deleteBuffer(this.indices_);
    }
    super.disposeInternal();
    delete this.indices_;
    delete this.tileTextureCache_;
    delete this.frameState_;
  }
}
class PaletteTexture {
  constructor(name, data2) {
    this.name = name;
    this.data = data2;
    this.texture_ = null;
  }
  getTexture(gl) {
    if (!this.texture_) {
      const texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.data.length / 4, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.data);
      this.texture_ = texture;
    }
    return this.texture_;
  }
}
const ValueTypes = {
  NUMBER: 1,
  STRING: 2,
  COLOR: 4,
  BOOLEAN: 8,
  NUMBER_ARRAY: 16,
  ANY: 31,
  NONE: 0
};
const Operators = {};
function getValueType(value) {
  if (typeof value === "number") {
    return ValueTypes.NUMBER;
  }
  if (typeof value === "boolean") {
    return ValueTypes.BOOLEAN;
  }
  if (typeof value === "string") {
    if (isStringColor(value)) {
      return ValueTypes.COLOR | ValueTypes.STRING;
    }
    return ValueTypes.STRING;
  }
  if (!Array.isArray(value)) {
    throw new Error(`Unhandled value type: ${JSON.stringify(value)}`);
  }
  const valueArr = value;
  const onlyNumbers = valueArr.every(function(v2) {
    return typeof v2 === "number";
  });
  if (onlyNumbers) {
    if (valueArr.length === 3 || valueArr.length === 4) {
      return ValueTypes.COLOR | ValueTypes.NUMBER_ARRAY;
    }
    return ValueTypes.NUMBER_ARRAY;
  }
  if (typeof valueArr[0] !== "string") {
    throw new Error(`Expected an expression operator but received: ${JSON.stringify(valueArr)}`);
  }
  const operator = Operators[valueArr[0]];
  if (operator === void 0) {
    throw new Error(`Unrecognized expression operator: ${JSON.stringify(valueArr)}`);
  }
  return operator.getReturnType(valueArr.slice(1));
}
function isTypeUnique(valueType) {
  return Math.log2(valueType) % 1 === 0;
}
function numberToGlsl(v2) {
  const s2 = v2.toString();
  return s2.includes(".") ? s2 : s2 + ".0";
}
function arrayToGlsl(array) {
  if (array.length < 2 || array.length > 4) {
    throw new Error("`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.");
  }
  return `vec${array.length}(${array.map(numberToGlsl).join(", ")})`;
}
function colorToGlsl(color2) {
  const array = asArray(color2).slice();
  if (array.length < 4) {
    array.push(1);
  }
  return arrayToGlsl(array.map(function(c2, i2) {
    return i2 < 3 ? c2 / 255 : c2;
  }));
}
function getStringNumberEquivalent(context2, string) {
  if (context2.stringLiteralsMap[string] === void 0) {
    context2.stringLiteralsMap[string] = Object.keys(context2.stringLiteralsMap).length;
  }
  return context2.stringLiteralsMap[string];
}
function stringToGlsl(context2, string) {
  return numberToGlsl(getStringNumberEquivalent(context2, string));
}
function expressionToGlsl(context2, value, typeHint) {
  if (Array.isArray(value) && typeof value[0] === "string") {
    const operator = Operators[value[0]];
    if (operator === void 0) {
      throw new Error(`Unrecognized expression operator: ${JSON.stringify(value)}`);
    }
    return operator.toGlsl(context2, value.slice(1), typeHint);
  }
  const valueType = getValueType(value);
  if ((valueType & ValueTypes.NUMBER) > 0) {
    return numberToGlsl(value);
  }
  if ((valueType & ValueTypes.BOOLEAN) > 0) {
    return value.toString();
  }
  if ((valueType & ValueTypes.STRING) > 0 && (typeHint === void 0 || typeHint == ValueTypes.STRING)) {
    return stringToGlsl(context2, value.toString());
  }
  if ((valueType & ValueTypes.COLOR) > 0 && (typeHint === void 0 || typeHint == ValueTypes.COLOR)) {
    return colorToGlsl(value);
  }
  if ((valueType & ValueTypes.NUMBER_ARRAY) > 0) {
    return arrayToGlsl(value);
  }
  throw new Error(`Unexpected expression ${value} (expected type ${typeHint})`);
}
function assertNumber(value) {
  if (!(getValueType(value) & ValueTypes.NUMBER)) {
    throw new Error(`A numeric value was expected, got ${JSON.stringify(value)} instead`);
  }
}
function assertNumbers(values3) {
  for (let i2 = 0; i2 < values3.length; i2++) {
    assertNumber(values3[i2]);
  }
}
function assertString(value) {
  if (!(getValueType(value) & ValueTypes.STRING)) {
    throw new Error(`A string value was expected, got ${JSON.stringify(value)} instead`);
  }
}
function assertBoolean(value) {
  if (!(getValueType(value) & ValueTypes.BOOLEAN)) {
    throw new Error(`A boolean value was expected, got ${JSON.stringify(value)} instead`);
  }
}
function assertArgsCount(args, count) {
  if (args.length !== count) {
    throw new Error(`Exactly ${count} arguments were expected, got ${args.length} instead`);
  }
}
function assertArgsMinCount(args, count) {
  if (args.length < count) {
    throw new Error(`At least ${count} arguments were expected, got ${args.length} instead`);
  }
}
function assertArgsMaxCount(args, count) {
  if (args.length > count) {
    throw new Error(`At most ${count} arguments were expected, got ${args.length} instead`);
  }
}
function assertArgsEven(args) {
  if (args.length % 2 !== 0) {
    throw new Error(`An even amount of arguments was expected, got ${args} instead`);
  }
}
function assertArgsOdd(args) {
  if (args.length % 2 === 0) {
    throw new Error(`An odd amount of arguments was expected, got ${args} instead`);
  }
}
function assertUniqueInferredType(args, types) {
  if (!isTypeUnique(types)) {
    throw new Error(`Could not infer only one type from the following expression: ${JSON.stringify(args)}`);
  }
}
Operators["get"] = {
  getReturnType: function(args) {
    return ValueTypes.ANY;
  },
  toGlsl: function(context2, args) {
    assertArgsCount(args, 1);
    assertString(args[0]);
    const value = args[0].toString();
    if (!context2.attributes.includes(value)) {
      context2.attributes.push(value);
    }
    const prefix = context2.inFragmentShader ? "v_" : "a_";
    return prefix + value;
  }
};
function uniformNameForVariable(variableName) {
  return "u_var_" + variableName;
}
Operators["var"] = {
  getReturnType: function(args) {
    return ValueTypes.ANY;
  },
  toGlsl: function(context2, args) {
    assertArgsCount(args, 1);
    assertString(args[0]);
    const value = args[0].toString();
    if (!context2.variables.includes(value)) {
      context2.variables.push(value);
    }
    return uniformNameForVariable(value);
  }
};
const PALETTE_TEXTURE_ARRAY = "u_paletteTextures";
Operators["palette"] = {
  getReturnType: function(args) {
    return ValueTypes.COLOR;
  },
  toGlsl: function(context2, args) {
    assertArgsCount(args, 2);
    assertNumber(args[0]);
    const index2 = expressionToGlsl(context2, args[0]);
    const colors = args[1];
    if (!Array.isArray(colors)) {
      throw new Error("The second argument of palette must be an array");
    }
    const numColors = colors.length;
    const palette = new Uint8Array(numColors * 4);
    for (let i2 = 0; i2 < numColors; i2++) {
      const candidate = colors[i2];
      let color2;
      if (typeof candidate === "string") {
        color2 = fromString(candidate);
      } else {
        if (!Array.isArray(candidate)) {
          throw new Error("The second argument of palette must be an array of strings or colors");
        }
        const length = candidate.length;
        if (length === 4) {
          color2 = candidate;
        } else {
          if (length !== 3) {
            throw new Error(`Expected palette color to have 3 or 4 values, got ${length}`);
          }
          color2 = [candidate[0], candidate[1], candidate[2], 1];
        }
      }
      const offset2 = i2 * 4;
      palette[offset2] = color2[0];
      palette[offset2 + 1] = color2[1];
      palette[offset2 + 2] = color2[2];
      palette[offset2 + 3] = color2[3] * 255;
    }
    if (!context2.paletteTextures) {
      context2.paletteTextures = [];
    }
    const paletteName = `${PALETTE_TEXTURE_ARRAY}[${context2.paletteTextures.length}]`;
    const paletteTexture = new PaletteTexture(paletteName, palette);
    context2.paletteTextures.push(paletteTexture);
    return `texture2D(${paletteName}, vec2((${index2} + 0.5) / ${numColors}.0, 0.5))`;
  }
};
const GET_BAND_VALUE_FUNC = "getBandValue";
Operators["band"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context2, args) {
    assertArgsMinCount(args, 1);
    assertArgsMaxCount(args, 3);
    const band = args[0];
    if (!(GET_BAND_VALUE_FUNC in context2.functions)) {
      let ifBlocks = "";
      const bandCount = context2.bandCount || 1;
      for (let i2 = 0; i2 < bandCount; i2++) {
        const colorIndex = Math.floor(i2 / 4);
        let bandIndex = i2 % 4;
        if (i2 === bandCount - 1 && bandIndex === 1) {
          bandIndex = 3;
        }
        const textureName = `${Uniforms.TILE_TEXTURE_ARRAY}[${colorIndex}]`;
        ifBlocks += `
          if (band == ${i2 + 1}.0) {
            return texture2D(${textureName}, v_textureCoord + vec2(dx, dy))[${bandIndex}];
          }
        `;
      }
      context2.functions[GET_BAND_VALUE_FUNC] = `
        float getBandValue(float band, float xOffset, float yOffset) {
          float dx = xOffset / ${Uniforms.TEXTURE_PIXEL_WIDTH};
          float dy = yOffset / ${Uniforms.TEXTURE_PIXEL_HEIGHT};
          ${ifBlocks}
        }
      `;
    }
    const bandExpression = expressionToGlsl(context2, band);
    const xOffsetExpression = expressionToGlsl(context2, args[1] || 0);
    const yOffsetExpression = expressionToGlsl(context2, args[2] || 0);
    return `${GET_BAND_VALUE_FUNC}(${bandExpression}, ${xOffsetExpression}, ${yOffsetExpression})`;
  }
};
Operators["time"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context2, args) {
    assertArgsCount(args, 0);
    return "u_time";
  }
};
Operators["zoom"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context2, args) {
    assertArgsCount(args, 0);
    return "u_zoom";
  }
};
Operators["resolution"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context2, args) {
    assertArgsCount(args, 0);
    return "u_resolution";
  }
};
Operators["*"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context2, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return `(${expressionToGlsl(context2, args[0])} * ${expressionToGlsl(context2, args[1])})`;
  }
};
Operators["/"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context2, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return `(${expressionToGlsl(context2, args[0])} / ${expressionToGlsl(context2, args[1])})`;
  }
};
Operators["+"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context2, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return `(${expressionToGlsl(context2, args[0])} + ${expressionToGlsl(context2, args[1])})`;
  }
};
Operators["-"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context2, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return `(${expressionToGlsl(context2, args[0])} - ${expressionToGlsl(context2, args[1])})`;
  }
};
Operators["clamp"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context2, args) {
    assertArgsCount(args, 3);
    assertNumbers(args);
    const min2 = expressionToGlsl(context2, args[1]);
    const max2 = expressionToGlsl(context2, args[2]);
    return `clamp(${expressionToGlsl(context2, args[0])}, ${min2}, ${max2})`;
  }
};
Operators["%"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context2, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return `mod(${expressionToGlsl(context2, args[0])}, ${expressionToGlsl(context2, args[1])})`;
  }
};
Operators["^"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context2, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return `pow(${expressionToGlsl(context2, args[0])}, ${expressionToGlsl(context2, args[1])})`;
  }
};
Operators["abs"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context2, args) {
    assertArgsCount(args, 1);
    assertNumbers(args);
    return `abs(${expressionToGlsl(context2, args[0])})`;
  }
};
Operators["floor"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context2, args) {
    assertArgsCount(args, 1);
    assertNumbers(args);
    return `floor(${expressionToGlsl(context2, args[0])})`;
  }
};
Operators["round"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context2, args) {
    assertArgsCount(args, 1);
    assertNumbers(args);
    return `floor(${expressionToGlsl(context2, args[0])} + 0.5)`;
  }
};
Operators["ceil"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context2, args) {
    assertArgsCount(args, 1);
    assertNumbers(args);
    return `ceil(${expressionToGlsl(context2, args[0])})`;
  }
};
Operators["sin"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context2, args) {
    assertArgsCount(args, 1);
    assertNumbers(args);
    return `sin(${expressionToGlsl(context2, args[0])})`;
  }
};
Operators["cos"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context2, args) {
    assertArgsCount(args, 1);
    assertNumbers(args);
    return `cos(${expressionToGlsl(context2, args[0])})`;
  }
};
Operators["atan"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context2, args) {
    assertArgsMinCount(args, 1);
    assertArgsMaxCount(args, 2);
    assertNumbers(args);
    return args.length === 2 ? `atan(${expressionToGlsl(context2, args[0])}, ${expressionToGlsl(context2, args[1])})` : `atan(${expressionToGlsl(context2, args[0])})`;
  }
};
Operators[">"] = {
  getReturnType: function(args) {
    return ValueTypes.BOOLEAN;
  },
  toGlsl: function(context2, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return `(${expressionToGlsl(context2, args[0])} > ${expressionToGlsl(context2, args[1])})`;
  }
};
Operators[">="] = {
  getReturnType: function(args) {
    return ValueTypes.BOOLEAN;
  },
  toGlsl: function(context2, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return `(${expressionToGlsl(context2, args[0])} >= ${expressionToGlsl(context2, args[1])})`;
  }
};
Operators["<"] = {
  getReturnType: function(args) {
    return ValueTypes.BOOLEAN;
  },
  toGlsl: function(context2, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return `(${expressionToGlsl(context2, args[0])} < ${expressionToGlsl(context2, args[1])})`;
  }
};
Operators["<="] = {
  getReturnType: function(args) {
    return ValueTypes.BOOLEAN;
  },
  toGlsl: function(context2, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return `(${expressionToGlsl(context2, args[0])} <= ${expressionToGlsl(context2, args[1])})`;
  }
};
function getEqualOperator(operator) {
  return {
    getReturnType: function(args) {
      return ValueTypes.BOOLEAN;
    },
    toGlsl: function(context2, args) {
      assertArgsCount(args, 2);
      let type = ValueTypes.ANY;
      for (let i2 = 0; i2 < args.length; i2++) {
        type &= getValueType(args[i2]);
      }
      if (type === ValueTypes.NONE) {
        throw new Error(`All arguments should be of compatible type, got ${JSON.stringify(args)} instead`);
      }
      type &= ~ValueTypes.COLOR;
      return `(${expressionToGlsl(context2, args[0], type)} ${operator} ${expressionToGlsl(context2, args[1], type)})`;
    }
  };
}
Operators["=="] = getEqualOperator("==");
Operators["!="] = getEqualOperator("!=");
Operators["!"] = {
  getReturnType: function(args) {
    return ValueTypes.BOOLEAN;
  },
  toGlsl: function(context2, args) {
    assertArgsCount(args, 1);
    assertBoolean(args[0]);
    return `(!${expressionToGlsl(context2, args[0])})`;
  }
};
function getDecisionOperator(operator) {
  return {
    getReturnType: function(args) {
      return ValueTypes.BOOLEAN;
    },
    toGlsl: function(context2, args) {
      assertArgsMinCount(args, 2);
      for (let i2 = 0; i2 < args.length; i2++) {
        assertBoolean(args[i2]);
      }
      let result = "";
      result = args.map((arg) => expressionToGlsl(context2, arg)).join(` ${operator} `);
      result = `(${result})`;
      return result;
    }
  };
}
Operators["all"] = getDecisionOperator("&&");
Operators["any"] = getDecisionOperator("||");
Operators["between"] = {
  getReturnType: function(args) {
    return ValueTypes.BOOLEAN;
  },
  toGlsl: function(context2, args) {
    assertArgsCount(args, 3);
    assertNumbers(args);
    const min2 = expressionToGlsl(context2, args[1]);
    const max2 = expressionToGlsl(context2, args[2]);
    const value = expressionToGlsl(context2, args[0]);
    return `(${value} >= ${min2} && ${value} <= ${max2})`;
  }
};
Operators["array"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER_ARRAY;
  },
  toGlsl: function(context2, args) {
    assertArgsMinCount(args, 2);
    assertArgsMaxCount(args, 4);
    assertNumbers(args);
    const parsedArgs = args.map(function(val) {
      return expressionToGlsl(context2, val, ValueTypes.NUMBER);
    });
    return `vec${args.length}(${parsedArgs.join(", ")})`;
  }
};
Operators["color"] = {
  getReturnType: function(args) {
    return ValueTypes.COLOR;
  },
  toGlsl: function(context2, args) {
    assertArgsMinCount(args, 3);
    assertArgsMaxCount(args, 4);
    assertNumbers(args);
    const array = args;
    if (args.length === 3) {
      array.push(1);
    }
    const parsedArgs = args.map(function(val, i2) {
      return expressionToGlsl(context2, val, ValueTypes.NUMBER) + (i2 < 3 ? " / 255.0" : "");
    });
    return `vec${args.length}(${parsedArgs.join(", ")})`;
  }
};
Operators["interpolate"] = {
  getReturnType: function(args) {
    let type = ValueTypes.COLOR | ValueTypes.NUMBER;
    for (let i2 = 3; i2 < args.length; i2 += 2) {
      type = type & getValueType(args[i2]);
    }
    return type;
  },
  toGlsl: function(context2, args, typeHint) {
    assertArgsEven(args);
    assertArgsMinCount(args, 6);
    const type = args[0];
    let interpolation;
    switch (type[0]) {
      case "linear":
        interpolation = 1;
        break;
      case "exponential":
        interpolation = type[1];
        break;
      default:
        interpolation = null;
    }
    if (!interpolation) {
      throw new Error(`Invalid interpolation type for "interpolate" operator, received: ${JSON.stringify(type)}`);
    }
    typeHint = typeHint !== void 0 ? typeHint : ValueTypes.ANY;
    const outputType = Operators["interpolate"].getReturnType(args) & typeHint;
    assertUniqueInferredType(args, outputType);
    const input = expressionToGlsl(context2, args[1]);
    const exponent = numberToGlsl(interpolation);
    let result = "";
    for (let i2 = 2; i2 < args.length - 2; i2 += 2) {
      const stop1 = expressionToGlsl(context2, args[i2]);
      const output1 = result || expressionToGlsl(context2, args[i2 + 1], outputType);
      const stop2 = expressionToGlsl(context2, args[i2 + 2]);
      const output2 = expressionToGlsl(context2, args[i2 + 3], outputType);
      result = `mix(${output1}, ${output2}, pow(clamp((${input} - ${stop1}) / (${stop2} - ${stop1}), 0.0, 1.0), ${exponent}))`;
    }
    return result;
  }
};
Operators["match"] = {
  getReturnType: function(args) {
    let type = ValueTypes.ANY;
    for (let i2 = 2; i2 < args.length; i2 += 2) {
      type = type & getValueType(args[i2]);
    }
    type = type & getValueType(args[args.length - 1]);
    return type;
  },
  toGlsl: function(context2, args, typeHint) {
    assertArgsEven(args);
    assertArgsMinCount(args, 4);
    typeHint = typeHint !== void 0 ? typeHint : ValueTypes.ANY;
    const outputType = Operators["match"].getReturnType(args) & typeHint;
    assertUniqueInferredType(args, outputType);
    const input = expressionToGlsl(context2, args[0]);
    const fallback = expressionToGlsl(context2, args[args.length - 1], outputType);
    let result = null;
    for (let i2 = args.length - 3; i2 >= 1; i2 -= 2) {
      const match2 = expressionToGlsl(context2, args[i2]);
      const output = expressionToGlsl(context2, args[i2 + 1], outputType);
      result = `(${input} == ${match2} ? ${output} : ${result || fallback})`;
    }
    return result;
  }
};
Operators["case"] = {
  getReturnType: function(args) {
    let type = ValueTypes.ANY;
    for (let i2 = 1; i2 < args.length; i2 += 2) {
      type = type & getValueType(args[i2]);
    }
    type = type & getValueType(args[args.length - 1]);
    return type;
  },
  toGlsl: function(context2, args, typeHint) {
    assertArgsOdd(args);
    assertArgsMinCount(args, 3);
    typeHint = typeHint !== void 0 ? typeHint : ValueTypes.ANY;
    const outputType = Operators["case"].getReturnType(args) & typeHint;
    assertUniqueInferredType(args, outputType);
    for (let i2 = 0; i2 < args.length - 1; i2 += 2) {
      assertBoolean(args[i2]);
    }
    const fallback = expressionToGlsl(context2, args[args.length - 1], outputType);
    let result = null;
    for (let i2 = args.length - 3; i2 >= 0; i2 -= 2) {
      const condition = expressionToGlsl(context2, args[i2]);
      const output = expressionToGlsl(context2, args[i2 + 1], outputType);
      result = `(${condition} ? ${output} : ${result || fallback})`;
    }
    return result;
  }
};
function parseStyle(style2, bandCount) {
  const vertexShader = `
    attribute vec2 ${Attributes.TEXTURE_COORD};
    uniform mat4 ${Uniforms.TILE_TRANSFORM};
    uniform float ${Uniforms.TEXTURE_PIXEL_WIDTH};
    uniform float ${Uniforms.TEXTURE_PIXEL_HEIGHT};
    uniform float ${Uniforms.TEXTURE_RESOLUTION};
    uniform float ${Uniforms.TEXTURE_ORIGIN_X};
    uniform float ${Uniforms.TEXTURE_ORIGIN_Y};
    uniform float ${Uniforms.DEPTH};

    varying vec2 v_textureCoord;
    varying vec2 v_mapCoord;

    void main() {
      v_textureCoord = ${Attributes.TEXTURE_COORD};
      v_mapCoord = vec2(
        ${Uniforms.TEXTURE_ORIGIN_X} + ${Uniforms.TEXTURE_RESOLUTION} * ${Uniforms.TEXTURE_PIXEL_WIDTH} * v_textureCoord[0],
        ${Uniforms.TEXTURE_ORIGIN_Y} - ${Uniforms.TEXTURE_RESOLUTION} * ${Uniforms.TEXTURE_PIXEL_HEIGHT} * v_textureCoord[1]
      );
      gl_Position = ${Uniforms.TILE_TRANSFORM} * vec4(${Attributes.TEXTURE_COORD}, ${Uniforms.DEPTH}, 1.0);
    }
  `;
  const context2 = {
    inFragmentShader: true,
    variables: [],
    attributes: [],
    stringLiteralsMap: {},
    functions: {},
    bandCount
  };
  const pipeline = [];
  if (style2.color !== void 0) {
    const color2 = expressionToGlsl(context2, style2.color, ValueTypes.COLOR);
    pipeline.push(`color = ${color2};`);
  }
  if (style2.contrast !== void 0) {
    const contrast = expressionToGlsl(context2, style2.contrast, ValueTypes.NUMBER);
    pipeline.push(`color.rgb = clamp((${contrast} + 1.0) * color.rgb - (${contrast} / 2.0), vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`);
  }
  if (style2.exposure !== void 0) {
    const exposure = expressionToGlsl(context2, style2.exposure, ValueTypes.NUMBER);
    pipeline.push(`color.rgb = clamp((${exposure} + 1.0) * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`);
  }
  if (style2.saturation !== void 0) {
    const saturation = expressionToGlsl(context2, style2.saturation, ValueTypes.NUMBER);
    pipeline.push(`
      float saturation = ${saturation} + 1.0;
      float sr = (1.0 - saturation) * 0.2126;
      float sg = (1.0 - saturation) * 0.7152;
      float sb = (1.0 - saturation) * 0.0722;
      mat3 saturationMatrix = mat3(
        sr + saturation, sr, sr,
        sg, sg + saturation, sg,
        sb, sb, sb + saturation
      );
      color.rgb = clamp(saturationMatrix * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));
    `);
  }
  if (style2.gamma !== void 0) {
    const gamma = expressionToGlsl(context2, style2.gamma, ValueTypes.NUMBER);
    pipeline.push(`color.rgb = pow(color.rgb, vec3(1.0 / ${gamma}));`);
  }
  if (style2.brightness !== void 0) {
    const brightness = expressionToGlsl(context2, style2.brightness, ValueTypes.NUMBER);
    pipeline.push(`color.rgb = clamp(color.rgb + ${brightness}, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`);
  }
  const uniforms = {};
  const numVariables = context2.variables.length;
  if (numVariables > 1 && !style2.variables) {
    throw new Error(`Missing variables in style (expected ${context2.variables})`);
  }
  for (let i2 = 0; i2 < numVariables; ++i2) {
    const variableName = context2.variables[i2];
    if (!(variableName in style2.variables)) {
      throw new Error(`Missing '${variableName}' in style variables`);
    }
    const uniformName = uniformNameForVariable(variableName);
    uniforms[uniformName] = function() {
      let value = style2.variables[variableName];
      if (typeof value === "string") {
        value = getStringNumberEquivalent(context2, value);
      }
      return value !== void 0 ? value : -9999999;
    };
  }
  const uniformDeclarations = Object.keys(uniforms).map(function(name) {
    return `uniform float ${name};`;
  });
  const textureCount = Math.ceil(bandCount / 4);
  uniformDeclarations.push(`uniform sampler2D ${Uniforms.TILE_TEXTURE_ARRAY}[${textureCount}];`);
  if (context2.paletteTextures) {
    uniformDeclarations.push(`uniform sampler2D ${PALETTE_TEXTURE_ARRAY}[${context2.paletteTextures.length}];`);
  }
  const functionDefintions = Object.keys(context2.functions).map(function(name) {
    return context2.functions[name];
  });
  const fragmentShader = `
    #ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    #else
    precision mediump float;
    #endif

    varying vec2 v_textureCoord;
    varying vec2 v_mapCoord;
    uniform vec4 ${Uniforms.RENDER_EXTENT};
    uniform float ${Uniforms.TRANSITION_ALPHA};
    uniform float ${Uniforms.TEXTURE_PIXEL_WIDTH};
    uniform float ${Uniforms.TEXTURE_PIXEL_HEIGHT};
    uniform float ${Uniforms.RESOLUTION};
    uniform float ${Uniforms.ZOOM};

    ${uniformDeclarations.join("\n")}

    ${functionDefintions.join("\n")}

    void main() {
      if (
        v_mapCoord[0] < ${Uniforms.RENDER_EXTENT}[0] ||
        v_mapCoord[1] < ${Uniforms.RENDER_EXTENT}[1] ||
        v_mapCoord[0] > ${Uniforms.RENDER_EXTENT}[2] ||
        v_mapCoord[1] > ${Uniforms.RENDER_EXTENT}[3]
      ) {
        discard;
      }

      vec4 color = texture2D(${Uniforms.TILE_TEXTURE_ARRAY}[0],  v_textureCoord);

      ${pipeline.join("\n")}

      if (color.a == 0.0) {
        discard;
      }

      gl_FragColor = color;
      gl_FragColor.rgb *= gl_FragColor.a;
      gl_FragColor *= ${Uniforms.TRANSITION_ALPHA};
    }`;
  return {
    vertexShader,
    fragmentShader,
    uniforms,
    paletteTextures: context2.paletteTextures
  };
}
class WebGLTileLayer$1 extends BaseTileLayer {
  constructor(options) {
    options = options ? Object.assign({}, options) : {};
    const style2 = options.style || {};
    delete options.style;
    const cacheSize = options.cacheSize;
    delete options.cacheSize;
    super(options);
    this.sources_ = options.sources;
    this.renderedSource_ = null;
    this.renderedResolution_ = NaN;
    this.style_ = style2;
    this.cacheSize_ = cacheSize;
    this.styleVariables_ = this.style_.variables || {};
    this.addChangeListener(LayerProperty.SOURCE, this.handleSourceUpdate_);
  }
  getSources(extent2, resolution) {
    const source = this.getSource();
    return this.sources_ ? typeof this.sources_ === "function" ? this.sources_(extent2, resolution) : this.sources_ : source ? [source] : [];
  }
  getRenderSource() {
    return this.renderedSource_ || this.getSource();
  }
  getSourceState() {
    const source = this.getRenderSource();
    return source ? source.getState() : "undefined";
  }
  handleSourceUpdate_() {
    if (this.hasRenderer()) {
      this.getRenderer().clearCache();
    }
    if (this.getSource()) {
      this.setStyle(this.style_);
    }
  }
  getSourceBandCount_() {
    const max2 = Number.MAX_SAFE_INTEGER;
    const sources = this.getSources([-max2, -max2, max2, max2], max2);
    return sources && sources.length && "bandCount" in sources[0] ? sources[0].bandCount : 4;
  }
  createRenderer() {
    const parsedStyle = parseStyle(this.style_, this.getSourceBandCount_());
    return new WebGLTileLayerRenderer(this, {
      vertexShader: parsedStyle.vertexShader,
      fragmentShader: parsedStyle.fragmentShader,
      uniforms: parsedStyle.uniforms,
      cacheSize: this.cacheSize_,
      paletteTextures: parsedStyle.paletteTextures
    });
  }
  renderSources(frameState, sources) {
    const layerRenderer = this.getRenderer();
    let canvas;
    for (let i2 = 0, ii = sources.length; i2 < ii; ++i2) {
      this.renderedSource_ = sources[i2];
      if (layerRenderer.prepareFrame(frameState)) {
        canvas = layerRenderer.renderFrame(frameState);
      }
    }
    return canvas;
  }
  render(frameState, target) {
    this.rendered = true;
    const viewState = frameState.viewState;
    const sources = this.getSources(frameState.extent, viewState.resolution);
    let ready = true;
    for (let i2 = 0, ii = sources.length; i2 < ii; ++i2) {
      const source = sources[i2];
      const sourceState = source.getState();
      if (sourceState == "loading") {
        const onChange = () => {
          if (source.getState() == "ready") {
            source.removeEventListener("change", onChange);
            this.changed();
          }
        };
        source.addEventListener("change", onChange);
      }
      ready = ready && sourceState == "ready";
    }
    const canvas = this.renderSources(frameState, sources);
    if (this.getRenderer().renderComplete && ready) {
      this.renderedResolution_ = viewState.resolution;
      return canvas;
    }
    if (this.renderedResolution_ > 0.5 * viewState.resolution) {
      const altSources = this.getSources(frameState.extent, this.renderedResolution_).filter((source) => !sources.includes(source));
      if (altSources.length > 0) {
        return this.renderSources(frameState, altSources);
      }
    }
    return canvas;
  }
  setStyle(style2) {
    this.styleVariables_ = style2.variables || {};
    this.style_ = style2;
    const parsedStyle = parseStyle(this.style_, this.getSourceBandCount_());
    const renderer = this.getRenderer();
    renderer.reset({
      vertexShader: parsedStyle.vertexShader,
      fragmentShader: parsedStyle.fragmentShader,
      uniforms: parsedStyle.uniforms,
      paletteTextures: parsedStyle.paletteTextures
    });
    this.changed();
  }
  updateStyleVariables(variables) {
    Object.assign(this.styleVariables_, variables);
    this.changed();
  }
}
WebGLTileLayer$1.prototype.dispose;
const _sfc_main$_ = {
  extends: BaseLayer,
  name: "ol-webgl-tile-layer",
  setup(props) {
    const map = inject("map");
    const overViewMap = inject("overviewMap", null);
    const {
      properties
    } = usePropsAsObjectProperties(props);
    const tileLayer = computed(() => new WebGLTileLayer$1(properties));
    const applyTileLayer = () => {
      if (overViewMap != null) {
        overViewMap.value.getOverviewMap().addLayer(tileLayer.value);
        overViewMap.value.changed();
      } else {
        map.addLayer(tileLayer.value);
      }
    };
    const removeTileLayer = () => {
      if (overViewMap != null) {
        overViewMap.value.getOverviewMap().removeLayer(tileLayer.value);
        overViewMap.value.changed();
      } else {
        map.removeLayer(tileLayer.value);
      }
    };
    if (overViewMap != null) {
      watch(overViewMap, () => {
        removeTileLayer();
        applyTileLayer();
      });
    }
    onMounted(() => {
      applyTileLayer();
    });
    onUnmounted(() => {
      removeTileLayer();
    });
    provide("tileLayer", tileLayer);
    return {
      tileLayer
    };
  },
  props: {
    preload: {
      type: Number,
      default: 1
    }
  }
};
function _sfc_render$_(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var WebGLTileLayer = /* @__PURE__ */ _export_sfc(_sfc_main$_, [["render", _sfc_render$_]]);
class BaseImageLayer extends Layer {
  constructor(options) {
    options = options ? options : {};
    super(options);
  }
}
class CanvasImageLayerRenderer extends CanvasLayerRenderer {
  constructor(imageLayer) {
    super(imageLayer);
    this.image_ = null;
  }
  getImage() {
    return !this.image_ ? null : this.image_.getImage();
  }
  prepareFrame(frameState) {
    const layerState = frameState.layerStatesArray[frameState.layerIndex];
    const pixelRatio = frameState.pixelRatio;
    const viewState = frameState.viewState;
    const viewResolution = viewState.resolution;
    const imageSource = this.getLayer().getSource();
    const hints = frameState.viewHints;
    let renderedExtent = frameState.extent;
    if (layerState.extent !== void 0) {
      renderedExtent = getIntersection(renderedExtent, fromUserExtent(layerState.extent, viewState.projection));
    }
    if (!hints[ViewHint.ANIMATING] && !hints[ViewHint.INTERACTING] && !isEmpty(renderedExtent)) {
      if (imageSource) {
        const projection = viewState.projection;
        const image2 = imageSource.getImage(renderedExtent, viewResolution, pixelRatio, projection);
        if (image2) {
          if (this.loadImage(image2)) {
            this.image_ = image2;
          } else if (image2.getState() === ImageState.EMPTY) {
            this.image_ = null;
          }
        }
      } else {
        this.image_ = null;
      }
    }
    return !!this.image_;
  }
  getData(pixel) {
    const frameState = this.frameState;
    if (!frameState) {
      return null;
    }
    const layer = this.getLayer();
    const coordinate = apply$5(frameState.pixelToCoordinateTransform, pixel.slice());
    const layerExtent = layer.getExtent();
    if (layerExtent) {
      if (!containsCoordinate(layerExtent, coordinate)) {
        return null;
      }
    }
    const imageExtent = this.image_.getExtent();
    const img = this.image_.getImage();
    const imageMapWidth = getWidth(imageExtent);
    const col = Math.floor(img.width * ((coordinate[0] - imageExtent[0]) / imageMapWidth));
    if (col < 0 || col >= img.width) {
      return null;
    }
    const imageMapHeight = getHeight(imageExtent);
    const row = Math.floor(img.height * ((imageExtent[3] - coordinate[1]) / imageMapHeight));
    if (row < 0 || row >= img.height) {
      return null;
    }
    return this.getImageData(img, col, row);
  }
  renderFrame(frameState, target) {
    const image2 = this.image_;
    const imageExtent = image2.getExtent();
    const imageResolution = image2.getResolution();
    const imagePixelRatio = image2.getPixelRatio();
    const layerState = frameState.layerStatesArray[frameState.layerIndex];
    const pixelRatio = frameState.pixelRatio;
    const viewState = frameState.viewState;
    const viewCenter = viewState.center;
    const viewResolution = viewState.resolution;
    const scale2 = pixelRatio * imageResolution / (viewResolution * imagePixelRatio);
    const extent2 = frameState.extent;
    const resolution = viewState.resolution;
    const rotation = viewState.rotation;
    const width = Math.round(getWidth(extent2) / resolution * pixelRatio);
    const height = Math.round(getHeight(extent2) / resolution * pixelRatio);
    compose(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / pixelRatio, 1 / pixelRatio, rotation, -width / 2, -height / 2);
    makeInverse(this.inversePixelTransform, this.pixelTransform);
    const canvasTransform = toString$e(this.pixelTransform);
    this.useContainer(target, canvasTransform, this.getBackground(frameState));
    const context2 = this.context;
    const canvas = context2.canvas;
    if (canvas.width != width || canvas.height != height) {
      canvas.width = width;
      canvas.height = height;
    } else if (!this.containerReused) {
      context2.clearRect(0, 0, width, height);
    }
    let clipped = false;
    let render2 = true;
    if (layerState.extent) {
      const layerExtent = fromUserExtent(layerState.extent, viewState.projection);
      render2 = intersects$2(layerExtent, frameState.extent);
      clipped = render2 && !containsExtent(layerExtent, frameState.extent);
      if (clipped) {
        this.clipUnrotated(context2, frameState, layerExtent);
      }
    }
    const img = image2.getImage();
    const transform2 = compose(this.tempTransform, width / 2, height / 2, scale2, scale2, 0, imagePixelRatio * (imageExtent[0] - viewCenter[0]) / imageResolution, imagePixelRatio * (viewCenter[1] - imageExtent[3]) / imageResolution);
    this.renderedResolution = imageResolution * pixelRatio / imagePixelRatio;
    const dw = img.width * transform2[0];
    const dh = img.height * transform2[3];
    if (!this.getLayer().getSource().getInterpolate()) {
      context2.imageSmoothingEnabled = false;
    }
    this.preRender(context2, frameState);
    if (render2 && dw >= 0.5 && dh >= 0.5) {
      const dx = transform2[4];
      const dy = transform2[5];
      const opacity2 = layerState.opacity;
      let previousAlpha;
      if (opacity2 !== 1) {
        previousAlpha = context2.globalAlpha;
        context2.globalAlpha = opacity2;
      }
      context2.drawImage(img, 0, 0, +img.width, +img.height, dx, dy, dw, dh);
      if (opacity2 !== 1) {
        context2.globalAlpha = previousAlpha;
      }
    }
    this.postRender(context2, frameState);
    if (clipped) {
      context2.restore();
    }
    context2.imageSmoothingEnabled = true;
    if (canvasTransform !== canvas.style.transform) {
      canvas.style.transform = canvasTransform;
    }
    return this.container;
  }
}
class ImageLayer$1 extends BaseImageLayer {
  constructor(options) {
    super(options);
  }
  createRenderer() {
    return new CanvasImageLayerRenderer(this);
  }
  getData(pixel) {
    return super.getData(pixel);
  }
}
const _sfc_main$Z = {
  extends: BaseLayer,
  name: "ol-image-layer",
  setup(props) {
    const map = inject("map");
    const {
      properties
    } = usePropsAsObjectProperties(props);
    const imageLayer = new ImageLayer$1(properties);
    watch(properties, () => {
      imageLayer.setProperties(properties);
    });
    onMounted(() => {
      map.addLayer(imageLayer);
    });
    onUnmounted(() => {
      map.removeLayer(imageLayer);
    });
    provide("imageLayer", imageLayer);
    return {
      imageLayer
    };
  }
};
function _sfc_render$Z(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var ImageLayer = /* @__PURE__ */ _export_sfc(_sfc_main$Z, [["render", _sfc_render$Z]]);
function quickselect(arr, k2, left, right, compare) {
  quickselectStep(arr, k2, left || 0, right || arr.length - 1, compare || defaultCompare);
}
function quickselectStep(arr, k2, left, right, compare) {
  while (right > left) {
    if (right - left > 600) {
      var n2 = right - left + 1;
      var m2 = k2 - left + 1;
      var z2 = Math.log(n2);
      var s2 = 0.5 * Math.exp(2 * z2 / 3);
      var sd = 0.5 * Math.sqrt(z2 * s2 * (n2 - s2) / n2) * (m2 - n2 / 2 < 0 ? -1 : 1);
      var newLeft = Math.max(left, Math.floor(k2 - m2 * s2 / n2 + sd));
      var newRight = Math.min(right, Math.floor(k2 + (n2 - m2) * s2 / n2 + sd));
      quickselectStep(arr, k2, newLeft, newRight, compare);
    }
    var t3 = arr[k2];
    var i2 = left;
    var j2 = right;
    swap(arr, left, k2);
    if (compare(arr[right], t3) > 0)
      swap(arr, left, right);
    while (i2 < j2) {
      swap(arr, i2, j2);
      i2++;
      j2--;
      while (compare(arr[i2], t3) < 0)
        i2++;
      while (compare(arr[j2], t3) > 0)
        j2--;
    }
    if (compare(arr[left], t3) === 0)
      swap(arr, left, j2);
    else {
      j2++;
      swap(arr, j2, right);
    }
    if (j2 <= k2)
      left = j2 + 1;
    if (k2 <= j2)
      right = j2 - 1;
  }
}
function swap(arr, i2, j2) {
  var tmp = arr[i2];
  arr[i2] = arr[j2];
  arr[j2] = tmp;
}
function defaultCompare(a2, b2) {
  return a2 < b2 ? -1 : a2 > b2 ? 1 : 0;
}
class RBush$1 {
  constructor(maxEntries = 9) {
    this._maxEntries = Math.max(4, maxEntries);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
    this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(bbox2) {
    let node2 = this.data;
    const result = [];
    if (!intersects$1(bbox2, node2))
      return result;
    const toBBox = this.toBBox;
    const nodesToSearch = [];
    while (node2) {
      for (let i2 = 0; i2 < node2.children.length; i2++) {
        const child = node2.children[i2];
        const childBBox = node2.leaf ? toBBox(child) : child;
        if (intersects$1(bbox2, childBBox)) {
          if (node2.leaf)
            result.push(child);
          else if (contains$1(bbox2, childBBox))
            this._all(child, result);
          else
            nodesToSearch.push(child);
        }
      }
      node2 = nodesToSearch.pop();
    }
    return result;
  }
  collides(bbox2) {
    let node2 = this.data;
    if (!intersects$1(bbox2, node2))
      return false;
    const nodesToSearch = [];
    while (node2) {
      for (let i2 = 0; i2 < node2.children.length; i2++) {
        const child = node2.children[i2];
        const childBBox = node2.leaf ? this.toBBox(child) : child;
        if (intersects$1(bbox2, childBBox)) {
          if (node2.leaf || contains$1(bbox2, childBBox))
            return true;
          nodesToSearch.push(child);
        }
      }
      node2 = nodesToSearch.pop();
    }
    return false;
  }
  load(data2) {
    if (!(data2 && data2.length))
      return this;
    if (data2.length < this._minEntries) {
      for (let i2 = 0; i2 < data2.length; i2++) {
        this.insert(data2[i2]);
      }
      return this;
    }
    let node2 = this._build(data2.slice(), 0, data2.length - 1, 0);
    if (!this.data.children.length) {
      this.data = node2;
    } else if (this.data.height === node2.height) {
      this._splitRoot(this.data, node2);
    } else {
      if (this.data.height < node2.height) {
        const tmpNode = this.data;
        this.data = node2;
        node2 = tmpNode;
      }
      this._insert(node2, this.data.height - node2.height - 1, true);
    }
    return this;
  }
  insert(item) {
    if (item)
      this._insert(item, this.data.height - 1);
    return this;
  }
  clear() {
    this.data = createNode([]);
    return this;
  }
  remove(item, equalsFn) {
    if (!item)
      return this;
    let node2 = this.data;
    const bbox2 = this.toBBox(item);
    const path = [];
    const indexes = [];
    let i2, parent, goingUp;
    while (node2 || path.length) {
      if (!node2) {
        node2 = path.pop();
        parent = path[path.length - 1];
        i2 = indexes.pop();
        goingUp = true;
      }
      if (node2.leaf) {
        const index2 = findItem(item, node2.children, equalsFn);
        if (index2 !== -1) {
          node2.children.splice(index2, 1);
          path.push(node2);
          this._condense(path);
          return this;
        }
      }
      if (!goingUp && !node2.leaf && contains$1(node2, bbox2)) {
        path.push(node2);
        indexes.push(i2);
        i2 = 0;
        parent = node2;
        node2 = node2.children[0];
      } else if (parent) {
        i2++;
        node2 = parent.children[i2];
        goingUp = false;
      } else
        node2 = null;
    }
    return this;
  }
  toBBox(item) {
    return item;
  }
  compareMinX(a2, b2) {
    return a2.minX - b2.minX;
  }
  compareMinY(a2, b2) {
    return a2.minY - b2.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(data2) {
    this.data = data2;
    return this;
  }
  _all(node2, result) {
    const nodesToSearch = [];
    while (node2) {
      if (node2.leaf)
        result.push(...node2.children);
      else
        nodesToSearch.push(...node2.children);
      node2 = nodesToSearch.pop();
    }
    return result;
  }
  _build(items, left, right, height) {
    const N2 = right - left + 1;
    let M2 = this._maxEntries;
    let node2;
    if (N2 <= M2) {
      node2 = createNode(items.slice(left, right + 1));
      calcBBox(node2, this.toBBox);
      return node2;
    }
    if (!height) {
      height = Math.ceil(Math.log(N2) / Math.log(M2));
      M2 = Math.ceil(N2 / Math.pow(M2, height - 1));
    }
    node2 = createNode([]);
    node2.leaf = false;
    node2.height = height;
    const N22 = Math.ceil(N2 / M2);
    const N1 = N22 * Math.ceil(Math.sqrt(M2));
    multiSelect(items, left, right, N1, this.compareMinX);
    for (let i2 = left; i2 <= right; i2 += N1) {
      const right2 = Math.min(i2 + N1 - 1, right);
      multiSelect(items, i2, right2, N22, this.compareMinY);
      for (let j2 = i2; j2 <= right2; j2 += N22) {
        const right3 = Math.min(j2 + N22 - 1, right2);
        node2.children.push(this._build(items, j2, right3, height - 1));
      }
    }
    calcBBox(node2, this.toBBox);
    return node2;
  }
  _chooseSubtree(bbox2, node2, level, path) {
    while (true) {
      path.push(node2);
      if (node2.leaf || path.length - 1 === level)
        break;
      let minArea = Infinity;
      let minEnlargement = Infinity;
      let targetNode;
      for (let i2 = 0; i2 < node2.children.length; i2++) {
        const child = node2.children[i2];
        const area2 = bboxArea(child);
        const enlargement = enlargedArea(bbox2, child) - area2;
        if (enlargement < minEnlargement) {
          minEnlargement = enlargement;
          minArea = area2 < minArea ? area2 : minArea;
          targetNode = child;
        } else if (enlargement === minEnlargement) {
          if (area2 < minArea) {
            minArea = area2;
            targetNode = child;
          }
        }
      }
      node2 = targetNode || node2.children[0];
    }
    return node2;
  }
  _insert(item, level, isNode) {
    const bbox2 = isNode ? item : this.toBBox(item);
    const insertPath = [];
    const node2 = this._chooseSubtree(bbox2, this.data, level, insertPath);
    node2.children.push(item);
    extend(node2, bbox2);
    while (level >= 0) {
      if (insertPath[level].children.length > this._maxEntries) {
        this._split(insertPath, level);
        level--;
      } else
        break;
    }
    this._adjustParentBBoxes(bbox2, insertPath, level);
  }
  _split(insertPath, level) {
    const node2 = insertPath[level];
    const M2 = node2.children.length;
    const m2 = this._minEntries;
    this._chooseSplitAxis(node2, m2, M2);
    const splitIndex = this._chooseSplitIndex(node2, m2, M2);
    const newNode = createNode(node2.children.splice(splitIndex, node2.children.length - splitIndex));
    newNode.height = node2.height;
    newNode.leaf = node2.leaf;
    calcBBox(node2, this.toBBox);
    calcBBox(newNode, this.toBBox);
    if (level)
      insertPath[level - 1].children.push(newNode);
    else
      this._splitRoot(node2, newNode);
  }
  _splitRoot(node2, newNode) {
    this.data = createNode([node2, newNode]);
    this.data.height = node2.height + 1;
    this.data.leaf = false;
    calcBBox(this.data, this.toBBox);
  }
  _chooseSplitIndex(node2, m2, M2) {
    let index2;
    let minOverlap = Infinity;
    let minArea = Infinity;
    for (let i2 = m2; i2 <= M2 - m2; i2++) {
      const bbox1 = distBBox(node2, 0, i2, this.toBBox);
      const bbox2 = distBBox(node2, i2, M2, this.toBBox);
      const overlap = intersectionArea(bbox1, bbox2);
      const area2 = bboxArea(bbox1) + bboxArea(bbox2);
      if (overlap < minOverlap) {
        minOverlap = overlap;
        index2 = i2;
        minArea = area2 < minArea ? area2 : minArea;
      } else if (overlap === minOverlap) {
        if (area2 < minArea) {
          minArea = area2;
          index2 = i2;
        }
      }
    }
    return index2 || M2 - m2;
  }
  _chooseSplitAxis(node2, m2, M2) {
    const compareMinX = node2.leaf ? this.compareMinX : compareNodeMinX;
    const compareMinY = node2.leaf ? this.compareMinY : compareNodeMinY;
    const xMargin = this._allDistMargin(node2, m2, M2, compareMinX);
    const yMargin = this._allDistMargin(node2, m2, M2, compareMinY);
    if (xMargin < yMargin)
      node2.children.sort(compareMinX);
  }
  _allDistMargin(node2, m2, M2, compare) {
    node2.children.sort(compare);
    const toBBox = this.toBBox;
    const leftBBox = distBBox(node2, 0, m2, toBBox);
    const rightBBox = distBBox(node2, M2 - m2, M2, toBBox);
    let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);
    for (let i2 = m2; i2 < M2 - m2; i2++) {
      const child = node2.children[i2];
      extend(leftBBox, node2.leaf ? toBBox(child) : child);
      margin += bboxMargin(leftBBox);
    }
    for (let i2 = M2 - m2 - 1; i2 >= m2; i2--) {
      const child = node2.children[i2];
      extend(rightBBox, node2.leaf ? toBBox(child) : child);
      margin += bboxMargin(rightBBox);
    }
    return margin;
  }
  _adjustParentBBoxes(bbox2, path, level) {
    for (let i2 = level; i2 >= 0; i2--) {
      extend(path[i2], bbox2);
    }
  }
  _condense(path) {
    for (let i2 = path.length - 1, siblings; i2 >= 0; i2--) {
      if (path[i2].children.length === 0) {
        if (i2 > 0) {
          siblings = path[i2 - 1].children;
          siblings.splice(siblings.indexOf(path[i2]), 1);
        } else
          this.clear();
      } else
        calcBBox(path[i2], this.toBBox);
    }
  }
}
function findItem(item, items, equalsFn) {
  if (!equalsFn)
    return items.indexOf(item);
  for (let i2 = 0; i2 < items.length; i2++) {
    if (equalsFn(item, items[i2]))
      return i2;
  }
  return -1;
}
function calcBBox(node2, toBBox) {
  distBBox(node2, 0, node2.children.length, toBBox, node2);
}
function distBBox(node2, k2, p5, toBBox, destNode) {
  if (!destNode)
    destNode = createNode(null);
  destNode.minX = Infinity;
  destNode.minY = Infinity;
  destNode.maxX = -Infinity;
  destNode.maxY = -Infinity;
  for (let i2 = k2; i2 < p5; i2++) {
    const child = node2.children[i2];
    extend(destNode, node2.leaf ? toBBox(child) : child);
  }
  return destNode;
}
function extend(a2, b2) {
  a2.minX = Math.min(a2.minX, b2.minX);
  a2.minY = Math.min(a2.minY, b2.minY);
  a2.maxX = Math.max(a2.maxX, b2.maxX);
  a2.maxY = Math.max(a2.maxY, b2.maxY);
  return a2;
}
function compareNodeMinX(a2, b2) {
  return a2.minX - b2.minX;
}
function compareNodeMinY(a2, b2) {
  return a2.minY - b2.minY;
}
function bboxArea(a2) {
  return (a2.maxX - a2.minX) * (a2.maxY - a2.minY);
}
function bboxMargin(a2) {
  return a2.maxX - a2.minX + (a2.maxY - a2.minY);
}
function enlargedArea(a2, b2) {
  return (Math.max(b2.maxX, a2.maxX) - Math.min(b2.minX, a2.minX)) * (Math.max(b2.maxY, a2.maxY) - Math.min(b2.minY, a2.minY));
}
function intersectionArea(a2, b2) {
  const minX = Math.max(a2.minX, b2.minX);
  const minY = Math.max(a2.minY, b2.minY);
  const maxX = Math.min(a2.maxX, b2.maxX);
  const maxY = Math.min(a2.maxY, b2.maxY);
  return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
}
function contains$1(a2, b2) {
  return a2.minX <= b2.minX && a2.minY <= b2.minY && b2.maxX <= a2.maxX && b2.maxY <= a2.maxY;
}
function intersects$1(a2, b2) {
  return b2.minX <= a2.maxX && b2.minY <= a2.maxY && b2.maxX >= a2.minX && b2.maxY >= a2.minY;
}
function createNode(children) {
  return {
    children,
    height: 1,
    leaf: true,
    minX: Infinity,
    minY: Infinity,
    maxX: -Infinity,
    maxY: -Infinity
  };
}
function multiSelect(arr, left, right, n2, compare) {
  const stack = [left, right];
  while (stack.length) {
    right = stack.pop();
    left = stack.pop();
    if (right - left <= n2)
      continue;
    const mid = left + Math.ceil((right - left) / n2 / 2) * n2;
    quickselect(arr, mid, left, right, compare);
    stack.push(left, mid, mid, right);
  }
}
class ImageStyle {
  constructor(options) {
    this.opacity_ = options.opacity;
    this.rotateWithView_ = options.rotateWithView;
    this.rotation_ = options.rotation;
    this.scale_ = options.scale;
    this.scaleArray_ = toSize(options.scale);
    this.displacement_ = options.displacement;
    this.declutterMode_ = options.declutterMode;
  }
  clone() {
    const scale2 = this.getScale();
    return new ImageStyle({
      opacity: this.getOpacity(),
      scale: Array.isArray(scale2) ? scale2.slice() : scale2,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
  }
  getOpacity() {
    return this.opacity_;
  }
  getRotateWithView() {
    return this.rotateWithView_;
  }
  getRotation() {
    return this.rotation_;
  }
  getScale() {
    return this.scale_;
  }
  getScaleArray() {
    return this.scaleArray_;
  }
  getDisplacement() {
    return this.displacement_;
  }
  getDeclutterMode() {
    return this.declutterMode_;
  }
  getAnchor() {
    return abstract();
  }
  getImage(pixelRatio) {
    return abstract();
  }
  getHitDetectionImage() {
    return abstract();
  }
  getPixelRatio(pixelRatio) {
    return 1;
  }
  getImageState() {
    return abstract();
  }
  getImageSize() {
    return abstract();
  }
  getOrigin() {
    return abstract();
  }
  getSize() {
    return abstract();
  }
  setDisplacement(displacement) {
    this.displacement_ = displacement;
  }
  setOpacity(opacity2) {
    this.opacity_ = opacity2;
  }
  setRotateWithView(rotateWithView) {
    this.rotateWithView_ = rotateWithView;
  }
  setRotation(rotation) {
    this.rotation_ = rotation;
  }
  setScale(scale2) {
    this.scale_ = scale2;
    this.scaleArray_ = toSize(scale2);
  }
  listenImageChange(listener2) {
    abstract();
  }
  load() {
    abstract();
  }
  unlistenImageChange(listener2) {
    abstract();
  }
}
function asColorLike(color2) {
  if (Array.isArray(color2)) {
    return toString$d(color2);
  }
  return color2;
}
class RegularShape extends ImageStyle {
  constructor(options) {
    const rotateWithView = options.rotateWithView !== void 0 ? options.rotateWithView : false;
    super({
      opacity: 1,
      rotateWithView,
      rotation: options.rotation !== void 0 ? options.rotation : 0,
      scale: options.scale !== void 0 ? options.scale : 1,
      displacement: options.displacement !== void 0 ? options.displacement : [0, 0],
      declutterMode: options.declutterMode
    });
    this.canvas_ = void 0;
    this.hitDetectionCanvas_ = null;
    this.fill_ = options.fill !== void 0 ? options.fill : null;
    this.origin_ = [0, 0];
    this.points_ = options.points;
    this.radius_ = options.radius !== void 0 ? options.radius : options.radius1;
    this.radius2_ = options.radius2;
    this.angle_ = options.angle !== void 0 ? options.angle : 0;
    this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
    this.size_ = null;
    this.renderOptions_ = null;
    this.render();
  }
  clone() {
    const scale2 = this.getScale();
    const style2 = new RegularShape({
      fill: this.getFill() ? this.getFill().clone() : void 0,
      points: this.getPoints(),
      radius: this.getRadius(),
      radius2: this.getRadius2(),
      angle: this.getAngle(),
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(scale2) ? scale2.slice() : scale2,
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
    style2.setOpacity(this.getOpacity());
    return style2;
  }
  getAnchor() {
    const size = this.size_;
    if (!size) {
      return null;
    }
    const displacement = this.getDisplacement();
    const scale2 = this.getScaleArray();
    return [
      size[0] / 2 - displacement[0] / scale2[0],
      size[1] / 2 + displacement[1] / scale2[1]
    ];
  }
  getAngle() {
    return this.angle_;
  }
  getFill() {
    return this.fill_;
  }
  setFill(fill) {
    this.fill_ = fill;
    this.render();
  }
  getHitDetectionImage() {
    if (!this.hitDetectionCanvas_) {
      this.createHitDetectionCanvas_(this.renderOptions_);
    }
    return this.hitDetectionCanvas_;
  }
  getImage(pixelRatio) {
    let image2 = this.canvas_[pixelRatio];
    if (!image2) {
      const renderOptions = this.renderOptions_;
      const context2 = createCanvasContext2D(renderOptions.size * pixelRatio, renderOptions.size * pixelRatio);
      this.draw_(renderOptions, context2, pixelRatio);
      image2 = context2.canvas;
      this.canvas_[pixelRatio] = image2;
    }
    return image2;
  }
  getPixelRatio(pixelRatio) {
    return pixelRatio;
  }
  getImageSize() {
    return this.size_;
  }
  getImageState() {
    return ImageState.LOADED;
  }
  getOrigin() {
    return this.origin_;
  }
  getPoints() {
    return this.points_;
  }
  getRadius() {
    return this.radius_;
  }
  getRadius2() {
    return this.radius2_;
  }
  getSize() {
    return this.size_;
  }
  getStroke() {
    return this.stroke_;
  }
  setStroke(stroke) {
    this.stroke_ = stroke;
    this.render();
  }
  listenImageChange(listener2) {
  }
  load() {
  }
  unlistenImageChange(listener2) {
  }
  calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit) {
    if (strokeWidth === 0 || this.points_ === Infinity || lineJoin !== "bevel" && lineJoin !== "miter") {
      return strokeWidth;
    }
    let r1 = this.radius_;
    let r2 = this.radius2_ === void 0 ? r1 : this.radius2_;
    if (r1 < r2) {
      const tmp = r1;
      r1 = r2;
      r2 = tmp;
    }
    const points = this.radius2_ === void 0 ? this.points_ : this.points_ * 2;
    const alpha = 2 * Math.PI / points;
    const a2 = r2 * Math.sin(alpha);
    const b2 = Math.sqrt(r2 * r2 - a2 * a2);
    const d2 = r1 - b2;
    const e2 = Math.sqrt(a2 * a2 + d2 * d2);
    const miterRatio = e2 / a2;
    if (lineJoin === "miter" && miterRatio <= miterLimit) {
      return miterRatio * strokeWidth;
    }
    const k2 = strokeWidth / 2 / miterRatio;
    const l2 = strokeWidth / 2 * (d2 / e2);
    const maxr = Math.sqrt((r1 + k2) * (r1 + k2) + l2 * l2);
    const bevelAdd = maxr - r1;
    if (this.radius2_ === void 0 || lineJoin === "bevel") {
      return bevelAdd * 2;
    }
    const aa = r1 * Math.sin(alpha);
    const bb = Math.sqrt(r1 * r1 - aa * aa);
    const dd = r2 - bb;
    const ee2 = Math.sqrt(aa * aa + dd * dd);
    const innerMiterRatio = ee2 / aa;
    if (innerMiterRatio <= miterLimit) {
      const innerLength = innerMiterRatio * strokeWidth / 2 - r2 - r1;
      return 2 * Math.max(bevelAdd, innerLength);
    }
    return bevelAdd * 2;
  }
  createRenderOptions() {
    let lineJoin = defaultLineJoin;
    let miterLimit = 0;
    let lineDash = null;
    let lineDashOffset = 0;
    let strokeStyle;
    let strokeWidth = 0;
    if (this.stroke_) {
      strokeStyle = this.stroke_.getColor();
      if (strokeStyle === null) {
        strokeStyle = defaultStrokeStyle;
      }
      strokeStyle = asColorLike(strokeStyle);
      strokeWidth = this.stroke_.getWidth();
      if (strokeWidth === void 0) {
        strokeWidth = defaultLineWidth;
      }
      lineDash = this.stroke_.getLineDash();
      lineDashOffset = this.stroke_.getLineDashOffset();
      lineJoin = this.stroke_.getLineJoin();
      if (lineJoin === void 0) {
        lineJoin = defaultLineJoin;
      }
      miterLimit = this.stroke_.getMiterLimit();
      if (miterLimit === void 0) {
        miterLimit = defaultMiterLimit;
      }
    }
    const add2 = this.calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit);
    const maxRadius = Math.max(this.radius_, this.radius2_ || 0);
    const size = Math.ceil(2 * maxRadius + add2);
    return {
      strokeStyle,
      strokeWidth,
      size,
      lineDash,
      lineDashOffset,
      lineJoin,
      miterLimit
    };
  }
  render() {
    this.renderOptions_ = this.createRenderOptions();
    const size = this.renderOptions_.size;
    this.canvas_ = {};
    this.size_ = [size, size];
  }
  draw_(renderOptions, context2, pixelRatio) {
    context2.scale(pixelRatio, pixelRatio);
    context2.translate(renderOptions.size / 2, renderOptions.size / 2);
    this.createPath_(context2);
    if (this.fill_) {
      let color2 = this.fill_.getColor();
      if (color2 === null) {
        color2 = defaultFillStyle;
      }
      context2.fillStyle = asColorLike(color2);
      context2.fill();
    }
    if (this.stroke_) {
      context2.strokeStyle = renderOptions.strokeStyle;
      context2.lineWidth = renderOptions.strokeWidth;
      if (renderOptions.lineDash) {
        context2.setLineDash(renderOptions.lineDash);
        context2.lineDashOffset = renderOptions.lineDashOffset;
      }
      context2.lineJoin = renderOptions.lineJoin;
      context2.miterLimit = renderOptions.miterLimit;
      context2.stroke();
    }
  }
  createHitDetectionCanvas_(renderOptions) {
    if (this.fill_) {
      let color2 = this.fill_.getColor();
      let opacity2 = 0;
      if (typeof color2 === "string") {
        color2 = asArray(color2);
      }
      if (color2 === null) {
        opacity2 = 1;
      } else if (Array.isArray(color2)) {
        opacity2 = color2.length === 4 ? color2[3] : 1;
      }
      if (opacity2 === 0) {
        const context2 = createCanvasContext2D(renderOptions.size, renderOptions.size);
        this.hitDetectionCanvas_ = context2.canvas;
        this.drawHitDetectionCanvas_(renderOptions, context2);
      }
    }
    if (!this.hitDetectionCanvas_) {
      this.hitDetectionCanvas_ = this.getImage(1);
    }
  }
  createPath_(context2) {
    let points = this.points_;
    const radius = this.radius_;
    if (points === Infinity) {
      context2.arc(0, 0, radius, 0, 2 * Math.PI);
    } else {
      const radius2 = this.radius2_ === void 0 ? radius : this.radius2_;
      if (this.radius2_ !== void 0) {
        points *= 2;
      }
      const startAngle = this.angle_ - Math.PI / 2;
      const step = 2 * Math.PI / points;
      for (let i2 = 0; i2 < points; i2++) {
        const angle0 = startAngle + i2 * step;
        const radiusC = i2 % 2 === 0 ? radius : radius2;
        context2.lineTo(radiusC * Math.cos(angle0), radiusC * Math.sin(angle0));
      }
      context2.closePath();
    }
  }
  drawHitDetectionCanvas_(renderOptions, context2) {
    context2.translate(renderOptions.size / 2, renderOptions.size / 2);
    this.createPath_(context2);
    context2.fillStyle = defaultFillStyle;
    context2.fill();
    if (this.stroke_) {
      context2.strokeStyle = renderOptions.strokeStyle;
      context2.lineWidth = renderOptions.strokeWidth;
      if (renderOptions.lineDash) {
        context2.setLineDash(renderOptions.lineDash);
        context2.lineDashOffset = renderOptions.lineDashOffset;
      }
      context2.lineJoin = renderOptions.lineJoin;
      context2.miterLimit = renderOptions.miterLimit;
      context2.stroke();
    }
  }
}
class CircleStyle extends RegularShape {
  constructor(options) {
    options = options ? options : { radius: 5 };
    super({
      points: Infinity,
      fill: options.fill,
      radius: options.radius,
      stroke: options.stroke,
      scale: options.scale !== void 0 ? options.scale : 1,
      rotation: options.rotation !== void 0 ? options.rotation : 0,
      rotateWithView: options.rotateWithView !== void 0 ? options.rotateWithView : false,
      displacement: options.displacement !== void 0 ? options.displacement : [0, 0],
      declutterMode: options.declutterMode
    });
  }
  clone() {
    const scale2 = this.getScale();
    const style2 = new CircleStyle({
      fill: this.getFill() ? this.getFill().clone() : void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      radius: this.getRadius(),
      scale: Array.isArray(scale2) ? scale2.slice() : scale2,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
    style2.setOpacity(this.getOpacity());
    return style2;
  }
  setRadius(radius) {
    this.radius_ = radius;
    this.render();
  }
}
class Fill$1 {
  constructor(options) {
    options = options || {};
    this.color_ = options.color !== void 0 ? options.color : null;
  }
  clone() {
    const color2 = this.getColor();
    return new Fill$1({
      color: Array.isArray(color2) ? color2.slice() : color2 || void 0
    });
  }
  getColor() {
    return this.color_;
  }
  setColor(color2) {
    this.color_ = color2;
  }
}
class Stroke$1 {
  constructor(options) {
    options = options || {};
    this.color_ = options.color !== void 0 ? options.color : null;
    this.lineCap_ = options.lineCap;
    this.lineDash_ = options.lineDash !== void 0 ? options.lineDash : null;
    this.lineDashOffset_ = options.lineDashOffset;
    this.lineJoin_ = options.lineJoin;
    this.miterLimit_ = options.miterLimit;
    this.width_ = options.width;
  }
  clone() {
    const color2 = this.getColor();
    return new Stroke$1({
      color: Array.isArray(color2) ? color2.slice() : color2 || void 0,
      lineCap: this.getLineCap(),
      lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,
      lineDashOffset: this.getLineDashOffset(),
      lineJoin: this.getLineJoin(),
      miterLimit: this.getMiterLimit(),
      width: this.getWidth()
    });
  }
  getColor() {
    return this.color_;
  }
  getLineCap() {
    return this.lineCap_;
  }
  getLineDash() {
    return this.lineDash_;
  }
  getLineDashOffset() {
    return this.lineDashOffset_;
  }
  getLineJoin() {
    return this.lineJoin_;
  }
  getMiterLimit() {
    return this.miterLimit_;
  }
  getWidth() {
    return this.width_;
  }
  setColor(color2) {
    this.color_ = color2;
  }
  setLineCap(lineCap) {
    this.lineCap_ = lineCap;
  }
  setLineDash(lineDash) {
    this.lineDash_ = lineDash;
  }
  setLineDashOffset(lineDashOffset) {
    this.lineDashOffset_ = lineDashOffset;
  }
  setLineJoin(lineJoin) {
    this.lineJoin_ = lineJoin;
  }
  setMiterLimit(miterLimit) {
    this.miterLimit_ = miterLimit;
  }
  setWidth(width) {
    this.width_ = width;
  }
}
class Style$1 {
  constructor(options) {
    options = options || {};
    this.geometry_ = null;
    this.geometryFunction_ = defaultGeometryFunction;
    if (options.geometry !== void 0) {
      this.setGeometry(options.geometry);
    }
    this.fill_ = options.fill !== void 0 ? options.fill : null;
    this.image_ = options.image !== void 0 ? options.image : null;
    this.renderer_ = options.renderer !== void 0 ? options.renderer : null;
    this.hitDetectionRenderer_ = options.hitDetectionRenderer !== void 0 ? options.hitDetectionRenderer : null;
    this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
    this.text_ = options.text !== void 0 ? options.text : null;
    this.zIndex_ = options.zIndex;
  }
  clone() {
    let geometry = this.getGeometry();
    if (geometry && typeof geometry === "object") {
      geometry = geometry.clone();
    }
    return new Style$1({
      geometry,
      fill: this.getFill() ? this.getFill().clone() : void 0,
      image: this.getImage() ? this.getImage().clone() : void 0,
      renderer: this.getRenderer(),
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      text: this.getText() ? this.getText().clone() : void 0,
      zIndex: this.getZIndex()
    });
  }
  getRenderer() {
    return this.renderer_;
  }
  setRenderer(renderer) {
    this.renderer_ = renderer;
  }
  setHitDetectionRenderer(renderer) {
    this.hitDetectionRenderer_ = renderer;
  }
  getHitDetectionRenderer() {
    return this.hitDetectionRenderer_;
  }
  getGeometry() {
    return this.geometry_;
  }
  getGeometryFunction() {
    return this.geometryFunction_;
  }
  getFill() {
    return this.fill_;
  }
  setFill(fill) {
    this.fill_ = fill;
  }
  getImage() {
    return this.image_;
  }
  setImage(image2) {
    this.image_ = image2;
  }
  getStroke() {
    return this.stroke_;
  }
  setStroke(stroke) {
    this.stroke_ = stroke;
  }
  getText() {
    return this.text_;
  }
  setText(text2) {
    this.text_ = text2;
  }
  getZIndex() {
    return this.zIndex_;
  }
  setGeometry(geometry) {
    if (typeof geometry === "function") {
      this.geometryFunction_ = geometry;
    } else if (typeof geometry === "string") {
      this.geometryFunction_ = function(feature) {
        return feature.get(geometry);
      };
    } else if (!geometry) {
      this.geometryFunction_ = defaultGeometryFunction;
    } else if (geometry !== void 0) {
      this.geometryFunction_ = function() {
        return geometry;
      };
    }
    this.geometry_ = geometry;
  }
  setZIndex(zIndex2) {
    this.zIndex_ = zIndex2;
  }
}
function toFunction(obj) {
  let styleFunction;
  if (typeof obj === "function") {
    styleFunction = obj;
  } else {
    let styles;
    if (Array.isArray(obj)) {
      styles = obj;
    } else {
      assert(typeof obj.getZIndex === "function", 41);
      const style2 = obj;
      styles = [style2];
    }
    styleFunction = function() {
      return styles;
    };
  }
  return styleFunction;
}
let defaultStyles = null;
function createDefaultStyle(feature, resolution) {
  if (!defaultStyles) {
    const fill = new Fill$1({
      color: "rgba(255,255,255,0.4)"
    });
    const stroke = new Stroke$1({
      color: "#3399CC",
      width: 1.25
    });
    defaultStyles = [
      new Style$1({
        image: new CircleStyle({
          fill,
          stroke,
          radius: 5
        }),
        fill,
        stroke
      })
    ];
  }
  return defaultStyles;
}
function createEditingStyle() {
  const styles = {};
  const white = [255, 255, 255, 1];
  const blue = [0, 153, 255, 1];
  const width = 3;
  styles["Polygon"] = [
    new Style$1({
      fill: new Fill$1({
        color: [255, 255, 255, 0.5]
      })
    })
  ];
  styles["MultiPolygon"] = styles["Polygon"];
  styles["LineString"] = [
    new Style$1({
      stroke: new Stroke$1({
        color: white,
        width: width + 2
      })
    }),
    new Style$1({
      stroke: new Stroke$1({
        color: blue,
        width
      })
    })
  ];
  styles["MultiLineString"] = styles["LineString"];
  styles["Circle"] = styles["Polygon"].concat(styles["LineString"]);
  styles["Point"] = [
    new Style$1({
      image: new CircleStyle({
        radius: width * 2,
        fill: new Fill$1({
          color: blue
        }),
        stroke: new Stroke$1({
          color: white,
          width: width / 2
        })
      }),
      zIndex: Infinity
    })
  ];
  styles["MultiPoint"] = styles["Point"];
  styles["GeometryCollection"] = styles["Polygon"].concat(styles["LineString"], styles["Point"]);
  return styles;
}
function defaultGeometryFunction(feature) {
  return feature.getGeometry();
}
let taintedTestContext = null;
class IconImage extends Target {
  constructor(image2, src, size, crossOrigin, imageState, color2) {
    super();
    this.hitDetectionImage_ = null;
    this.image_ = image2;
    this.crossOrigin_ = crossOrigin;
    this.canvas_ = {};
    this.color_ = color2;
    this.unlisten_ = null;
    this.imageState_ = imageState;
    this.size_ = size;
    this.src_ = src;
    this.tainted_;
  }
  initializeImage_() {
    this.image_ = new Image();
    if (this.crossOrigin_ !== null) {
      this.image_.crossOrigin = this.crossOrigin_;
    }
  }
  isTainted_() {
    if (this.tainted_ === void 0 && this.imageState_ === ImageState.LOADED) {
      if (!taintedTestContext) {
        taintedTestContext = createCanvasContext2D(1, 1);
      }
      taintedTestContext.drawImage(this.image_, 0, 0);
      try {
        taintedTestContext.getImageData(0, 0, 1, 1);
        this.tainted_ = false;
      } catch (e2) {
        taintedTestContext = null;
        this.tainted_ = true;
      }
    }
    return this.tainted_ === true;
  }
  dispatchChangeEvent_() {
    this.dispatchEvent(EventType.CHANGE);
  }
  handleImageError_() {
    this.imageState_ = ImageState.ERROR;
    this.unlistenImage_();
    this.dispatchChangeEvent_();
  }
  handleImageLoad_() {
    this.imageState_ = ImageState.LOADED;
    if (this.size_) {
      this.image_.width = this.size_[0];
      this.image_.height = this.size_[1];
    } else {
      this.size_ = [this.image_.width, this.image_.height];
    }
    this.unlistenImage_();
    this.dispatchChangeEvent_();
  }
  getImage(pixelRatio) {
    if (!this.image_) {
      this.initializeImage_();
    }
    this.replaceColor_(pixelRatio);
    return this.canvas_[pixelRatio] ? this.canvas_[pixelRatio] : this.image_;
  }
  getPixelRatio(pixelRatio) {
    this.replaceColor_(pixelRatio);
    return this.canvas_[pixelRatio] ? pixelRatio : 1;
  }
  getImageState() {
    return this.imageState_;
  }
  getHitDetectionImage() {
    if (!this.image_) {
      this.initializeImage_();
    }
    if (!this.hitDetectionImage_) {
      if (this.isTainted_()) {
        const width = this.size_[0];
        const height = this.size_[1];
        const context2 = createCanvasContext2D(width, height);
        context2.fillRect(0, 0, width, height);
        this.hitDetectionImage_ = context2.canvas;
      } else {
        this.hitDetectionImage_ = this.image_;
      }
    }
    return this.hitDetectionImage_;
  }
  getSize() {
    return this.size_;
  }
  getSrc() {
    return this.src_;
  }
  load() {
    if (this.imageState_ !== ImageState.IDLE) {
      return;
    }
    if (!this.image_) {
      this.initializeImage_();
    }
    this.imageState_ = ImageState.LOADING;
    try {
      this.image_.src = this.src_;
    } catch (e2) {
      this.handleImageError_();
    }
    this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
  }
  replaceColor_(pixelRatio) {
    if (!this.color_ || this.canvas_[pixelRatio] || this.imageState_ !== ImageState.LOADED) {
      return;
    }
    const image2 = this.image_;
    const canvas = document.createElement("canvas");
    canvas.width = Math.ceil(image2.width * pixelRatio);
    canvas.height = Math.ceil(image2.height * pixelRatio);
    const ctx = canvas.getContext("2d");
    ctx.scale(pixelRatio, pixelRatio);
    ctx.drawImage(image2, 0, 0);
    ctx.globalCompositeOperation = "multiply";
    ctx.fillStyle = asString$1(this.color_);
    ctx.fillRect(0, 0, canvas.width / pixelRatio, canvas.height / pixelRatio);
    ctx.globalCompositeOperation = "destination-in";
    ctx.drawImage(image2, 0, 0);
    this.canvas_[pixelRatio] = canvas;
  }
  unlistenImage_() {
    if (this.unlisten_) {
      this.unlisten_();
      this.unlisten_ = null;
    }
  }
}
function get$2(image2, src, size, crossOrigin, imageState, color2) {
  let iconImage = shared$5.get(src, crossOrigin, color2);
  if (!iconImage) {
    iconImage = new IconImage(image2, src, size, crossOrigin, imageState, color2);
    shared$5.set(src, crossOrigin, color2, iconImage);
  }
  return iconImage;
}
class Icon$1 extends ImageStyle {
  constructor(options) {
    options = options || {};
    const opacity2 = options.opacity !== void 0 ? options.opacity : 1;
    const rotation = options.rotation !== void 0 ? options.rotation : 0;
    const scale2 = options.scale !== void 0 ? options.scale : 1;
    const rotateWithView = options.rotateWithView !== void 0 ? options.rotateWithView : false;
    super({
      opacity: opacity2,
      rotation,
      scale: scale2,
      displacement: options.displacement !== void 0 ? options.displacement : [0, 0],
      rotateWithView,
      declutterMode: options.declutterMode
    });
    this.anchor_ = options.anchor !== void 0 ? options.anchor : [0.5, 0.5];
    this.normalizedAnchor_ = null;
    this.anchorOrigin_ = options.anchorOrigin !== void 0 ? options.anchorOrigin : "top-left";
    this.anchorXUnits_ = options.anchorXUnits !== void 0 ? options.anchorXUnits : "fraction";
    this.anchorYUnits_ = options.anchorYUnits !== void 0 ? options.anchorYUnits : "fraction";
    this.crossOrigin_ = options.crossOrigin !== void 0 ? options.crossOrigin : null;
    const image2 = options.img !== void 0 ? options.img : null;
    this.imgSize_ = options.imgSize;
    let src = options.src;
    assert(!(src !== void 0 && image2), 4);
    assert(!image2 || image2 && this.imgSize_, 5);
    if ((src === void 0 || src.length === 0) && image2) {
      src = image2.src || getUid(image2);
    }
    assert(src !== void 0 && src.length > 0, 6);
    const imageState = options.src !== void 0 ? ImageState.IDLE : ImageState.LOADED;
    this.color_ = options.color !== void 0 ? asArray(options.color) : null;
    this.iconImage_ = get$2(image2, src, this.imgSize_ !== void 0 ? this.imgSize_ : null, this.crossOrigin_, imageState, this.color_);
    this.offset_ = options.offset !== void 0 ? options.offset : [0, 0];
    this.offsetOrigin_ = options.offsetOrigin !== void 0 ? options.offsetOrigin : "top-left";
    this.origin_ = null;
    this.size_ = options.size !== void 0 ? options.size : null;
  }
  clone() {
    const scale2 = this.getScale();
    return new Icon$1({
      anchor: this.anchor_.slice(),
      anchorOrigin: this.anchorOrigin_,
      anchorXUnits: this.anchorXUnits_,
      anchorYUnits: this.anchorYUnits_,
      color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0,
      crossOrigin: this.crossOrigin_,
      imgSize: this.imgSize_,
      offset: this.offset_.slice(),
      offsetOrigin: this.offsetOrigin_,
      opacity: this.getOpacity(),
      rotateWithView: this.getRotateWithView(),
      rotation: this.getRotation(),
      scale: Array.isArray(scale2) ? scale2.slice() : scale2,
      size: this.size_ !== null ? this.size_.slice() : void 0,
      src: this.getSrc(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
  }
  getAnchor() {
    let anchor = this.normalizedAnchor_;
    if (!anchor) {
      anchor = this.anchor_;
      const size = this.getSize();
      if (this.anchorXUnits_ == "fraction" || this.anchorYUnits_ == "fraction") {
        if (!size) {
          return null;
        }
        anchor = this.anchor_.slice();
        if (this.anchorXUnits_ == "fraction") {
          anchor[0] *= size[0];
        }
        if (this.anchorYUnits_ == "fraction") {
          anchor[1] *= size[1];
        }
      }
      if (this.anchorOrigin_ != "top-left") {
        if (!size) {
          return null;
        }
        if (anchor === this.anchor_) {
          anchor = this.anchor_.slice();
        }
        if (this.anchorOrigin_ == "top-right" || this.anchorOrigin_ == "bottom-right") {
          anchor[0] = -anchor[0] + size[0];
        }
        if (this.anchorOrigin_ == "bottom-left" || this.anchorOrigin_ == "bottom-right") {
          anchor[1] = -anchor[1] + size[1];
        }
      }
      this.normalizedAnchor_ = anchor;
    }
    const displacement = this.getDisplacement();
    const scale2 = this.getScaleArray();
    return [
      anchor[0] - displacement[0] / scale2[0],
      anchor[1] + displacement[1] / scale2[1]
    ];
  }
  setAnchor(anchor) {
    this.anchor_ = anchor;
    this.normalizedAnchor_ = null;
  }
  getColor() {
    return this.color_;
  }
  getImage(pixelRatio) {
    return this.iconImage_.getImage(pixelRatio);
  }
  getPixelRatio(pixelRatio) {
    return this.iconImage_.getPixelRatio(pixelRatio);
  }
  getImageSize() {
    return this.iconImage_.getSize();
  }
  getImageState() {
    return this.iconImage_.getImageState();
  }
  getHitDetectionImage() {
    return this.iconImage_.getHitDetectionImage();
  }
  getOrigin() {
    if (this.origin_) {
      return this.origin_;
    }
    let offset2 = this.offset_;
    if (this.offsetOrigin_ != "top-left") {
      const size = this.getSize();
      const iconImageSize = this.iconImage_.getSize();
      if (!size || !iconImageSize) {
        return null;
      }
      offset2 = offset2.slice();
      if (this.offsetOrigin_ == "top-right" || this.offsetOrigin_ == "bottom-right") {
        offset2[0] = iconImageSize[0] - size[0] - offset2[0];
      }
      if (this.offsetOrigin_ == "bottom-left" || this.offsetOrigin_ == "bottom-right") {
        offset2[1] = iconImageSize[1] - size[1] - offset2[1];
      }
    }
    this.origin_ = offset2;
    return this.origin_;
  }
  getSrc() {
    return this.iconImage_.getSrc();
  }
  getSize() {
    return !this.size_ ? this.iconImage_.getSize() : this.size_;
  }
  listenImageChange(listener2) {
    this.iconImage_.addEventListener(EventType.CHANGE, listener2);
  }
  load() {
    this.iconImage_.load();
  }
  unlistenImageChange(listener2) {
    this.iconImage_.removeEventListener(EventType.CHANGE, listener2);
  }
}
const DEFAULT_FILL_COLOR = "#333";
class Text$1 {
  constructor(options) {
    options = options || {};
    this.font_ = options.font;
    this.rotation_ = options.rotation;
    this.rotateWithView_ = options.rotateWithView;
    this.scale_ = options.scale;
    this.scaleArray_ = toSize(options.scale !== void 0 ? options.scale : 1);
    this.text_ = options.text;
    this.textAlign_ = options.textAlign;
    this.justify_ = options.justify;
    this.textBaseline_ = options.textBaseline;
    this.fill_ = options.fill !== void 0 ? options.fill : new Fill$1({ color: DEFAULT_FILL_COLOR });
    this.maxAngle_ = options.maxAngle !== void 0 ? options.maxAngle : Math.PI / 4;
    this.placement_ = options.placement !== void 0 ? options.placement : "point";
    this.overflow_ = !!options.overflow;
    this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
    this.offsetX_ = options.offsetX !== void 0 ? options.offsetX : 0;
    this.offsetY_ = options.offsetY !== void 0 ? options.offsetY : 0;
    this.backgroundFill_ = options.backgroundFill ? options.backgroundFill : null;
    this.backgroundStroke_ = options.backgroundStroke ? options.backgroundStroke : null;
    this.padding_ = options.padding === void 0 ? null : options.padding;
  }
  clone() {
    const scale2 = this.getScale();
    return new Text$1({
      font: this.getFont(),
      placement: this.getPlacement(),
      maxAngle: this.getMaxAngle(),
      overflow: this.getOverflow(),
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(scale2) ? scale2.slice() : scale2,
      text: this.getText(),
      textAlign: this.getTextAlign(),
      justify: this.getJustify(),
      textBaseline: this.getTextBaseline(),
      fill: this.getFill() ? this.getFill().clone() : void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      offsetX: this.getOffsetX(),
      offsetY: this.getOffsetY(),
      backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : void 0,
      backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : void 0,
      padding: this.getPadding() || void 0
    });
  }
  getOverflow() {
    return this.overflow_;
  }
  getFont() {
    return this.font_;
  }
  getMaxAngle() {
    return this.maxAngle_;
  }
  getPlacement() {
    return this.placement_;
  }
  getOffsetX() {
    return this.offsetX_;
  }
  getOffsetY() {
    return this.offsetY_;
  }
  getFill() {
    return this.fill_;
  }
  getRotateWithView() {
    return this.rotateWithView_;
  }
  getRotation() {
    return this.rotation_;
  }
  getScale() {
    return this.scale_;
  }
  getScaleArray() {
    return this.scaleArray_;
  }
  getStroke() {
    return this.stroke_;
  }
  getText() {
    return this.text_;
  }
  getTextAlign() {
    return this.textAlign_;
  }
  getJustify() {
    return this.justify_;
  }
  getTextBaseline() {
    return this.textBaseline_;
  }
  getBackgroundFill() {
    return this.backgroundFill_;
  }
  getBackgroundStroke() {
    return this.backgroundStroke_;
  }
  getPadding() {
    return this.padding_;
  }
  setOverflow(overflow2) {
    this.overflow_ = overflow2;
  }
  setFont(font) {
    this.font_ = font;
  }
  setMaxAngle(maxAngle) {
    this.maxAngle_ = maxAngle;
  }
  setOffsetX(offsetX) {
    this.offsetX_ = offsetX;
  }
  setOffsetY(offsetY) {
    this.offsetY_ = offsetY;
  }
  setPlacement(placement) {
    this.placement_ = placement;
  }
  setRotateWithView(rotateWithView) {
    this.rotateWithView_ = rotateWithView;
  }
  setFill(fill) {
    this.fill_ = fill;
  }
  setRotation(rotation) {
    this.rotation_ = rotation;
  }
  setScale(scale2) {
    this.scale_ = scale2;
    this.scaleArray_ = toSize(scale2 !== void 0 ? scale2 : 1);
  }
  setStroke(stroke) {
    this.stroke_ = stroke;
  }
  setText(text2) {
    this.text_ = text2;
  }
  setTextAlign(textAlign2) {
    this.textAlign_ = textAlign2;
  }
  setJustify(justify) {
    this.justify_ = justify;
  }
  setTextBaseline(textBaseline) {
    this.textBaseline_ = textBaseline;
  }
  setBackgroundFill(fill) {
    this.backgroundFill_ = fill;
  }
  setBackgroundStroke(stroke) {
    this.backgroundStroke_ = stroke;
  }
  setPadding(padding) {
    this.padding_ = padding;
  }
}
function toStyle(flatStyle) {
  const style2 = new Style$1({
    fill: getFill(flatStyle, ""),
    stroke: getStroke(flatStyle, ""),
    text: getText$1(flatStyle),
    image: getImage(flatStyle)
  });
  return style2;
}
function getFill(flatStyle, prefix) {
  const color2 = flatStyle[prefix + "fill-color"];
  if (!color2) {
    return;
  }
  return new Fill$1({ color: color2 });
}
function getStroke(flatStyle, prefix) {
  const width = flatStyle[prefix + "stroke-width"];
  const color2 = flatStyle[prefix + "stroke-color"];
  if (!width && !color2) {
    return;
  }
  return new Stroke$1({
    width,
    color: color2,
    lineCap: flatStyle[prefix + "stroke-line-cap"],
    lineJoin: flatStyle[prefix + "stroke-line-join"],
    lineDash: flatStyle[prefix + "stroke-line-dash"],
    lineDashOffset: flatStyle[prefix + "stroke-line-dash-offset"],
    miterLimit: flatStyle[prefix + "stroke-miter-limit"]
  });
}
function getText$1(flatStyle) {
  const value = flatStyle["text-value"];
  if (!value) {
    return;
  }
  const text2 = new Text$1({
    text: value,
    font: flatStyle["text-font"],
    maxAngle: flatStyle["text-max-angle"],
    offsetX: flatStyle["text-offset-x"],
    offsetY: flatStyle["text-offset-y"],
    overflow: flatStyle["text-overflow"],
    placement: flatStyle["text-placement"],
    scale: flatStyle["text-scale"],
    rotateWithView: flatStyle["text-rotate-with-view"],
    rotation: flatStyle["text-rotation"],
    textAlign: flatStyle["text-align"],
    justify: flatStyle["text-justify"],
    textBaseline: flatStyle["text-baseline"],
    padding: flatStyle["text-padding"],
    fill: getFill(flatStyle, "text-"),
    backgroundFill: getFill(flatStyle, "text-background-"),
    stroke: getStroke(flatStyle, "text-"),
    backgroundStroke: getStroke(flatStyle, "text-background-")
  });
  return text2;
}
function getImage(flatStyle) {
  const iconSrc = flatStyle["icon-src"];
  const iconImg = flatStyle["icon-img"];
  if (iconSrc || iconImg) {
    const icon = new Icon$1({
      src: iconSrc,
      img: iconImg,
      imgSize: flatStyle["icon-img-size"],
      anchor: flatStyle["icon-anchor"],
      anchorOrigin: flatStyle["icon-anchor-origin"],
      anchorXUnits: flatStyle["icon-anchor-x-units"],
      anchorYUnits: flatStyle["icon-anchor-y-units"],
      color: flatStyle["icon-color"],
      crossOrigin: flatStyle["icon-cross-origin"],
      offset: flatStyle["icon-offset"],
      displacement: flatStyle["icon-displacement"],
      opacity: flatStyle["icon-opacity"],
      scale: flatStyle["icon-scale"],
      rotation: flatStyle["icon-rotation"],
      rotateWithView: flatStyle["icon-rotate-with-view"],
      size: flatStyle["icon-size"],
      declutterMode: flatStyle["icon-declutter-mode"]
    });
    return icon;
  }
  const shapePoints = flatStyle["shape-points"];
  if (shapePoints) {
    const prefix = "shape-";
    const shape = new RegularShape({
      points: shapePoints,
      fill: getFill(flatStyle, prefix),
      stroke: getStroke(flatStyle, prefix),
      radius: flatStyle["shape-radius"],
      radius1: flatStyle["shape-radius1"],
      radius2: flatStyle["shape-radius2"],
      angle: flatStyle["shape-angle"],
      displacement: flatStyle["shape-displacement"],
      rotation: flatStyle["shape-rotation"],
      rotateWithView: flatStyle["shape-rotate-with-view"],
      scale: flatStyle["shape-scale"],
      declutterMode: flatStyle["shape-declutter-mode"]
    });
    return shape;
  }
  const circleRadius = flatStyle["circle-radius"];
  if (circleRadius) {
    const prefix = "circle-";
    const circle = new CircleStyle({
      radius: circleRadius,
      fill: getFill(flatStyle, prefix),
      stroke: getStroke(flatStyle, prefix),
      displacement: flatStyle["circle-displacement"],
      scale: flatStyle["circle-scale"],
      rotation: flatStyle["circle-rotation"],
      rotateWithView: flatStyle["circle-rotate-with-view"],
      declutterMode: flatStyle["circle-declutter-mode"]
    });
    return circle;
  }
  return;
}
const Property$2 = {
  RENDER_ORDER: "renderOrder"
};
class BaseVectorLayer extends Layer {
  constructor(options) {
    options = options ? options : {};
    const baseOptions = Object.assign({}, options);
    delete baseOptions.style;
    delete baseOptions.renderBuffer;
    delete baseOptions.updateWhileAnimating;
    delete baseOptions.updateWhileInteracting;
    super(baseOptions);
    this.declutter_ = options.declutter !== void 0 ? options.declutter : false;
    this.renderBuffer_ = options.renderBuffer !== void 0 ? options.renderBuffer : 100;
    this.style_ = null;
    this.styleFunction_ = void 0;
    this.setStyle(options.style);
    this.updateWhileAnimating_ = options.updateWhileAnimating !== void 0 ? options.updateWhileAnimating : false;
    this.updateWhileInteracting_ = options.updateWhileInteracting !== void 0 ? options.updateWhileInteracting : false;
  }
  getDeclutter() {
    return this.declutter_;
  }
  getFeatures(pixel) {
    return super.getFeatures(pixel);
  }
  getRenderBuffer() {
    return this.renderBuffer_;
  }
  getRenderOrder() {
    return this.get(Property$2.RENDER_ORDER);
  }
  getStyle() {
    return this.style_;
  }
  getStyleFunction() {
    return this.styleFunction_;
  }
  getUpdateWhileAnimating() {
    return this.updateWhileAnimating_;
  }
  getUpdateWhileInteracting() {
    return this.updateWhileInteracting_;
  }
  renderDeclutter(frameState) {
    if (!frameState.declutterTree) {
      frameState.declutterTree = new RBush$1(9);
    }
    this.getRenderer().renderDeclutter(frameState);
  }
  setRenderOrder(renderOrder) {
    this.set(Property$2.RENDER_ORDER, renderOrder);
  }
  setStyle(style2) {
    let styleLike;
    if (style2 === void 0) {
      styleLike = createDefaultStyle;
    } else if (style2 === null) {
      styleLike = null;
    } else if (typeof style2 === "function") {
      styleLike = style2;
    } else if (style2 instanceof Style$1) {
      styleLike = style2;
    } else if (Array.isArray(style2)) {
      const len = style2.length;
      const styles = new Array(len);
      for (let i2 = 0; i2 < len; ++i2) {
        const s2 = style2[i2];
        if (s2 instanceof Style$1) {
          styles[i2] = s2;
        } else {
          styles[i2] = toStyle(s2);
        }
      }
      styleLike = styles;
    } else {
      styleLike = toStyle(style2);
    }
    this.style_ = styleLike;
    this.styleFunction_ = style2 === null ? void 0 : toFunction(this.style_);
    this.changed();
  }
}
const Instruction = {
  BEGIN_GEOMETRY: 0,
  BEGIN_PATH: 1,
  CIRCLE: 2,
  CLOSE_PATH: 3,
  CUSTOM: 4,
  DRAW_CHARS: 5,
  DRAW_IMAGE: 6,
  END_GEOMETRY: 7,
  FILL: 8,
  MOVE_TO_LINE_TO: 9,
  SET_FILL_STYLE: 10,
  SET_STROKE_STYLE: 11,
  STROKE: 12
};
const fillInstruction = [Instruction.FILL];
const strokeInstruction = [Instruction.STROKE];
const beginPathInstruction = [Instruction.BEGIN_PATH];
const closePathInstruction = [Instruction.CLOSE_PATH];
class VectorContext {
  drawCustom(geometry, feature, renderer, hitDetectionRenderer) {
  }
  drawGeometry(geometry) {
  }
  setStyle(style2) {
  }
  drawCircle(circleGeometry, feature) {
  }
  drawFeature(feature, style2) {
  }
  drawGeometryCollection(geometryCollectionGeometry, feature) {
  }
  drawLineString(lineStringGeometry, feature) {
  }
  drawMultiLineString(multiLineStringGeometry, feature) {
  }
  drawMultiPoint(multiPointGeometry, feature) {
  }
  drawMultiPolygon(multiPolygonGeometry, feature) {
  }
  drawPoint(pointGeometry, feature) {
  }
  drawPolygon(polygonGeometry, feature) {
  }
  drawText(geometry, feature) {
  }
  setFillStrokeStyle(fillStyle, strokeStyle) {
  }
  setImageStyle(imageStyle, declutterImageWithText) {
  }
  setTextStyle(textStyle, declutterImageWithText) {
  }
}
class CanvasBuilder extends VectorContext {
  constructor(tolerance, maxExtent, resolution, pixelRatio) {
    super();
    this.tolerance = tolerance;
    this.maxExtent = maxExtent;
    this.pixelRatio = pixelRatio;
    this.maxLineWidth = 0;
    this.resolution = resolution;
    this.beginGeometryInstruction1_ = null;
    this.beginGeometryInstruction2_ = null;
    this.bufferedMaxExtent_ = null;
    this.instructions = [];
    this.coordinates = [];
    this.tmpCoordinate_ = [];
    this.hitDetectionInstructions = [];
    this.state = {};
  }
  applyPixelRatio(dashArray) {
    const pixelRatio = this.pixelRatio;
    return pixelRatio == 1 ? dashArray : dashArray.map(function(dash) {
      return dash * pixelRatio;
    });
  }
  appendFlatPointCoordinates(flatCoordinates, stride) {
    const extent2 = this.getBufferedMaxExtent();
    const tmpCoord = this.tmpCoordinate_;
    const coordinates2 = this.coordinates;
    let myEnd = coordinates2.length;
    for (let i2 = 0, ii = flatCoordinates.length; i2 < ii; i2 += stride) {
      tmpCoord[0] = flatCoordinates[i2];
      tmpCoord[1] = flatCoordinates[i2 + 1];
      if (containsCoordinate(extent2, tmpCoord)) {
        coordinates2[myEnd++] = tmpCoord[0];
        coordinates2[myEnd++] = tmpCoord[1];
      }
    }
    return myEnd;
  }
  appendFlatLineCoordinates(flatCoordinates, offset2, end, stride, closed, skipFirst) {
    const coordinates2 = this.coordinates;
    let myEnd = coordinates2.length;
    const extent2 = this.getBufferedMaxExtent();
    if (skipFirst) {
      offset2 += stride;
    }
    let lastXCoord = flatCoordinates[offset2];
    let lastYCoord = flatCoordinates[offset2 + 1];
    const nextCoord = this.tmpCoordinate_;
    let skipped = true;
    let i2, lastRel, nextRel;
    for (i2 = offset2 + stride; i2 < end; i2 += stride) {
      nextCoord[0] = flatCoordinates[i2];
      nextCoord[1] = flatCoordinates[i2 + 1];
      nextRel = coordinateRelationship(extent2, nextCoord);
      if (nextRel !== lastRel) {
        if (skipped) {
          coordinates2[myEnd++] = lastXCoord;
          coordinates2[myEnd++] = lastYCoord;
          skipped = false;
        }
        coordinates2[myEnd++] = nextCoord[0];
        coordinates2[myEnd++] = nextCoord[1];
      } else if (nextRel === Relationship.INTERSECTING) {
        coordinates2[myEnd++] = nextCoord[0];
        coordinates2[myEnd++] = nextCoord[1];
        skipped = false;
      } else {
        skipped = true;
      }
      lastXCoord = nextCoord[0];
      lastYCoord = nextCoord[1];
      lastRel = nextRel;
    }
    if (closed && skipped || i2 === offset2 + stride) {
      coordinates2[myEnd++] = lastXCoord;
      coordinates2[myEnd++] = lastYCoord;
    }
    return myEnd;
  }
  drawCustomCoordinates_(flatCoordinates, offset2, ends, stride, builderEnds) {
    for (let i2 = 0, ii = ends.length; i2 < ii; ++i2) {
      const end = ends[i2];
      const builderEnd = this.appendFlatLineCoordinates(flatCoordinates, offset2, end, stride, false, false);
      builderEnds.push(builderEnd);
      offset2 = end;
    }
    return offset2;
  }
  drawCustom(geometry, feature, renderer, hitDetectionRenderer) {
    this.beginGeometry(geometry, feature);
    const type = geometry.getType();
    const stride = geometry.getStride();
    const builderBegin = this.coordinates.length;
    let flatCoordinates, builderEnd, builderEnds, builderEndss;
    let offset2;
    switch (type) {
      case "MultiPolygon":
        flatCoordinates = geometry.getOrientedFlatCoordinates();
        builderEndss = [];
        const endss = geometry.getEndss();
        offset2 = 0;
        for (let i2 = 0, ii = endss.length; i2 < ii; ++i2) {
          const myEnds = [];
          offset2 = this.drawCustomCoordinates_(flatCoordinates, offset2, endss[i2], stride, myEnds);
          builderEndss.push(myEnds);
        }
        this.instructions.push([
          Instruction.CUSTOM,
          builderBegin,
          builderEndss,
          geometry,
          renderer,
          inflateMultiCoordinatesArray
        ]);
        this.hitDetectionInstructions.push([
          Instruction.CUSTOM,
          builderBegin,
          builderEndss,
          geometry,
          hitDetectionRenderer || renderer,
          inflateMultiCoordinatesArray
        ]);
        break;
      case "Polygon":
      case "MultiLineString":
        builderEnds = [];
        flatCoordinates = type == "Polygon" ? geometry.getOrientedFlatCoordinates() : geometry.getFlatCoordinates();
        offset2 = this.drawCustomCoordinates_(flatCoordinates, 0, geometry.getEnds(), stride, builderEnds);
        this.instructions.push([
          Instruction.CUSTOM,
          builderBegin,
          builderEnds,
          geometry,
          renderer,
          inflateCoordinatesArray
        ]);
        this.hitDetectionInstructions.push([
          Instruction.CUSTOM,
          builderBegin,
          builderEnds,
          geometry,
          hitDetectionRenderer || renderer,
          inflateCoordinatesArray
        ]);
        break;
      case "LineString":
      case "Circle":
        flatCoordinates = geometry.getFlatCoordinates();
        builderEnd = this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
        this.instructions.push([
          Instruction.CUSTOM,
          builderBegin,
          builderEnd,
          geometry,
          renderer,
          inflateCoordinates
        ]);
        this.hitDetectionInstructions.push([
          Instruction.CUSTOM,
          builderBegin,
          builderEnd,
          geometry,
          hitDetectionRenderer || renderer,
          inflateCoordinates
        ]);
        break;
      case "MultiPoint":
        flatCoordinates = geometry.getFlatCoordinates();
        builderEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
        if (builderEnd > builderBegin) {
          this.instructions.push([
            Instruction.CUSTOM,
            builderBegin,
            builderEnd,
            geometry,
            renderer,
            inflateCoordinates
          ]);
          this.hitDetectionInstructions.push([
            Instruction.CUSTOM,
            builderBegin,
            builderEnd,
            geometry,
            hitDetectionRenderer || renderer,
            inflateCoordinates
          ]);
        }
        break;
      case "Point":
        flatCoordinates = geometry.getFlatCoordinates();
        this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);
        builderEnd = this.coordinates.length;
        this.instructions.push([
          Instruction.CUSTOM,
          builderBegin,
          builderEnd,
          geometry,
          renderer
        ]);
        this.hitDetectionInstructions.push([
          Instruction.CUSTOM,
          builderBegin,
          builderEnd,
          geometry,
          hitDetectionRenderer || renderer
        ]);
        break;
    }
    this.endGeometry(feature);
  }
  beginGeometry(geometry, feature) {
    this.beginGeometryInstruction1_ = [
      Instruction.BEGIN_GEOMETRY,
      feature,
      0,
      geometry
    ];
    this.instructions.push(this.beginGeometryInstruction1_);
    this.beginGeometryInstruction2_ = [
      Instruction.BEGIN_GEOMETRY,
      feature,
      0,
      geometry
    ];
    this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
  }
  finish() {
    return {
      instructions: this.instructions,
      hitDetectionInstructions: this.hitDetectionInstructions,
      coordinates: this.coordinates
    };
  }
  reverseHitDetectionInstructions() {
    const hitDetectionInstructions = this.hitDetectionInstructions;
    hitDetectionInstructions.reverse();
    let i2;
    const n2 = hitDetectionInstructions.length;
    let instruction;
    let type;
    let begin = -1;
    for (i2 = 0; i2 < n2; ++i2) {
      instruction = hitDetectionInstructions[i2];
      type = instruction[0];
      if (type == Instruction.END_GEOMETRY) {
        begin = i2;
      } else if (type == Instruction.BEGIN_GEOMETRY) {
        instruction[2] = i2;
        reverseSubArray(this.hitDetectionInstructions, begin, i2);
        begin = -1;
      }
    }
  }
  setFillStrokeStyle(fillStyle, strokeStyle) {
    const state = this.state;
    if (fillStyle) {
      const fillStyleColor = fillStyle.getColor();
      state.fillStyle = asColorLike(fillStyleColor ? fillStyleColor : defaultFillStyle);
    } else {
      state.fillStyle = void 0;
    }
    if (strokeStyle) {
      const strokeStyleColor = strokeStyle.getColor();
      state.strokeStyle = asColorLike(strokeStyleColor ? strokeStyleColor : defaultStrokeStyle);
      const strokeStyleLineCap = strokeStyle.getLineCap();
      state.lineCap = strokeStyleLineCap !== void 0 ? strokeStyleLineCap : defaultLineCap;
      const strokeStyleLineDash = strokeStyle.getLineDash();
      state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : defaultLineDash;
      const strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
      state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset;
      const strokeStyleLineJoin = strokeStyle.getLineJoin();
      state.lineJoin = strokeStyleLineJoin !== void 0 ? strokeStyleLineJoin : defaultLineJoin;
      const strokeStyleWidth = strokeStyle.getWidth();
      state.lineWidth = strokeStyleWidth !== void 0 ? strokeStyleWidth : defaultLineWidth;
      const strokeStyleMiterLimit = strokeStyle.getMiterLimit();
      state.miterLimit = strokeStyleMiterLimit !== void 0 ? strokeStyleMiterLimit : defaultMiterLimit;
      if (state.lineWidth > this.maxLineWidth) {
        this.maxLineWidth = state.lineWidth;
        this.bufferedMaxExtent_ = null;
      }
    } else {
      state.strokeStyle = void 0;
      state.lineCap = void 0;
      state.lineDash = null;
      state.lineDashOffset = void 0;
      state.lineJoin = void 0;
      state.lineWidth = void 0;
      state.miterLimit = void 0;
    }
  }
  createFill(state) {
    const fillStyle = state.fillStyle;
    const fillInstruction2 = [Instruction.SET_FILL_STYLE, fillStyle];
    if (typeof fillStyle !== "string") {
      fillInstruction2.push(true);
    }
    return fillInstruction2;
  }
  applyStroke(state) {
    this.instructions.push(this.createStroke(state));
  }
  createStroke(state) {
    return [
      Instruction.SET_STROKE_STYLE,
      state.strokeStyle,
      state.lineWidth * this.pixelRatio,
      state.lineCap,
      state.lineJoin,
      state.miterLimit,
      this.applyPixelRatio(state.lineDash),
      state.lineDashOffset * this.pixelRatio
    ];
  }
  updateFillStyle(state, createFill) {
    const fillStyle = state.fillStyle;
    if (typeof fillStyle !== "string" || state.currentFillStyle != fillStyle) {
      if (fillStyle !== void 0) {
        this.instructions.push(createFill.call(this, state));
      }
      state.currentFillStyle = fillStyle;
    }
  }
  updateStrokeStyle(state, applyStroke) {
    const strokeStyle = state.strokeStyle;
    const lineCap = state.lineCap;
    const lineDash = state.lineDash;
    const lineDashOffset = state.lineDashOffset;
    const lineJoin = state.lineJoin;
    const lineWidth = state.lineWidth;
    const miterLimit = state.miterLimit;
    if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !equals$3(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {
      if (strokeStyle !== void 0) {
        applyStroke.call(this, state);
      }
      state.currentStrokeStyle = strokeStyle;
      state.currentLineCap = lineCap;
      state.currentLineDash = lineDash;
      state.currentLineDashOffset = lineDashOffset;
      state.currentLineJoin = lineJoin;
      state.currentLineWidth = lineWidth;
      state.currentMiterLimit = miterLimit;
    }
  }
  endGeometry(feature) {
    this.beginGeometryInstruction1_[2] = this.instructions.length;
    this.beginGeometryInstruction1_ = null;
    this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;
    this.beginGeometryInstruction2_ = null;
    const endGeometryInstruction = [Instruction.END_GEOMETRY, feature];
    this.instructions.push(endGeometryInstruction);
    this.hitDetectionInstructions.push(endGeometryInstruction);
  }
  getBufferedMaxExtent() {
    if (!this.bufferedMaxExtent_) {
      this.bufferedMaxExtent_ = clone$1(this.maxExtent);
      if (this.maxLineWidth > 0) {
        const width = this.resolution * (this.maxLineWidth + 1) / 2;
        buffer$2(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
      }
    }
    return this.bufferedMaxExtent_;
  }
}
class CanvasImageBuilder extends CanvasBuilder {
  constructor(tolerance, maxExtent, resolution, pixelRatio) {
    super(tolerance, maxExtent, resolution, pixelRatio);
    this.hitDetectionImage_ = null;
    this.image_ = null;
    this.imagePixelRatio_ = void 0;
    this.anchorX_ = void 0;
    this.anchorY_ = void 0;
    this.height_ = void 0;
    this.opacity_ = void 0;
    this.originX_ = void 0;
    this.originY_ = void 0;
    this.rotateWithView_ = void 0;
    this.rotation_ = void 0;
    this.scale_ = void 0;
    this.width_ = void 0;
    this.declutterMode_ = void 0;
    this.declutterImageWithText_ = void 0;
  }
  drawPoint(pointGeometry, feature) {
    if (!this.image_) {
      return;
    }
    this.beginGeometry(pointGeometry, feature);
    const flatCoordinates = pointGeometry.getFlatCoordinates();
    const stride = pointGeometry.getStride();
    const myBegin = this.coordinates.length;
    const myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
    this.instructions.push([
      Instruction.DRAW_IMAGE,
      myBegin,
      myEnd,
      this.image_,
      this.anchorX_ * this.imagePixelRatio_,
      this.anchorY_ * this.imagePixelRatio_,
      Math.ceil(this.height_ * this.imagePixelRatio_),
      this.opacity_,
      this.originX_ * this.imagePixelRatio_,
      this.originY_ * this.imagePixelRatio_,
      this.rotateWithView_,
      this.rotation_,
      [
        this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
        this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
      ],
      Math.ceil(this.width_ * this.imagePixelRatio_),
      this.declutterMode_,
      this.declutterImageWithText_
    ]);
    this.hitDetectionInstructions.push([
      Instruction.DRAW_IMAGE,
      myBegin,
      myEnd,
      this.hitDetectionImage_,
      this.anchorX_,
      this.anchorY_,
      this.height_,
      this.opacity_,
      this.originX_,
      this.originY_,
      this.rotateWithView_,
      this.rotation_,
      this.scale_,
      this.width_,
      this.declutterMode_,
      this.declutterImageWithText_
    ]);
    this.endGeometry(feature);
  }
  drawMultiPoint(multiPointGeometry, feature) {
    if (!this.image_) {
      return;
    }
    this.beginGeometry(multiPointGeometry, feature);
    const flatCoordinates = multiPointGeometry.getFlatCoordinates();
    const stride = multiPointGeometry.getStride();
    const myBegin = this.coordinates.length;
    const myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
    this.instructions.push([
      Instruction.DRAW_IMAGE,
      myBegin,
      myEnd,
      this.image_,
      this.anchorX_ * this.imagePixelRatio_,
      this.anchorY_ * this.imagePixelRatio_,
      Math.ceil(this.height_ * this.imagePixelRatio_),
      this.opacity_,
      this.originX_ * this.imagePixelRatio_,
      this.originY_ * this.imagePixelRatio_,
      this.rotateWithView_,
      this.rotation_,
      [
        this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
        this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
      ],
      Math.ceil(this.width_ * this.imagePixelRatio_),
      this.declutterMode_,
      this.declutterImageWithText_
    ]);
    this.hitDetectionInstructions.push([
      Instruction.DRAW_IMAGE,
      myBegin,
      myEnd,
      this.hitDetectionImage_,
      this.anchorX_,
      this.anchorY_,
      this.height_,
      this.opacity_,
      this.originX_,
      this.originY_,
      this.rotateWithView_,
      this.rotation_,
      this.scale_,
      this.width_,
      this.declutterMode_,
      this.declutterImageWithText_
    ]);
    this.endGeometry(feature);
  }
  finish() {
    this.reverseHitDetectionInstructions();
    this.anchorX_ = void 0;
    this.anchorY_ = void 0;
    this.hitDetectionImage_ = null;
    this.image_ = null;
    this.imagePixelRatio_ = void 0;
    this.height_ = void 0;
    this.scale_ = void 0;
    this.opacity_ = void 0;
    this.originX_ = void 0;
    this.originY_ = void 0;
    this.rotateWithView_ = void 0;
    this.rotation_ = void 0;
    this.width_ = void 0;
    return super.finish();
  }
  setImageStyle(imageStyle, sharedData) {
    const anchor = imageStyle.getAnchor();
    const size = imageStyle.getSize();
    const origin = imageStyle.getOrigin();
    this.imagePixelRatio_ = imageStyle.getPixelRatio(this.pixelRatio);
    this.anchorX_ = anchor[0];
    this.anchorY_ = anchor[1];
    this.hitDetectionImage_ = imageStyle.getHitDetectionImage();
    this.image_ = imageStyle.getImage(this.pixelRatio);
    this.height_ = size[1];
    this.opacity_ = imageStyle.getOpacity();
    this.originX_ = origin[0];
    this.originY_ = origin[1];
    this.rotateWithView_ = imageStyle.getRotateWithView();
    this.rotation_ = imageStyle.getRotation();
    this.scale_ = imageStyle.getScaleArray();
    this.width_ = size[0];
    this.declutterMode_ = imageStyle.getDeclutterMode();
    this.declutterImageWithText_ = sharedData;
  }
}
class CanvasLineStringBuilder extends CanvasBuilder {
  constructor(tolerance, maxExtent, resolution, pixelRatio) {
    super(tolerance, maxExtent, resolution, pixelRatio);
  }
  drawFlatCoordinates_(flatCoordinates, offset2, end, stride) {
    const myBegin = this.coordinates.length;
    const myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset2, end, stride, false, false);
    const moveToLineToInstruction = [
      Instruction.MOVE_TO_LINE_TO,
      myBegin,
      myEnd
    ];
    this.instructions.push(moveToLineToInstruction);
    this.hitDetectionInstructions.push(moveToLineToInstruction);
    return end;
  }
  drawLineString(lineStringGeometry, feature) {
    const state = this.state;
    const strokeStyle = state.strokeStyle;
    const lineWidth = state.lineWidth;
    if (strokeStyle === void 0 || lineWidth === void 0) {
      return;
    }
    this.updateStrokeStyle(state, this.applyStroke);
    this.beginGeometry(lineStringGeometry, feature);
    this.hitDetectionInstructions.push([
      Instruction.SET_STROKE_STYLE,
      state.strokeStyle,
      state.lineWidth,
      state.lineCap,
      state.lineJoin,
      state.miterLimit,
      defaultLineDash,
      defaultLineDashOffset
    ], beginPathInstruction);
    const flatCoordinates = lineStringGeometry.getFlatCoordinates();
    const stride = lineStringGeometry.getStride();
    this.drawFlatCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
    this.hitDetectionInstructions.push(strokeInstruction);
    this.endGeometry(feature);
  }
  drawMultiLineString(multiLineStringGeometry, feature) {
    const state = this.state;
    const strokeStyle = state.strokeStyle;
    const lineWidth = state.lineWidth;
    if (strokeStyle === void 0 || lineWidth === void 0) {
      return;
    }
    this.updateStrokeStyle(state, this.applyStroke);
    this.beginGeometry(multiLineStringGeometry, feature);
    this.hitDetectionInstructions.push([
      Instruction.SET_STROKE_STYLE,
      state.strokeStyle,
      state.lineWidth,
      state.lineCap,
      state.lineJoin,
      state.miterLimit,
      state.lineDash,
      state.lineDashOffset
    ], beginPathInstruction);
    const ends = multiLineStringGeometry.getEnds();
    const flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
    const stride = multiLineStringGeometry.getStride();
    let offset2 = 0;
    for (let i2 = 0, ii = ends.length; i2 < ii; ++i2) {
      offset2 = this.drawFlatCoordinates_(flatCoordinates, offset2, ends[i2], stride);
    }
    this.hitDetectionInstructions.push(strokeInstruction);
    this.endGeometry(feature);
  }
  finish() {
    const state = this.state;
    if (state.lastStroke != void 0 && state.lastStroke != this.coordinates.length) {
      this.instructions.push(strokeInstruction);
    }
    this.reverseHitDetectionInstructions();
    this.state = null;
    return super.finish();
  }
  applyStroke(state) {
    if (state.lastStroke != void 0 && state.lastStroke != this.coordinates.length) {
      this.instructions.push(strokeInstruction);
      state.lastStroke = this.coordinates.length;
    }
    state.lastStroke = 0;
    super.applyStroke(state);
    this.instructions.push(beginPathInstruction);
  }
}
class CanvasPolygonBuilder extends CanvasBuilder {
  constructor(tolerance, maxExtent, resolution, pixelRatio) {
    super(tolerance, maxExtent, resolution, pixelRatio);
  }
  drawFlatCoordinatess_(flatCoordinates, offset2, ends, stride) {
    const state = this.state;
    const fill = state.fillStyle !== void 0;
    const stroke = state.strokeStyle !== void 0;
    const numEnds = ends.length;
    this.instructions.push(beginPathInstruction);
    this.hitDetectionInstructions.push(beginPathInstruction);
    for (let i2 = 0; i2 < numEnds; ++i2) {
      const end = ends[i2];
      const myBegin = this.coordinates.length;
      const myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset2, end, stride, true, !stroke);
      const moveToLineToInstruction = [
        Instruction.MOVE_TO_LINE_TO,
        myBegin,
        myEnd
      ];
      this.instructions.push(moveToLineToInstruction);
      this.hitDetectionInstructions.push(moveToLineToInstruction);
      if (stroke) {
        this.instructions.push(closePathInstruction);
        this.hitDetectionInstructions.push(closePathInstruction);
      }
      offset2 = end;
    }
    if (fill) {
      this.instructions.push(fillInstruction);
      this.hitDetectionInstructions.push(fillInstruction);
    }
    if (stroke) {
      this.instructions.push(strokeInstruction);
      this.hitDetectionInstructions.push(strokeInstruction);
    }
    return offset2;
  }
  drawCircle(circleGeometry, feature) {
    const state = this.state;
    const fillStyle = state.fillStyle;
    const strokeStyle = state.strokeStyle;
    if (fillStyle === void 0 && strokeStyle === void 0) {
      return;
    }
    this.setFillStrokeStyles_();
    this.beginGeometry(circleGeometry, feature);
    if (state.fillStyle !== void 0) {
      this.hitDetectionInstructions.push([
        Instruction.SET_FILL_STYLE,
        defaultFillStyle
      ]);
    }
    if (state.strokeStyle !== void 0) {
      this.hitDetectionInstructions.push([
        Instruction.SET_STROKE_STYLE,
        state.strokeStyle,
        state.lineWidth,
        state.lineCap,
        state.lineJoin,
        state.miterLimit,
        state.lineDash,
        state.lineDashOffset
      ]);
    }
    const flatCoordinates = circleGeometry.getFlatCoordinates();
    const stride = circleGeometry.getStride();
    const myBegin = this.coordinates.length;
    this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
    const circleInstruction = [Instruction.CIRCLE, myBegin];
    this.instructions.push(beginPathInstruction, circleInstruction);
    this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);
    if (state.fillStyle !== void 0) {
      this.instructions.push(fillInstruction);
      this.hitDetectionInstructions.push(fillInstruction);
    }
    if (state.strokeStyle !== void 0) {
      this.instructions.push(strokeInstruction);
      this.hitDetectionInstructions.push(strokeInstruction);
    }
    this.endGeometry(feature);
  }
  drawPolygon(polygonGeometry, feature) {
    const state = this.state;
    const fillStyle = state.fillStyle;
    const strokeStyle = state.strokeStyle;
    if (fillStyle === void 0 && strokeStyle === void 0) {
      return;
    }
    this.setFillStrokeStyles_();
    this.beginGeometry(polygonGeometry, feature);
    if (state.fillStyle !== void 0) {
      this.hitDetectionInstructions.push([
        Instruction.SET_FILL_STYLE,
        defaultFillStyle
      ]);
    }
    if (state.strokeStyle !== void 0) {
      this.hitDetectionInstructions.push([
        Instruction.SET_STROKE_STYLE,
        state.strokeStyle,
        state.lineWidth,
        state.lineCap,
        state.lineJoin,
        state.miterLimit,
        state.lineDash,
        state.lineDashOffset
      ]);
    }
    const ends = polygonGeometry.getEnds();
    const flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();
    const stride = polygonGeometry.getStride();
    this.drawFlatCoordinatess_(flatCoordinates, 0, ends, stride);
    this.endGeometry(feature);
  }
  drawMultiPolygon(multiPolygonGeometry, feature) {
    const state = this.state;
    const fillStyle = state.fillStyle;
    const strokeStyle = state.strokeStyle;
    if (fillStyle === void 0 && strokeStyle === void 0) {
      return;
    }
    this.setFillStrokeStyles_();
    this.beginGeometry(multiPolygonGeometry, feature);
    if (state.fillStyle !== void 0) {
      this.hitDetectionInstructions.push([
        Instruction.SET_FILL_STYLE,
        defaultFillStyle
      ]);
    }
    if (state.strokeStyle !== void 0) {
      this.hitDetectionInstructions.push([
        Instruction.SET_STROKE_STYLE,
        state.strokeStyle,
        state.lineWidth,
        state.lineCap,
        state.lineJoin,
        state.miterLimit,
        state.lineDash,
        state.lineDashOffset
      ]);
    }
    const endss = multiPolygonGeometry.getEndss();
    const flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();
    const stride = multiPolygonGeometry.getStride();
    let offset2 = 0;
    for (let i2 = 0, ii = endss.length; i2 < ii; ++i2) {
      offset2 = this.drawFlatCoordinatess_(flatCoordinates, offset2, endss[i2], stride);
    }
    this.endGeometry(feature);
  }
  finish() {
    this.reverseHitDetectionInstructions();
    this.state = null;
    const tolerance = this.tolerance;
    if (tolerance !== 0) {
      const coordinates2 = this.coordinates;
      for (let i2 = 0, ii = coordinates2.length; i2 < ii; ++i2) {
        coordinates2[i2] = snap(coordinates2[i2], tolerance);
      }
    }
    return super.finish();
  }
  setFillStrokeStyles_() {
    const state = this.state;
    const fillStyle = state.fillStyle;
    if (fillStyle !== void 0) {
      this.updateFillStyle(state, this.createFill);
    }
    if (state.strokeStyle !== void 0) {
      this.updateStrokeStyle(state, this.applyStroke);
    }
  }
}
function matchingChunk(maxAngle, flatCoordinates, offset2, end, stride) {
  let chunkStart = offset2;
  let chunkEnd = offset2;
  let chunkM = 0;
  let m2 = 0;
  let start2 = offset2;
  let acos, i2, m12, m23, x1, y1, x12, y12, x23, y23;
  for (i2 = offset2; i2 < end; i2 += stride) {
    const x2 = flatCoordinates[i2];
    const y2 = flatCoordinates[i2 + 1];
    if (x1 !== void 0) {
      x23 = x2 - x1;
      y23 = y2 - y1;
      m23 = Math.sqrt(x23 * x23 + y23 * y23);
      if (x12 !== void 0) {
        m2 += m12;
        acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));
        if (acos > maxAngle) {
          if (m2 > chunkM) {
            chunkM = m2;
            chunkStart = start2;
            chunkEnd = i2;
          }
          m2 = 0;
          start2 = i2 - stride;
        }
      }
      m12 = m23;
      x12 = x23;
      y12 = y23;
    }
    x1 = x2;
    y1 = y2;
  }
  m2 += m23;
  return m2 > chunkM ? [start2, i2] : [chunkStart, chunkEnd];
}
const TEXT_ALIGN = {
  "left": 0,
  "end": 0,
  "center": 0.5,
  "right": 1,
  "start": 1,
  "top": 0,
  "middle": 0.5,
  "hanging": 0.2,
  "alphabetic": 0.8,
  "ideographic": 0.8,
  "bottom": 1
};
class CanvasTextBuilder extends CanvasBuilder {
  constructor(tolerance, maxExtent, resolution, pixelRatio) {
    super(tolerance, maxExtent, resolution, pixelRatio);
    this.labels_ = null;
    this.text_ = "";
    this.textOffsetX_ = 0;
    this.textOffsetY_ = 0;
    this.textRotateWithView_ = void 0;
    this.textRotation_ = 0;
    this.textFillState_ = null;
    this.fillStates = {};
    this.textStrokeState_ = null;
    this.strokeStates = {};
    this.textState_ = {};
    this.textStates = {};
    this.textKey_ = "";
    this.fillKey_ = "";
    this.strokeKey_ = "";
    this.declutterImageWithText_ = void 0;
  }
  finish() {
    const instructions = super.finish();
    instructions.textStates = this.textStates;
    instructions.fillStates = this.fillStates;
    instructions.strokeStates = this.strokeStates;
    return instructions;
  }
  drawText(geometry, feature) {
    const fillState = this.textFillState_;
    const strokeState = this.textStrokeState_;
    const textState = this.textState_;
    if (this.text_ === "" || !textState || !fillState && !strokeState) {
      return;
    }
    const coordinates2 = this.coordinates;
    let begin = coordinates2.length;
    const geometryType = geometry.getType();
    let flatCoordinates = null;
    let stride = geometry.getStride();
    if (textState.placement === "line" && (geometryType == "LineString" || geometryType == "MultiLineString" || geometryType == "Polygon" || geometryType == "MultiPolygon")) {
      if (!intersects$2(this.getBufferedMaxExtent(), geometry.getExtent())) {
        return;
      }
      let ends;
      flatCoordinates = geometry.getFlatCoordinates();
      if (geometryType == "LineString") {
        ends = [flatCoordinates.length];
      } else if (geometryType == "MultiLineString") {
        ends = geometry.getEnds();
      } else if (geometryType == "Polygon") {
        ends = geometry.getEnds().slice(0, 1);
      } else if (geometryType == "MultiPolygon") {
        const endss = geometry.getEndss();
        ends = [];
        for (let i2 = 0, ii = endss.length; i2 < ii; ++i2) {
          ends.push(endss[i2][0]);
        }
      }
      this.beginGeometry(geometry, feature);
      const textAlign2 = textState.textAlign;
      let flatOffset = 0;
      let flatEnd;
      for (let o2 = 0, oo = ends.length; o2 < oo; ++o2) {
        if (textAlign2 == void 0) {
          const range = matchingChunk(textState.maxAngle, flatCoordinates, flatOffset, ends[o2], stride);
          flatOffset = range[0];
          flatEnd = range[1];
        } else {
          flatEnd = ends[o2];
        }
        for (let i2 = flatOffset; i2 < flatEnd; i2 += stride) {
          coordinates2.push(flatCoordinates[i2], flatCoordinates[i2 + 1]);
        }
        const end = coordinates2.length;
        flatOffset = ends[o2];
        this.drawChars_(begin, end);
        begin = end;
      }
      this.endGeometry(feature);
    } else {
      let geometryWidths = textState.overflow ? null : [];
      switch (geometryType) {
        case "Point":
        case "MultiPoint":
          flatCoordinates = geometry.getFlatCoordinates();
          break;
        case "LineString":
          flatCoordinates = geometry.getFlatMidpoint();
          break;
        case "Circle":
          flatCoordinates = geometry.getCenter();
          break;
        case "MultiLineString":
          flatCoordinates = geometry.getFlatMidpoints();
          stride = 2;
          break;
        case "Polygon":
          flatCoordinates = geometry.getFlatInteriorPoint();
          if (!textState.overflow) {
            geometryWidths.push(flatCoordinates[2] / this.resolution);
          }
          stride = 3;
          break;
        case "MultiPolygon":
          const interiorPoints = geometry.getFlatInteriorPoints();
          flatCoordinates = [];
          for (let i2 = 0, ii = interiorPoints.length; i2 < ii; i2 += 3) {
            if (!textState.overflow) {
              geometryWidths.push(interiorPoints[i2 + 2] / this.resolution);
            }
            flatCoordinates.push(interiorPoints[i2], interiorPoints[i2 + 1]);
          }
          if (flatCoordinates.length === 0) {
            return;
          }
          stride = 2;
          break;
      }
      const end = this.appendFlatPointCoordinates(flatCoordinates, stride);
      if (end === begin) {
        return;
      }
      if (geometryWidths && (end - begin) / 2 !== flatCoordinates.length / stride) {
        let beg = begin / 2;
        geometryWidths = geometryWidths.filter((w2, i2) => {
          const keep = coordinates2[(beg + i2) * 2] === flatCoordinates[i2 * stride] && coordinates2[(beg + i2) * 2 + 1] === flatCoordinates[i2 * stride + 1];
          if (!keep) {
            --beg;
          }
          return keep;
        });
      }
      this.saveTextStates_();
      if (textState.backgroundFill || textState.backgroundStroke) {
        this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);
        if (textState.backgroundFill) {
          this.updateFillStyle(this.state, this.createFill);
          this.hitDetectionInstructions.push(this.createFill(this.state));
        }
        if (textState.backgroundStroke) {
          this.updateStrokeStyle(this.state, this.applyStroke);
          this.hitDetectionInstructions.push(this.createStroke(this.state));
        }
      }
      this.beginGeometry(geometry, feature);
      let padding = textState.padding;
      if (padding != defaultPadding && (textState.scale[0] < 0 || textState.scale[1] < 0)) {
        let p0 = textState.padding[0];
        let p12 = textState.padding[1];
        let p22 = textState.padding[2];
        let p32 = textState.padding[3];
        if (textState.scale[0] < 0) {
          p12 = -p12;
          p32 = -p32;
        }
        if (textState.scale[1] < 0) {
          p0 = -p0;
          p22 = -p22;
        }
        padding = [p0, p12, p22, p32];
      }
      const pixelRatio = this.pixelRatio;
      this.instructions.push([
        Instruction.DRAW_IMAGE,
        begin,
        end,
        null,
        NaN,
        NaN,
        NaN,
        1,
        0,
        0,
        this.textRotateWithView_,
        this.textRotation_,
        [1, 1],
        NaN,
        void 0,
        this.declutterImageWithText_,
        padding == defaultPadding ? defaultPadding : padding.map(function(p5) {
          return p5 * pixelRatio;
        }),
        !!textState.backgroundFill,
        !!textState.backgroundStroke,
        this.text_,
        this.textKey_,
        this.strokeKey_,
        this.fillKey_,
        this.textOffsetX_,
        this.textOffsetY_,
        geometryWidths
      ]);
      const scale2 = 1 / pixelRatio;
      this.hitDetectionInstructions.push([
        Instruction.DRAW_IMAGE,
        begin,
        end,
        null,
        NaN,
        NaN,
        NaN,
        1,
        0,
        0,
        this.textRotateWithView_,
        this.textRotation_,
        [scale2, scale2],
        NaN,
        void 0,
        this.declutterImageWithText_,
        padding,
        !!textState.backgroundFill,
        !!textState.backgroundStroke,
        this.text_,
        this.textKey_,
        this.strokeKey_,
        this.fillKey_,
        this.textOffsetX_,
        this.textOffsetY_,
        geometryWidths
      ]);
      this.endGeometry(feature);
    }
  }
  saveTextStates_() {
    const strokeState = this.textStrokeState_;
    const textState = this.textState_;
    const fillState = this.textFillState_;
    const strokeKey = this.strokeKey_;
    if (strokeState) {
      if (!(strokeKey in this.strokeStates)) {
        this.strokeStates[strokeKey] = {
          strokeStyle: strokeState.strokeStyle,
          lineCap: strokeState.lineCap,
          lineDashOffset: strokeState.lineDashOffset,
          lineWidth: strokeState.lineWidth,
          lineJoin: strokeState.lineJoin,
          miterLimit: strokeState.miterLimit,
          lineDash: strokeState.lineDash
        };
      }
    }
    const textKey = this.textKey_;
    if (!(textKey in this.textStates)) {
      this.textStates[textKey] = {
        font: textState.font,
        textAlign: textState.textAlign || defaultTextAlign,
        justify: textState.justify,
        textBaseline: textState.textBaseline || defaultTextBaseline,
        scale: textState.scale
      };
    }
    const fillKey = this.fillKey_;
    if (fillState) {
      if (!(fillKey in this.fillStates)) {
        this.fillStates[fillKey] = {
          fillStyle: fillState.fillStyle
        };
      }
    }
  }
  drawChars_(begin, end) {
    const strokeState = this.textStrokeState_;
    const textState = this.textState_;
    const strokeKey = this.strokeKey_;
    const textKey = this.textKey_;
    const fillKey = this.fillKey_;
    this.saveTextStates_();
    const pixelRatio = this.pixelRatio;
    const baseline = TEXT_ALIGN[textState.textBaseline];
    const offsetY = this.textOffsetY_ * pixelRatio;
    const text2 = this.text_;
    const strokeWidth = strokeState ? strokeState.lineWidth * Math.abs(textState.scale[0]) / 2 : 0;
    this.instructions.push([
      Instruction.DRAW_CHARS,
      begin,
      end,
      baseline,
      textState.overflow,
      fillKey,
      textState.maxAngle,
      pixelRatio,
      offsetY,
      strokeKey,
      strokeWidth * pixelRatio,
      text2,
      textKey,
      1
    ]);
    this.hitDetectionInstructions.push([
      Instruction.DRAW_CHARS,
      begin,
      end,
      baseline,
      textState.overflow,
      fillKey,
      textState.maxAngle,
      1,
      offsetY,
      strokeKey,
      strokeWidth,
      text2,
      textKey,
      1 / pixelRatio
    ]);
  }
  setTextStyle(textStyle, sharedData) {
    let textState, fillState, strokeState;
    if (!textStyle) {
      this.text_ = "";
    } else {
      const textFillStyle = textStyle.getFill();
      if (!textFillStyle) {
        fillState = null;
        this.textFillState_ = fillState;
      } else {
        fillState = this.textFillState_;
        if (!fillState) {
          fillState = {};
          this.textFillState_ = fillState;
        }
        fillState.fillStyle = asColorLike(textFillStyle.getColor() || defaultFillStyle);
      }
      const textStrokeStyle = textStyle.getStroke();
      if (!textStrokeStyle) {
        strokeState = null;
        this.textStrokeState_ = strokeState;
      } else {
        strokeState = this.textStrokeState_;
        if (!strokeState) {
          strokeState = {};
          this.textStrokeState_ = strokeState;
        }
        const lineDash = textStrokeStyle.getLineDash();
        const lineDashOffset = textStrokeStyle.getLineDashOffset();
        const lineWidth = textStrokeStyle.getWidth();
        const miterLimit = textStrokeStyle.getMiterLimit();
        strokeState.lineCap = textStrokeStyle.getLineCap() || defaultLineCap;
        strokeState.lineDash = lineDash ? lineDash.slice() : defaultLineDash;
        strokeState.lineDashOffset = lineDashOffset === void 0 ? defaultLineDashOffset : lineDashOffset;
        strokeState.lineJoin = textStrokeStyle.getLineJoin() || defaultLineJoin;
        strokeState.lineWidth = lineWidth === void 0 ? defaultLineWidth : lineWidth;
        strokeState.miterLimit = miterLimit === void 0 ? defaultMiterLimit : miterLimit;
        strokeState.strokeStyle = asColorLike(textStrokeStyle.getColor() || defaultStrokeStyle);
      }
      textState = this.textState_;
      const font = textStyle.getFont() || defaultFont;
      registerFont(font);
      const textScale = textStyle.getScaleArray();
      textState.overflow = textStyle.getOverflow();
      textState.font = font;
      textState.maxAngle = textStyle.getMaxAngle();
      textState.placement = textStyle.getPlacement();
      textState.textAlign = textStyle.getTextAlign();
      textState.justify = textStyle.getJustify();
      textState.textBaseline = textStyle.getTextBaseline() || defaultTextBaseline;
      textState.backgroundFill = textStyle.getBackgroundFill();
      textState.backgroundStroke = textStyle.getBackgroundStroke();
      textState.padding = textStyle.getPadding() || defaultPadding;
      textState.scale = textScale === void 0 ? [1, 1] : textScale;
      const textOffsetX = textStyle.getOffsetX();
      const textOffsetY = textStyle.getOffsetY();
      const textRotateWithView = textStyle.getRotateWithView();
      const textRotation = textStyle.getRotation();
      this.text_ = textStyle.getText() || "";
      this.textOffsetX_ = textOffsetX === void 0 ? 0 : textOffsetX;
      this.textOffsetY_ = textOffsetY === void 0 ? 0 : textOffsetY;
      this.textRotateWithView_ = textRotateWithView === void 0 ? false : textRotateWithView;
      this.textRotation_ = textRotation === void 0 ? 0 : textRotation;
      this.strokeKey_ = strokeState ? (typeof strokeState.strokeStyle == "string" ? strokeState.strokeStyle : getUid(strokeState.strokeStyle)) + strokeState.lineCap + strokeState.lineDashOffset + "|" + strokeState.lineWidth + strokeState.lineJoin + strokeState.miterLimit + "[" + strokeState.lineDash.join() + "]" : "";
      this.textKey_ = textState.font + textState.scale + (textState.textAlign || "?") + (textState.justify || "?") + (textState.textBaseline || "?");
      this.fillKey_ = fillState ? typeof fillState.fillStyle == "string" ? fillState.fillStyle : "|" + getUid(fillState.fillStyle) : "";
    }
    this.declutterImageWithText_ = sharedData;
  }
}
const BATCH_CONSTRUCTORS = {
  "Circle": CanvasPolygonBuilder,
  "Default": CanvasBuilder,
  "Image": CanvasImageBuilder,
  "LineString": CanvasLineStringBuilder,
  "Polygon": CanvasPolygonBuilder,
  "Text": CanvasTextBuilder
};
class BuilderGroup {
  constructor(tolerance, maxExtent, resolution, pixelRatio) {
    this.tolerance_ = tolerance;
    this.maxExtent_ = maxExtent;
    this.pixelRatio_ = pixelRatio;
    this.resolution_ = resolution;
    this.buildersByZIndex_ = {};
  }
  finish() {
    const builderInstructions = {};
    for (const zKey in this.buildersByZIndex_) {
      builderInstructions[zKey] = builderInstructions[zKey] || {};
      const builders = this.buildersByZIndex_[zKey];
      for (const builderKey in builders) {
        const builderInstruction = builders[builderKey].finish();
        builderInstructions[zKey][builderKey] = builderInstruction;
      }
    }
    return builderInstructions;
  }
  getBuilder(zIndex2, builderType) {
    const zIndexKey = zIndex2 !== void 0 ? zIndex2.toString() : "0";
    let replays = this.buildersByZIndex_[zIndexKey];
    if (replays === void 0) {
      replays = {};
      this.buildersByZIndex_[zIndexKey] = replays;
    }
    let replay = replays[builderType];
    if (replay === void 0) {
      const Constructor = BATCH_CONSTRUCTORS[builderType];
      replay = new Constructor(this.tolerance_, this.maxExtent_, this.resolution_, this.pixelRatio_);
      replays[builderType] = replay;
    }
    return replay;
  }
}
function drawTextOnPath(flatCoordinates, offset2, end, stride, text2, startM, maxAngle, scale2, measureAndCacheTextWidth2, font, cache2, rotation) {
  let x2 = flatCoordinates[offset2];
  let y2 = flatCoordinates[offset2 + 1];
  let x1 = 0;
  let y1 = 0;
  let segmentLength = 0;
  let segmentM = 0;
  function advance() {
    x1 = x2;
    y1 = y2;
    offset2 += stride;
    x2 = flatCoordinates[offset2];
    y2 = flatCoordinates[offset2 + 1];
    segmentM += segmentLength;
    segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
  }
  do {
    advance();
  } while (offset2 < end - stride && segmentM + segmentLength < startM);
  let interpolate = segmentLength === 0 ? 0 : (startM - segmentM) / segmentLength;
  const beginX = lerp$2(x1, x2, interpolate);
  const beginY = lerp$2(y1, y2, interpolate);
  const startOffset = offset2 - stride;
  const startLength = segmentM;
  const endM = startM + scale2 * measureAndCacheTextWidth2(font, text2, cache2);
  while (offset2 < end - stride && segmentM + segmentLength < endM) {
    advance();
  }
  interpolate = segmentLength === 0 ? 0 : (endM - segmentM) / segmentLength;
  const endX = lerp$2(x1, x2, interpolate);
  const endY = lerp$2(y1, y2, interpolate);
  let reverse2;
  if (rotation) {
    const flat = [beginX, beginY, endX, endY];
    rotate(flat, 0, 4, 2, rotation, flat, flat);
    reverse2 = flat[0] > flat[2];
  } else {
    reverse2 = beginX > endX;
  }
  const PI = Math.PI;
  const result = [];
  const singleSegment = startOffset + stride === offset2;
  offset2 = startOffset;
  segmentLength = 0;
  segmentM = startLength;
  x2 = flatCoordinates[offset2];
  y2 = flatCoordinates[offset2 + 1];
  let previousAngle;
  if (singleSegment) {
    advance();
    previousAngle = Math.atan2(y2 - y1, x2 - x1);
    if (reverse2) {
      previousAngle += previousAngle > 0 ? -PI : PI;
    }
    const x3 = (endX + beginX) / 2;
    const y3 = (endY + beginY) / 2;
    result[0] = [x3, y3, (endM - startM) / 2, previousAngle, text2];
    return result;
  }
  text2 = text2.replace(/\n/g, " ");
  for (let i2 = 0, ii = text2.length; i2 < ii; ) {
    advance();
    let angle2 = Math.atan2(y2 - y1, x2 - x1);
    if (reverse2) {
      angle2 += angle2 > 0 ? -PI : PI;
    }
    if (previousAngle !== void 0) {
      let delta = angle2 - previousAngle;
      delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;
      if (Math.abs(delta) > maxAngle) {
        return null;
      }
    }
    previousAngle = angle2;
    const iStart = i2;
    let charLength = 0;
    for (; i2 < ii; ++i2) {
      const index2 = reverse2 ? ii - i2 - 1 : i2;
      const len = scale2 * measureAndCacheTextWidth2(font, text2[index2], cache2);
      if (offset2 + stride < end && segmentM + segmentLength < startM + charLength + len / 2) {
        break;
      }
      charLength += len;
    }
    if (i2 === iStart) {
      continue;
    }
    const chars2 = reverse2 ? text2.substring(ii - iStart, ii - i2) : text2.substring(iStart, i2);
    interpolate = segmentLength === 0 ? 0 : (startM + charLength / 2 - segmentM) / segmentLength;
    const x3 = lerp$2(x1, x2, interpolate);
    const y3 = lerp$2(y1, y2, interpolate);
    result.push([x3, y3, charLength / 2, angle2, chars2]);
    startM += charLength;
  }
  return result;
}
function lineStringLength(flatCoordinates, offset2, end, stride) {
  let x1 = flatCoordinates[offset2];
  let y1 = flatCoordinates[offset2 + 1];
  let length = 0;
  for (let i2 = offset2 + stride; i2 < end; i2 += stride) {
    const x2 = flatCoordinates[i2];
    const y2 = flatCoordinates[i2 + 1];
    length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    x1 = x2;
    y1 = y2;
  }
  return length;
}
const tmpExtent = createEmpty();
const p1 = [];
const p2 = [];
const p3 = [];
const p4 = [];
function getDeclutterBox(replayImageOrLabelArgs) {
  return replayImageOrLabelArgs[3].declutterBox;
}
const rtlRegEx = new RegExp("[" + String.fromCharCode(1425) + "-" + String.fromCharCode(2303) + String.fromCharCode(64285) + "-" + String.fromCharCode(65023) + String.fromCharCode(65136) + "-" + String.fromCharCode(65276) + String.fromCharCode(67584) + "-" + String.fromCharCode(69631) + String.fromCharCode(124928) + "-" + String.fromCharCode(126975) + "]");
function horizontalTextAlign(text2, align) {
  if ((align === "start" || align === "end") && !rtlRegEx.test(text2)) {
    align = align === "start" ? "left" : "right";
  }
  return TEXT_ALIGN[align];
}
function createTextChunks(acc, line, i2) {
  if (i2 > 0) {
    acc.push("\n", "");
  }
  acc.push(line, "");
  return acc;
}
class Executor {
  constructor(resolution, pixelRatio, overlaps, instructions) {
    this.overlaps = overlaps;
    this.pixelRatio = pixelRatio;
    this.resolution = resolution;
    this.alignFill_;
    this.instructions = instructions.instructions;
    this.coordinates = instructions.coordinates;
    this.coordinateCache_ = {};
    this.renderedTransform_ = create$7();
    this.hitDetectionInstructions = instructions.hitDetectionInstructions;
    this.pixelCoordinates_ = null;
    this.viewRotation_ = 0;
    this.fillStates = instructions.fillStates || {};
    this.strokeStates = instructions.strokeStates || {};
    this.textStates = instructions.textStates || {};
    this.widths_ = {};
    this.labels_ = {};
  }
  createLabel(text2, textKey, fillKey, strokeKey) {
    const key = text2 + textKey + fillKey + strokeKey;
    if (this.labels_[key]) {
      return this.labels_[key];
    }
    const strokeState = strokeKey ? this.strokeStates[strokeKey] : null;
    const fillState = fillKey ? this.fillStates[fillKey] : null;
    const textState = this.textStates[textKey];
    const pixelRatio = this.pixelRatio;
    const scale2 = [
      textState.scale[0] * pixelRatio,
      textState.scale[1] * pixelRatio
    ];
    const textIsArray = Array.isArray(text2);
    const align = textState.justify ? TEXT_ALIGN[textState.justify] : horizontalTextAlign(Array.isArray(text2) ? text2[0] : text2, textState.textAlign || defaultTextAlign);
    const strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;
    const chunks = textIsArray ? text2 : text2.split("\n").reduce(createTextChunks, []);
    const { width, height, widths, heights, lineWidths } = getTextDimensions(textState, chunks);
    const renderWidth = width + strokeWidth;
    const contextInstructions = [];
    const w2 = (renderWidth + 2) * scale2[0];
    const h2 = (height + strokeWidth) * scale2[1];
    const label = {
      width: w2 < 0 ? Math.floor(w2) : Math.ceil(w2),
      height: h2 < 0 ? Math.floor(h2) : Math.ceil(h2),
      contextInstructions
    };
    if (scale2[0] != 1 || scale2[1] != 1) {
      contextInstructions.push("scale", scale2);
    }
    if (strokeKey) {
      contextInstructions.push("strokeStyle", strokeState.strokeStyle);
      contextInstructions.push("lineWidth", strokeWidth);
      contextInstructions.push("lineCap", strokeState.lineCap);
      contextInstructions.push("lineJoin", strokeState.lineJoin);
      contextInstructions.push("miterLimit", strokeState.miterLimit);
      contextInstructions.push("setLineDash", [strokeState.lineDash]);
      contextInstructions.push("lineDashOffset", strokeState.lineDashOffset);
    }
    if (fillKey) {
      contextInstructions.push("fillStyle", fillState.fillStyle);
    }
    contextInstructions.push("textBaseline", "middle");
    contextInstructions.push("textAlign", "center");
    const leftRight = 0.5 - align;
    let x2 = align * renderWidth + leftRight * strokeWidth;
    const strokeInstructions = [];
    const fillInstructions = [];
    let lineHeight2 = 0;
    let lineOffset = 0;
    let widthHeightIndex = 0;
    let lineWidthIndex = 0;
    let previousFont;
    for (let i2 = 0, ii = chunks.length; i2 < ii; i2 += 2) {
      const text3 = chunks[i2];
      if (text3 === "\n") {
        lineOffset += lineHeight2;
        lineHeight2 = 0;
        x2 = align * renderWidth + leftRight * strokeWidth;
        ++lineWidthIndex;
        continue;
      }
      const font = chunks[i2 + 1] || textState.font;
      if (font !== previousFont) {
        if (strokeKey) {
          strokeInstructions.push("font", font);
        }
        if (fillKey) {
          fillInstructions.push("font", font);
        }
        previousFont = font;
      }
      lineHeight2 = Math.max(lineHeight2, heights[widthHeightIndex]);
      const fillStrokeArgs = [
        text3,
        x2 + leftRight * widths[widthHeightIndex] + align * (widths[widthHeightIndex] - lineWidths[lineWidthIndex]),
        0.5 * (strokeWidth + lineHeight2) + lineOffset
      ];
      x2 += widths[widthHeightIndex];
      if (strokeKey) {
        strokeInstructions.push("strokeText", fillStrokeArgs);
      }
      if (fillKey) {
        fillInstructions.push("fillText", fillStrokeArgs);
      }
      ++widthHeightIndex;
    }
    Array.prototype.push.apply(contextInstructions, strokeInstructions);
    Array.prototype.push.apply(contextInstructions, fillInstructions);
    this.labels_[key] = label;
    return label;
  }
  replayTextBackground_(context2, p12, p22, p32, p42, fillInstruction2, strokeInstruction2) {
    context2.beginPath();
    context2.moveTo.apply(context2, p12);
    context2.lineTo.apply(context2, p22);
    context2.lineTo.apply(context2, p32);
    context2.lineTo.apply(context2, p42);
    context2.lineTo.apply(context2, p12);
    if (fillInstruction2) {
      this.alignFill_ = fillInstruction2[2];
      this.fill_(context2);
    }
    if (strokeInstruction2) {
      this.setStrokeStyle_(context2, strokeInstruction2);
      context2.stroke();
    }
  }
  calculateImageOrLabelDimensions_(sheetWidth, sheetHeight, centerX, centerY, width, height, anchorX, anchorY, originX, originY, rotation, scale2, snapToPixel, padding, fillStroke, feature) {
    anchorX *= scale2[0];
    anchorY *= scale2[1];
    let x2 = centerX - anchorX;
    let y2 = centerY - anchorY;
    const w2 = width + originX > sheetWidth ? sheetWidth - originX : width;
    const h2 = height + originY > sheetHeight ? sheetHeight - originY : height;
    const boxW = padding[3] + w2 * scale2[0] + padding[1];
    const boxH = padding[0] + h2 * scale2[1] + padding[2];
    const boxX = x2 - padding[3];
    const boxY = y2 - padding[0];
    if (fillStroke || rotation !== 0) {
      p1[0] = boxX;
      p4[0] = boxX;
      p1[1] = boxY;
      p2[1] = boxY;
      p2[0] = boxX + boxW;
      p3[0] = p2[0];
      p3[1] = boxY + boxH;
      p4[1] = p3[1];
    }
    let transform2;
    if (rotation !== 0) {
      transform2 = compose(create$7(), centerX, centerY, 1, 1, rotation, -centerX, -centerY);
      apply$5(transform2, p1);
      apply$5(transform2, p2);
      apply$5(transform2, p3);
      apply$5(transform2, p4);
      createOrUpdate$2(Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1]), tmpExtent);
    } else {
      createOrUpdate$2(Math.min(boxX, boxX + boxW), Math.min(boxY, boxY + boxH), Math.max(boxX, boxX + boxW), Math.max(boxY, boxY + boxH), tmpExtent);
    }
    if (snapToPixel) {
      x2 = Math.round(x2);
      y2 = Math.round(y2);
    }
    return {
      drawImageX: x2,
      drawImageY: y2,
      drawImageW: w2,
      drawImageH: h2,
      originX,
      originY,
      declutterBox: {
        minX: tmpExtent[0],
        minY: tmpExtent[1],
        maxX: tmpExtent[2],
        maxY: tmpExtent[3],
        value: feature
      },
      canvasTransform: transform2,
      scale: scale2
    };
  }
  replayImageOrLabel_(context2, contextScale, imageOrLabel, dimensions, opacity2, fillInstruction2, strokeInstruction2) {
    const fillStroke = !!(fillInstruction2 || strokeInstruction2);
    const box = dimensions.declutterBox;
    const canvas = context2.canvas;
    const strokePadding = strokeInstruction2 ? strokeInstruction2[2] * dimensions.scale[0] / 2 : 0;
    const intersects2 = box.minX - strokePadding <= canvas.width / contextScale && box.maxX + strokePadding >= 0 && box.minY - strokePadding <= canvas.height / contextScale && box.maxY + strokePadding >= 0;
    if (intersects2) {
      if (fillStroke) {
        this.replayTextBackground_(context2, p1, p2, p3, p4, fillInstruction2, strokeInstruction2);
      }
      drawImageOrLabel(context2, dimensions.canvasTransform, opacity2, imageOrLabel, dimensions.originX, dimensions.originY, dimensions.drawImageW, dimensions.drawImageH, dimensions.drawImageX, dimensions.drawImageY, dimensions.scale);
    }
    return true;
  }
  fill_(context2) {
    if (this.alignFill_) {
      const origin = apply$5(this.renderedTransform_, [0, 0]);
      const repeatSize = 512 * this.pixelRatio;
      context2.save();
      context2.translate(origin[0] % repeatSize, origin[1] % repeatSize);
      context2.rotate(this.viewRotation_);
    }
    context2.fill();
    if (this.alignFill_) {
      context2.restore();
    }
  }
  setStrokeStyle_(context2, instruction) {
    context2["strokeStyle"] = instruction[1];
    context2.lineWidth = instruction[2];
    context2.lineCap = instruction[3];
    context2.lineJoin = instruction[4];
    context2.miterLimit = instruction[5];
    context2.lineDashOffset = instruction[7];
    context2.setLineDash(instruction[6]);
  }
  drawLabelWithPointPlacement_(text2, textKey, strokeKey, fillKey) {
    const textState = this.textStates[textKey];
    const label = this.createLabel(text2, textKey, fillKey, strokeKey);
    const strokeState = this.strokeStates[strokeKey];
    const pixelRatio = this.pixelRatio;
    const align = horizontalTextAlign(Array.isArray(text2) ? text2[0] : text2, textState.textAlign || defaultTextAlign);
    const baseline = TEXT_ALIGN[textState.textBaseline || defaultTextBaseline];
    const strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;
    const width = label.width / pixelRatio - 2 * textState.scale[0];
    const anchorX = align * width + 2 * (0.5 - align) * strokeWidth;
    const anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;
    return {
      label,
      anchorX,
      anchorY
    };
  }
  execute_(context2, contextScale, transform2, instructions, snapToPixel, featureCallback, hitExtent, declutterTree) {
    let pixelCoordinates;
    if (this.pixelCoordinates_ && equals$3(transform2, this.renderedTransform_)) {
      pixelCoordinates = this.pixelCoordinates_;
    } else {
      if (!this.pixelCoordinates_) {
        this.pixelCoordinates_ = [];
      }
      pixelCoordinates = transform2D(this.coordinates, 0, this.coordinates.length, 2, transform2, this.pixelCoordinates_);
      setFromArray(this.renderedTransform_, transform2);
    }
    let i2 = 0;
    const ii = instructions.length;
    let d2 = 0;
    let dd;
    let anchorX, anchorY, prevX, prevY, roundX, roundY, image2, text2, textKey, strokeKey, fillKey;
    let pendingFill = 0;
    let pendingStroke = 0;
    let lastFillInstruction = null;
    let lastStrokeInstruction = null;
    const coordinateCache = this.coordinateCache_;
    const viewRotation = this.viewRotation_;
    const viewRotationFromTransform = Math.round(Math.atan2(-transform2[1], transform2[0]) * 1e12) / 1e12;
    const state = {
      context: context2,
      pixelRatio: this.pixelRatio,
      resolution: this.resolution,
      rotation: viewRotation
    };
    const batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;
    let feature;
    let x2, y2, currentGeometry;
    while (i2 < ii) {
      const instruction = instructions[i2];
      const type = instruction[0];
      switch (type) {
        case Instruction.BEGIN_GEOMETRY:
          feature = instruction[1];
          currentGeometry = instruction[3];
          if (!feature.getGeometry()) {
            i2 = instruction[2];
          } else if (hitExtent !== void 0 && !intersects$2(hitExtent, currentGeometry.getExtent())) {
            i2 = instruction[2] + 1;
          } else {
            ++i2;
          }
          break;
        case Instruction.BEGIN_PATH:
          if (pendingFill > batchSize) {
            this.fill_(context2);
            pendingFill = 0;
          }
          if (pendingStroke > batchSize) {
            context2.stroke();
            pendingStroke = 0;
          }
          if (!pendingFill && !pendingStroke) {
            context2.beginPath();
            prevX = NaN;
            prevY = NaN;
          }
          ++i2;
          break;
        case Instruction.CIRCLE:
          d2 = instruction[1];
          const x1 = pixelCoordinates[d2];
          const y1 = pixelCoordinates[d2 + 1];
          const x22 = pixelCoordinates[d2 + 2];
          const y22 = pixelCoordinates[d2 + 3];
          const dx = x22 - x1;
          const dy = y22 - y1;
          const r2 = Math.sqrt(dx * dx + dy * dy);
          context2.moveTo(x1 + r2, y1);
          context2.arc(x1, y1, r2, 0, 2 * Math.PI, true);
          ++i2;
          break;
        case Instruction.CLOSE_PATH:
          context2.closePath();
          ++i2;
          break;
        case Instruction.CUSTOM:
          d2 = instruction[1];
          dd = instruction[2];
          const geometry = instruction[3];
          const renderer = instruction[4];
          const fn = instruction.length == 6 ? instruction[5] : void 0;
          state.geometry = geometry;
          state.feature = feature;
          if (!(i2 in coordinateCache)) {
            coordinateCache[i2] = [];
          }
          const coords = coordinateCache[i2];
          if (fn) {
            fn(pixelCoordinates, d2, dd, 2, coords);
          } else {
            coords[0] = pixelCoordinates[d2];
            coords[1] = pixelCoordinates[d2 + 1];
            coords.length = 2;
          }
          renderer(coords, state);
          ++i2;
          break;
        case Instruction.DRAW_IMAGE:
          d2 = instruction[1];
          dd = instruction[2];
          image2 = instruction[3];
          anchorX = instruction[4];
          anchorY = instruction[5];
          let height = instruction[6];
          const opacity2 = instruction[7];
          const originX = instruction[8];
          const originY = instruction[9];
          const rotateWithView = instruction[10];
          let rotation = instruction[11];
          const scale2 = instruction[12];
          let width = instruction[13];
          const declutterMode = instruction[14];
          const declutterImageWithText = instruction[15];
          if (!image2 && instruction.length >= 20) {
            text2 = instruction[19];
            textKey = instruction[20];
            strokeKey = instruction[21];
            fillKey = instruction[22];
            const labelWithAnchor = this.drawLabelWithPointPlacement_(text2, textKey, strokeKey, fillKey);
            image2 = labelWithAnchor.label;
            instruction[3] = image2;
            const textOffsetX = instruction[23];
            anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;
            instruction[4] = anchorX;
            const textOffsetY = instruction[24];
            anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;
            instruction[5] = anchorY;
            height = image2.height;
            instruction[6] = height;
            width = image2.width;
            instruction[13] = width;
          }
          let geometryWidths;
          if (instruction.length > 25) {
            geometryWidths = instruction[25];
          }
          let padding, backgroundFill, backgroundStroke;
          if (instruction.length > 17) {
            padding = instruction[16];
            backgroundFill = instruction[17];
            backgroundStroke = instruction[18];
          } else {
            padding = defaultPadding;
            backgroundFill = false;
            backgroundStroke = false;
          }
          if (rotateWithView && viewRotationFromTransform) {
            rotation += viewRotation;
          } else if (!rotateWithView && !viewRotationFromTransform) {
            rotation -= viewRotation;
          }
          let widthIndex = 0;
          for (; d2 < dd; d2 += 2) {
            if (geometryWidths && geometryWidths[widthIndex++] < width / this.pixelRatio) {
              continue;
            }
            const dimensions = this.calculateImageOrLabelDimensions_(image2.width, image2.height, pixelCoordinates[d2], pixelCoordinates[d2 + 1], width, height, anchorX, anchorY, originX, originY, rotation, scale2, snapToPixel, padding, backgroundFill || backgroundStroke, feature);
            const args = [
              context2,
              contextScale,
              image2,
              dimensions,
              opacity2,
              backgroundFill ? lastFillInstruction : null,
              backgroundStroke ? lastStrokeInstruction : null
            ];
            if (declutterTree) {
              if (declutterMode === "none") {
                continue;
              } else if (declutterMode === "obstacle") {
                declutterTree.insert(dimensions.declutterBox);
                continue;
              } else {
                let imageArgs;
                let imageDeclutterBox;
                if (declutterImageWithText) {
                  const index2 = dd - d2;
                  if (!declutterImageWithText[index2]) {
                    declutterImageWithText[index2] = args;
                    continue;
                  }
                  imageArgs = declutterImageWithText[index2];
                  delete declutterImageWithText[index2];
                  imageDeclutterBox = getDeclutterBox(imageArgs);
                  if (declutterTree.collides(imageDeclutterBox)) {
                    continue;
                  }
                }
                if (declutterTree.collides(dimensions.declutterBox)) {
                  continue;
                }
                if (imageArgs) {
                  declutterTree.insert(imageDeclutterBox);
                  this.replayImageOrLabel_.apply(this, imageArgs);
                }
                declutterTree.insert(dimensions.declutterBox);
              }
            }
            this.replayImageOrLabel_.apply(this, args);
          }
          ++i2;
          break;
        case Instruction.DRAW_CHARS:
          const begin = instruction[1];
          const end = instruction[2];
          const baseline = instruction[3];
          const overflow2 = instruction[4];
          fillKey = instruction[5];
          const maxAngle = instruction[6];
          const measurePixelRatio = instruction[7];
          const offsetY = instruction[8];
          strokeKey = instruction[9];
          const strokeWidth = instruction[10];
          text2 = instruction[11];
          textKey = instruction[12];
          const pixelRatioScale = [
            instruction[13],
            instruction[13]
          ];
          const textState = this.textStates[textKey];
          const font = textState.font;
          const textScale = [
            textState.scale[0] * measurePixelRatio,
            textState.scale[1] * measurePixelRatio
          ];
          let cachedWidths;
          if (font in this.widths_) {
            cachedWidths = this.widths_[font];
          } else {
            cachedWidths = {};
            this.widths_[font] = cachedWidths;
          }
          const pathLength = lineStringLength(pixelCoordinates, begin, end, 2);
          const textLength = Math.abs(textScale[0]) * measureAndCacheTextWidth(font, text2, cachedWidths);
          if (overflow2 || textLength <= pathLength) {
            const textAlign2 = this.textStates[textKey].textAlign;
            const startM = (pathLength - textLength) * TEXT_ALIGN[textAlign2];
            const parts = drawTextOnPath(pixelCoordinates, begin, end, 2, text2, startM, maxAngle, Math.abs(textScale[0]), measureAndCacheTextWidth, font, cachedWidths, viewRotationFromTransform ? 0 : this.viewRotation_);
            drawChars:
              if (parts) {
                const replayImageOrLabelArgs = [];
                let c2, cc, chars2, label, part;
                if (strokeKey) {
                  for (c2 = 0, cc = parts.length; c2 < cc; ++c2) {
                    part = parts[c2];
                    chars2 = part[4];
                    label = this.createLabel(chars2, textKey, "", strokeKey);
                    anchorX = part[2] + (textScale[0] < 0 ? -strokeWidth : strokeWidth);
                    anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth * textScale[1] / textScale[0] - offsetY;
                    const dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, defaultPadding, false, feature);
                    if (declutterTree && declutterTree.collides(dimensions.declutterBox)) {
                      break drawChars;
                    }
                    replayImageOrLabelArgs.push([
                      context2,
                      contextScale,
                      label,
                      dimensions,
                      1,
                      null,
                      null
                    ]);
                  }
                }
                if (fillKey) {
                  for (c2 = 0, cc = parts.length; c2 < cc; ++c2) {
                    part = parts[c2];
                    chars2 = part[4];
                    label = this.createLabel(chars2, textKey, fillKey, "");
                    anchorX = part[2];
                    anchorY = baseline * label.height - offsetY;
                    const dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, defaultPadding, false, feature);
                    if (declutterTree && declutterTree.collides(dimensions.declutterBox)) {
                      break drawChars;
                    }
                    replayImageOrLabelArgs.push([
                      context2,
                      contextScale,
                      label,
                      dimensions,
                      1,
                      null,
                      null
                    ]);
                  }
                }
                if (declutterTree) {
                  declutterTree.load(replayImageOrLabelArgs.map(getDeclutterBox));
                }
                for (let i3 = 0, ii2 = replayImageOrLabelArgs.length; i3 < ii2; ++i3) {
                  this.replayImageOrLabel_.apply(this, replayImageOrLabelArgs[i3]);
                }
              }
          }
          ++i2;
          break;
        case Instruction.END_GEOMETRY:
          if (featureCallback !== void 0) {
            feature = instruction[1];
            const result = featureCallback(feature, currentGeometry);
            if (result) {
              return result;
            }
          }
          ++i2;
          break;
        case Instruction.FILL:
          if (batchSize) {
            pendingFill++;
          } else {
            this.fill_(context2);
          }
          ++i2;
          break;
        case Instruction.MOVE_TO_LINE_TO:
          d2 = instruction[1];
          dd = instruction[2];
          x2 = pixelCoordinates[d2];
          y2 = pixelCoordinates[d2 + 1];
          roundX = x2 + 0.5 | 0;
          roundY = y2 + 0.5 | 0;
          if (roundX !== prevX || roundY !== prevY) {
            context2.moveTo(x2, y2);
            prevX = roundX;
            prevY = roundY;
          }
          for (d2 += 2; d2 < dd; d2 += 2) {
            x2 = pixelCoordinates[d2];
            y2 = pixelCoordinates[d2 + 1];
            roundX = x2 + 0.5 | 0;
            roundY = y2 + 0.5 | 0;
            if (d2 == dd - 2 || roundX !== prevX || roundY !== prevY) {
              context2.lineTo(x2, y2);
              prevX = roundX;
              prevY = roundY;
            }
          }
          ++i2;
          break;
        case Instruction.SET_FILL_STYLE:
          lastFillInstruction = instruction;
          this.alignFill_ = instruction[2];
          if (pendingFill) {
            this.fill_(context2);
            pendingFill = 0;
            if (pendingStroke) {
              context2.stroke();
              pendingStroke = 0;
            }
          }
          context2.fillStyle = instruction[1];
          ++i2;
          break;
        case Instruction.SET_STROKE_STYLE:
          lastStrokeInstruction = instruction;
          if (pendingStroke) {
            context2.stroke();
            pendingStroke = 0;
          }
          this.setStrokeStyle_(context2, instruction);
          ++i2;
          break;
        case Instruction.STROKE:
          if (batchSize) {
            pendingStroke++;
          } else {
            context2.stroke();
          }
          ++i2;
          break;
        default:
          ++i2;
          break;
      }
    }
    if (pendingFill) {
      this.fill_(context2);
    }
    if (pendingStroke) {
      context2.stroke();
    }
    return void 0;
  }
  execute(context2, contextScale, transform2, viewRotation, snapToPixel, declutterTree) {
    this.viewRotation_ = viewRotation;
    this.execute_(context2, contextScale, transform2, this.instructions, snapToPixel, void 0, void 0, declutterTree);
  }
  executeHitDetection(context2, transform2, viewRotation, featureCallback, hitExtent) {
    this.viewRotation_ = viewRotation;
    return this.execute_(context2, 1, transform2, this.hitDetectionInstructions, true, featureCallback, hitExtent);
  }
}
const ORDER = ["Polygon", "Circle", "LineString", "Image", "Text", "Default"];
class ExecutorGroup {
  constructor(maxExtent, resolution, pixelRatio, overlaps, allInstructions, renderBuffer) {
    this.maxExtent_ = maxExtent;
    this.overlaps_ = overlaps;
    this.pixelRatio_ = pixelRatio;
    this.resolution_ = resolution;
    this.renderBuffer_ = renderBuffer;
    this.executorsByZIndex_ = {};
    this.hitDetectionContext_ = null;
    this.hitDetectionTransform_ = create$7();
    this.createExecutors_(allInstructions);
  }
  clip(context2, transform2) {
    const flatClipCoords = this.getClipCoords(transform2);
    context2.beginPath();
    context2.moveTo(flatClipCoords[0], flatClipCoords[1]);
    context2.lineTo(flatClipCoords[2], flatClipCoords[3]);
    context2.lineTo(flatClipCoords[4], flatClipCoords[5]);
    context2.lineTo(flatClipCoords[6], flatClipCoords[7]);
    context2.clip();
  }
  createExecutors_(allInstructions) {
    for (const zIndex2 in allInstructions) {
      let executors = this.executorsByZIndex_[zIndex2];
      if (executors === void 0) {
        executors = {};
        this.executorsByZIndex_[zIndex2] = executors;
      }
      const instructionByZindex = allInstructions[zIndex2];
      for (const builderType in instructionByZindex) {
        const instructions = instructionByZindex[builderType];
        executors[builderType] = new Executor(this.resolution_, this.pixelRatio_, this.overlaps_, instructions);
      }
    }
  }
  hasExecutors(executors) {
    for (const zIndex2 in this.executorsByZIndex_) {
      const candidates = this.executorsByZIndex_[zIndex2];
      for (let i2 = 0, ii = executors.length; i2 < ii; ++i2) {
        if (executors[i2] in candidates) {
          return true;
        }
      }
    }
    return false;
  }
  forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, callback, declutteredFeatures) {
    hitTolerance = Math.round(hitTolerance);
    const contextSize = hitTolerance * 2 + 1;
    const transform2 = compose(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);
    const newContext = !this.hitDetectionContext_;
    if (newContext) {
      this.hitDetectionContext_ = createCanvasContext2D(contextSize, contextSize);
    }
    const context2 = this.hitDetectionContext_;
    if (context2.canvas.width !== contextSize || context2.canvas.height !== contextSize) {
      context2.canvas.width = contextSize;
      context2.canvas.height = contextSize;
    } else if (!newContext) {
      context2.clearRect(0, 0, contextSize, contextSize);
    }
    let hitExtent;
    if (this.renderBuffer_ !== void 0) {
      hitExtent = createEmpty();
      extendCoordinate(hitExtent, coordinate);
      buffer$2(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);
    }
    const indexes = getPixelIndexArray(hitTolerance);
    let builderType;
    function featureCallback(feature, geometry) {
      const imageData = context2.getImageData(0, 0, contextSize, contextSize).data;
      for (let i3 = 0, ii = indexes.length; i3 < ii; i3++) {
        if (imageData[indexes[i3]] > 0) {
          if (!declutteredFeatures || builderType !== "Image" && builderType !== "Text" || declutteredFeatures.includes(feature)) {
            const idx = (indexes[i3] - 3) / 4;
            const x2 = hitTolerance - idx % contextSize;
            const y2 = hitTolerance - (idx / contextSize | 0);
            const result2 = callback(feature, geometry, x2 * x2 + y2 * y2);
            if (result2) {
              return result2;
            }
          }
          context2.clearRect(0, 0, contextSize, contextSize);
          break;
        }
      }
      return void 0;
    }
    const zs = Object.keys(this.executorsByZIndex_).map(Number);
    zs.sort(numberSafeCompareFunction);
    let i2, j2, executors, executor, result;
    for (i2 = zs.length - 1; i2 >= 0; --i2) {
      const zIndexKey = zs[i2].toString();
      executors = this.executorsByZIndex_[zIndexKey];
      for (j2 = ORDER.length - 1; j2 >= 0; --j2) {
        builderType = ORDER[j2];
        executor = executors[builderType];
        if (executor !== void 0) {
          result = executor.executeHitDetection(context2, transform2, rotation, featureCallback, hitExtent);
          if (result) {
            return result;
          }
        }
      }
    }
    return void 0;
  }
  getClipCoords(transform2) {
    const maxExtent = this.maxExtent_;
    if (!maxExtent) {
      return null;
    }
    const minX = maxExtent[0];
    const minY = maxExtent[1];
    const maxX = maxExtent[2];
    const maxY = maxExtent[3];
    const flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];
    transform2D(flatClipCoords, 0, 8, 2, transform2, flatClipCoords);
    return flatClipCoords;
  }
  isEmpty() {
    return isEmpty$1(this.executorsByZIndex_);
  }
  execute(context2, contextScale, transform2, viewRotation, snapToPixel, builderTypes, declutterTree) {
    const zs = Object.keys(this.executorsByZIndex_).map(Number);
    zs.sort(numberSafeCompareFunction);
    if (this.maxExtent_) {
      context2.save();
      this.clip(context2, transform2);
    }
    builderTypes = builderTypes ? builderTypes : ORDER;
    let i2, ii, j2, jj, replays, replay;
    if (declutterTree) {
      zs.reverse();
    }
    for (i2 = 0, ii = zs.length; i2 < ii; ++i2) {
      const zIndexKey = zs[i2].toString();
      replays = this.executorsByZIndex_[zIndexKey];
      for (j2 = 0, jj = builderTypes.length; j2 < jj; ++j2) {
        const builderType = builderTypes[j2];
        replay = replays[builderType];
        if (replay !== void 0) {
          replay.execute(context2, contextScale, transform2, viewRotation, snapToPixel, declutterTree);
        }
      }
    }
    if (this.maxExtent_) {
      context2.restore();
    }
  }
}
const circlePixelIndexArrayCache = {};
function getPixelIndexArray(radius) {
  if (circlePixelIndexArrayCache[radius] !== void 0) {
    return circlePixelIndexArrayCache[radius];
  }
  const size = radius * 2 + 1;
  const maxDistanceSq = radius * radius;
  const distances = new Array(maxDistanceSq + 1);
  for (let i2 = 0; i2 <= radius; ++i2) {
    for (let j2 = 0; j2 <= radius; ++j2) {
      const distanceSq = i2 * i2 + j2 * j2;
      if (distanceSq > maxDistanceSq) {
        break;
      }
      let distance2 = distances[distanceSq];
      if (!distance2) {
        distance2 = [];
        distances[distanceSq] = distance2;
      }
      distance2.push(((radius + i2) * size + (radius + j2)) * 4 + 3);
      if (i2 > 0) {
        distance2.push(((radius - i2) * size + (radius + j2)) * 4 + 3);
      }
      if (j2 > 0) {
        distance2.push(((radius + i2) * size + (radius - j2)) * 4 + 3);
        if (i2 > 0) {
          distance2.push(((radius - i2) * size + (radius - j2)) * 4 + 3);
        }
      }
    }
  }
  const pixelIndex = [];
  for (let i2 = 0, ii = distances.length; i2 < ii; ++i2) {
    if (distances[i2]) {
      pixelIndex.push(...distances[i2]);
    }
  }
  circlePixelIndexArrayCache[radius] = pixelIndex;
  return pixelIndex;
}
class CanvasImmediateRenderer extends VectorContext {
  constructor(context2, pixelRatio, extent2, transform2, viewRotation, squaredTolerance, userTransform) {
    super();
    this.context_ = context2;
    this.pixelRatio_ = pixelRatio;
    this.extent_ = extent2;
    this.transform_ = transform2;
    this.viewRotation_ = viewRotation;
    this.squaredTolerance_ = squaredTolerance;
    this.userTransform_ = userTransform;
    this.contextFillState_ = null;
    this.contextStrokeState_ = null;
    this.contextTextState_ = null;
    this.fillState_ = null;
    this.strokeState_ = null;
    this.image_ = null;
    this.imageAnchorX_ = 0;
    this.imageAnchorY_ = 0;
    this.imageHeight_ = 0;
    this.imageOpacity_ = 0;
    this.imageOriginX_ = 0;
    this.imageOriginY_ = 0;
    this.imageRotateWithView_ = false;
    this.imageRotation_ = 0;
    this.imageScale_ = [0, 0];
    this.imageWidth_ = 0;
    this.text_ = "";
    this.textOffsetX_ = 0;
    this.textOffsetY_ = 0;
    this.textRotateWithView_ = false;
    this.textRotation_ = 0;
    this.textScale_ = [0, 0];
    this.textFillState_ = null;
    this.textStrokeState_ = null;
    this.textState_ = null;
    this.pixelCoordinates_ = [];
    this.tmpLocalTransform_ = create$7();
  }
  drawImages_(flatCoordinates, offset2, end, stride) {
    if (!this.image_) {
      return;
    }
    const pixelCoordinates = transform2D(flatCoordinates, offset2, end, stride, this.transform_, this.pixelCoordinates_);
    const context2 = this.context_;
    const localTransform = this.tmpLocalTransform_;
    const alpha = context2.globalAlpha;
    if (this.imageOpacity_ != 1) {
      context2.globalAlpha = alpha * this.imageOpacity_;
    }
    let rotation = this.imageRotation_;
    if (this.imageRotateWithView_) {
      rotation += this.viewRotation_;
    }
    for (let i2 = 0, ii = pixelCoordinates.length; i2 < ii; i2 += 2) {
      const x2 = pixelCoordinates[i2] - this.imageAnchorX_;
      const y2 = pixelCoordinates[i2 + 1] - this.imageAnchorY_;
      if (rotation !== 0 || this.imageScale_[0] != 1 || this.imageScale_[1] != 1) {
        const centerX = x2 + this.imageAnchorX_;
        const centerY = y2 + this.imageAnchorY_;
        compose(localTransform, centerX, centerY, 1, 1, rotation, -centerX, -centerY);
        context2.setTransform.apply(context2, localTransform);
        context2.translate(centerX, centerY);
        context2.scale(this.imageScale_[0], this.imageScale_[1]);
        context2.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, -this.imageAnchorX_, -this.imageAnchorY_, this.imageWidth_, this.imageHeight_);
        context2.setTransform(1, 0, 0, 1, 0, 0);
      } else {
        context2.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, x2, y2, this.imageWidth_, this.imageHeight_);
      }
    }
    if (this.imageOpacity_ != 1) {
      context2.globalAlpha = alpha;
    }
  }
  drawText_(flatCoordinates, offset2, end, stride) {
    if (!this.textState_ || this.text_ === "") {
      return;
    }
    if (this.textFillState_) {
      this.setContextFillState_(this.textFillState_);
    }
    if (this.textStrokeState_) {
      this.setContextStrokeState_(this.textStrokeState_);
    }
    this.setContextTextState_(this.textState_);
    const pixelCoordinates = transform2D(flatCoordinates, offset2, end, stride, this.transform_, this.pixelCoordinates_);
    const context2 = this.context_;
    let rotation = this.textRotation_;
    if (this.textRotateWithView_) {
      rotation += this.viewRotation_;
    }
    for (; offset2 < end; offset2 += stride) {
      const x2 = pixelCoordinates[offset2] + this.textOffsetX_;
      const y2 = pixelCoordinates[offset2 + 1] + this.textOffsetY_;
      if (rotation !== 0 || this.textScale_[0] != 1 || this.textScale_[1] != 1) {
        context2.translate(x2 - this.textOffsetX_, y2 - this.textOffsetY_);
        context2.rotate(rotation);
        context2.translate(this.textOffsetX_, this.textOffsetY_);
        context2.scale(this.textScale_[0], this.textScale_[1]);
        if (this.textStrokeState_) {
          context2.strokeText(this.text_, 0, 0);
        }
        if (this.textFillState_) {
          context2.fillText(this.text_, 0, 0);
        }
        context2.setTransform(1, 0, 0, 1, 0, 0);
      } else {
        if (this.textStrokeState_) {
          context2.strokeText(this.text_, x2, y2);
        }
        if (this.textFillState_) {
          context2.fillText(this.text_, x2, y2);
        }
      }
    }
  }
  moveToLineTo_(flatCoordinates, offset2, end, stride, close) {
    const context2 = this.context_;
    const pixelCoordinates = transform2D(flatCoordinates, offset2, end, stride, this.transform_, this.pixelCoordinates_);
    context2.moveTo(pixelCoordinates[0], pixelCoordinates[1]);
    let length = pixelCoordinates.length;
    if (close) {
      length -= 2;
    }
    for (let i2 = 2; i2 < length; i2 += 2) {
      context2.lineTo(pixelCoordinates[i2], pixelCoordinates[i2 + 1]);
    }
    if (close) {
      context2.closePath();
    }
    return end;
  }
  drawRings_(flatCoordinates, offset2, ends, stride) {
    for (let i2 = 0, ii = ends.length; i2 < ii; ++i2) {
      offset2 = this.moveToLineTo_(flatCoordinates, offset2, ends[i2], stride, true);
    }
    return offset2;
  }
  drawCircle(geometry) {
    if (!intersects$2(this.extent_, geometry.getExtent())) {
      return;
    }
    if (this.fillState_ || this.strokeState_) {
      if (this.fillState_) {
        this.setContextFillState_(this.fillState_);
      }
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
      }
      const pixelCoordinates = transformGeom2D(geometry, this.transform_, this.pixelCoordinates_);
      const dx = pixelCoordinates[2] - pixelCoordinates[0];
      const dy = pixelCoordinates[3] - pixelCoordinates[1];
      const radius = Math.sqrt(dx * dx + dy * dy);
      const context2 = this.context_;
      context2.beginPath();
      context2.arc(pixelCoordinates[0], pixelCoordinates[1], radius, 0, 2 * Math.PI);
      if (this.fillState_) {
        context2.fill();
      }
      if (this.strokeState_) {
        context2.stroke();
      }
    }
    if (this.text_ !== "") {
      this.drawText_(geometry.getCenter(), 0, 2, 2);
    }
  }
  setStyle(style2) {
    this.setFillStrokeStyle(style2.getFill(), style2.getStroke());
    this.setImageStyle(style2.getImage());
    this.setTextStyle(style2.getText());
  }
  setTransform(transform2) {
    this.transform_ = transform2;
  }
  drawGeometry(geometry) {
    const type = geometry.getType();
    switch (type) {
      case "Point":
        this.drawPoint(geometry);
        break;
      case "LineString":
        this.drawLineString(geometry);
        break;
      case "Polygon":
        this.drawPolygon(geometry);
        break;
      case "MultiPoint":
        this.drawMultiPoint(geometry);
        break;
      case "MultiLineString":
        this.drawMultiLineString(geometry);
        break;
      case "MultiPolygon":
        this.drawMultiPolygon(geometry);
        break;
      case "GeometryCollection":
        this.drawGeometryCollection(geometry);
        break;
      case "Circle":
        this.drawCircle(geometry);
        break;
    }
  }
  drawFeature(feature, style2) {
    const geometry = style2.getGeometryFunction()(feature);
    if (!geometry || !intersects$2(this.extent_, geometry.getExtent())) {
      return;
    }
    this.setStyle(style2);
    this.drawGeometry(geometry);
  }
  drawGeometryCollection(geometry) {
    const geometries = geometry.getGeometriesArray();
    for (let i2 = 0, ii = geometries.length; i2 < ii; ++i2) {
      this.drawGeometry(geometries[i2]);
    }
  }
  drawPoint(geometry) {
    if (this.squaredTolerance_) {
      geometry = geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
    }
    const flatCoordinates = geometry.getFlatCoordinates();
    const stride = geometry.getStride();
    if (this.image_) {
      this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
    if (this.text_ !== "") {
      this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
  }
  drawMultiPoint(geometry) {
    if (this.squaredTolerance_) {
      geometry = geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
    }
    const flatCoordinates = geometry.getFlatCoordinates();
    const stride = geometry.getStride();
    if (this.image_) {
      this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
    if (this.text_ !== "") {
      this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
  }
  drawLineString(geometry) {
    if (this.squaredTolerance_) {
      geometry = geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
    }
    if (!intersects$2(this.extent_, geometry.getExtent())) {
      return;
    }
    if (this.strokeState_) {
      this.setContextStrokeState_(this.strokeState_);
      const context2 = this.context_;
      const flatCoordinates = geometry.getFlatCoordinates();
      context2.beginPath();
      this.moveToLineTo_(flatCoordinates, 0, flatCoordinates.length, geometry.getStride(), false);
      context2.stroke();
    }
    if (this.text_ !== "") {
      const flatMidpoint = geometry.getFlatMidpoint();
      this.drawText_(flatMidpoint, 0, 2, 2);
    }
  }
  drawMultiLineString(geometry) {
    if (this.squaredTolerance_) {
      geometry = geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
    }
    const geometryExtent = geometry.getExtent();
    if (!intersects$2(this.extent_, geometryExtent)) {
      return;
    }
    if (this.strokeState_) {
      this.setContextStrokeState_(this.strokeState_);
      const context2 = this.context_;
      const flatCoordinates = geometry.getFlatCoordinates();
      let offset2 = 0;
      const ends = geometry.getEnds();
      const stride = geometry.getStride();
      context2.beginPath();
      for (let i2 = 0, ii = ends.length; i2 < ii; ++i2) {
        offset2 = this.moveToLineTo_(flatCoordinates, offset2, ends[i2], stride, false);
      }
      context2.stroke();
    }
    if (this.text_ !== "") {
      const flatMidpoints = geometry.getFlatMidpoints();
      this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);
    }
  }
  drawPolygon(geometry) {
    if (this.squaredTolerance_) {
      geometry = geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
    }
    if (!intersects$2(this.extent_, geometry.getExtent())) {
      return;
    }
    if (this.strokeState_ || this.fillState_) {
      if (this.fillState_) {
        this.setContextFillState_(this.fillState_);
      }
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
      }
      const context2 = this.context_;
      context2.beginPath();
      this.drawRings_(geometry.getOrientedFlatCoordinates(), 0, geometry.getEnds(), geometry.getStride());
      if (this.fillState_) {
        context2.fill();
      }
      if (this.strokeState_) {
        context2.stroke();
      }
    }
    if (this.text_ !== "") {
      const flatInteriorPoint = geometry.getFlatInteriorPoint();
      this.drawText_(flatInteriorPoint, 0, 2, 2);
    }
  }
  drawMultiPolygon(geometry) {
    if (this.squaredTolerance_) {
      geometry = geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
    }
    if (!intersects$2(this.extent_, geometry.getExtent())) {
      return;
    }
    if (this.strokeState_ || this.fillState_) {
      if (this.fillState_) {
        this.setContextFillState_(this.fillState_);
      }
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
      }
      const context2 = this.context_;
      const flatCoordinates = geometry.getOrientedFlatCoordinates();
      let offset2 = 0;
      const endss = geometry.getEndss();
      const stride = geometry.getStride();
      context2.beginPath();
      for (let i2 = 0, ii = endss.length; i2 < ii; ++i2) {
        const ends = endss[i2];
        offset2 = this.drawRings_(flatCoordinates, offset2, ends, stride);
      }
      if (this.fillState_) {
        context2.fill();
      }
      if (this.strokeState_) {
        context2.stroke();
      }
    }
    if (this.text_ !== "") {
      const flatInteriorPoints = geometry.getFlatInteriorPoints();
      this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);
    }
  }
  setContextFillState_(fillState) {
    const context2 = this.context_;
    const contextFillState = this.contextFillState_;
    if (!contextFillState) {
      context2.fillStyle = fillState.fillStyle;
      this.contextFillState_ = {
        fillStyle: fillState.fillStyle
      };
    } else {
      if (contextFillState.fillStyle != fillState.fillStyle) {
        contextFillState.fillStyle = fillState.fillStyle;
        context2.fillStyle = fillState.fillStyle;
      }
    }
  }
  setContextStrokeState_(strokeState) {
    const context2 = this.context_;
    const contextStrokeState = this.contextStrokeState_;
    if (!contextStrokeState) {
      context2.lineCap = strokeState.lineCap;
      context2.setLineDash(strokeState.lineDash);
      context2.lineDashOffset = strokeState.lineDashOffset;
      context2.lineJoin = strokeState.lineJoin;
      context2.lineWidth = strokeState.lineWidth;
      context2.miterLimit = strokeState.miterLimit;
      context2.strokeStyle = strokeState.strokeStyle;
      this.contextStrokeState_ = {
        lineCap: strokeState.lineCap,
        lineDash: strokeState.lineDash,
        lineDashOffset: strokeState.lineDashOffset,
        lineJoin: strokeState.lineJoin,
        lineWidth: strokeState.lineWidth,
        miterLimit: strokeState.miterLimit,
        strokeStyle: strokeState.strokeStyle
      };
    } else {
      if (contextStrokeState.lineCap != strokeState.lineCap) {
        contextStrokeState.lineCap = strokeState.lineCap;
        context2.lineCap = strokeState.lineCap;
      }
      if (!equals$3(contextStrokeState.lineDash, strokeState.lineDash)) {
        context2.setLineDash(contextStrokeState.lineDash = strokeState.lineDash);
      }
      if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {
        contextStrokeState.lineDashOffset = strokeState.lineDashOffset;
        context2.lineDashOffset = strokeState.lineDashOffset;
      }
      if (contextStrokeState.lineJoin != strokeState.lineJoin) {
        contextStrokeState.lineJoin = strokeState.lineJoin;
        context2.lineJoin = strokeState.lineJoin;
      }
      if (contextStrokeState.lineWidth != strokeState.lineWidth) {
        contextStrokeState.lineWidth = strokeState.lineWidth;
        context2.lineWidth = strokeState.lineWidth;
      }
      if (contextStrokeState.miterLimit != strokeState.miterLimit) {
        contextStrokeState.miterLimit = strokeState.miterLimit;
        context2.miterLimit = strokeState.miterLimit;
      }
      if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {
        contextStrokeState.strokeStyle = strokeState.strokeStyle;
        context2.strokeStyle = strokeState.strokeStyle;
      }
    }
  }
  setContextTextState_(textState) {
    const context2 = this.context_;
    const contextTextState = this.contextTextState_;
    const textAlign2 = textState.textAlign ? textState.textAlign : defaultTextAlign;
    if (!contextTextState) {
      context2.font = textState.font;
      context2.textAlign = textAlign2;
      context2.textBaseline = textState.textBaseline;
      this.contextTextState_ = {
        font: textState.font,
        textAlign: textAlign2,
        textBaseline: textState.textBaseline
      };
    } else {
      if (contextTextState.font != textState.font) {
        contextTextState.font = textState.font;
        context2.font = textState.font;
      }
      if (contextTextState.textAlign != textAlign2) {
        contextTextState.textAlign = textAlign2;
        context2.textAlign = textAlign2;
      }
      if (contextTextState.textBaseline != textState.textBaseline) {
        contextTextState.textBaseline = textState.textBaseline;
        context2.textBaseline = textState.textBaseline;
      }
    }
  }
  setFillStrokeStyle(fillStyle, strokeStyle) {
    if (!fillStyle) {
      this.fillState_ = null;
    } else {
      const fillStyleColor = fillStyle.getColor();
      this.fillState_ = {
        fillStyle: asColorLike(fillStyleColor ? fillStyleColor : defaultFillStyle)
      };
    }
    if (!strokeStyle) {
      this.strokeState_ = null;
    } else {
      const strokeStyleColor = strokeStyle.getColor();
      const strokeStyleLineCap = strokeStyle.getLineCap();
      const strokeStyleLineDash = strokeStyle.getLineDash();
      const strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
      const strokeStyleLineJoin = strokeStyle.getLineJoin();
      const strokeStyleWidth = strokeStyle.getWidth();
      const strokeStyleMiterLimit = strokeStyle.getMiterLimit();
      const lineDash = strokeStyleLineDash ? strokeStyleLineDash : defaultLineDash;
      this.strokeState_ = {
        lineCap: strokeStyleLineCap !== void 0 ? strokeStyleLineCap : defaultLineCap,
        lineDash: this.pixelRatio_ === 1 ? lineDash : lineDash.map((n2) => n2 * this.pixelRatio_),
        lineDashOffset: (strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset) * this.pixelRatio_,
        lineJoin: strokeStyleLineJoin !== void 0 ? strokeStyleLineJoin : defaultLineJoin,
        lineWidth: (strokeStyleWidth !== void 0 ? strokeStyleWidth : defaultLineWidth) * this.pixelRatio_,
        miterLimit: strokeStyleMiterLimit !== void 0 ? strokeStyleMiterLimit : defaultMiterLimit,
        strokeStyle: asColorLike(strokeStyleColor ? strokeStyleColor : defaultStrokeStyle)
      };
    }
  }
  setImageStyle(imageStyle) {
    let imageSize;
    if (!imageStyle || !(imageSize = imageStyle.getSize())) {
      this.image_ = null;
      return;
    }
    const imagePixelRatio = imageStyle.getPixelRatio(this.pixelRatio_);
    const imageAnchor = imageStyle.getAnchor();
    const imageOrigin = imageStyle.getOrigin();
    this.image_ = imageStyle.getImage(this.pixelRatio_);
    this.imageAnchorX_ = imageAnchor[0] * imagePixelRatio;
    this.imageAnchorY_ = imageAnchor[1] * imagePixelRatio;
    this.imageHeight_ = imageSize[1] * imagePixelRatio;
    this.imageOpacity_ = imageStyle.getOpacity();
    this.imageOriginX_ = imageOrigin[0];
    this.imageOriginY_ = imageOrigin[1];
    this.imageRotateWithView_ = imageStyle.getRotateWithView();
    this.imageRotation_ = imageStyle.getRotation();
    const imageScale = imageStyle.getScaleArray();
    this.imageScale_ = [
      imageScale[0] * this.pixelRatio_ / imagePixelRatio,
      imageScale[1] * this.pixelRatio_ / imagePixelRatio
    ];
    this.imageWidth_ = imageSize[0] * imagePixelRatio;
  }
  setTextStyle(textStyle) {
    if (!textStyle) {
      this.text_ = "";
    } else {
      const textFillStyle = textStyle.getFill();
      if (!textFillStyle) {
        this.textFillState_ = null;
      } else {
        const textFillStyleColor = textFillStyle.getColor();
        this.textFillState_ = {
          fillStyle: asColorLike(textFillStyleColor ? textFillStyleColor : defaultFillStyle)
        };
      }
      const textStrokeStyle = textStyle.getStroke();
      if (!textStrokeStyle) {
        this.textStrokeState_ = null;
      } else {
        const textStrokeStyleColor = textStrokeStyle.getColor();
        const textStrokeStyleLineCap = textStrokeStyle.getLineCap();
        const textStrokeStyleLineDash = textStrokeStyle.getLineDash();
        const textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();
        const textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
        const textStrokeStyleWidth = textStrokeStyle.getWidth();
        const textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
        this.textStrokeState_ = {
          lineCap: textStrokeStyleLineCap !== void 0 ? textStrokeStyleLineCap : defaultLineCap,
          lineDash: textStrokeStyleLineDash ? textStrokeStyleLineDash : defaultLineDash,
          lineDashOffset: textStrokeStyleLineDashOffset ? textStrokeStyleLineDashOffset : defaultLineDashOffset,
          lineJoin: textStrokeStyleLineJoin !== void 0 ? textStrokeStyleLineJoin : defaultLineJoin,
          lineWidth: textStrokeStyleWidth !== void 0 ? textStrokeStyleWidth : defaultLineWidth,
          miterLimit: textStrokeStyleMiterLimit !== void 0 ? textStrokeStyleMiterLimit : defaultMiterLimit,
          strokeStyle: asColorLike(textStrokeStyleColor ? textStrokeStyleColor : defaultStrokeStyle)
        };
      }
      const textFont = textStyle.getFont();
      const textOffsetX = textStyle.getOffsetX();
      const textOffsetY = textStyle.getOffsetY();
      const textRotateWithView = textStyle.getRotateWithView();
      const textRotation = textStyle.getRotation();
      const textScale = textStyle.getScaleArray();
      const textText = textStyle.getText();
      const textTextAlign = textStyle.getTextAlign();
      const textTextBaseline = textStyle.getTextBaseline();
      this.textState_ = {
        font: textFont !== void 0 ? textFont : defaultFont,
        textAlign: textTextAlign !== void 0 ? textTextAlign : defaultTextAlign,
        textBaseline: textTextBaseline !== void 0 ? textTextBaseline : defaultTextBaseline
      };
      this.text_ = textText !== void 0 ? Array.isArray(textText) ? textText.reduce((acc, t3, i2) => acc += i2 % 2 ? " " : t3, "") : textText : "";
      this.textOffsetX_ = textOffsetX !== void 0 ? this.pixelRatio_ * textOffsetX : 0;
      this.textOffsetY_ = textOffsetY !== void 0 ? this.pixelRatio_ * textOffsetY : 0;
      this.textRotateWithView_ = textRotateWithView !== void 0 ? textRotateWithView : false;
      this.textRotation_ = textRotation !== void 0 ? textRotation : 0;
      this.textScale_ = [
        this.pixelRatio_ * textScale[0],
        this.pixelRatio_ * textScale[1]
      ];
    }
  }
}
const HIT_DETECT_RESOLUTION = 0.5;
function createHitDetectionImageData(size, transforms2, features, styleFunction, extent2, resolution, rotation) {
  const width = size[0] * HIT_DETECT_RESOLUTION;
  const height = size[1] * HIT_DETECT_RESOLUTION;
  const context2 = createCanvasContext2D(width, height);
  context2.imageSmoothingEnabled = false;
  const canvas = context2.canvas;
  const renderer = new CanvasImmediateRenderer(context2, HIT_DETECT_RESOLUTION, extent2, null, rotation);
  const featureCount = features.length;
  const indexFactor = Math.floor((256 * 256 * 256 - 1) / featureCount);
  const featuresByZIndex = {};
  for (let i2 = 1; i2 <= featureCount; ++i2) {
    const feature = features[i2 - 1];
    const featureStyleFunction = feature.getStyleFunction() || styleFunction;
    if (!styleFunction) {
      continue;
    }
    let styles = featureStyleFunction(feature, resolution);
    if (!styles) {
      continue;
    }
    if (!Array.isArray(styles)) {
      styles = [styles];
    }
    const index2 = i2 * indexFactor;
    const color2 = index2.toString(16).padStart(7, "#00000");
    for (let j2 = 0, jj = styles.length; j2 < jj; ++j2) {
      const originalStyle = styles[j2];
      const geometry = originalStyle.getGeometryFunction()(feature);
      if (!geometry || !intersects$2(extent2, geometry.getExtent())) {
        continue;
      }
      const style2 = originalStyle.clone();
      const fill = style2.getFill();
      if (fill) {
        fill.setColor(color2);
      }
      const stroke = style2.getStroke();
      if (stroke) {
        stroke.setColor(color2);
        stroke.setLineDash(null);
      }
      style2.setText(void 0);
      const image2 = originalStyle.getImage();
      if (image2 && image2.getOpacity() !== 0) {
        const imgSize = image2.getImageSize();
        if (!imgSize) {
          continue;
        }
        const imgContext = createCanvasContext2D(imgSize[0], imgSize[1], void 0, { alpha: false });
        const img = imgContext.canvas;
        imgContext.fillStyle = color2;
        imgContext.fillRect(0, 0, img.width, img.height);
        style2.setImage(new Icon$1({
          img,
          imgSize,
          anchor: image2.getAnchor(),
          anchorXUnits: "pixels",
          anchorYUnits: "pixels",
          offset: image2.getOrigin(),
          opacity: 1,
          size: image2.getSize(),
          scale: image2.getScale(),
          rotation: image2.getRotation(),
          rotateWithView: image2.getRotateWithView()
        }));
      }
      const zIndex2 = style2.getZIndex() || 0;
      let byGeometryType = featuresByZIndex[zIndex2];
      if (!byGeometryType) {
        byGeometryType = {};
        featuresByZIndex[zIndex2] = byGeometryType;
        byGeometryType["Polygon"] = [];
        byGeometryType["Circle"] = [];
        byGeometryType["LineString"] = [];
        byGeometryType["Point"] = [];
      }
      const type = geometry.getType();
      if (type === "GeometryCollection") {
        const geometries = geometry.getGeometriesArrayRecursive();
        for (let i3 = 0, ii = geometries.length; i3 < ii; ++i3) {
          const geometry2 = geometries[i3];
          byGeometryType[geometry2.getType().replace("Multi", "")].push(geometry2, style2);
        }
      } else {
        byGeometryType[type.replace("Multi", "")].push(geometry, style2);
      }
    }
  }
  const zIndexKeys = Object.keys(featuresByZIndex).map(Number).sort(numberSafeCompareFunction);
  for (let i2 = 0, ii = zIndexKeys.length; i2 < ii; ++i2) {
    const byGeometryType = featuresByZIndex[zIndexKeys[i2]];
    for (const type in byGeometryType) {
      const geomAndStyle = byGeometryType[type];
      for (let j2 = 0, jj = geomAndStyle.length; j2 < jj; j2 += 2) {
        renderer.setStyle(geomAndStyle[j2 + 1]);
        for (let k2 = 0, kk = transforms2.length; k2 < kk; ++k2) {
          renderer.setTransform(transforms2[k2]);
          renderer.drawGeometry(geomAndStyle[j2]);
        }
      }
    }
  }
  return context2.getImageData(0, 0, canvas.width, canvas.height);
}
function hitDetect(pixel, features, imageData) {
  const resultFeatures = [];
  if (imageData) {
    const x2 = Math.floor(Math.round(pixel[0]) * HIT_DETECT_RESOLUTION);
    const y2 = Math.floor(Math.round(pixel[1]) * HIT_DETECT_RESOLUTION);
    const index2 = (clamp(x2, 0, imageData.width - 1) + clamp(y2, 0, imageData.height - 1) * imageData.width) * 4;
    const r2 = imageData.data[index2];
    const g2 = imageData.data[index2 + 1];
    const b2 = imageData.data[index2 + 2];
    const i2 = b2 + 256 * (g2 + 256 * r2);
    const indexFactor = Math.floor((256 * 256 * 256 - 1) / features.length);
    if (i2 && i2 % indexFactor === 0) {
      resultFeatures.push(features[i2 / indexFactor - 1]);
    }
  }
  return resultFeatures;
}
const SIMPLIFY_TOLERANCE = 0.5;
const GEOMETRY_RENDERERS = {
  "Point": renderPointGeometry,
  "LineString": renderLineStringGeometry,
  "Polygon": renderPolygonGeometry,
  "MultiPoint": renderMultiPointGeometry,
  "MultiLineString": renderMultiLineStringGeometry,
  "MultiPolygon": renderMultiPolygonGeometry,
  "GeometryCollection": renderGeometryCollectionGeometry,
  "Circle": renderCircleGeometry
};
function defaultOrder(feature1, feature2) {
  return parseInt(getUid(feature1), 10) - parseInt(getUid(feature2), 10);
}
function getSquaredTolerance(resolution, pixelRatio) {
  const tolerance = getTolerance(resolution, pixelRatio);
  return tolerance * tolerance;
}
function getTolerance(resolution, pixelRatio) {
  return SIMPLIFY_TOLERANCE * resolution / pixelRatio;
}
function renderCircleGeometry(builderGroup, geometry, style2, feature, declutterBuilderGroup) {
  const fillStyle = style2.getFill();
  const strokeStyle = style2.getStroke();
  if (fillStyle || strokeStyle) {
    const circleReplay = builderGroup.getBuilder(style2.getZIndex(), "Circle");
    circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    circleReplay.drawCircle(geometry, feature);
  }
  const textStyle = style2.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(style2.getZIndex(), "Text");
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
function renderFeature(replayGroup, feature, style2, squaredTolerance, listener2, transform2, declutterBuilderGroup) {
  let loading = false;
  const imageStyle = style2.getImage();
  if (imageStyle) {
    const imageState = imageStyle.getImageState();
    if (imageState == ImageState.LOADED || imageState == ImageState.ERROR) {
      imageStyle.unlistenImageChange(listener2);
    } else {
      if (imageState == ImageState.IDLE) {
        imageStyle.load();
      }
      imageStyle.listenImageChange(listener2);
      loading = true;
    }
  }
  renderFeatureInternal(replayGroup, feature, style2, squaredTolerance, transform2, declutterBuilderGroup);
  return loading;
}
function renderFeatureInternal(replayGroup, feature, style2, squaredTolerance, transform2, declutterBuilderGroup) {
  const geometry = style2.getGeometryFunction()(feature);
  if (!geometry) {
    return;
  }
  const simplifiedGeometry = geometry.simplifyTransformed(squaredTolerance, transform2);
  const renderer = style2.getRenderer();
  if (renderer) {
    renderGeometry(replayGroup, simplifiedGeometry, style2, feature);
  } else {
    const geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];
    geometryRenderer(replayGroup, simplifiedGeometry, style2, feature, declutterBuilderGroup);
  }
}
function renderGeometry(replayGroup, geometry, style2, feature) {
  if (geometry.getType() == "GeometryCollection") {
    const geometries = geometry.getGeometries();
    for (let i2 = 0, ii = geometries.length; i2 < ii; ++i2) {
      renderGeometry(replayGroup, geometries[i2], style2, feature);
    }
    return;
  }
  const replay = replayGroup.getBuilder(style2.getZIndex(), "Default");
  replay.drawCustom(geometry, feature, style2.getRenderer(), style2.getHitDetectionRenderer());
}
function renderGeometryCollectionGeometry(replayGroup, geometry, style2, feature, declutterBuilderGroup) {
  const geometries = geometry.getGeometriesArray();
  let i2, ii;
  for (i2 = 0, ii = geometries.length; i2 < ii; ++i2) {
    const geometryRenderer = GEOMETRY_RENDERERS[geometries[i2].getType()];
    geometryRenderer(replayGroup, geometries[i2], style2, feature, declutterBuilderGroup);
  }
}
function renderLineStringGeometry(builderGroup, geometry, style2, feature, declutterBuilderGroup) {
  const strokeStyle = style2.getStroke();
  if (strokeStyle) {
    const lineStringReplay = builderGroup.getBuilder(style2.getZIndex(), "LineString");
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawLineString(geometry, feature);
  }
  const textStyle = style2.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(style2.getZIndex(), "Text");
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
function renderMultiLineStringGeometry(builderGroup, geometry, style2, feature, declutterBuilderGroup) {
  const strokeStyle = style2.getStroke();
  if (strokeStyle) {
    const lineStringReplay = builderGroup.getBuilder(style2.getZIndex(), "LineString");
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawMultiLineString(geometry, feature);
  }
  const textStyle = style2.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(style2.getZIndex(), "Text");
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
function renderMultiPolygonGeometry(builderGroup, geometry, style2, feature, declutterBuilderGroup) {
  const fillStyle = style2.getFill();
  const strokeStyle = style2.getStroke();
  if (strokeStyle || fillStyle) {
    const polygonReplay = builderGroup.getBuilder(style2.getZIndex(), "Polygon");
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawMultiPolygon(geometry, feature);
  }
  const textStyle = style2.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(style2.getZIndex(), "Text");
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
function renderPointGeometry(builderGroup, geometry, style2, feature, declutterBuilderGroup) {
  const imageStyle = style2.getImage();
  const textStyle = style2.getText();
  let declutterImageWithText;
  if (imageStyle) {
    if (imageStyle.getImageState() != ImageState.LOADED) {
      return;
    }
    let imageBuilderGroup = builderGroup;
    if (declutterBuilderGroup) {
      const declutterMode = imageStyle.getDeclutterMode();
      if (declutterMode !== "none") {
        imageBuilderGroup = declutterBuilderGroup;
        if (declutterMode === "obstacle") {
          const imageReplay2 = builderGroup.getBuilder(style2.getZIndex(), "Image");
          imageReplay2.setImageStyle(imageStyle, declutterImageWithText);
          imageReplay2.drawPoint(geometry, feature);
        } else if (textStyle && textStyle.getText()) {
          declutterImageWithText = {};
        }
      }
    }
    const imageReplay = imageBuilderGroup.getBuilder(style2.getZIndex(), "Image");
    imageReplay.setImageStyle(imageStyle, declutterImageWithText);
    imageReplay.drawPoint(geometry, feature);
  }
  if (textStyle && textStyle.getText()) {
    let textBuilderGroup = builderGroup;
    if (declutterBuilderGroup) {
      textBuilderGroup = declutterBuilderGroup;
    }
    const textReplay = textBuilderGroup.getBuilder(style2.getZIndex(), "Text");
    textReplay.setTextStyle(textStyle, declutterImageWithText);
    textReplay.drawText(geometry, feature);
  }
}
function renderMultiPointGeometry(builderGroup, geometry, style2, feature, declutterBuilderGroup) {
  const imageStyle = style2.getImage();
  const textStyle = style2.getText();
  let declutterImageWithText;
  if (imageStyle) {
    if (imageStyle.getImageState() != ImageState.LOADED) {
      return;
    }
    let imageBuilderGroup = builderGroup;
    if (declutterBuilderGroup) {
      const declutterMode = imageStyle.getDeclutterMode();
      if (declutterMode !== "none") {
        imageBuilderGroup = declutterBuilderGroup;
        if (declutterMode === "obstacle") {
          const imageReplay2 = builderGroup.getBuilder(style2.getZIndex(), "Image");
          imageReplay2.setImageStyle(imageStyle, declutterImageWithText);
          imageReplay2.drawMultiPoint(geometry, feature);
        } else if (textStyle && textStyle.getText()) {
          declutterImageWithText = {};
        }
      }
    }
    const imageReplay = imageBuilderGroup.getBuilder(style2.getZIndex(), "Image");
    imageReplay.setImageStyle(imageStyle, declutterImageWithText);
    imageReplay.drawMultiPoint(geometry, feature);
  }
  if (textStyle && textStyle.getText()) {
    let textBuilderGroup = builderGroup;
    if (declutterBuilderGroup) {
      textBuilderGroup = declutterBuilderGroup;
    }
    const textReplay = textBuilderGroup.getBuilder(style2.getZIndex(), "Text");
    textReplay.setTextStyle(textStyle, declutterImageWithText);
    textReplay.drawText(geometry, feature);
  }
}
function renderPolygonGeometry(builderGroup, geometry, style2, feature, declutterBuilderGroup) {
  const fillStyle = style2.getFill();
  const strokeStyle = style2.getStroke();
  if (fillStyle || strokeStyle) {
    const polygonReplay = builderGroup.getBuilder(style2.getZIndex(), "Polygon");
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawPolygon(geometry, feature);
  }
  const textStyle = style2.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(style2.getZIndex(), "Text");
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
class CanvasVectorLayerRenderer extends CanvasLayerRenderer {
  constructor(vectorLayer) {
    super(vectorLayer);
    this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this);
    this.animatingOrInteracting_;
    this.hitDetectionImageData_ = null;
    this.renderedFeatures_ = null;
    this.renderedRevision_ = -1;
    this.renderedResolution_ = NaN;
    this.renderedExtent_ = createEmpty();
    this.wrappedRenderedExtent_ = createEmpty();
    this.renderedRotation_;
    this.renderedCenter_ = null;
    this.renderedProjection_ = null;
    this.renderedRenderOrder_ = null;
    this.replayGroup_ = null;
    this.replayGroupChanged = true;
    this.declutterExecutorGroup = null;
    this.clipping = true;
    this.compositionContext_ = null;
    this.opacity_ = 1;
  }
  renderWorlds(executorGroup, frameState, declutterTree) {
    const extent2 = frameState.extent;
    const viewState = frameState.viewState;
    const center = viewState.center;
    const resolution = viewState.resolution;
    const projection = viewState.projection;
    const rotation = viewState.rotation;
    const projectionExtent = projection.getExtent();
    const vectorSource = this.getLayer().getSource();
    const pixelRatio = frameState.pixelRatio;
    const viewHints = frameState.viewHints;
    const snapToPixel = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);
    const context2 = this.compositionContext_;
    const width = Math.round(frameState.size[0] * pixelRatio);
    const height = Math.round(frameState.size[1] * pixelRatio);
    const multiWorld = vectorSource.getWrapX() && projection.canWrapX();
    const worldWidth = multiWorld ? getWidth(projectionExtent) : null;
    const endWorld = multiWorld ? Math.ceil((extent2[2] - projectionExtent[2]) / worldWidth) + 1 : 1;
    let world = multiWorld ? Math.floor((extent2[0] - projectionExtent[0]) / worldWidth) : 0;
    do {
      const transform2 = this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, world * worldWidth);
      executorGroup.execute(context2, 1, transform2, rotation, snapToPixel, void 0, declutterTree);
    } while (++world < endWorld);
  }
  setupCompositionContext_() {
    if (this.opacity_ !== 1) {
      const compositionContext = createCanvasContext2D(this.context.canvas.width, this.context.canvas.height, canvasPool$1);
      this.compositionContext_ = compositionContext;
    } else {
      this.compositionContext_ = this.context;
    }
  }
  releaseCompositionContext_() {
    if (this.opacity_ !== 1) {
      const alpha = this.context.globalAlpha;
      this.context.globalAlpha = this.opacity_;
      this.context.drawImage(this.compositionContext_.canvas, 0, 0);
      this.context.globalAlpha = alpha;
      releaseCanvas$1(this.compositionContext_);
      canvasPool$1.push(this.compositionContext_.canvas);
      this.compositionContext_ = null;
    }
  }
  renderDeclutter(frameState) {
    if (this.declutterExecutorGroup) {
      this.setupCompositionContext_();
      this.renderWorlds(this.declutterExecutorGroup, frameState, frameState.declutterTree);
      this.releaseCompositionContext_();
    }
  }
  renderFrame(frameState, target) {
    const pixelRatio = frameState.pixelRatio;
    const layerState = frameState.layerStatesArray[frameState.layerIndex];
    makeScale(this.pixelTransform, 1 / pixelRatio, 1 / pixelRatio);
    makeInverse(this.inversePixelTransform, this.pixelTransform);
    const canvasTransform = toString$e(this.pixelTransform);
    this.useContainer(target, canvasTransform, this.getBackground(frameState));
    const context2 = this.context;
    const canvas = context2.canvas;
    const replayGroup = this.replayGroup_;
    const declutterExecutorGroup = this.declutterExecutorGroup;
    if ((!replayGroup || replayGroup.isEmpty()) && (!declutterExecutorGroup || declutterExecutorGroup.isEmpty())) {
      return null;
    }
    const width = Math.round(frameState.size[0] * pixelRatio);
    const height = Math.round(frameState.size[1] * pixelRatio);
    if (canvas.width != width || canvas.height != height) {
      canvas.width = width;
      canvas.height = height;
      if (canvas.style.transform !== canvasTransform) {
        canvas.style.transform = canvasTransform;
      }
    } else if (!this.containerReused) {
      context2.clearRect(0, 0, width, height);
    }
    this.preRender(context2, frameState);
    const viewState = frameState.viewState;
    viewState.projection;
    this.opacity_ = layerState.opacity;
    this.setupCompositionContext_();
    let clipped = false;
    let render2 = true;
    if (layerState.extent && this.clipping) {
      const layerExtent = fromUserExtent(layerState.extent);
      render2 = intersects$2(layerExtent, frameState.extent);
      clipped = render2 && !containsExtent(layerExtent, frameState.extent);
      if (clipped) {
        this.clipUnrotated(this.compositionContext_, frameState, layerExtent);
      }
    }
    if (render2) {
      this.renderWorlds(replayGroup, frameState);
    }
    if (clipped) {
      this.compositionContext_.restore();
    }
    this.releaseCompositionContext_();
    this.postRender(context2, frameState);
    if (this.renderedRotation_ !== viewState.rotation) {
      this.renderedRotation_ = viewState.rotation;
      this.hitDetectionImageData_ = null;
    }
    return this.container;
  }
  getFeatures(pixel) {
    return new Promise((resolve2) => {
      if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
        const size = [this.context.canvas.width, this.context.canvas.height];
        apply$5(this.pixelTransform, size);
        const center = this.renderedCenter_;
        const resolution = this.renderedResolution_;
        const rotation = this.renderedRotation_;
        const projection = this.renderedProjection_;
        const extent2 = this.wrappedRenderedExtent_;
        const layer = this.getLayer();
        const transforms2 = [];
        const width = size[0] * HIT_DETECT_RESOLUTION;
        const height = size[1] * HIT_DETECT_RESOLUTION;
        transforms2.push(this.getRenderTransform(center, resolution, rotation, HIT_DETECT_RESOLUTION, width, height, 0).slice());
        const source = layer.getSource();
        const projectionExtent = projection.getExtent();
        if (source.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, extent2)) {
          let startX = extent2[0];
          const worldWidth = getWidth(projectionExtent);
          let world = 0;
          let offsetX;
          while (startX < projectionExtent[0]) {
            --world;
            offsetX = worldWidth * world;
            transforms2.push(this.getRenderTransform(center, resolution, rotation, HIT_DETECT_RESOLUTION, width, height, offsetX).slice());
            startX += worldWidth;
          }
          world = 0;
          startX = extent2[2];
          while (startX > projectionExtent[2]) {
            ++world;
            offsetX = worldWidth * world;
            transforms2.push(this.getRenderTransform(center, resolution, rotation, HIT_DETECT_RESOLUTION, width, height, offsetX).slice());
            startX -= worldWidth;
          }
        }
        this.hitDetectionImageData_ = createHitDetectionImageData(size, transforms2, this.renderedFeatures_, layer.getStyleFunction(), extent2, resolution, rotation);
      }
      resolve2(hitDetect(pixel, this.renderedFeatures_, this.hitDetectionImageData_));
    });
  }
  forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {
    if (!this.replayGroup_) {
      return void 0;
    }
    const resolution = frameState.viewState.resolution;
    const rotation = frameState.viewState.rotation;
    const layer = this.getLayer();
    const features = {};
    const featureCallback = function(feature, geometry, distanceSq) {
      const key = getUid(feature);
      const match2 = features[key];
      if (!match2) {
        if (distanceSq === 0) {
          features[key] = true;
          return callback(feature, layer, geometry);
        }
        matches.push(features[key] = {
          feature,
          layer,
          geometry,
          distanceSq,
          callback
        });
      } else if (match2 !== true && distanceSq < match2.distanceSq) {
        if (distanceSq === 0) {
          features[key] = true;
          matches.splice(matches.lastIndexOf(match2), 1);
          return callback(feature, layer, geometry);
        }
        match2.geometry = geometry;
        match2.distanceSq = distanceSq;
      }
      return void 0;
    };
    let result;
    const executorGroups = [this.replayGroup_];
    if (this.declutterExecutorGroup) {
      executorGroups.push(this.declutterExecutorGroup);
    }
    executorGroups.some((executorGroup) => {
      return result = executorGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, featureCallback, executorGroup === this.declutterExecutorGroup && frameState.declutterTree ? frameState.declutterTree.all().map((item) => item.value) : null);
    });
    return result;
  }
  handleFontsChanged() {
    const layer = this.getLayer();
    if (layer.getVisible() && this.replayGroup_) {
      layer.changed();
    }
  }
  handleStyleImageChange_(event) {
    this.renderIfReadyAndVisible();
  }
  prepareFrame(frameState) {
    const vectorLayer = this.getLayer();
    const vectorSource = vectorLayer.getSource();
    if (!vectorSource) {
      return false;
    }
    const animating = frameState.viewHints[ViewHint.ANIMATING];
    const interacting = frameState.viewHints[ViewHint.INTERACTING];
    const updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
    const updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();
    if (this.ready && !updateWhileAnimating && animating || !updateWhileInteracting && interacting) {
      this.animatingOrInteracting_ = true;
      return true;
    }
    this.animatingOrInteracting_ = false;
    const frameStateExtent = frameState.extent;
    const viewState = frameState.viewState;
    const projection = viewState.projection;
    const resolution = viewState.resolution;
    const pixelRatio = frameState.pixelRatio;
    const vectorLayerRevision = vectorLayer.getRevision();
    const vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
    let vectorLayerRenderOrder = vectorLayer.getRenderOrder();
    if (vectorLayerRenderOrder === void 0) {
      vectorLayerRenderOrder = defaultOrder;
    }
    const center = viewState.center.slice();
    const extent2 = buffer$2(frameStateExtent, vectorLayerRenderBuffer * resolution);
    const renderedExtent = extent2.slice();
    const loadExtents = [extent2.slice()];
    const projectionExtent = projection.getExtent();
    if (vectorSource.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, frameState.extent)) {
      const worldWidth = getWidth(projectionExtent);
      const gutter = Math.max(getWidth(extent2) / 2, worldWidth);
      extent2[0] = projectionExtent[0] - gutter;
      extent2[2] = projectionExtent[2] + gutter;
      wrapX$1(center, projection);
      const loadExtent = wrapX$2(loadExtents[0], projection);
      if (loadExtent[0] < projectionExtent[0] && loadExtent[2] < projectionExtent[2]) {
        loadExtents.push([
          loadExtent[0] + worldWidth,
          loadExtent[1],
          loadExtent[2] + worldWidth,
          loadExtent[3]
        ]);
      } else if (loadExtent[0] > projectionExtent[0] && loadExtent[2] > projectionExtent[2]) {
        loadExtents.push([
          loadExtent[0] - worldWidth,
          loadExtent[1],
          loadExtent[2] - worldWidth,
          loadExtent[3]
        ]);
      }
    }
    if (this.ready && this.renderedResolution_ == resolution && this.renderedRevision_ == vectorLayerRevision && this.renderedRenderOrder_ == vectorLayerRenderOrder && containsExtent(this.wrappedRenderedExtent_, extent2)) {
      if (!equals$3(this.renderedExtent_, renderedExtent)) {
        this.hitDetectionImageData_ = null;
        this.renderedExtent_ = renderedExtent;
      }
      this.renderedCenter_ = center;
      this.replayGroupChanged = false;
      return true;
    }
    this.replayGroup_ = null;
    const replayGroup = new BuilderGroup(getTolerance(resolution, pixelRatio), extent2, resolution, pixelRatio);
    let declutterBuilderGroup;
    if (this.getLayer().getDeclutter()) {
      declutterBuilderGroup = new BuilderGroup(getTolerance(resolution, pixelRatio), extent2, resolution, pixelRatio);
    }
    let userTransform;
    {
      for (let i2 = 0, ii = loadExtents.length; i2 < ii; ++i2) {
        vectorSource.loadFeatures(loadExtents[i2], resolution, projection);
      }
    }
    const squaredTolerance = getSquaredTolerance(resolution, pixelRatio);
    let ready = true;
    const render2 = (feature) => {
      let styles;
      const styleFunction = feature.getStyleFunction() || vectorLayer.getStyleFunction();
      if (styleFunction) {
        styles = styleFunction(feature, resolution);
      }
      if (styles) {
        const dirty = this.renderFeature(feature, squaredTolerance, styles, replayGroup, userTransform, declutterBuilderGroup);
        ready = ready && !dirty;
      }
    };
    const userExtent = toUserExtent(extent2);
    const features = vectorSource.getFeaturesInExtent(userExtent);
    if (vectorLayerRenderOrder) {
      features.sort(vectorLayerRenderOrder);
    }
    for (let i2 = 0, ii = features.length; i2 < ii; ++i2) {
      render2(features[i2]);
    }
    this.renderedFeatures_ = features;
    this.ready = ready;
    const replayGroupInstructions = replayGroup.finish();
    const executorGroup = new ExecutorGroup(extent2, resolution, pixelRatio, vectorSource.getOverlaps(), replayGroupInstructions, vectorLayer.getRenderBuffer());
    if (declutterBuilderGroup) {
      this.declutterExecutorGroup = new ExecutorGroup(extent2, resolution, pixelRatio, vectorSource.getOverlaps(), declutterBuilderGroup.finish(), vectorLayer.getRenderBuffer());
    }
    this.renderedResolution_ = resolution;
    this.renderedRevision_ = vectorLayerRevision;
    this.renderedRenderOrder_ = vectorLayerRenderOrder;
    this.renderedExtent_ = renderedExtent;
    this.wrappedRenderedExtent_ = extent2;
    this.renderedCenter_ = center;
    this.renderedProjection_ = projection;
    this.replayGroup_ = executorGroup;
    this.hitDetectionImageData_ = null;
    this.replayGroupChanged = true;
    return true;
  }
  renderFeature(feature, squaredTolerance, styles, builderGroup, transform2, declutterBuilderGroup) {
    if (!styles) {
      return false;
    }
    let loading = false;
    if (Array.isArray(styles)) {
      for (let i2 = 0, ii = styles.length; i2 < ii; ++i2) {
        loading = renderFeature(builderGroup, feature, styles[i2], squaredTolerance, this.boundHandleStyleImageChange_, transform2, declutterBuilderGroup) || loading;
      }
    } else {
      loading = renderFeature(builderGroup, feature, styles, squaredTolerance, this.boundHandleStyleImageChange_, transform2, declutterBuilderGroup);
    }
    return loading;
  }
}
class VectorLayer$1 extends BaseVectorLayer {
  constructor(options) {
    super(options);
  }
  createRenderer() {
    return new CanvasVectorLayerRenderer(this);
  }
}
const _sfc_main$Y = {
  extends: BaseLayer,
  name: "ol-vector-layer",
  setup(props) {
    const map = inject("map");
    const {
      properties
    } = usePropsAsObjectProperties(props);
    const vectorLayer = computed(() => new VectorLayer$1(properties));
    watch(properties, () => {
      vectorLayer.value.setProperties(properties);
    });
    onMounted(() => {
      map.addLayer(vectorLayer.value);
    });
    onUnmounted(() => {
      map.removeLayer(vectorLayer.value);
    });
    provide("vectorLayer", vectorLayer);
    provide("stylable", vectorLayer);
    return {
      vectorLayer
    };
  },
  props: {
    renderBuffer: {
      type: Number,
      default: 100
    },
    updateWhileAnimating: {
      type: Boolean,
      default: false
    },
    style: {
      type: Function
    },
    updateWhileInteracting: {
      type: Boolean,
      default: false
    }
  }
};
function _sfc_render$Y(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var VectorLayer = /* @__PURE__ */ _export_sfc(_sfc_main$Y, [["render", _sfc_render$Y]]);
class TileCache extends LRUCache$1 {
  clear() {
    while (this.getCount() > 0) {
      this.pop().release();
    }
    super.clear();
  }
  expireCache(usedTiles) {
    while (this.canExpireCache()) {
      const tile2 = this.peekLast();
      if (tile2.getKey() in usedTiles) {
        break;
      } else {
        this.pop().release();
      }
    }
  }
  pruneExceptNewestZ() {
    if (this.getCount() === 0) {
      return;
    }
    const key = this.peekFirstKey();
    const tileCoord = fromKey(key);
    const z2 = tileCoord[0];
    this.forEach((tile2) => {
      if (tile2.tileCoord[0] !== z2) {
        this.remove(getKey(tile2.tileCoord));
        tile2.release();
      }
    });
  }
}
var TileEventType = {
  TILELOADSTART: "tileloadstart",
  TILELOADEND: "tileloadend",
  TILELOADERROR: "tileloaderror"
};
class Source extends BaseObject {
  constructor(options) {
    super();
    this.projection = get$4(options.projection);
    this.attributions_ = adaptAttributions(options.attributions);
    this.attributionsCollapsible_ = options.attributionsCollapsible !== void 0 ? options.attributionsCollapsible : true;
    this.loading = false;
    this.state_ = options.state !== void 0 ? options.state : "ready";
    this.wrapX_ = options.wrapX !== void 0 ? options.wrapX : false;
    this.interpolate_ = !!options.interpolate;
    this.viewResolver = null;
    this.viewRejector = null;
    const self2 = this;
    this.viewPromise_ = new Promise(function(resolve2, reject2) {
      self2.viewResolver = resolve2;
      self2.viewRejector = reject2;
    });
  }
  getAttributions() {
    return this.attributions_;
  }
  getAttributionsCollapsible() {
    return this.attributionsCollapsible_;
  }
  getProjection() {
    return this.projection;
  }
  getResolutions() {
    return abstract();
  }
  getView() {
    return this.viewPromise_;
  }
  getState() {
    return this.state_;
  }
  getWrapX() {
    return this.wrapX_;
  }
  getInterpolate() {
    return this.interpolate_;
  }
  refresh() {
    this.changed();
  }
  setAttributions(attributions) {
    this.attributions_ = adaptAttributions(attributions);
    this.changed();
  }
  setState(state) {
    this.state_ = state;
    this.changed();
  }
}
function adaptAttributions(attributionLike) {
  if (!attributionLike) {
    return null;
  }
  if (Array.isArray(attributionLike)) {
    return function(frameState) {
      return attributionLike;
    };
  }
  if (typeof attributionLike === "function") {
    return attributionLike;
  }
  return function(frameState) {
    return [attributionLike];
  };
}
const tmpTileCoord = [0, 0, 0];
const DECIMALS$1 = 5;
class TileGrid {
  constructor(options) {
    this.minZoom = options.minZoom !== void 0 ? options.minZoom : 0;
    this.resolutions_ = options.resolutions;
    assert(isSorted(this.resolutions_, function(a2, b2) {
      return b2 - a2;
    }, true), 17);
    let zoomFactor;
    if (!options.origins) {
      for (let i2 = 0, ii = this.resolutions_.length - 1; i2 < ii; ++i2) {
        if (!zoomFactor) {
          zoomFactor = this.resolutions_[i2] / this.resolutions_[i2 + 1];
        } else {
          if (this.resolutions_[i2] / this.resolutions_[i2 + 1] !== zoomFactor) {
            zoomFactor = void 0;
            break;
          }
        }
      }
    }
    this.zoomFactor_ = zoomFactor;
    this.maxZoom = this.resolutions_.length - 1;
    this.origin_ = options.origin !== void 0 ? options.origin : null;
    this.origins_ = null;
    if (options.origins !== void 0) {
      this.origins_ = options.origins;
      assert(this.origins_.length == this.resolutions_.length, 20);
    }
    const extent2 = options.extent;
    if (extent2 !== void 0 && !this.origin_ && !this.origins_) {
      this.origin_ = getTopLeft(extent2);
    }
    assert(!this.origin_ && this.origins_ || this.origin_ && !this.origins_, 18);
    this.tileSizes_ = null;
    if (options.tileSizes !== void 0) {
      this.tileSizes_ = options.tileSizes;
      assert(this.tileSizes_.length == this.resolutions_.length, 19);
    }
    this.tileSize_ = options.tileSize !== void 0 ? options.tileSize : !this.tileSizes_ ? DEFAULT_TILE_SIZE : null;
    assert(!this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_, 22);
    this.extent_ = extent2 !== void 0 ? extent2 : null;
    this.fullTileRanges_ = null;
    this.tmpSize_ = [0, 0];
    this.tmpExtent_ = [0, 0, 0, 0];
    if (options.sizes !== void 0) {
      this.fullTileRanges_ = options.sizes.map(function(size, z2) {
        const tileRange = new TileRange(Math.min(0, size[0]), Math.max(size[0] - 1, -1), Math.min(0, size[1]), Math.max(size[1] - 1, -1));
        if (extent2) {
          const restrictedTileRange = this.getTileRangeForExtentAndZ(extent2, z2);
          tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);
          tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);
          tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);
          tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);
        }
        return tileRange;
      }, this);
    } else if (extent2) {
      this.calculateTileRanges_(extent2);
    }
  }
  forEachTileCoord(extent2, zoom, callback) {
    const tileRange = this.getTileRangeForExtentAndZ(extent2, zoom);
    for (let i2 = tileRange.minX, ii = tileRange.maxX; i2 <= ii; ++i2) {
      for (let j2 = tileRange.minY, jj = tileRange.maxY; j2 <= jj; ++j2) {
        callback([zoom, i2, j2]);
      }
    }
  }
  forEachTileCoordParentTileRange(tileCoord, callback, tempTileRange, tempExtent2) {
    let tileRange, x2, y2;
    let tileCoordExtent = null;
    let z2 = tileCoord[0] - 1;
    if (this.zoomFactor_ === 2) {
      x2 = tileCoord[1];
      y2 = tileCoord[2];
    } else {
      tileCoordExtent = this.getTileCoordExtent(tileCoord, tempExtent2);
    }
    while (z2 >= this.minZoom) {
      if (this.zoomFactor_ === 2) {
        x2 = Math.floor(x2 / 2);
        y2 = Math.floor(y2 / 2);
        tileRange = createOrUpdate$1(x2, x2, y2, y2, tempTileRange);
      } else {
        tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z2, tempTileRange);
      }
      if (callback(z2, tileRange)) {
        return true;
      }
      --z2;
    }
    return false;
  }
  getExtent() {
    return this.extent_;
  }
  getMaxZoom() {
    return this.maxZoom;
  }
  getMinZoom() {
    return this.minZoom;
  }
  getOrigin(z2) {
    if (this.origin_) {
      return this.origin_;
    }
    return this.origins_[z2];
  }
  getResolution(z2) {
    return this.resolutions_[z2];
  }
  getResolutions() {
    return this.resolutions_;
  }
  getTileCoordChildTileRange(tileCoord, tempTileRange, tempExtent2) {
    if (tileCoord[0] < this.maxZoom) {
      if (this.zoomFactor_ === 2) {
        const minX = tileCoord[1] * 2;
        const minY = tileCoord[2] * 2;
        return createOrUpdate$1(minX, minX + 1, minY, minY + 1, tempTileRange);
      }
      const tileCoordExtent = this.getTileCoordExtent(tileCoord, tempExtent2 || this.tmpExtent_);
      return this.getTileRangeForExtentAndZ(tileCoordExtent, tileCoord[0] + 1, tempTileRange);
    }
    return null;
  }
  getTileRangeForTileCoordAndZ(tileCoord, z2, tempTileRange) {
    if (z2 > this.maxZoom || z2 < this.minZoom) {
      return null;
    }
    const tileCoordZ = tileCoord[0];
    const tileCoordX = tileCoord[1];
    const tileCoordY = tileCoord[2];
    if (z2 === tileCoordZ) {
      return createOrUpdate$1(tileCoordX, tileCoordY, tileCoordX, tileCoordY, tempTileRange);
    }
    if (this.zoomFactor_) {
      const factor = Math.pow(this.zoomFactor_, z2 - tileCoordZ);
      const minX = Math.floor(tileCoordX * factor);
      const minY = Math.floor(tileCoordY * factor);
      if (z2 < tileCoordZ) {
        return createOrUpdate$1(minX, minX, minY, minY, tempTileRange);
      }
      const maxX = Math.floor(factor * (tileCoordX + 1)) - 1;
      const maxY = Math.floor(factor * (tileCoordY + 1)) - 1;
      return createOrUpdate$1(minX, maxX, minY, maxY, tempTileRange);
    }
    const tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);
    return this.getTileRangeForExtentAndZ(tileCoordExtent, z2, tempTileRange);
  }
  getTileRangeExtent(z2, tileRange, tempExtent2) {
    const origin = this.getOrigin(z2);
    const resolution = this.getResolution(z2);
    const tileSize = toSize(this.getTileSize(z2), this.tmpSize_);
    const minX = origin[0] + tileRange.minX * tileSize[0] * resolution;
    const maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;
    const minY = origin[1] + tileRange.minY * tileSize[1] * resolution;
    const maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;
    return createOrUpdate$2(minX, minY, maxX, maxY, tempExtent2);
  }
  getTileRangeForExtentAndZ(extent2, z2, tempTileRange) {
    const tileCoord = tmpTileCoord;
    this.getTileCoordForXYAndZ_(extent2[0], extent2[3], z2, false, tileCoord);
    const minX = tileCoord[1];
    const minY = tileCoord[2];
    this.getTileCoordForXYAndZ_(extent2[2], extent2[1], z2, true, tileCoord);
    return createOrUpdate$1(minX, tileCoord[1], minY, tileCoord[2], tempTileRange);
  }
  getTileCoordCenter(tileCoord) {
    const origin = this.getOrigin(tileCoord[0]);
    const resolution = this.getResolution(tileCoord[0]);
    const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
    return [
      origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,
      origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution
    ];
  }
  getTileCoordExtent(tileCoord, tempExtent2) {
    const origin = this.getOrigin(tileCoord[0]);
    const resolution = this.getResolution(tileCoord[0]);
    const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
    const minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
    const minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;
    const maxX = minX + tileSize[0] * resolution;
    const maxY = minY + tileSize[1] * resolution;
    return createOrUpdate$2(minX, minY, maxX, maxY, tempExtent2);
  }
  getTileCoordForCoordAndResolution(coordinate, resolution, opt_tileCoord) {
    return this.getTileCoordForXYAndResolution_(coordinate[0], coordinate[1], resolution, false, opt_tileCoord);
  }
  getTileCoordForXYAndResolution_(x2, y2, resolution, reverseIntersectionPolicy, opt_tileCoord) {
    const z2 = this.getZForResolution(resolution);
    const scale2 = resolution / this.getResolution(z2);
    const origin = this.getOrigin(z2);
    const tileSize = toSize(this.getTileSize(z2), this.tmpSize_);
    let tileCoordX = scale2 * (x2 - origin[0]) / resolution / tileSize[0];
    let tileCoordY = scale2 * (origin[1] - y2) / resolution / tileSize[1];
    if (reverseIntersectionPolicy) {
      tileCoordX = ceil$1(tileCoordX, DECIMALS$1) - 1;
      tileCoordY = ceil$1(tileCoordY, DECIMALS$1) - 1;
    } else {
      tileCoordX = floor$2(tileCoordX, DECIMALS$1);
      tileCoordY = floor$2(tileCoordY, DECIMALS$1);
    }
    return createOrUpdate(z2, tileCoordX, tileCoordY, opt_tileCoord);
  }
  getTileCoordForXYAndZ_(x2, y2, z2, reverseIntersectionPolicy, opt_tileCoord) {
    const origin = this.getOrigin(z2);
    const resolution = this.getResolution(z2);
    const tileSize = toSize(this.getTileSize(z2), this.tmpSize_);
    let tileCoordX = (x2 - origin[0]) / resolution / tileSize[0];
    let tileCoordY = (origin[1] - y2) / resolution / tileSize[1];
    if (reverseIntersectionPolicy) {
      tileCoordX = ceil$1(tileCoordX, DECIMALS$1) - 1;
      tileCoordY = ceil$1(tileCoordY, DECIMALS$1) - 1;
    } else {
      tileCoordX = floor$2(tileCoordX, DECIMALS$1);
      tileCoordY = floor$2(tileCoordY, DECIMALS$1);
    }
    return createOrUpdate(z2, tileCoordX, tileCoordY, opt_tileCoord);
  }
  getTileCoordForCoordAndZ(coordinate, z2, opt_tileCoord) {
    return this.getTileCoordForXYAndZ_(coordinate[0], coordinate[1], z2, false, opt_tileCoord);
  }
  getTileCoordResolution(tileCoord) {
    return this.resolutions_[tileCoord[0]];
  }
  getTileSize(z2) {
    if (this.tileSize_) {
      return this.tileSize_;
    }
    return this.tileSizes_[z2];
  }
  getFullTileRange(z2) {
    if (!this.fullTileRanges_) {
      return this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, z2) : null;
    }
    return this.fullTileRanges_[z2];
  }
  getZForResolution(resolution, opt_direction) {
    const z2 = linearFindNearest(this.resolutions_, resolution, opt_direction || 0);
    return clamp(z2, this.minZoom, this.maxZoom);
  }
  tileCoordIntersectsViewport(tileCoord, viewport) {
    return intersectsLinearRing(viewport, 0, viewport.length, 2, this.getTileCoordExtent(tileCoord));
  }
  calculateTileRanges_(extent2) {
    const length = this.resolutions_.length;
    const fullTileRanges = new Array(length);
    for (let z2 = this.minZoom; z2 < length; ++z2) {
      fullTileRanges[z2] = this.getTileRangeForExtentAndZ(extent2, z2);
    }
    this.fullTileRanges_ = fullTileRanges;
  }
}
function getForProjection(projection) {
  let tileGrid = projection.getDefaultTileGrid();
  if (!tileGrid) {
    tileGrid = createForProjection(projection);
    projection.setDefaultTileGrid(tileGrid);
  }
  return tileGrid;
}
function wrapX(tileGrid, tileCoord, projection) {
  const z2 = tileCoord[0];
  const center = tileGrid.getTileCoordCenter(tileCoord);
  const projectionExtent = extentFromProjection(projection);
  if (!containsCoordinate(projectionExtent, center)) {
    const worldWidth = getWidth(projectionExtent);
    const worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);
    center[0] += worldWidth * worldsAway;
    return tileGrid.getTileCoordForCoordAndZ(center, z2);
  }
  return tileCoord;
}
function createForExtent(extent2, maxZoom, tileSize, corner) {
  corner = corner !== void 0 ? corner : "top-left";
  const resolutions = resolutionsFromExtent(extent2, maxZoom, tileSize);
  return new TileGrid({
    extent: extent2,
    origin: getCorner(extent2, corner),
    resolutions,
    tileSize
  });
}
function createXYZ(options) {
  const xyzOptions = options || {};
  const extent2 = xyzOptions.extent || get$4("EPSG:3857").getExtent();
  const gridOptions = {
    extent: extent2,
    minZoom: xyzOptions.minZoom,
    tileSize: xyzOptions.tileSize,
    resolutions: resolutionsFromExtent(extent2, xyzOptions.maxZoom, xyzOptions.tileSize, xyzOptions.maxResolution)
  };
  return new TileGrid(gridOptions);
}
function resolutionsFromExtent(extent2, maxZoom, tileSize, maxResolution) {
  maxZoom = maxZoom !== void 0 ? maxZoom : DEFAULT_MAX_ZOOM;
  tileSize = toSize(tileSize !== void 0 ? tileSize : DEFAULT_TILE_SIZE);
  const height = getHeight(extent2);
  const width = getWidth(extent2);
  maxResolution = maxResolution > 0 ? maxResolution : Math.max(width / tileSize[0], height / tileSize[1]);
  const length = maxZoom + 1;
  const resolutions = new Array(length);
  for (let z2 = 0; z2 < length; ++z2) {
    resolutions[z2] = maxResolution / Math.pow(2, z2);
  }
  return resolutions;
}
function createForProjection(projection, maxZoom, tileSize, corner) {
  const extent2 = extentFromProjection(projection);
  return createForExtent(extent2, maxZoom, tileSize, corner);
}
function extentFromProjection(projection) {
  projection = get$4(projection);
  let extent2 = projection.getExtent();
  if (!extent2) {
    const half = 180 * METERS_PER_UNIT$1.degrees / projection.getMetersPerUnit();
    extent2 = createOrUpdate$2(-half, -half, half, half);
  }
  return extent2;
}
class TileSource extends Source {
  constructor(options) {
    super({
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      projection: options.projection,
      state: options.state,
      wrapX: options.wrapX,
      interpolate: options.interpolate
    });
    this.on;
    this.once;
    this.un;
    this.opaque_ = options.opaque !== void 0 ? options.opaque : false;
    this.tilePixelRatio_ = options.tilePixelRatio !== void 0 ? options.tilePixelRatio : 1;
    this.tileGrid = options.tileGrid !== void 0 ? options.tileGrid : null;
    const tileSize = [256, 256];
    if (this.tileGrid) {
      toSize(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), tileSize);
    }
    this.tileCache = new TileCache(options.cacheSize || 0);
    this.tmpSize = [0, 0];
    this.key_ = options.key || "";
    this.tileOptions = {
      transition: options.transition,
      interpolate: options.interpolate
    };
    this.zDirection = options.zDirection ? options.zDirection : 0;
  }
  canExpireCache() {
    return this.tileCache.canExpireCache();
  }
  expireCache(projection, usedTiles) {
    const tileCache = this.getTileCacheForProjection(projection);
    if (tileCache) {
      tileCache.expireCache(usedTiles);
    }
  }
  forEachLoadedTile(projection, z2, tileRange, callback) {
    const tileCache = this.getTileCacheForProjection(projection);
    if (!tileCache) {
      return false;
    }
    let covered = true;
    let tile2, tileCoordKey, loaded;
    for (let x2 = tileRange.minX; x2 <= tileRange.maxX; ++x2) {
      for (let y2 = tileRange.minY; y2 <= tileRange.maxY; ++y2) {
        tileCoordKey = getKeyZXY(z2, x2, y2);
        loaded = false;
        if (tileCache.containsKey(tileCoordKey)) {
          tile2 = tileCache.get(tileCoordKey);
          loaded = tile2.getState() === TileState.LOADED;
          if (loaded) {
            loaded = callback(tile2) !== false;
          }
        }
        if (!loaded) {
          covered = false;
        }
      }
    }
    return covered;
  }
  getGutterForProjection(projection) {
    return 0;
  }
  getKey() {
    return this.key_;
  }
  setKey(key) {
    if (this.key_ !== key) {
      this.key_ = key;
      this.changed();
    }
  }
  getOpaque(projection) {
    return this.opaque_;
  }
  getResolutions() {
    if (!this.tileGrid) {
      return null;
    }
    return this.tileGrid.getResolutions();
  }
  getTile(z2, x2, y2, pixelRatio, projection) {
    return abstract();
  }
  getTileGrid() {
    return this.tileGrid;
  }
  getTileGridForProjection(projection) {
    if (!this.tileGrid) {
      return getForProjection(projection);
    }
    return this.tileGrid;
  }
  getTileCacheForProjection(projection) {
    const sourceProjection = this.getProjection();
    assert(sourceProjection === null || equivalent(sourceProjection, projection), 68);
    return this.tileCache;
  }
  getTilePixelRatio(pixelRatio) {
    return this.tilePixelRatio_;
  }
  getTilePixelSize(z2, pixelRatio, projection) {
    const tileGrid = this.getTileGridForProjection(projection);
    const tilePixelRatio = this.getTilePixelRatio(pixelRatio);
    const tileSize = toSize(tileGrid.getTileSize(z2), this.tmpSize);
    if (tilePixelRatio == 1) {
      return tileSize;
    }
    return scale(tileSize, tilePixelRatio, this.tmpSize);
  }
  getTileCoordForTileUrlFunction(tileCoord, projection) {
    projection = projection !== void 0 ? projection : this.getProjection();
    const tileGrid = this.getTileGridForProjection(projection);
    if (this.getWrapX() && projection.isGlobal()) {
      tileCoord = wrapX(tileGrid, tileCoord, projection);
    }
    return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;
  }
  clear() {
    this.tileCache.clear();
  }
  refresh() {
    this.clear();
    super.refresh();
  }
  updateCacheSize(tileCount, projection) {
    const tileCache = this.getTileCacheForProjection(projection);
    if (tileCount > tileCache.highWaterMark) {
      tileCache.highWaterMark = tileCount;
    }
  }
  useTile(z2, x2, y2, projection) {
  }
}
class TileSourceEvent extends BaseEvent {
  constructor(type, tile2) {
    super(type);
    this.tile = tile2;
  }
}
function createFromTemplate(template, tileGrid) {
  const zRegEx = /\{z\}/g;
  const xRegEx = /\{x\}/g;
  const yRegEx = /\{y\}/g;
  const dashYRegEx = /\{-y\}/g;
  return function(tileCoord, pixelRatio, projection) {
    if (!tileCoord) {
      return void 0;
    }
    return template.replace(zRegEx, tileCoord[0].toString()).replace(xRegEx, tileCoord[1].toString()).replace(yRegEx, tileCoord[2].toString()).replace(dashYRegEx, function() {
      const z2 = tileCoord[0];
      const range = tileGrid.getFullTileRange(z2);
      assert(range, 55);
      const y2 = range.getHeight() - tileCoord[2] - 1;
      return y2.toString();
    });
  };
}
function createFromTemplates(templates, tileGrid) {
  const len = templates.length;
  const tileUrlFunctions = new Array(len);
  for (let i2 = 0; i2 < len; ++i2) {
    tileUrlFunctions[i2] = createFromTemplate(templates[i2], tileGrid);
  }
  return createFromTileUrlFunctions(tileUrlFunctions);
}
function createFromTileUrlFunctions(tileUrlFunctions) {
  if (tileUrlFunctions.length === 1) {
    return tileUrlFunctions[0];
  }
  return function(tileCoord, pixelRatio, projection) {
    if (!tileCoord) {
      return void 0;
    }
    const h2 = hash(tileCoord);
    const index2 = modulo(h2, tileUrlFunctions.length);
    return tileUrlFunctions[index2](tileCoord, pixelRatio, projection);
  };
}
function expandUrl(url) {
  const urls = [];
  let match2 = /\{([a-z])-([a-z])\}/.exec(url);
  if (match2) {
    const startCharCode = match2[1].charCodeAt(0);
    const stopCharCode = match2[2].charCodeAt(0);
    let charCode;
    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
      urls.push(url.replace(match2[0], String.fromCharCode(charCode)));
    }
    return urls;
  }
  match2 = /\{(\d+)-(\d+)\}/.exec(url);
  if (match2) {
    const stop = parseInt(match2[2], 10);
    for (let i2 = parseInt(match2[1], 10); i2 <= stop; i2++) {
      urls.push(url.replace(match2[0], i2.toString()));
    }
    return urls;
  }
  urls.push(url);
  return urls;
}
class UrlTile extends TileSource {
  constructor(options) {
    super({
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      opaque: options.opaque,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tilePixelRatio: options.tilePixelRatio,
      wrapX: options.wrapX,
      transition: options.transition,
      interpolate: options.interpolate,
      key: options.key,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection
    });
    this.generateTileUrlFunction_ = this.tileUrlFunction === UrlTile.prototype.tileUrlFunction;
    this.tileLoadFunction = options.tileLoadFunction;
    if (options.tileUrlFunction) {
      this.tileUrlFunction = options.tileUrlFunction;
    }
    this.urls = null;
    if (options.urls) {
      this.setUrls(options.urls);
    } else if (options.url) {
      this.setUrl(options.url);
    }
    this.tileLoadingKeys_ = {};
  }
  getTileLoadFunction() {
    return this.tileLoadFunction;
  }
  getTileUrlFunction() {
    return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction;
  }
  getUrls() {
    return this.urls;
  }
  handleTileChange(event) {
    const tile2 = event.target;
    const uid2 = getUid(tile2);
    const tileState = tile2.getState();
    let type;
    if (tileState == TileState.LOADING) {
      this.tileLoadingKeys_[uid2] = true;
      type = TileEventType.TILELOADSTART;
    } else if (uid2 in this.tileLoadingKeys_) {
      delete this.tileLoadingKeys_[uid2];
      type = tileState == TileState.ERROR ? TileEventType.TILELOADERROR : tileState == TileState.LOADED ? TileEventType.TILELOADEND : void 0;
    }
    if (type != void 0) {
      this.dispatchEvent(new TileSourceEvent(type, tile2));
    }
  }
  setTileLoadFunction(tileLoadFunction) {
    this.tileCache.clear();
    this.tileLoadFunction = tileLoadFunction;
    this.changed();
  }
  setTileUrlFunction(tileUrlFunction, key) {
    this.tileUrlFunction = tileUrlFunction;
    this.tileCache.pruneExceptNewestZ();
    if (typeof key !== "undefined") {
      this.setKey(key);
    } else {
      this.changed();
    }
  }
  setUrl(url) {
    const urls = expandUrl(url);
    this.urls = urls;
    this.setUrls(urls);
  }
  setUrls(urls) {
    this.urls = urls;
    const key = urls.join("\n");
    if (this.generateTileUrlFunction_) {
      this.setTileUrlFunction(createFromTemplates(urls, this.tileGrid), key);
    } else {
      this.setKey(key);
    }
  }
  tileUrlFunction(tileCoord, pixelRatio, projection) {
    return void 0;
  }
  useTile(z2, x2, y2) {
    const tileCoordKey = getKeyZXY(z2, x2, y2);
    if (this.tileCache.containsKey(tileCoordKey)) {
      this.tileCache.get(tileCoordKey);
    }
  }
}
class TileImage extends UrlTile {
  constructor(options) {
    super({
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      opaque: options.opaque,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultTileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX,
      transition: options.transition,
      interpolate: options.interpolate !== void 0 ? options.interpolate : true,
      key: options.key,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection
    });
    this.crossOrigin = options.crossOrigin !== void 0 ? options.crossOrigin : null;
    this.tileClass = options.tileClass !== void 0 ? options.tileClass : ImageTile;
    this.tileCacheForProjection = {};
    this.tileGridForProjection = {};
    this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;
    this.renderReprojectionEdges_ = false;
  }
  canExpireCache() {
    if (this.tileCache.canExpireCache()) {
      return true;
    }
    for (const key in this.tileCacheForProjection) {
      if (this.tileCacheForProjection[key].canExpireCache()) {
        return true;
      }
    }
    return false;
  }
  expireCache(projection, usedTiles) {
    const usedTileCache = this.getTileCacheForProjection(projection);
    this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});
    for (const id in this.tileCacheForProjection) {
      const tileCache = this.tileCacheForProjection[id];
      tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});
    }
  }
  getGutterForProjection(projection) {
    if (this.getProjection() && projection && !equivalent(this.getProjection(), projection)) {
      return 0;
    }
    return this.getGutter();
  }
  getGutter() {
    return 0;
  }
  getKey() {
    let key = super.getKey();
    if (!this.getInterpolate()) {
      key += ":disable-interpolation";
    }
    return key;
  }
  getOpaque(projection) {
    if (this.getProjection() && projection && !equivalent(this.getProjection(), projection)) {
      return false;
    }
    return super.getOpaque(projection);
  }
  getTileGridForProjection(projection) {
    const thisProj = this.getProjection();
    if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {
      return this.tileGrid;
    }
    const projKey = getUid(projection);
    if (!(projKey in this.tileGridForProjection)) {
      this.tileGridForProjection[projKey] = getForProjection(projection);
    }
    return this.tileGridForProjection[projKey];
  }
  getTileCacheForProjection(projection) {
    const thisProj = this.getProjection();
    if (!thisProj || equivalent(thisProj, projection)) {
      return this.tileCache;
    }
    const projKey = getUid(projection);
    if (!(projKey in this.tileCacheForProjection)) {
      this.tileCacheForProjection[projKey] = new TileCache(this.tileCache.highWaterMark);
    }
    return this.tileCacheForProjection[projKey];
  }
  createTile_(z2, x2, y2, pixelRatio, projection, key) {
    const tileCoord = [z2, x2, y2];
    const urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
    const tileUrl = urlTileCoord ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection) : void 0;
    const tile2 = new this.tileClass(tileCoord, tileUrl !== void 0 ? TileState.IDLE : TileState.EMPTY, tileUrl !== void 0 ? tileUrl : "", this.crossOrigin, this.tileLoadFunction, this.tileOptions);
    tile2.key = key;
    tile2.addEventListener(EventType.CHANGE, this.handleTileChange.bind(this));
    return tile2;
  }
  getTile(z2, x2, y2, pixelRatio, projection) {
    const sourceProjection = this.getProjection();
    if (!sourceProjection || !projection || equivalent(sourceProjection, projection)) {
      return this.getTileInternal(z2, x2, y2, pixelRatio, sourceProjection || projection);
    }
    const cache2 = this.getTileCacheForProjection(projection);
    const tileCoord = [z2, x2, y2];
    let tile2;
    const tileCoordKey = getKey(tileCoord);
    if (cache2.containsKey(tileCoordKey)) {
      tile2 = cache2.get(tileCoordKey);
    }
    const key = this.getKey();
    if (tile2 && tile2.key == key) {
      return tile2;
    }
    const sourceTileGrid = this.getTileGridForProjection(sourceProjection);
    const targetTileGrid = this.getTileGridForProjection(projection);
    const wrappedTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
    const newTile = new ReprojTile(sourceProjection, sourceTileGrid, projection, targetTileGrid, tileCoord, wrappedTileCoord, this.getTilePixelRatio(pixelRatio), this.getGutter(), (z3, x3, y3, pixelRatio2) => this.getTileInternal(z3, x3, y3, pixelRatio2, sourceProjection), this.reprojectionErrorThreshold_, this.renderReprojectionEdges_, this.getInterpolate());
    newTile.key = key;
    if (tile2) {
      newTile.interimTile = tile2;
      newTile.refreshInterimChain();
      cache2.replace(tileCoordKey, newTile);
    } else {
      cache2.set(tileCoordKey, newTile);
    }
    return newTile;
  }
  getTileInternal(z2, x2, y2, pixelRatio, projection) {
    let tile2 = null;
    const tileCoordKey = getKeyZXY(z2, x2, y2);
    const key = this.getKey();
    if (!this.tileCache.containsKey(tileCoordKey)) {
      tile2 = this.createTile_(z2, x2, y2, pixelRatio, projection, key);
      this.tileCache.set(tileCoordKey, tile2);
    } else {
      tile2 = this.tileCache.get(tileCoordKey);
      if (tile2.key != key) {
        const interimTile = tile2;
        tile2 = this.createTile_(z2, x2, y2, pixelRatio, projection, key);
        if (interimTile.getState() == TileState.IDLE) {
          tile2.interimTile = interimTile.interimTile;
        } else {
          tile2.interimTile = interimTile;
        }
        tile2.refreshInterimChain();
        this.tileCache.replace(tileCoordKey, tile2);
      }
    }
    return tile2;
  }
  setRenderReprojectionEdges(render2) {
    if (this.renderReprojectionEdges_ == render2) {
      return;
    }
    this.renderReprojectionEdges_ = render2;
    for (const id in this.tileCacheForProjection) {
      this.tileCacheForProjection[id].clear();
    }
    this.changed();
  }
  setTileGridForProjection(projection, tilegrid) {
    const proj = get$4(projection);
    if (proj) {
      const projKey = getUid(proj);
      if (!(projKey in this.tileGridForProjection)) {
        this.tileGridForProjection[projKey] = tilegrid;
      }
    }
  }
  clear() {
    super.clear();
    for (const id in this.tileCacheForProjection) {
      this.tileCacheForProjection[id].clear();
    }
  }
}
function defaultTileLoadFunction(imageTile, src) {
  imageTile.getImage().src = src;
}
function jsonp(url, callback, errback, callbackParam) {
  const script = document.createElement("script");
  const key = "olc_" + getUid(callback);
  function cleanup() {
    delete window[key];
    script.parentNode.removeChild(script);
  }
  script.async = true;
  script.src = url + (url.includes("?") ? "&" : "?") + (callbackParam || "callback") + "=" + key;
  const timer = setTimeout(function() {
    cleanup();
    if (errback) {
      errback();
    }
  }, 1e4);
  window[key] = function(data2) {
    clearTimeout(timer);
    cleanup();
    callback(data2);
  };
  document.head.appendChild(script);
}
function quadKey(tileCoord) {
  const z2 = tileCoord[0];
  const digits = new Array(z2);
  let mask = 1 << z2 - 1;
  let i2, charCode;
  for (i2 = 0; i2 < z2; ++i2) {
    charCode = 48;
    if (tileCoord[1] & mask) {
      charCode += 1;
    }
    if (tileCoord[2] & mask) {
      charCode += 2;
    }
    digits[i2] = String.fromCharCode(charCode);
    mask >>= 1;
  }
  return digits.join("");
}
const TOS_ATTRIBUTION = '<a class="ol-attribution-bing-tos" href="https://www.microsoft.com/maps/product/terms.html" target="_blank">Terms of Use</a>';
class BingMaps extends TileImage {
  constructor(options) {
    const hidpi = options.hidpi !== void 0 ? options.hidpi : false;
    super({
      cacheSize: options.cacheSize,
      crossOrigin: "anonymous",
      interpolate: options.interpolate,
      opaque: true,
      projection: get$4("EPSG:3857"),
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      state: "loading",
      tileLoadFunction: options.tileLoadFunction,
      tilePixelRatio: hidpi ? 2 : 1,
      wrapX: options.wrapX !== void 0 ? options.wrapX : true,
      transition: options.transition,
      zDirection: options.zDirection
    });
    this.hidpi_ = hidpi;
    this.culture_ = options.culture !== void 0 ? options.culture : "en-us";
    this.maxZoom_ = options.maxZoom !== void 0 ? options.maxZoom : -1;
    this.apiKey_ = options.key;
    this.imagerySet_ = options.imagerySet;
    const url = "https://dev.virtualearth.net/REST/v1/Imagery/Metadata/" + this.imagerySet_ + "?uriScheme=https&include=ImageryProviders&key=" + this.apiKey_ + "&c=" + this.culture_;
    jsonp(url, this.handleImageryMetadataResponse.bind(this), void 0, "jsonp");
  }
  getApiKey() {
    return this.apiKey_;
  }
  getImagerySet() {
    return this.imagerySet_;
  }
  handleImageryMetadataResponse(response) {
    if (response.statusCode != 200 || response.statusDescription != "OK" || response.authenticationResultCode != "ValidCredentials" || response.resourceSets.length != 1 || response.resourceSets[0].resources.length != 1) {
      this.setState("error");
      return;
    }
    const resource = response.resourceSets[0].resources[0];
    const maxZoom = this.maxZoom_ == -1 ? resource.zoomMax : this.maxZoom_;
    const sourceProjection = this.getProjection();
    const extent2 = extentFromProjection(sourceProjection);
    const scale2 = this.hidpi_ ? 2 : 1;
    const tileSize = resource.imageWidth == resource.imageHeight ? resource.imageWidth / scale2 : [resource.imageWidth / scale2, resource.imageHeight / scale2];
    const tileGrid = createXYZ({
      extent: extent2,
      minZoom: resource.zoomMin,
      maxZoom,
      tileSize
    });
    this.tileGrid = tileGrid;
    const culture = this.culture_;
    const hidpi = this.hidpi_;
    this.tileUrlFunction = createFromTileUrlFunctions(resource.imageUrlSubdomains.map(function(subdomain) {
      const quadKeyTileCoord = [0, 0, 0];
      const imageUrl = resource.imageUrl.replace("{subdomain}", subdomain).replace("{culture}", culture);
      return function(tileCoord, pixelRatio, projection) {
        if (!tileCoord) {
          return void 0;
        }
        createOrUpdate(tileCoord[0], tileCoord[1], tileCoord[2], quadKeyTileCoord);
        let url = imageUrl;
        if (hidpi) {
          url += "&dpi=d1&device=mobile";
        }
        return url.replace("{quadkey}", quadKey(quadKeyTileCoord));
      };
    }));
    if (resource.imageryProviders) {
      const transform2 = getTransformFromProjections(get$4("EPSG:4326"), this.getProjection());
      this.setAttributions((frameState) => {
        const attributions = [];
        const viewState = frameState.viewState;
        const tileGrid2 = this.getTileGrid();
        const z2 = tileGrid2.getZForResolution(viewState.resolution, this.zDirection);
        const tileCoord = tileGrid2.getTileCoordForCoordAndZ(viewState.center, z2);
        const zoom = tileCoord[0];
        resource.imageryProviders.map(function(imageryProvider) {
          let intersecting = false;
          const coverageAreas = imageryProvider.coverageAreas;
          for (let i2 = 0, ii = coverageAreas.length; i2 < ii; ++i2) {
            const coverageArea = coverageAreas[i2];
            if (zoom >= coverageArea.zoomMin && zoom <= coverageArea.zoomMax) {
              const bbox2 = coverageArea.bbox;
              const epsg4326Extent = [bbox2[1], bbox2[0], bbox2[3], bbox2[2]];
              const extent3 = applyTransform(epsg4326Extent, transform2);
              if (intersects$2(extent3, frameState.extent)) {
                intersecting = true;
                break;
              }
            }
          }
          if (intersecting) {
            attributions.push(imageryProvider.attribution);
          }
        });
        attributions.push(TOS_ATTRIBUTION);
        return attributions;
      });
    }
    this.setState("ready");
  }
}
class XYZ extends TileImage {
  constructor(options) {
    options = options || {};
    const projection = options.projection !== void 0 ? options.projection : "EPSG:3857";
    const tileGrid = options.tileGrid !== void 0 ? options.tileGrid : createXYZ({
      extent: extentFromProjection(projection),
      maxResolution: options.maxResolution,
      maxZoom: options.maxZoom,
      minZoom: options.minZoom,
      tileSize: options.tileSize
    });
    super({
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      interpolate: options.interpolate,
      opaque: options.opaque,
      projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX !== void 0 ? options.wrapX : true,
      transition: options.transition,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection
    });
    this.gutter_ = options.gutter !== void 0 ? options.gutter : 0;
  }
  getGutter() {
    return this.gutter_;
  }
}
class RBush {
  constructor(maxEntries) {
    this.rbush_ = new RBush$1(maxEntries);
    this.items_ = {};
  }
  insert(extent2, value) {
    const item = {
      minX: extent2[0],
      minY: extent2[1],
      maxX: extent2[2],
      maxY: extent2[3],
      value
    };
    this.rbush_.insert(item);
    this.items_[getUid(value)] = item;
  }
  load(extents, values3) {
    const items = new Array(values3.length);
    for (let i2 = 0, l2 = values3.length; i2 < l2; i2++) {
      const extent2 = extents[i2];
      const value = values3[i2];
      const item = {
        minX: extent2[0],
        minY: extent2[1],
        maxX: extent2[2],
        maxY: extent2[3],
        value
      };
      items[i2] = item;
      this.items_[getUid(value)] = item;
    }
    this.rbush_.load(items);
  }
  remove(value) {
    const uid2 = getUid(value);
    const item = this.items_[uid2];
    delete this.items_[uid2];
    return this.rbush_.remove(item) !== null;
  }
  update(extent2, value) {
    const item = this.items_[getUid(value)];
    const bbox2 = [item.minX, item.minY, item.maxX, item.maxY];
    if (!equals$2(bbox2, extent2)) {
      this.remove(value);
      this.insert(extent2, value);
    }
  }
  getAll() {
    const items = this.rbush_.all();
    return items.map(function(item) {
      return item.value;
    });
  }
  getInExtent(extent2) {
    const bbox2 = {
      minX: extent2[0],
      minY: extent2[1],
      maxX: extent2[2],
      maxY: extent2[3]
    };
    const items = this.rbush_.search(bbox2);
    return items.map(function(item) {
      return item.value;
    });
  }
  forEach(callback) {
    return this.forEach_(this.getAll(), callback);
  }
  forEachInExtent(extent2, callback) {
    return this.forEach_(this.getInExtent(extent2), callback);
  }
  forEach_(values3, callback) {
    let result;
    for (let i2 = 0, l2 = values3.length; i2 < l2; i2++) {
      result = callback(values3[i2]);
      if (result) {
        return result;
      }
    }
    return result;
  }
  isEmpty() {
    return isEmpty$1(this.items_);
  }
  clear() {
    this.rbush_.clear();
    this.items_ = {};
  }
  getExtent(extent2) {
    const data2 = this.rbush_.toJSON();
    return createOrUpdate$2(data2.minX, data2.minY, data2.maxX, data2.maxY, extent2);
  }
  concat(rbush) {
    this.rbush_.load(rbush.rbush_.all());
    for (const i2 in rbush.items_) {
      this.items_[i2] = rbush.items_[i2];
    }
  }
}
var VectorEventType = {
  ADDFEATURE: "addfeature",
  CHANGEFEATURE: "changefeature",
  CLEAR: "clear",
  REMOVEFEATURE: "removefeature",
  FEATURESLOADSTART: "featuresloadstart",
  FEATURESLOADEND: "featuresloadend",
  FEATURESLOADERROR: "featuresloaderror"
};
function all(extent2, resolution) {
  return [[-Infinity, -Infinity, Infinity, Infinity]];
}
function bbox$1(extent2, resolution) {
  return [extent2];
}
function tile(tileGrid) {
  return function(extent2, resolution, projection) {
    const z2 = tileGrid.getZForResolution(fromUserResolution(resolution));
    const tileRange = tileGrid.getTileRangeForExtentAndZ(fromUserExtent(extent2), z2);
    const extents = [];
    const tileCoord = [z2, 0, 0];
    for (tileCoord[1] = tileRange.minX; tileCoord[1] <= tileRange.maxX; ++tileCoord[1]) {
      for (tileCoord[2] = tileRange.minY; tileCoord[2] <= tileRange.maxY; ++tileCoord[2]) {
        extents.push(toUserExtent(tileGrid.getTileCoordExtent(tileCoord)));
      }
    }
    return extents;
  };
}
var loadingstrategy = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  all,
  bbox: bbox$1,
  tile
}, Symbol.toStringTag, { value: "Module" }));
let withCredentials = false;
function loadFeaturesXhr(url, format2, extent2, resolution, projection, success, failure) {
  const xhr2 = new XMLHttpRequest();
  xhr2.open("GET", typeof url === "function" ? url(extent2, resolution, projection) : url, true);
  if (format2.getType() == "arraybuffer") {
    xhr2.responseType = "arraybuffer";
  }
  xhr2.withCredentials = withCredentials;
  xhr2.onload = function(event) {
    if (!xhr2.status || xhr2.status >= 200 && xhr2.status < 300) {
      const type = format2.getType();
      let source;
      if (type == "json" || type == "text") {
        source = xhr2.responseText;
      } else if (type == "xml") {
        source = xhr2.responseXML;
        if (!source) {
          source = new DOMParser().parseFromString(xhr2.responseText, "application/xml");
        }
      } else if (type == "arraybuffer") {
        source = xhr2.response;
      }
      if (source) {
        success(format2.readFeatures(source, {
          extent: extent2,
          featureProjection: projection
        }), format2.readProjection(source));
      } else {
        failure();
      }
    } else {
      failure();
    }
  };
  xhr2.onerror = failure;
  xhr2.send();
}
function xhr(url, format2) {
  return function(extent2, resolution, projection, success, failure) {
    const source = this;
    loadFeaturesXhr(url, format2, extent2, resolution, projection, function(features, dataProjection) {
      source.addFeatures(features);
      if (success !== void 0) {
        success(features);
      }
    }, failure ? failure : VOID);
  };
}
class VectorSourceEvent extends BaseEvent {
  constructor(type, feature, features) {
    super(type);
    this.feature = feature;
    this.features = features;
  }
}
class VectorSource extends Source {
  constructor(options) {
    options = options || {};
    super({
      attributions: options.attributions,
      interpolate: true,
      projection: void 0,
      state: "ready",
      wrapX: options.wrapX !== void 0 ? options.wrapX : true
    });
    this.on;
    this.once;
    this.un;
    this.loader_ = VOID;
    this.format_ = options.format;
    this.overlaps_ = options.overlaps === void 0 ? true : options.overlaps;
    this.url_ = options.url;
    if (options.loader !== void 0) {
      this.loader_ = options.loader;
    } else if (this.url_ !== void 0) {
      assert(this.format_, 7);
      this.loader_ = xhr(this.url_, this.format_);
    }
    this.strategy_ = options.strategy !== void 0 ? options.strategy : all;
    const useSpatialIndex = options.useSpatialIndex !== void 0 ? options.useSpatialIndex : true;
    this.featuresRtree_ = useSpatialIndex ? new RBush() : null;
    this.loadedExtentsRtree_ = new RBush();
    this.loadingExtentsCount_ = 0;
    this.nullGeometryFeatures_ = {};
    this.idIndex_ = {};
    this.uidIndex_ = {};
    this.featureChangeKeys_ = {};
    this.featuresCollection_ = null;
    let collection;
    let features;
    if (Array.isArray(options.features)) {
      features = options.features;
    } else if (options.features) {
      collection = options.features;
      features = collection.getArray();
    }
    if (!useSpatialIndex && collection === void 0) {
      collection = new Collection(features);
    }
    if (features !== void 0) {
      this.addFeaturesInternal(features);
    }
    if (collection !== void 0) {
      this.bindFeaturesCollection_(collection);
    }
  }
  addFeature(feature) {
    this.addFeatureInternal(feature);
    this.changed();
  }
  addFeatureInternal(feature) {
    const featureKey = getUid(feature);
    if (!this.addToIndex_(featureKey, feature)) {
      if (this.featuresCollection_) {
        this.featuresCollection_.remove(feature);
      }
      return;
    }
    this.setupChangeEvents_(featureKey, feature);
    const geometry = feature.getGeometry();
    if (geometry) {
      const extent2 = geometry.getExtent();
      if (this.featuresRtree_) {
        this.featuresRtree_.insert(extent2, feature);
      }
    } else {
      this.nullGeometryFeatures_[featureKey] = feature;
    }
    this.dispatchEvent(new VectorSourceEvent(VectorEventType.ADDFEATURE, feature));
  }
  setupChangeEvents_(featureKey, feature) {
    this.featureChangeKeys_[featureKey] = [
      listen(feature, EventType.CHANGE, this.handleFeatureChange_, this),
      listen(feature, ObjectEventType.PROPERTYCHANGE, this.handleFeatureChange_, this)
    ];
  }
  addToIndex_(featureKey, feature) {
    let valid = true;
    const id = feature.getId();
    if (id !== void 0) {
      if (!(id.toString() in this.idIndex_)) {
        this.idIndex_[id.toString()] = feature;
      } else {
        valid = false;
      }
    }
    if (valid) {
      assert(!(featureKey in this.uidIndex_), 30);
      this.uidIndex_[featureKey] = feature;
    }
    return valid;
  }
  addFeatures(features) {
    this.addFeaturesInternal(features);
    this.changed();
  }
  addFeaturesInternal(features) {
    const extents = [];
    const newFeatures = [];
    const geometryFeatures = [];
    for (let i2 = 0, length = features.length; i2 < length; i2++) {
      const feature = features[i2];
      const featureKey = getUid(feature);
      if (this.addToIndex_(featureKey, feature)) {
        newFeatures.push(feature);
      }
    }
    for (let i2 = 0, length = newFeatures.length; i2 < length; i2++) {
      const feature = newFeatures[i2];
      const featureKey = getUid(feature);
      this.setupChangeEvents_(featureKey, feature);
      const geometry = feature.getGeometry();
      if (geometry) {
        const extent2 = geometry.getExtent();
        extents.push(extent2);
        geometryFeatures.push(feature);
      } else {
        this.nullGeometryFeatures_[featureKey] = feature;
      }
    }
    if (this.featuresRtree_) {
      this.featuresRtree_.load(extents, geometryFeatures);
    }
    if (this.hasListener(VectorEventType.ADDFEATURE)) {
      for (let i2 = 0, length = newFeatures.length; i2 < length; i2++) {
        this.dispatchEvent(new VectorSourceEvent(VectorEventType.ADDFEATURE, newFeatures[i2]));
      }
    }
  }
  bindFeaturesCollection_(collection) {
    let modifyingCollection = false;
    this.addEventListener(VectorEventType.ADDFEATURE, function(evt) {
      if (!modifyingCollection) {
        modifyingCollection = true;
        collection.push(evt.feature);
        modifyingCollection = false;
      }
    });
    this.addEventListener(VectorEventType.REMOVEFEATURE, function(evt) {
      if (!modifyingCollection) {
        modifyingCollection = true;
        collection.remove(evt.feature);
        modifyingCollection = false;
      }
    });
    collection.addEventListener(CollectionEventType.ADD, (evt) => {
      if (!modifyingCollection) {
        modifyingCollection = true;
        this.addFeature(evt.element);
        modifyingCollection = false;
      }
    });
    collection.addEventListener(CollectionEventType.REMOVE, (evt) => {
      if (!modifyingCollection) {
        modifyingCollection = true;
        this.removeFeature(evt.element);
        modifyingCollection = false;
      }
    });
    this.featuresCollection_ = collection;
  }
  clear(fast) {
    if (fast) {
      for (const featureId in this.featureChangeKeys_) {
        const keys3 = this.featureChangeKeys_[featureId];
        keys3.forEach(unlistenByKey);
      }
      if (!this.featuresCollection_) {
        this.featureChangeKeys_ = {};
        this.idIndex_ = {};
        this.uidIndex_ = {};
      }
    } else {
      if (this.featuresRtree_) {
        const removeAndIgnoreReturn = (feature) => {
          this.removeFeatureInternal(feature);
        };
        this.featuresRtree_.forEach(removeAndIgnoreReturn);
        for (const id in this.nullGeometryFeatures_) {
          this.removeFeatureInternal(this.nullGeometryFeatures_[id]);
        }
      }
    }
    if (this.featuresCollection_) {
      this.featuresCollection_.clear();
    }
    if (this.featuresRtree_) {
      this.featuresRtree_.clear();
    }
    this.nullGeometryFeatures_ = {};
    const clearEvent = new VectorSourceEvent(VectorEventType.CLEAR);
    this.dispatchEvent(clearEvent);
    this.changed();
  }
  forEachFeature(callback) {
    if (this.featuresRtree_) {
      return this.featuresRtree_.forEach(callback);
    } else if (this.featuresCollection_) {
      this.featuresCollection_.forEach(callback);
    }
  }
  forEachFeatureAtCoordinateDirect(coordinate, callback) {
    const extent2 = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];
    return this.forEachFeatureInExtent(extent2, function(feature) {
      const geometry = feature.getGeometry();
      if (geometry.intersectsCoordinate(coordinate)) {
        return callback(feature);
      }
      return void 0;
    });
  }
  forEachFeatureInExtent(extent2, callback) {
    if (this.featuresRtree_) {
      return this.featuresRtree_.forEachInExtent(extent2, callback);
    } else if (this.featuresCollection_) {
      this.featuresCollection_.forEach(callback);
    }
  }
  forEachFeatureIntersectingExtent(extent2, callback) {
    return this.forEachFeatureInExtent(extent2, function(feature) {
      const geometry = feature.getGeometry();
      if (geometry.intersectsExtent(extent2)) {
        const result = callback(feature);
        if (result) {
          return result;
        }
      }
    });
  }
  getFeaturesCollection() {
    return this.featuresCollection_;
  }
  getFeatures() {
    let features;
    if (this.featuresCollection_) {
      features = this.featuresCollection_.getArray().slice(0);
    } else if (this.featuresRtree_) {
      features = this.featuresRtree_.getAll();
      if (!isEmpty$1(this.nullGeometryFeatures_)) {
        extend$3(features, Object.values(this.nullGeometryFeatures_));
      }
    }
    return features;
  }
  getFeaturesAtCoordinate(coordinate) {
    const features = [];
    this.forEachFeatureAtCoordinateDirect(coordinate, function(feature) {
      features.push(feature);
    });
    return features;
  }
  getFeaturesInExtent(extent2, projection) {
    if (this.featuresRtree_) {
      const multiWorld = projection && projection.canWrapX() && this.getWrapX();
      if (!multiWorld) {
        return this.featuresRtree_.getInExtent(extent2);
      }
      const extents = wrapAndSliceX(extent2, projection);
      return [].concat(...extents.map((anExtent) => this.featuresRtree_.getInExtent(anExtent)));
    } else if (this.featuresCollection_) {
      return this.featuresCollection_.getArray().slice(0);
    }
    return [];
  }
  getClosestFeatureToCoordinate(coordinate, filter) {
    const x2 = coordinate[0];
    const y2 = coordinate[1];
    let closestFeature = null;
    const closestPoint = [NaN, NaN];
    let minSquaredDistance = Infinity;
    const extent2 = [-Infinity, -Infinity, Infinity, Infinity];
    filter = filter ? filter : TRUE;
    this.featuresRtree_.forEachInExtent(extent2, function(feature) {
      if (filter(feature)) {
        const geometry = feature.getGeometry();
        const previousMinSquaredDistance = minSquaredDistance;
        minSquaredDistance = geometry.closestPointXY(x2, y2, closestPoint, minSquaredDistance);
        if (minSquaredDistance < previousMinSquaredDistance) {
          closestFeature = feature;
          const minDistance = Math.sqrt(minSquaredDistance);
          extent2[0] = x2 - minDistance;
          extent2[1] = y2 - minDistance;
          extent2[2] = x2 + minDistance;
          extent2[3] = y2 + minDistance;
        }
      }
    });
    return closestFeature;
  }
  getExtent(extent2) {
    return this.featuresRtree_.getExtent(extent2);
  }
  getFeatureById(id) {
    const feature = this.idIndex_[id.toString()];
    return feature !== void 0 ? feature : null;
  }
  getFeatureByUid(uid2) {
    const feature = this.uidIndex_[uid2];
    return feature !== void 0 ? feature : null;
  }
  getFormat() {
    return this.format_;
  }
  getOverlaps() {
    return this.overlaps_;
  }
  getUrl() {
    return this.url_;
  }
  handleFeatureChange_(event) {
    const feature = event.target;
    const featureKey = getUid(feature);
    const geometry = feature.getGeometry();
    if (!geometry) {
      if (!(featureKey in this.nullGeometryFeatures_)) {
        if (this.featuresRtree_) {
          this.featuresRtree_.remove(feature);
        }
        this.nullGeometryFeatures_[featureKey] = feature;
      }
    } else {
      const extent2 = geometry.getExtent();
      if (featureKey in this.nullGeometryFeatures_) {
        delete this.nullGeometryFeatures_[featureKey];
        if (this.featuresRtree_) {
          this.featuresRtree_.insert(extent2, feature);
        }
      } else {
        if (this.featuresRtree_) {
          this.featuresRtree_.update(extent2, feature);
        }
      }
    }
    const id = feature.getId();
    if (id !== void 0) {
      const sid = id.toString();
      if (this.idIndex_[sid] !== feature) {
        this.removeFromIdIndex_(feature);
        this.idIndex_[sid] = feature;
      }
    } else {
      this.removeFromIdIndex_(feature);
      this.uidIndex_[featureKey] = feature;
    }
    this.changed();
    this.dispatchEvent(new VectorSourceEvent(VectorEventType.CHANGEFEATURE, feature));
  }
  hasFeature(feature) {
    const id = feature.getId();
    if (id !== void 0) {
      return id in this.idIndex_;
    }
    return getUid(feature) in this.uidIndex_;
  }
  isEmpty() {
    if (this.featuresRtree_) {
      return this.featuresRtree_.isEmpty() && isEmpty$1(this.nullGeometryFeatures_);
    }
    if (this.featuresCollection_) {
      return this.featuresCollection_.getLength() === 0;
    }
    return true;
  }
  loadFeatures(extent2, resolution, projection) {
    const loadedExtentsRtree = this.loadedExtentsRtree_;
    const extentsToLoad = this.strategy_(extent2, resolution, projection);
    for (let i2 = 0, ii = extentsToLoad.length; i2 < ii; ++i2) {
      const extentToLoad = extentsToLoad[i2];
      const alreadyLoaded = loadedExtentsRtree.forEachInExtent(extentToLoad, function(object) {
        return containsExtent(object.extent, extentToLoad);
      });
      if (!alreadyLoaded) {
        ++this.loadingExtentsCount_;
        this.dispatchEvent(new VectorSourceEvent(VectorEventType.FEATURESLOADSTART));
        this.loader_.call(this, extentToLoad, resolution, projection, (features) => {
          --this.loadingExtentsCount_;
          this.dispatchEvent(new VectorSourceEvent(VectorEventType.FEATURESLOADEND, void 0, features));
        }, () => {
          --this.loadingExtentsCount_;
          this.dispatchEvent(new VectorSourceEvent(VectorEventType.FEATURESLOADERROR));
        });
        loadedExtentsRtree.insert(extentToLoad, { extent: extentToLoad.slice() });
      }
    }
    this.loading = this.loader_.length < 4 ? false : this.loadingExtentsCount_ > 0;
  }
  refresh() {
    this.clear(true);
    this.loadedExtentsRtree_.clear();
    super.refresh();
  }
  removeLoadedExtent(extent2) {
    const loadedExtentsRtree = this.loadedExtentsRtree_;
    let obj;
    loadedExtentsRtree.forEachInExtent(extent2, function(object) {
      if (equals$2(object.extent, extent2)) {
        obj = object;
        return true;
      }
    });
    if (obj) {
      loadedExtentsRtree.remove(obj);
    }
  }
  removeFeature(feature) {
    if (!feature) {
      return;
    }
    const featureKey = getUid(feature);
    if (featureKey in this.nullGeometryFeatures_) {
      delete this.nullGeometryFeatures_[featureKey];
    } else {
      if (this.featuresRtree_) {
        this.featuresRtree_.remove(feature);
      }
    }
    const result = this.removeFeatureInternal(feature);
    if (result) {
      this.changed();
    }
  }
  removeFeatureInternal(feature) {
    const featureKey = getUid(feature);
    const featureChangeKeys = this.featureChangeKeys_[featureKey];
    if (!featureChangeKeys) {
      return;
    }
    featureChangeKeys.forEach(unlistenByKey);
    delete this.featureChangeKeys_[featureKey];
    const id = feature.getId();
    if (id !== void 0) {
      delete this.idIndex_[id.toString()];
    }
    delete this.uidIndex_[featureKey];
    this.dispatchEvent(new VectorSourceEvent(VectorEventType.REMOVEFEATURE, feature));
    return feature;
  }
  removeFromIdIndex_(feature) {
    let removed = false;
    for (const id in this.idIndex_) {
      if (this.idIndex_[id] === feature) {
        delete this.idIndex_[id];
        removed = true;
        break;
      }
    }
    return removed;
  }
  setLoader(loader) {
    this.loader_ = loader;
  }
  setUrl(url) {
    assert(this.format_, 7);
    this.url_ = url;
    this.setLoader(xhr(url, this.format_));
  }
}
class Cluster extends VectorSource {
  constructor(options) {
    super({
      attributions: options.attributions,
      wrapX: options.wrapX
    });
    this.resolution = void 0;
    this.distance = options.distance !== void 0 ? options.distance : 20;
    this.minDistance = options.minDistance || 0;
    this.interpolationRatio = 0;
    this.features = [];
    this.geometryFunction = options.geometryFunction || function(feature) {
      const geometry = feature.getGeometry();
      assert(geometry.getType() == "Point", 10);
      return geometry;
    };
    this.createCustomCluster_ = options.createCluster;
    this.source = null;
    this.boundRefresh_ = this.refresh.bind(this);
    this.updateDistance(this.distance, this.minDistance);
    this.setSource(options.source || null);
  }
  clear(fast) {
    this.features.length = 0;
    super.clear(fast);
  }
  getDistance() {
    return this.distance;
  }
  getSource() {
    return this.source;
  }
  loadFeatures(extent2, resolution, projection) {
    this.source.loadFeatures(extent2, resolution, projection);
    if (resolution !== this.resolution) {
      this.resolution = resolution;
      this.refresh();
    }
  }
  setDistance(distance2) {
    this.updateDistance(distance2, this.minDistance);
  }
  setMinDistance(minDistance) {
    this.updateDistance(this.distance, minDistance);
  }
  getMinDistance() {
    return this.minDistance;
  }
  setSource(source) {
    if (this.source) {
      this.source.removeEventListener(EventType.CHANGE, this.boundRefresh_);
    }
    this.source = source;
    if (source) {
      source.addEventListener(EventType.CHANGE, this.boundRefresh_);
    }
    this.refresh();
  }
  refresh() {
    this.clear();
    this.cluster();
    this.addFeatures(this.features);
  }
  updateDistance(distance2, minDistance) {
    const ratio = distance2 === 0 ? 0 : Math.min(minDistance, distance2) / distance2;
    const changed = distance2 !== this.distance || this.interpolationRatio !== ratio;
    this.distance = distance2;
    this.minDistance = minDistance;
    this.interpolationRatio = ratio;
    if (changed) {
      this.refresh();
    }
  }
  cluster() {
    if (this.resolution === void 0 || !this.source) {
      return;
    }
    const extent2 = createEmpty();
    const mapDistance = this.distance * this.resolution;
    const features = this.source.getFeatures();
    const clustered = {};
    for (let i2 = 0, ii = features.length; i2 < ii; i2++) {
      const feature = features[i2];
      if (!(getUid(feature) in clustered)) {
        const geometry = this.geometryFunction(feature);
        if (geometry) {
          const coordinates2 = geometry.getCoordinates();
          createOrUpdateFromCoordinate(coordinates2, extent2);
          buffer$2(extent2, mapDistance, extent2);
          const neighbors = this.source.getFeaturesInExtent(extent2).filter(function(neighbor) {
            const uid2 = getUid(neighbor);
            if (uid2 in clustered) {
              return false;
            }
            clustered[uid2] = true;
            return true;
          });
          this.features.push(this.createCluster(neighbors, extent2));
        }
      }
    }
  }
  createCluster(features, extent2) {
    const centroid2 = [0, 0];
    for (let i2 = features.length - 1; i2 >= 0; --i2) {
      const geometry2 = this.geometryFunction(features[i2]);
      if (geometry2) {
        add$3(centroid2, geometry2.getCoordinates());
      } else {
        features.splice(i2, 1);
      }
    }
    scale$2(centroid2, 1 / features.length);
    const searchCenter = getCenter(extent2);
    const ratio = this.interpolationRatio;
    const geometry = new Point$3([
      centroid2[0] * (1 - ratio) + searchCenter[0] * ratio,
      centroid2[1] * (1 - ratio) + searchCenter[1] * ratio
    ]);
    if (this.createCustomCluster_) {
      return this.createCustomCluster_(geometry, features);
    }
    return new Feature$1({
      geometry,
      features
    });
  }
}
class DataTileSource extends TileSource {
  constructor(options) {
    const projection = options.projection === void 0 ? "EPSG:3857" : options.projection;
    let tileGrid = options.tileGrid;
    if (tileGrid === void 0 && projection) {
      tileGrid = createXYZ({
        extent: extentFromProjection(projection),
        maxResolution: options.maxResolution,
        maxZoom: options.maxZoom,
        minZoom: options.minZoom,
        tileSize: options.tileSize
      });
    }
    super({
      cacheSize: 0.1,
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      projection,
      tileGrid,
      opaque: options.opaque,
      state: options.state,
      wrapX: options.wrapX,
      transition: options.transition,
      interpolate: options.interpolate
    });
    this.gutter_ = options.gutter !== void 0 ? options.gutter : 0;
    this.tileSize_ = options.tileSize ? toSize(options.tileSize) : null;
    this.tileSizes_ = null;
    this.tileLoadingKeys_ = {};
    this.loader_ = options.loader;
    this.handleTileChange_ = this.handleTileChange_.bind(this);
    this.bandCount = options.bandCount === void 0 ? 4 : options.bandCount;
    this.tileGridForProjection_ = {};
    this.tileCacheForProjection_ = {};
  }
  setTileSizes(tileSizes) {
    this.tileSizes_ = tileSizes;
  }
  getTileSize(z2) {
    if (this.tileSizes_) {
      return this.tileSizes_[z2];
    }
    if (this.tileSize_) {
      return this.tileSize_;
    }
    const tileGrid = this.getTileGrid();
    return tileGrid ? toSize(tileGrid.getTileSize(z2)) : [256, 256];
  }
  getGutterForProjection(projection) {
    const thisProj = this.getProjection();
    if (!thisProj || equivalent(thisProj, projection)) {
      return this.gutter_;
    }
    return 0;
  }
  setLoader(loader) {
    this.loader_ = loader;
  }
  getReprojTile_(z2, x2, y2, targetProjection, sourceProjection) {
    const cache2 = this.getTileCacheForProjection(targetProjection);
    const tileCoordKey = getKeyZXY(z2, x2, y2);
    if (cache2.containsKey(tileCoordKey)) {
      const tile2 = cache2.get(tileCoordKey);
      if (tile2 && tile2.key == this.getKey()) {
        return tile2;
      }
    }
    const tileGrid = this.getTileGrid();
    const reprojTilePixelRatio = Math.max.apply(null, tileGrid.getResolutions().map((r2, z3) => {
      const tileSize = toSize(tileGrid.getTileSize(z3));
      const textureSize = this.getTileSize(z3);
      return Math.max(textureSize[0] / tileSize[0], textureSize[1] / tileSize[1]);
    }));
    const sourceTileGrid = this.getTileGridForProjection(sourceProjection);
    const targetTileGrid = this.getTileGridForProjection(targetProjection);
    const tileCoord = [z2, x2, y2];
    const wrappedTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, targetProjection);
    const newTile = new ReprojDataTile(sourceProjection, sourceTileGrid, targetProjection, targetTileGrid, tileCoord, wrappedTileCoord, reprojTilePixelRatio, this.getGutterForProjection(sourceProjection), (z3, x3, y3, pixelRatio) => this.getTile(z3, x3, y3, pixelRatio, sourceProjection), this.getInterpolate());
    newTile.key = this.getKey();
    return newTile;
  }
  getTile(z2, x2, y2, pixelRatio, projection) {
    const sourceProjection = this.getProjection();
    if (sourceProjection && projection && !equivalent(sourceProjection, projection)) {
      return this.getReprojTile_(z2, x2, y2, projection, sourceProjection);
    }
    const size = this.getTileSize(z2);
    const tileCoordKey = getKeyZXY(z2, x2, y2);
    if (this.tileCache.containsKey(tileCoordKey)) {
      return this.tileCache.get(tileCoordKey);
    }
    const sourceLoader = this.loader_;
    function loader() {
      return toPromise(function() {
        return sourceLoader(z2, x2, y2);
      });
    }
    const options = Object.assign({
      tileCoord: [z2, x2, y2],
      loader,
      size
    }, this.tileOptions);
    const tile2 = new DataTile(options);
    tile2.key = this.getKey();
    tile2.addEventListener(EventType.CHANGE, this.handleTileChange_);
    this.tileCache.set(tileCoordKey, tile2);
    return tile2;
  }
  handleTileChange_(event) {
    const tile2 = event.target;
    const uid2 = getUid(tile2);
    const tileState = tile2.getState();
    let type;
    if (tileState == TileState.LOADING) {
      this.tileLoadingKeys_[uid2] = true;
      type = TileEventType.TILELOADSTART;
    } else if (uid2 in this.tileLoadingKeys_) {
      delete this.tileLoadingKeys_[uid2];
      type = tileState == TileState.ERROR ? TileEventType.TILELOADERROR : tileState == TileState.LOADED ? TileEventType.TILELOADEND : void 0;
    }
    if (type) {
      this.dispatchEvent(new TileSourceEvent(type, tile2));
    }
  }
  getTileGridForProjection(projection) {
    const thisProj = this.getProjection();
    if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {
      return this.tileGrid;
    }
    const projKey = getUid(projection);
    if (!(projKey in this.tileGridForProjection_)) {
      this.tileGridForProjection_[projKey] = getForProjection(projection);
    }
    return this.tileGridForProjection_[projKey];
  }
  setTileGridForProjection(projection, tilegrid) {
    const proj = get$4(projection);
    if (proj) {
      const projKey = getUid(proj);
      if (!(projKey in this.tileGridForProjection_)) {
        this.tileGridForProjection_[projKey] = tilegrid;
      }
    }
  }
  getTileCacheForProjection(projection) {
    const thisProj = this.getProjection();
    if (!thisProj || equivalent(thisProj, projection)) {
      return this.tileCache;
    }
    const projKey = getUid(projection);
    if (!(projKey in this.tileCacheForProjection_)) {
      this.tileCacheForProjection_[projKey] = new TileCache(0.1);
    }
    return this.tileCacheForProjection_[projKey];
  }
  expireCache(projection, usedTiles) {
    const usedTileCache = this.getTileCacheForProjection(projection);
    this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});
    for (const id in this.tileCacheForProjection_) {
      const tileCache = this.tileCacheForProjection_[id];
      tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});
    }
  }
  clear() {
    super.clear();
    for (const id in this.tileCacheForProjection_) {
      this.tileCacheForProjection_[id].clear();
    }
  }
}
function uncurryThis$r(target) {
  return (thisArg, ...args) => {
    return ReflectApply(target, thisArg, args);
  };
}
function uncurryThisGetter(target, key) {
  return uncurryThis$r(ReflectGetOwnPropertyDescriptor(target, key).get);
}
const {
  apply: ReflectApply,
  construct: ReflectConstruct,
  defineProperty: ReflectDefineProperty,
  get: ReflectGet,
  getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor,
  getPrototypeOf: ReflectGetPrototypeOf,
  has: ReflectHas,
  ownKeys: ReflectOwnKeys,
  set: ReflectSet,
  setPrototypeOf: ReflectSetPrototypeOf
} = Reflect;
const {
  iterator: SymbolIterator,
  species: SymbolSpecies,
  toStringTag: SymbolToStringTag,
  for: SymbolFor
} = Symbol;
const NativeObject = Object;
const {
  create: ObjectCreate,
  defineProperty: ObjectDefineProperty,
  freeze: ObjectFreeze,
  is: ObjectIs
} = NativeObject;
const NativeArray = Array;
const ArrayPrototype$2 = NativeArray.prototype;
const NativeArrayPrototypeSymbolIterator = ArrayPrototype$2[SymbolIterator];
const ArrayPrototypeSymbolIterator = uncurryThis$r(NativeArrayPrototypeSymbolIterator);
const NativeArrayBuffer = ArrayBuffer;
const ArrayBufferPrototype = NativeArrayBuffer.prototype;
uncurryThisGetter(ArrayBufferPrototype, "byteLength");
const NativeSharedArrayBuffer = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : null;
NativeSharedArrayBuffer && uncurryThisGetter(NativeSharedArrayBuffer.prototype, "byteLength");
const TypedArray = ReflectGetPrototypeOf(Uint8Array);
TypedArray.from;
const TypedArrayPrototype = TypedArray.prototype;
TypedArrayPrototype[SymbolIterator];
uncurryThis$r(TypedArrayPrototype.keys);
uncurryThis$r(TypedArrayPrototype.values);
uncurryThis$r(TypedArrayPrototype.entries);
uncurryThis$r(TypedArrayPrototype.set);
uncurryThis$r(TypedArrayPrototype.reverse);
uncurryThis$r(TypedArrayPrototype.fill);
uncurryThis$r(TypedArrayPrototype.copyWithin);
uncurryThis$r(TypedArrayPrototype.sort);
uncurryThis$r(TypedArrayPrototype.slice);
uncurryThis$r(TypedArrayPrototype.subarray);
uncurryThisGetter(TypedArrayPrototype, "buffer");
uncurryThisGetter(TypedArrayPrototype, "byteOffset");
uncurryThisGetter(TypedArrayPrototype, "length");
uncurryThisGetter(TypedArrayPrototype, SymbolToStringTag);
const NativeUint32Array = Uint32Array;
const NativeFloat32Array = Float32Array;
const ArrayIteratorPrototype = ReflectGetPrototypeOf([][SymbolIterator]());
const ArrayIteratorPrototypeNext = uncurryThis$r(ArrayIteratorPrototype.next);
const GeneratorPrototypeNext = uncurryThis$r(function* () {
}().next);
const IteratorPrototype$3 = ReflectGetPrototypeOf(ArrayIteratorPrototype);
const DataViewPrototype = DataView.prototype;
const DataViewPrototypeGetUint16 = uncurryThis$r(DataViewPrototype.getUint16);
const NativeWeakMap = WeakMap;
const WeakMapPrototype = NativeWeakMap.prototype;
const WeakMapPrototypeGet = uncurryThis$r(WeakMapPrototype.get);
const WeakMapPrototypeSet = uncurryThis$r(WeakMapPrototype.set);
const arrayIterators = new NativeWeakMap();
const SafeIteratorPrototype = ObjectCreate(null, {
  next: {
    value: function next() {
      const arrayIterator2 = WeakMapPrototypeGet(arrayIterators, this);
      return ArrayIteratorPrototypeNext(arrayIterator2);
    }
  },
  [SymbolIterator]: {
    value: function values() {
      return this;
    }
  }
});
function safeIfNeeded(array) {
  if (array[SymbolIterator] === NativeArrayPrototypeSymbolIterator) {
    return array;
  }
  const safe = ObjectCreate(SafeIteratorPrototype);
  WeakMapPrototypeSet(arrayIterators, safe, ArrayPrototypeSymbolIterator(array));
  return safe;
}
const generators = new NativeWeakMap();
const DummyArrayIteratorPrototype = ObjectCreate(IteratorPrototype$3, {
  next: {
    value: function next2() {
      const generator = WeakMapPrototypeGet(generators, this);
      return GeneratorPrototypeNext(generator);
    },
    writable: true,
    configurable: true
  }
});
for (const key of ReflectOwnKeys(ArrayIteratorPrototype)) {
  if (key === "next") {
    continue;
  }
  ObjectDefineProperty(DummyArrayIteratorPrototype, key, ReflectGetOwnPropertyDescriptor(ArrayIteratorPrototype, key));
}
const buffer = new NativeArrayBuffer(4);
const floatView = new NativeFloat32Array(buffer);
const uint32View = new NativeUint32Array(buffer);
const baseTable = new NativeUint32Array(512);
const shiftTable = new NativeUint32Array(512);
for (let i2 = 0; i2 < 256; ++i2) {
  const e2 = i2 - 127;
  if (e2 < -27) {
    baseTable[i2] = 0;
    baseTable[i2 | 256] = 32768;
    shiftTable[i2] = 24;
    shiftTable[i2 | 256] = 24;
  } else if (e2 < -14) {
    baseTable[i2] = 1024 >> -e2 - 14;
    baseTable[i2 | 256] = 1024 >> -e2 - 14 | 32768;
    shiftTable[i2] = -e2 - 1;
    shiftTable[i2 | 256] = -e2 - 1;
  } else if (e2 <= 15) {
    baseTable[i2] = e2 + 15 << 10;
    baseTable[i2 | 256] = e2 + 15 << 10 | 32768;
    shiftTable[i2] = 13;
    shiftTable[i2 | 256] = 13;
  } else if (e2 < 128) {
    baseTable[i2] = 31744;
    baseTable[i2 | 256] = 64512;
    shiftTable[i2] = 24;
    shiftTable[i2 | 256] = 24;
  } else {
    baseTable[i2] = 31744;
    baseTable[i2 | 256] = 64512;
    shiftTable[i2] = 13;
    shiftTable[i2 | 256] = 13;
  }
}
const mantissaTable = new NativeUint32Array(2048);
const exponentTable = new NativeUint32Array(64);
const offsetTable = new NativeUint32Array(64);
for (let i2 = 1; i2 < 1024; ++i2) {
  let m2 = i2 << 13;
  let e2 = 0;
  while ((m2 & 8388608) === 0) {
    m2 <<= 1;
    e2 -= 8388608;
  }
  m2 &= ~8388608;
  e2 += 947912704;
  mantissaTable[i2] = m2 | e2;
}
for (let i2 = 1024; i2 < 2048; ++i2) {
  mantissaTable[i2] = 939524096 + (i2 - 1024 << 13);
}
for (let i2 = 1; i2 < 31; ++i2) {
  exponentTable[i2] = i2 << 23;
}
exponentTable[31] = 1199570944;
exponentTable[32] = 2147483648;
for (let i2 = 33; i2 < 63; ++i2) {
  exponentTable[i2] = 2147483648 + (i2 - 32 << 23);
}
exponentTable[63] = 3347054592;
for (let i2 = 1; i2 < 64; ++i2) {
  if (i2 !== 32) {
    offsetTable[i2] = 1024;
  }
}
function convertToNumber(float16bits) {
  const m2 = float16bits >> 10;
  uint32View[0] = mantissaTable[offsetTable[m2] + (float16bits & 1023)] + exponentTable[m2];
  return floatView[0];
}
function getFloat16(dataView, byteOffset, ...opts) {
  return convertToNumber(DataViewPrototypeGetUint16(dataView, byteOffset, ...safeIfNeeded(opts)));
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var a2 = Object.defineProperty({}, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a2;
}
var getAttribute$2 = { exports: {} };
function getAttribute(tag, attributeName, options) {
  const debug = options && options.debug || false;
  if (debug)
    console.log("getting " + attributeName + " in " + tag);
  const xml2 = typeof tag === "object" ? tag.outer : tag;
  const pattern = `${attributeName}\\="([^"]*)"`;
  if (debug)
    console.log("pattern:", pattern);
  const re2 = new RegExp(pattern);
  const match2 = re2.exec(xml2);
  if (debug)
    console.log("match:", match2);
  if (match2)
    return match2[1];
}
getAttribute$2.exports = getAttribute;
getAttribute$2.exports.default = getAttribute;
var getAttribute$1 = getAttribute$2.exports;
var findTagsByName$2 = { exports: {} };
var findTagByName$2 = { exports: {} };
var indexOfMatch$2 = { exports: {} };
function indexOfMatch$1(xml2, pattern, startIndex) {
  const re2 = new RegExp(pattern);
  const match2 = re2.exec(xml2.slice(startIndex));
  if (match2)
    return startIndex + match2.index;
  else
    return -1;
}
indexOfMatch$2.exports = indexOfMatch$1;
indexOfMatch$2.exports.default = indexOfMatch$1;
var indexOfMatchEnd$2 = { exports: {} };
function indexOfMatchEnd$1(xml2, pattern, startIndex) {
  const re2 = new RegExp(pattern);
  const match2 = re2.exec(xml2.slice(startIndex));
  if (match2)
    return startIndex + match2.index + match2[0].length - 1;
  else
    return -1;
}
indexOfMatchEnd$2.exports = indexOfMatchEnd$1;
indexOfMatchEnd$2.exports.default = indexOfMatchEnd$1;
var countSubstring$2 = { exports: {} };
function countSubstring$1(string, substring) {
  const pattern = new RegExp(substring, "g");
  const match2 = string.match(pattern);
  return match2 ? match2.length : 0;
}
countSubstring$2.exports = countSubstring$1;
countSubstring$2.exports.default = countSubstring$1;
const indexOfMatch = indexOfMatch$2.exports;
const indexOfMatchEnd = indexOfMatchEnd$2.exports;
const countSubstring = countSubstring$2.exports;
function findTagByName$1(xml2, tagName, options) {
  const debug = options && options.debug || false;
  const nested = !(options && typeof options.nested === false);
  const startIndex = options && options.startIndex || 0;
  if (debug)
    console.log("[xml-utils] starting findTagByName with", tagName, " and ", options);
  const start2 = indexOfMatch(xml2, `<${tagName}[ >/]`, startIndex);
  if (debug)
    console.log("[xml-utils] start:", start2);
  if (start2 === -1)
    return void 0;
  const afterStart = xml2.slice(start2 + tagName.length);
  let relativeEnd = indexOfMatchEnd(afterStart, "^[^<]*[ /]>", 0);
  const selfClosing = relativeEnd !== -1 && afterStart[relativeEnd - 1] === "/";
  if (debug)
    console.log("[xml-utils] selfClosing:", selfClosing);
  if (selfClosing === false) {
    if (nested) {
      let startIndex2 = 0;
      let openings = 1;
      let closings = 0;
      while ((relativeEnd = indexOfMatchEnd(afterStart, "[ /]" + tagName + ">", startIndex2)) !== -1) {
        const clip = afterStart.substring(startIndex2, relativeEnd + 1);
        openings += countSubstring(clip, "<" + tagName);
        closings += countSubstring(clip, "/" + tagName + ">");
        if (closings >= openings)
          break;
        startIndex2 = relativeEnd;
      }
    } else {
      relativeEnd = indexOfMatchEnd(afterStart, "[ /]" + tagName + ">", 0);
    }
  }
  const end = start2 + tagName.length + relativeEnd + 1;
  if (debug)
    console.log("[xml-utils] end:", end);
  if (end === -1)
    return void 0;
  const outer = xml2.slice(start2, end);
  let inner;
  if (selfClosing) {
    inner = null;
  } else {
    inner = outer.slice(outer.indexOf(">") + 1, outer.lastIndexOf("<"));
  }
  return { inner, outer, start: start2, end };
}
findTagByName$2.exports = findTagByName$1;
findTagByName$2.exports.default = findTagByName$1;
const findTagByName = findTagByName$2.exports;
function findTagsByName(xml2, tagName, options) {
  const tags = [];
  const debug = options && options.debug || false;
  const nested = options && typeof options.nested === "boolean" ? options.nested : true;
  let startIndex = options && options.startIndex || 0;
  let tag;
  while (tag = findTagByName(xml2, tagName, { debug, startIndex })) {
    if (nested) {
      startIndex = tag.start + 1 + tagName.length;
    } else {
      startIndex = tag.end;
    }
    tags.push(tag);
  }
  if (debug)
    console.log("findTagsByName found", tags.length, "tags");
  return tags;
}
findTagsByName$2.exports = findTagsByName;
findTagsByName$2.exports.default = findTagsByName;
var findTagsByName$1 = findTagsByName$2.exports;
const fieldTagNames = {
  315: "Artist",
  258: "BitsPerSample",
  265: "CellLength",
  264: "CellWidth",
  320: "ColorMap",
  259: "Compression",
  33432: "Copyright",
  306: "DateTime",
  338: "ExtraSamples",
  266: "FillOrder",
  289: "FreeByteCounts",
  288: "FreeOffsets",
  291: "GrayResponseCurve",
  290: "GrayResponseUnit",
  316: "HostComputer",
  270: "ImageDescription",
  257: "ImageLength",
  256: "ImageWidth",
  271: "Make",
  281: "MaxSampleValue",
  280: "MinSampleValue",
  272: "Model",
  254: "NewSubfileType",
  274: "Orientation",
  262: "PhotometricInterpretation",
  284: "PlanarConfiguration",
  296: "ResolutionUnit",
  278: "RowsPerStrip",
  277: "SamplesPerPixel",
  305: "Software",
  279: "StripByteCounts",
  273: "StripOffsets",
  255: "SubfileType",
  263: "Threshholding",
  282: "XResolution",
  283: "YResolution",
  326: "BadFaxLines",
  327: "CleanFaxData",
  343: "ClipPath",
  328: "ConsecutiveBadFaxLines",
  433: "Decode",
  434: "DefaultImageColor",
  269: "DocumentName",
  336: "DotRange",
  321: "HalftoneHints",
  346: "Indexed",
  347: "JPEGTables",
  285: "PageName",
  297: "PageNumber",
  317: "Predictor",
  319: "PrimaryChromaticities",
  532: "ReferenceBlackWhite",
  339: "SampleFormat",
  340: "SMinSampleValue",
  341: "SMaxSampleValue",
  559: "StripRowCounts",
  330: "SubIFDs",
  292: "T4Options",
  293: "T6Options",
  325: "TileByteCounts",
  323: "TileLength",
  324: "TileOffsets",
  322: "TileWidth",
  301: "TransferFunction",
  318: "WhitePoint",
  344: "XClipPathUnits",
  286: "XPosition",
  529: "YCbCrCoefficients",
  531: "YCbCrPositioning",
  530: "YCbCrSubSampling",
  345: "YClipPathUnits",
  287: "YPosition",
  37378: "ApertureValue",
  40961: "ColorSpace",
  36868: "DateTimeDigitized",
  36867: "DateTimeOriginal",
  34665: "Exif IFD",
  36864: "ExifVersion",
  33434: "ExposureTime",
  41728: "FileSource",
  37385: "Flash",
  40960: "FlashpixVersion",
  33437: "FNumber",
  42016: "ImageUniqueID",
  37384: "LightSource",
  37500: "MakerNote",
  37377: "ShutterSpeedValue",
  37510: "UserComment",
  33723: "IPTC",
  34675: "ICC Profile",
  700: "XMP",
  42112: "GDAL_METADATA",
  42113: "GDAL_NODATA",
  34377: "Photoshop",
  33550: "ModelPixelScale",
  33922: "ModelTiepoint",
  34264: "ModelTransformation",
  34735: "GeoKeyDirectory",
  34736: "GeoDoubleParams",
  34737: "GeoAsciiParams",
  50674: "LercParameters"
};
const fieldTags = {};
for (const key in fieldTagNames) {
  if (fieldTagNames.hasOwnProperty(key)) {
    fieldTags[fieldTagNames[key]] = parseInt(key, 10);
  }
}
const arrayFields = [
  fieldTags.BitsPerSample,
  fieldTags.ExtraSamples,
  fieldTags.SampleFormat,
  fieldTags.StripByteCounts,
  fieldTags.StripOffsets,
  fieldTags.StripRowCounts,
  fieldTags.TileByteCounts,
  fieldTags.TileOffsets,
  fieldTags.SubIFDs
];
const fieldTypeNames = {
  1: "BYTE",
  2: "ASCII",
  3: "SHORT",
  4: "LONG",
  5: "RATIONAL",
  6: "SBYTE",
  7: "UNDEFINED",
  8: "SSHORT",
  9: "SLONG",
  10: "SRATIONAL",
  11: "FLOAT",
  12: "DOUBLE",
  13: "IFD",
  16: "LONG8",
  17: "SLONG8",
  18: "IFD8"
};
const fieldTypes = {};
for (const key in fieldTypeNames) {
  if (fieldTypeNames.hasOwnProperty(key)) {
    fieldTypes[fieldTypeNames[key]] = parseInt(key, 10);
  }
}
const photometricInterpretations = {
  WhiteIsZero: 0,
  BlackIsZero: 1,
  RGB: 2,
  Palette: 3,
  TransparencyMask: 4,
  CMYK: 5,
  YCbCr: 6,
  CIELab: 8,
  ICCLab: 9
};
const ExtraSamplesValues = {
  Unspecified: 0,
  Assocalpha: 1,
  Unassalpha: 2
};
const LercParameters = {
  Version: 0,
  AddCompression: 1
};
const LercAddCompression = {
  None: 0,
  Deflate: 1
};
const geoKeyNames = {
  1024: "GTModelTypeGeoKey",
  1025: "GTRasterTypeGeoKey",
  1026: "GTCitationGeoKey",
  2048: "GeographicTypeGeoKey",
  2049: "GeogCitationGeoKey",
  2050: "GeogGeodeticDatumGeoKey",
  2051: "GeogPrimeMeridianGeoKey",
  2052: "GeogLinearUnitsGeoKey",
  2053: "GeogLinearUnitSizeGeoKey",
  2054: "GeogAngularUnitsGeoKey",
  2055: "GeogAngularUnitSizeGeoKey",
  2056: "GeogEllipsoidGeoKey",
  2057: "GeogSemiMajorAxisGeoKey",
  2058: "GeogSemiMinorAxisGeoKey",
  2059: "GeogInvFlatteningGeoKey",
  2060: "GeogAzimuthUnitsGeoKey",
  2061: "GeogPrimeMeridianLongGeoKey",
  2062: "GeogTOWGS84GeoKey",
  3072: "ProjectedCSTypeGeoKey",
  3073: "PCSCitationGeoKey",
  3074: "ProjectionGeoKey",
  3075: "ProjCoordTransGeoKey",
  3076: "ProjLinearUnitsGeoKey",
  3077: "ProjLinearUnitSizeGeoKey",
  3078: "ProjStdParallel1GeoKey",
  3079: "ProjStdParallel2GeoKey",
  3080: "ProjNatOriginLongGeoKey",
  3081: "ProjNatOriginLatGeoKey",
  3082: "ProjFalseEastingGeoKey",
  3083: "ProjFalseNorthingGeoKey",
  3084: "ProjFalseOriginLongGeoKey",
  3085: "ProjFalseOriginLatGeoKey",
  3086: "ProjFalseOriginEastingGeoKey",
  3087: "ProjFalseOriginNorthingGeoKey",
  3088: "ProjCenterLongGeoKey",
  3089: "ProjCenterLatGeoKey",
  3090: "ProjCenterEastingGeoKey",
  3091: "ProjCenterNorthingGeoKey",
  3092: "ProjScaleAtNatOriginGeoKey",
  3093: "ProjScaleAtCenterGeoKey",
  3094: "ProjAzimuthAngleGeoKey",
  3095: "ProjStraightVertPoleLongGeoKey",
  3096: "ProjRectifiedGridAngleGeoKey",
  4096: "VerticalCSTypeGeoKey",
  4097: "VerticalCitationGeoKey",
  4098: "VerticalDatumGeoKey",
  4099: "VerticalUnitsGeoKey"
};
function fromWhiteIsZero(raster, max2) {
  const { width, height } = raster;
  const rgbRaster = new Uint8Array(width * height * 3);
  let value;
  for (let i2 = 0, j2 = 0; i2 < raster.length; ++i2, j2 += 3) {
    value = 256 - raster[i2] / max2 * 256;
    rgbRaster[j2] = value;
    rgbRaster[j2 + 1] = value;
    rgbRaster[j2 + 2] = value;
  }
  return rgbRaster;
}
function fromBlackIsZero(raster, max2) {
  const { width, height } = raster;
  const rgbRaster = new Uint8Array(width * height * 3);
  let value;
  for (let i2 = 0, j2 = 0; i2 < raster.length; ++i2, j2 += 3) {
    value = raster[i2] / max2 * 256;
    rgbRaster[j2] = value;
    rgbRaster[j2 + 1] = value;
    rgbRaster[j2 + 2] = value;
  }
  return rgbRaster;
}
function fromPalette(raster, colorMap) {
  const { width, height } = raster;
  const rgbRaster = new Uint8Array(width * height * 3);
  const greenOffset = colorMap.length / 3;
  const blueOffset = colorMap.length / 3 * 2;
  for (let i2 = 0, j2 = 0; i2 < raster.length; ++i2, j2 += 3) {
    const mapIndex = raster[i2];
    rgbRaster[j2] = colorMap[mapIndex] / 65536 * 256;
    rgbRaster[j2 + 1] = colorMap[mapIndex + greenOffset] / 65536 * 256;
    rgbRaster[j2 + 2] = colorMap[mapIndex + blueOffset] / 65536 * 256;
  }
  return rgbRaster;
}
function fromCMYK(cmykRaster) {
  const { width, height } = cmykRaster;
  const rgbRaster = new Uint8Array(width * height * 3);
  for (let i2 = 0, j2 = 0; i2 < cmykRaster.length; i2 += 4, j2 += 3) {
    const c2 = cmykRaster[i2];
    const m2 = cmykRaster[i2 + 1];
    const y2 = cmykRaster[i2 + 2];
    const k2 = cmykRaster[i2 + 3];
    rgbRaster[j2] = 255 * ((255 - c2) / 256) * ((255 - k2) / 256);
    rgbRaster[j2 + 1] = 255 * ((255 - m2) / 256) * ((255 - k2) / 256);
    rgbRaster[j2 + 2] = 255 * ((255 - y2) / 256) * ((255 - k2) / 256);
  }
  return rgbRaster;
}
function fromYCbCr(yCbCrRaster) {
  const { width, height } = yCbCrRaster;
  const rgbRaster = new Uint8ClampedArray(width * height * 3);
  for (let i2 = 0, j2 = 0; i2 < yCbCrRaster.length; i2 += 3, j2 += 3) {
    const y2 = yCbCrRaster[i2];
    const cb = yCbCrRaster[i2 + 1];
    const cr = yCbCrRaster[i2 + 2];
    rgbRaster[j2] = y2 + 1.402 * (cr - 128);
    rgbRaster[j2 + 1] = y2 - 0.34414 * (cb - 128) - 0.71414 * (cr - 128);
    rgbRaster[j2 + 2] = y2 + 1.772 * (cb - 128);
  }
  return rgbRaster;
}
const Xn = 0.95047;
const Yn = 1;
const Zn = 1.08883;
function fromCIELab(cieLabRaster) {
  const { width, height } = cieLabRaster;
  const rgbRaster = new Uint8Array(width * height * 3);
  for (let i2 = 0, j2 = 0; i2 < cieLabRaster.length; i2 += 3, j2 += 3) {
    const L2 = cieLabRaster[i2 + 0];
    const a_ = cieLabRaster[i2 + 1] << 24 >> 24;
    const b_ = cieLabRaster[i2 + 2] << 24 >> 24;
    let y2 = (L2 + 16) / 116;
    let x2 = a_ / 500 + y2;
    let z2 = y2 - b_ / 200;
    let r2;
    let g2;
    let b2;
    x2 = Xn * (x2 * x2 * x2 > 8856e-6 ? x2 * x2 * x2 : (x2 - 16 / 116) / 7.787);
    y2 = Yn * (y2 * y2 * y2 > 8856e-6 ? y2 * y2 * y2 : (y2 - 16 / 116) / 7.787);
    z2 = Zn * (z2 * z2 * z2 > 8856e-6 ? z2 * z2 * z2 : (z2 - 16 / 116) / 7.787);
    r2 = x2 * 3.2406 + y2 * -1.5372 + z2 * -0.4986;
    g2 = x2 * -0.9689 + y2 * 1.8758 + z2 * 0.0415;
    b2 = x2 * 0.0557 + y2 * -0.204 + z2 * 1.057;
    r2 = r2 > 31308e-7 ? 1.055 * r2 ** (1 / 2.4) - 0.055 : 12.92 * r2;
    g2 = g2 > 31308e-7 ? 1.055 * g2 ** (1 / 2.4) - 0.055 : 12.92 * g2;
    b2 = b2 > 31308e-7 ? 1.055 * b2 ** (1 / 2.4) - 0.055 : 12.92 * b2;
    rgbRaster[j2] = Math.max(0, Math.min(1, r2)) * 255;
    rgbRaster[j2 + 1] = Math.max(0, Math.min(1, g2)) * 255;
    rgbRaster[j2 + 2] = Math.max(0, Math.min(1, b2)) * 255;
  }
  return rgbRaster;
}
const registry = /* @__PURE__ */ new Map();
function addDecoder(cases, importFn) {
  if (!Array.isArray(cases)) {
    cases = [cases];
  }
  cases.forEach((c2) => registry.set(c2, importFn));
}
async function getDecoder(fileDirectory) {
  const importFn = registry.get(fileDirectory.Compression);
  if (!importFn) {
    throw new Error(`Unknown compression method identifier: ${fileDirectory.Compression}`);
  }
  const Decoder = await importFn();
  return new Decoder(fileDirectory);
}
addDecoder([void 0, 1], () => Promise.resolve().then(function() {
  return raw;
}).then((m2) => m2.default));
addDecoder(5, () => Promise.resolve().then(function() {
  return lzw;
}).then((m2) => m2.default));
addDecoder(6, () => {
  throw new Error("old style JPEG compression is not supported.");
});
addDecoder(7, () => Promise.resolve().then(function() {
  return jpeg;
}).then((m2) => m2.default));
addDecoder([8, 32946], () => Promise.resolve().then(function() {
  return deflate;
}).then((m2) => m2.default));
addDecoder(32773, () => Promise.resolve().then(function() {
  return packbits;
}).then((m2) => m2.default));
addDecoder(34887, () => Promise.resolve().then(function() {
  return lerc;
}).then((m2) => m2.default));
addDecoder(50001, () => Promise.resolve().then(function() {
  return webimage;
}).then((m2) => m2.default));
function copyNewSize(array, width, height, samplesPerPixel = 1) {
  return new (Object.getPrototypeOf(array)).constructor(width * height * samplesPerPixel);
}
function resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight) {
  const relX = inWidth / outWidth;
  const relY = inHeight / outHeight;
  return valueArrays.map((array) => {
    const newArray = copyNewSize(array, outWidth, outHeight);
    for (let y2 = 0; y2 < outHeight; ++y2) {
      const cy = Math.min(Math.round(relY * y2), inHeight - 1);
      for (let x2 = 0; x2 < outWidth; ++x2) {
        const cx = Math.min(Math.round(relX * x2), inWidth - 1);
        const value = array[cy * inWidth + cx];
        newArray[y2 * outWidth + x2] = value;
      }
    }
    return newArray;
  });
}
function lerp$1(v0, v1, t3) {
  return (1 - t3) * v0 + t3 * v1;
}
function resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight) {
  const relX = inWidth / outWidth;
  const relY = inHeight / outHeight;
  return valueArrays.map((array) => {
    const newArray = copyNewSize(array, outWidth, outHeight);
    for (let y2 = 0; y2 < outHeight; ++y2) {
      const rawY = relY * y2;
      const yl = Math.floor(rawY);
      const yh = Math.min(Math.ceil(rawY), inHeight - 1);
      for (let x2 = 0; x2 < outWidth; ++x2) {
        const rawX = relX * x2;
        const tx = rawX % 1;
        const xl = Math.floor(rawX);
        const xh = Math.min(Math.ceil(rawX), inWidth - 1);
        const ll = array[yl * inWidth + xl];
        const hl = array[yl * inWidth + xh];
        const lh = array[yh * inWidth + xl];
        const hh = array[yh * inWidth + xh];
        const value = lerp$1(lerp$1(ll, hl, tx), lerp$1(lh, hh, tx), rawY % 1);
        newArray[y2 * outWidth + x2] = value;
      }
    }
    return newArray;
  });
}
function resample(valueArrays, inWidth, inHeight, outWidth, outHeight, method = "nearest") {
  switch (method.toLowerCase()) {
    case "nearest":
      return resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight);
    case "bilinear":
    case "linear":
      return resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight);
    default:
      throw new Error(`Unsupported resampling method: '${method}'`);
  }
}
function resampleNearestInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples) {
  const relX = inWidth / outWidth;
  const relY = inHeight / outHeight;
  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);
  for (let y2 = 0; y2 < outHeight; ++y2) {
    const cy = Math.min(Math.round(relY * y2), inHeight - 1);
    for (let x2 = 0; x2 < outWidth; ++x2) {
      const cx = Math.min(Math.round(relX * x2), inWidth - 1);
      for (let i2 = 0; i2 < samples; ++i2) {
        const value = valueArray[cy * inWidth * samples + cx * samples + i2];
        newArray[y2 * outWidth * samples + x2 * samples + i2] = value;
      }
    }
  }
  return newArray;
}
function resampleBilinearInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples) {
  const relX = inWidth / outWidth;
  const relY = inHeight / outHeight;
  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);
  for (let y2 = 0; y2 < outHeight; ++y2) {
    const rawY = relY * y2;
    const yl = Math.floor(rawY);
    const yh = Math.min(Math.ceil(rawY), inHeight - 1);
    for (let x2 = 0; x2 < outWidth; ++x2) {
      const rawX = relX * x2;
      const tx = rawX % 1;
      const xl = Math.floor(rawX);
      const xh = Math.min(Math.ceil(rawX), inWidth - 1);
      for (let i2 = 0; i2 < samples; ++i2) {
        const ll = valueArray[yl * inWidth * samples + xl * samples + i2];
        const hl = valueArray[yl * inWidth * samples + xh * samples + i2];
        const lh = valueArray[yh * inWidth * samples + xl * samples + i2];
        const hh = valueArray[yh * inWidth * samples + xh * samples + i2];
        const value = lerp$1(lerp$1(ll, hl, tx), lerp$1(lh, hh, tx), rawY % 1);
        newArray[y2 * outWidth * samples + x2 * samples + i2] = value;
      }
    }
  }
  return newArray;
}
function resampleInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples, method = "nearest") {
  switch (method.toLowerCase()) {
    case "nearest":
      return resampleNearestInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples);
    case "bilinear":
    case "linear":
      return resampleBilinearInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples);
    default:
      throw new Error(`Unsupported resampling method: '${method}'`);
  }
}
function sum(array, start2, end) {
  let s2 = 0;
  for (let i2 = start2; i2 < end; ++i2) {
    s2 += array[i2];
  }
  return s2;
}
function arrayForType(format2, bitsPerSample, size) {
  switch (format2) {
    case 1:
      if (bitsPerSample <= 8) {
        return new Uint8Array(size);
      } else if (bitsPerSample <= 16) {
        return new Uint16Array(size);
      } else if (bitsPerSample <= 32) {
        return new Uint32Array(size);
      }
      break;
    case 2:
      if (bitsPerSample === 8) {
        return new Int8Array(size);
      } else if (bitsPerSample === 16) {
        return new Int16Array(size);
      } else if (bitsPerSample === 32) {
        return new Int32Array(size);
      }
      break;
    case 3:
      switch (bitsPerSample) {
        case 16:
        case 32:
          return new Float32Array(size);
        case 64:
          return new Float64Array(size);
      }
      break;
  }
  throw Error("Unsupported data format/bitsPerSample");
}
function needsNormalization(format2, bitsPerSample) {
  if ((format2 === 1 || format2 === 2) && bitsPerSample <= 32 && bitsPerSample % 8 === 0) {
    return false;
  } else if (format2 === 3 && (bitsPerSample === 16 || bitsPerSample === 32 || bitsPerSample === 64)) {
    return false;
  }
  return true;
}
function normalizeArray(inBuffer, format2, planarConfiguration, samplesPerPixel, bitsPerSample, tileWidth, tileHeight) {
  const view = new DataView(inBuffer);
  const outSize = planarConfiguration === 2 ? tileHeight * tileWidth : tileHeight * tileWidth * samplesPerPixel;
  const samplesToTransfer = planarConfiguration === 2 ? 1 : samplesPerPixel;
  const outArray = arrayForType(format2, bitsPerSample, outSize);
  const bitMask = parseInt("1".repeat(bitsPerSample), 2);
  if (format2 === 1) {
    let pixelBitSkip;
    if (planarConfiguration === 1) {
      pixelBitSkip = samplesPerPixel * bitsPerSample;
    } else {
      pixelBitSkip = bitsPerSample;
    }
    let bitsPerLine = tileWidth * pixelBitSkip;
    if ((bitsPerLine & 7) !== 0) {
      bitsPerLine = bitsPerLine + 7 & ~7;
    }
    for (let y2 = 0; y2 < tileHeight; ++y2) {
      const lineBitOffset = y2 * bitsPerLine;
      for (let x2 = 0; x2 < tileWidth; ++x2) {
        const pixelBitOffset = lineBitOffset + x2 * samplesToTransfer * bitsPerSample;
        for (let i2 = 0; i2 < samplesToTransfer; ++i2) {
          const bitOffset = pixelBitOffset + i2 * bitsPerSample;
          const outIndex = (y2 * tileWidth + x2) * samplesToTransfer + i2;
          const byteOffset = Math.floor(bitOffset / 8);
          const innerBitOffset = bitOffset % 8;
          if (innerBitOffset + bitsPerSample <= 8) {
            outArray[outIndex] = view.getUint8(byteOffset) >> 8 - bitsPerSample - innerBitOffset & bitMask;
          } else if (innerBitOffset + bitsPerSample <= 16) {
            outArray[outIndex] = view.getUint16(byteOffset) >> 16 - bitsPerSample - innerBitOffset & bitMask;
          } else if (innerBitOffset + bitsPerSample <= 24) {
            const raw2 = view.getUint16(byteOffset) << 8 | view.getUint8(byteOffset + 2);
            outArray[outIndex] = raw2 >> 24 - bitsPerSample - innerBitOffset & bitMask;
          } else {
            outArray[outIndex] = view.getUint32(byteOffset) >> 32 - bitsPerSample - innerBitOffset & bitMask;
          }
        }
      }
    }
  }
  return outArray.buffer;
}
class GeoTIFFImage {
  constructor(fileDirectory, geoKeys, dataView, littleEndian, cache2, source) {
    this.fileDirectory = fileDirectory;
    this.geoKeys = geoKeys;
    this.dataView = dataView;
    this.littleEndian = littleEndian;
    this.tiles = cache2 ? {} : null;
    this.isTiled = !fileDirectory.StripOffsets;
    const planarConfiguration = fileDirectory.PlanarConfiguration;
    this.planarConfiguration = typeof planarConfiguration === "undefined" ? 1 : planarConfiguration;
    if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) {
      throw new Error("Invalid planar configuration.");
    }
    this.source = source;
  }
  getFileDirectory() {
    return this.fileDirectory;
  }
  getGeoKeys() {
    return this.geoKeys;
  }
  getWidth() {
    return this.fileDirectory.ImageWidth;
  }
  getHeight() {
    return this.fileDirectory.ImageLength;
  }
  getSamplesPerPixel() {
    return typeof this.fileDirectory.SamplesPerPixel !== "undefined" ? this.fileDirectory.SamplesPerPixel : 1;
  }
  getTileWidth() {
    return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();
  }
  getTileHeight() {
    if (this.isTiled) {
      return this.fileDirectory.TileLength;
    }
    if (typeof this.fileDirectory.RowsPerStrip !== "undefined") {
      return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());
    }
    return this.getHeight();
  }
  getBlockWidth() {
    return this.getTileWidth();
  }
  getBlockHeight(y2) {
    if (this.isTiled || (y2 + 1) * this.getTileHeight() <= this.getHeight()) {
      return this.getTileHeight();
    } else {
      return this.getHeight() - y2 * this.getTileHeight();
    }
  }
  getBytesPerPixel() {
    let bytes = 0;
    for (let i2 = 0; i2 < this.fileDirectory.BitsPerSample.length; ++i2) {
      bytes += this.getSampleByteSize(i2);
    }
    return bytes;
  }
  getSampleByteSize(i2) {
    if (i2 >= this.fileDirectory.BitsPerSample.length) {
      throw new RangeError(`Sample index ${i2} is out of range.`);
    }
    return Math.ceil(this.fileDirectory.BitsPerSample[i2] / 8);
  }
  getReaderForSample(sampleIndex) {
    const format2 = this.fileDirectory.SampleFormat ? this.fileDirectory.SampleFormat[sampleIndex] : 1;
    const bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];
    switch (format2) {
      case 1:
        if (bitsPerSample <= 8) {
          return DataView.prototype.getUint8;
        } else if (bitsPerSample <= 16) {
          return DataView.prototype.getUint16;
        } else if (bitsPerSample <= 32) {
          return DataView.prototype.getUint32;
        }
        break;
      case 2:
        if (bitsPerSample <= 8) {
          return DataView.prototype.getInt8;
        } else if (bitsPerSample <= 16) {
          return DataView.prototype.getInt16;
        } else if (bitsPerSample <= 32) {
          return DataView.prototype.getInt32;
        }
        break;
      case 3:
        switch (bitsPerSample) {
          case 16:
            return function(offset2, littleEndian) {
              return getFloat16(this, offset2, littleEndian);
            };
          case 32:
            return DataView.prototype.getFloat32;
          case 64:
            return DataView.prototype.getFloat64;
        }
        break;
    }
    throw Error("Unsupported data format/bitsPerSample");
  }
  getSampleFormat(sampleIndex = 0) {
    return this.fileDirectory.SampleFormat ? this.fileDirectory.SampleFormat[sampleIndex] : 1;
  }
  getBitsPerSample(sampleIndex = 0) {
    return this.fileDirectory.BitsPerSample[sampleIndex];
  }
  getArrayForSample(sampleIndex, size) {
    const format2 = this.getSampleFormat(sampleIndex);
    const bitsPerSample = this.getBitsPerSample(sampleIndex);
    return arrayForType(format2, bitsPerSample, size);
  }
  async getTileOrStrip(x2, y2, sample, poolOrDecoder, signal) {
    const numTilesPerRow = Math.ceil(this.getWidth() / this.getTileWidth());
    const numTilesPerCol = Math.ceil(this.getHeight() / this.getTileHeight());
    let index2;
    const { tiles } = this;
    if (this.planarConfiguration === 1) {
      index2 = y2 * numTilesPerRow + x2;
    } else if (this.planarConfiguration === 2) {
      index2 = sample * numTilesPerRow * numTilesPerCol + y2 * numTilesPerRow + x2;
    }
    let offset2;
    let byteCount;
    if (this.isTiled) {
      offset2 = this.fileDirectory.TileOffsets[index2];
      byteCount = this.fileDirectory.TileByteCounts[index2];
    } else {
      offset2 = this.fileDirectory.StripOffsets[index2];
      byteCount = this.fileDirectory.StripByteCounts[index2];
    }
    const slice2 = (await this.source.fetch([{ offset: offset2, length: byteCount }], signal))[0];
    let request;
    if (tiles === null || !tiles[index2]) {
      request = (async () => {
        let data2 = await poolOrDecoder.decode(this.fileDirectory, slice2);
        const sampleFormat = this.getSampleFormat();
        const bitsPerSample = this.getBitsPerSample();
        if (needsNormalization(sampleFormat, bitsPerSample)) {
          data2 = normalizeArray(data2, sampleFormat, this.planarConfiguration, this.getSamplesPerPixel(), bitsPerSample, this.getTileWidth(), this.getBlockHeight(y2));
        }
        return data2;
      })();
      if (tiles !== null) {
        tiles[index2] = request;
      }
    } else {
      request = tiles[index2];
    }
    return { x: x2, y: y2, sample, data: await request };
  }
  async _readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal) {
    const tileWidth = this.getTileWidth();
    const tileHeight = this.getTileHeight();
    const imageWidth = this.getWidth();
    const imageHeight = this.getHeight();
    const minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);
    const maxXTile = Math.min(Math.ceil(imageWindow[2] / tileWidth), Math.ceil(imageWidth / tileWidth));
    const minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);
    const maxYTile = Math.min(Math.ceil(imageWindow[3] / tileHeight), Math.ceil(imageHeight / tileHeight));
    const windowWidth = imageWindow[2] - imageWindow[0];
    let bytesPerPixel = this.getBytesPerPixel();
    const srcSampleOffsets = [];
    const sampleReaders = [];
    for (let i2 = 0; i2 < samples.length; ++i2) {
      if (this.planarConfiguration === 1) {
        srcSampleOffsets.push(sum(this.fileDirectory.BitsPerSample, 0, samples[i2]) / 8);
      } else {
        srcSampleOffsets.push(0);
      }
      sampleReaders.push(this.getReaderForSample(samples[i2]));
    }
    const promises = [];
    const { littleEndian } = this;
    for (let yTile = minYTile; yTile < maxYTile; ++yTile) {
      for (let xTile = minXTile; xTile < maxXTile; ++xTile) {
        for (let sampleIndex = 0; sampleIndex < samples.length; ++sampleIndex) {
          const si = sampleIndex;
          const sample = samples[sampleIndex];
          if (this.planarConfiguration === 2) {
            bytesPerPixel = this.getSampleByteSize(sampleIndex);
          }
          const promise2 = this.getTileOrStrip(xTile, yTile, sample, poolOrDecoder, signal);
          promises.push(promise2);
          promise2.then((tile2) => {
            const buffer2 = tile2.data;
            const dataView = new DataView(buffer2);
            const blockHeight = this.getBlockHeight(tile2.y);
            const firstLine = tile2.y * tileHeight;
            const firstCol = tile2.x * tileWidth;
            const lastLine = firstLine + blockHeight;
            const lastCol = (tile2.x + 1) * tileWidth;
            const reader = sampleReaders[si];
            const ymax = Math.min(blockHeight, blockHeight - (lastLine - imageWindow[3]), imageHeight - firstLine);
            const xmax = Math.min(tileWidth, tileWidth - (lastCol - imageWindow[2]), imageWidth - firstCol);
            for (let y2 = Math.max(0, imageWindow[1] - firstLine); y2 < ymax; ++y2) {
              for (let x2 = Math.max(0, imageWindow[0] - firstCol); x2 < xmax; ++x2) {
                const pixelOffset = (y2 * tileWidth + x2) * bytesPerPixel;
                const value = reader.call(dataView, pixelOffset + srcSampleOffsets[si], littleEndian);
                let windowCoordinate;
                if (interleave) {
                  windowCoordinate = (y2 + firstLine - imageWindow[1]) * windowWidth * samples.length + (x2 + firstCol - imageWindow[0]) * samples.length + si;
                  valueArrays[windowCoordinate] = value;
                } else {
                  windowCoordinate = (y2 + firstLine - imageWindow[1]) * windowWidth + x2 + firstCol - imageWindow[0];
                  valueArrays[si][windowCoordinate] = value;
                }
              }
            }
          });
        }
      }
    }
    await Promise.all(promises);
    if (width && imageWindow[2] - imageWindow[0] !== width || height && imageWindow[3] - imageWindow[1] !== height) {
      let resampled;
      if (interleave) {
        resampled = resampleInterleaved(valueArrays, imageWindow[2] - imageWindow[0], imageWindow[3] - imageWindow[1], width, height, samples.length, resampleMethod);
      } else {
        resampled = resample(valueArrays, imageWindow[2] - imageWindow[0], imageWindow[3] - imageWindow[1], width, height, resampleMethod);
      }
      resampled.width = width;
      resampled.height = height;
      return resampled;
    }
    valueArrays.width = width || imageWindow[2] - imageWindow[0];
    valueArrays.height = height || imageWindow[3] - imageWindow[1];
    return valueArrays;
  }
  async readRasters({
    window: wnd,
    samples = [],
    interleave,
    pool = null,
    width,
    height,
    resampleMethod,
    fillValue,
    signal
  } = {}) {
    const imageWindow = wnd || [0, 0, this.getWidth(), this.getHeight()];
    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {
      throw new Error("Invalid subsets");
    }
    const imageWindowWidth = imageWindow[2] - imageWindow[0];
    const imageWindowHeight = imageWindow[3] - imageWindow[1];
    const numPixels = imageWindowWidth * imageWindowHeight;
    const samplesPerPixel = this.getSamplesPerPixel();
    if (!samples || !samples.length) {
      for (let i2 = 0; i2 < samplesPerPixel; ++i2) {
        samples.push(i2);
      }
    } else {
      for (let i2 = 0; i2 < samples.length; ++i2) {
        if (samples[i2] >= samplesPerPixel) {
          return Promise.reject(new RangeError(`Invalid sample index '${samples[i2]}'.`));
        }
      }
    }
    let valueArrays;
    if (interleave) {
      const format2 = this.fileDirectory.SampleFormat ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1;
      const bitsPerSample = Math.max.apply(null, this.fileDirectory.BitsPerSample);
      valueArrays = arrayForType(format2, bitsPerSample, numPixels * samples.length);
      if (fillValue) {
        valueArrays.fill(fillValue);
      }
    } else {
      valueArrays = [];
      for (let i2 = 0; i2 < samples.length; ++i2) {
        const valueArray = this.getArrayForSample(samples[i2], numPixels);
        if (Array.isArray(fillValue) && i2 < fillValue.length) {
          valueArray.fill(fillValue[i2]);
        } else if (fillValue && !Array.isArray(fillValue)) {
          valueArray.fill(fillValue);
        }
        valueArrays.push(valueArray);
      }
    }
    const poolOrDecoder = pool || await getDecoder(this.fileDirectory);
    const result = await this._readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal);
    return result;
  }
  async readRGB({
    window: window2,
    interleave = true,
    pool = null,
    width,
    height,
    resampleMethod,
    enableAlpha = false,
    signal
  } = {}) {
    const imageWindow = window2 || [0, 0, this.getWidth(), this.getHeight()];
    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {
      throw new Error("Invalid subsets");
    }
    const pi = this.fileDirectory.PhotometricInterpretation;
    if (pi === photometricInterpretations.RGB) {
      let s2 = [0, 1, 2];
      if (!(this.fileDirectory.ExtraSamples === ExtraSamplesValues.Unspecified) && enableAlpha) {
        s2 = [];
        for (let i2 = 0; i2 < this.fileDirectory.BitsPerSample.length; i2 += 1) {
          s2.push(i2);
        }
      }
      return this.readRasters({
        window: window2,
        interleave,
        samples: s2,
        pool,
        width,
        height,
        resampleMethod,
        signal
      });
    }
    let samples;
    switch (pi) {
      case photometricInterpretations.WhiteIsZero:
      case photometricInterpretations.BlackIsZero:
      case photometricInterpretations.Palette:
        samples = [0];
        break;
      case photometricInterpretations.CMYK:
        samples = [0, 1, 2, 3];
        break;
      case photometricInterpretations.YCbCr:
      case photometricInterpretations.CIELab:
        samples = [0, 1, 2];
        break;
      default:
        throw new Error("Invalid or unsupported photometric interpretation.");
    }
    const subOptions = {
      window: imageWindow,
      interleave: true,
      samples,
      pool,
      width,
      height,
      resampleMethod,
      signal
    };
    const { fileDirectory } = this;
    const raster = await this.readRasters(subOptions);
    const max2 = 2 ** this.fileDirectory.BitsPerSample[0];
    let data2;
    switch (pi) {
      case photometricInterpretations.WhiteIsZero:
        data2 = fromWhiteIsZero(raster, max2);
        break;
      case photometricInterpretations.BlackIsZero:
        data2 = fromBlackIsZero(raster, max2);
        break;
      case photometricInterpretations.Palette:
        data2 = fromPalette(raster, fileDirectory.ColorMap);
        break;
      case photometricInterpretations.CMYK:
        data2 = fromCMYK(raster);
        break;
      case photometricInterpretations.YCbCr:
        data2 = fromYCbCr(raster);
        break;
      case photometricInterpretations.CIELab:
        data2 = fromCIELab(raster);
        break;
      default:
        throw new Error("Unsupported photometric interpretation.");
    }
    if (!interleave) {
      const red = new Uint8Array(data2.length / 3);
      const green = new Uint8Array(data2.length / 3);
      const blue = new Uint8Array(data2.length / 3);
      for (let i2 = 0, j2 = 0; i2 < data2.length; i2 += 3, ++j2) {
        red[j2] = data2[i2];
        green[j2] = data2[i2 + 1];
        blue[j2] = data2[i2 + 2];
      }
      data2 = [red, green, blue];
    }
    data2.width = raster.width;
    data2.height = raster.height;
    return data2;
  }
  getTiePoints() {
    if (!this.fileDirectory.ModelTiepoint) {
      return [];
    }
    const tiePoints = [];
    for (let i2 = 0; i2 < this.fileDirectory.ModelTiepoint.length; i2 += 6) {
      tiePoints.push({
        i: this.fileDirectory.ModelTiepoint[i2],
        j: this.fileDirectory.ModelTiepoint[i2 + 1],
        k: this.fileDirectory.ModelTiepoint[i2 + 2],
        x: this.fileDirectory.ModelTiepoint[i2 + 3],
        y: this.fileDirectory.ModelTiepoint[i2 + 4],
        z: this.fileDirectory.ModelTiepoint[i2 + 5]
      });
    }
    return tiePoints;
  }
  getGDALMetadata(sample = null) {
    const metadata = {};
    if (!this.fileDirectory.GDAL_METADATA) {
      return null;
    }
    const string = this.fileDirectory.GDAL_METADATA;
    let items = findTagsByName$1(string, "Item");
    if (sample === null) {
      items = items.filter((item) => getAttribute$1(item, "sample") === void 0);
    } else {
      items = items.filter((item) => Number(getAttribute$1(item, "sample")) === sample);
    }
    for (let i2 = 0; i2 < items.length; ++i2) {
      const item = items[i2];
      metadata[getAttribute$1(item, "name")] = item.inner;
    }
    return metadata;
  }
  getGDALNoData() {
    if (!this.fileDirectory.GDAL_NODATA) {
      return null;
    }
    const string = this.fileDirectory.GDAL_NODATA;
    return Number(string.substring(0, string.length - 1));
  }
  getOrigin() {
    const tiePoints = this.fileDirectory.ModelTiepoint;
    const modelTransformation = this.fileDirectory.ModelTransformation;
    if (tiePoints && tiePoints.length === 6) {
      return [
        tiePoints[3],
        tiePoints[4],
        tiePoints[5]
      ];
    }
    if (modelTransformation) {
      return [
        modelTransformation[3],
        modelTransformation[7],
        modelTransformation[11]
      ];
    }
    throw new Error("The image does not have an affine transformation.");
  }
  getResolution(referenceImage = null) {
    const modelPixelScale = this.fileDirectory.ModelPixelScale;
    const modelTransformation = this.fileDirectory.ModelTransformation;
    if (modelPixelScale) {
      return [
        modelPixelScale[0],
        -modelPixelScale[1],
        modelPixelScale[2]
      ];
    }
    if (modelTransformation) {
      return [
        modelTransformation[0],
        modelTransformation[5],
        modelTransformation[10]
      ];
    }
    if (referenceImage) {
      const [refResX, refResY, refResZ] = referenceImage.getResolution();
      return [
        refResX * referenceImage.getWidth() / this.getWidth(),
        refResY * referenceImage.getHeight() / this.getHeight(),
        refResZ * referenceImage.getWidth() / this.getWidth()
      ];
    }
    throw new Error("The image does not have an affine transformation.");
  }
  pixelIsArea() {
    return this.geoKeys.GTRasterTypeGeoKey === 1;
  }
  getBoundingBox() {
    const origin = this.getOrigin();
    const resolution = this.getResolution();
    const x1 = origin[0];
    const y1 = origin[1];
    const x2 = x1 + resolution[0] * this.getWidth();
    const y2 = y1 + resolution[1] * this.getHeight();
    return [
      Math.min(x1, x2),
      Math.min(y1, y2),
      Math.max(x1, x2),
      Math.max(y1, y2)
    ];
  }
}
var GeoTIFFImage$1 = GeoTIFFImage;
class DataView64 {
  constructor(arrayBuffer) {
    this._dataView = new DataView(arrayBuffer);
  }
  get buffer() {
    return this._dataView.buffer;
  }
  getUint64(offset2, littleEndian) {
    const left = this.getUint32(offset2, littleEndian);
    const right = this.getUint32(offset2 + 4, littleEndian);
    let combined;
    if (littleEndian) {
      combined = left + 2 ** 32 * right;
      if (!Number.isSafeInteger(combined)) {
        throw new Error(`${combined} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);
      }
      return combined;
    }
    combined = 2 ** 32 * left + right;
    if (!Number.isSafeInteger(combined)) {
      throw new Error(`${combined} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);
    }
    return combined;
  }
  getInt64(offset2, littleEndian) {
    let value = 0;
    const isNegative = (this._dataView.getUint8(offset2 + (littleEndian ? 7 : 0)) & 128) > 0;
    let carrying = true;
    for (let i2 = 0; i2 < 8; i2++) {
      let byte = this._dataView.getUint8(offset2 + (littleEndian ? i2 : 7 - i2));
      if (isNegative) {
        if (carrying) {
          if (byte !== 0) {
            byte = ~(byte - 1) & 255;
            carrying = false;
          }
        } else {
          byte = ~byte & 255;
        }
      }
      value += byte * 256 ** i2;
    }
    if (isNegative) {
      value = -value;
    }
    return value;
  }
  getUint8(offset2, littleEndian) {
    return this._dataView.getUint8(offset2, littleEndian);
  }
  getInt8(offset2, littleEndian) {
    return this._dataView.getInt8(offset2, littleEndian);
  }
  getUint16(offset2, littleEndian) {
    return this._dataView.getUint16(offset2, littleEndian);
  }
  getInt16(offset2, littleEndian) {
    return this._dataView.getInt16(offset2, littleEndian);
  }
  getUint32(offset2, littleEndian) {
    return this._dataView.getUint32(offset2, littleEndian);
  }
  getInt32(offset2, littleEndian) {
    return this._dataView.getInt32(offset2, littleEndian);
  }
  getFloat16(offset2, littleEndian) {
    return getFloat16(this._dataView, offset2, littleEndian);
  }
  getFloat32(offset2, littleEndian) {
    return this._dataView.getFloat32(offset2, littleEndian);
  }
  getFloat64(offset2, littleEndian) {
    return this._dataView.getFloat64(offset2, littleEndian);
  }
}
class DataSlice {
  constructor(arrayBuffer, sliceOffset, littleEndian, bigTiff) {
    this._dataView = new DataView(arrayBuffer);
    this._sliceOffset = sliceOffset;
    this._littleEndian = littleEndian;
    this._bigTiff = bigTiff;
  }
  get sliceOffset() {
    return this._sliceOffset;
  }
  get sliceTop() {
    return this._sliceOffset + this.buffer.byteLength;
  }
  get littleEndian() {
    return this._littleEndian;
  }
  get bigTiff() {
    return this._bigTiff;
  }
  get buffer() {
    return this._dataView.buffer;
  }
  covers(offset2, length) {
    return this.sliceOffset <= offset2 && this.sliceTop >= offset2 + length;
  }
  readUint8(offset2) {
    return this._dataView.getUint8(offset2 - this._sliceOffset, this._littleEndian);
  }
  readInt8(offset2) {
    return this._dataView.getInt8(offset2 - this._sliceOffset, this._littleEndian);
  }
  readUint16(offset2) {
    return this._dataView.getUint16(offset2 - this._sliceOffset, this._littleEndian);
  }
  readInt16(offset2) {
    return this._dataView.getInt16(offset2 - this._sliceOffset, this._littleEndian);
  }
  readUint32(offset2) {
    return this._dataView.getUint32(offset2 - this._sliceOffset, this._littleEndian);
  }
  readInt32(offset2) {
    return this._dataView.getInt32(offset2 - this._sliceOffset, this._littleEndian);
  }
  readFloat32(offset2) {
    return this._dataView.getFloat32(offset2 - this._sliceOffset, this._littleEndian);
  }
  readFloat64(offset2) {
    return this._dataView.getFloat64(offset2 - this._sliceOffset, this._littleEndian);
  }
  readUint64(offset2) {
    const left = this.readUint32(offset2);
    const right = this.readUint32(offset2 + 4);
    let combined;
    if (this._littleEndian) {
      combined = left + 2 ** 32 * right;
      if (!Number.isSafeInteger(combined)) {
        throw new Error(`${combined} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);
      }
      return combined;
    }
    combined = 2 ** 32 * left + right;
    if (!Number.isSafeInteger(combined)) {
      throw new Error(`${combined} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);
    }
    return combined;
  }
  readInt64(offset2) {
    let value = 0;
    const isNegative = (this._dataView.getUint8(offset2 + (this._littleEndian ? 7 : 0)) & 128) > 0;
    let carrying = true;
    for (let i2 = 0; i2 < 8; i2++) {
      let byte = this._dataView.getUint8(offset2 + (this._littleEndian ? i2 : 7 - i2));
      if (isNegative) {
        if (carrying) {
          if (byte !== 0) {
            byte = ~(byte - 1) & 255;
            carrying = false;
          }
        } else {
          byte = ~byte & 255;
        }
      }
      value += byte * 256 ** i2;
    }
    if (isNegative) {
      value = -value;
    }
    return value;
  }
  readOffset(offset2) {
    if (this._bigTiff) {
      return this.readUint64(offset2);
    }
    return this.readUint32(offset2);
  }
}
const defaultPoolSize = typeof navigator !== "undefined" ? navigator.hardwareConcurrency || 2 : 2;
class Pool {
  constructor(size = defaultPoolSize, createWorker2) {
    this.workers = null;
    this._awaitingDecoder = null;
    this.size = size;
    this.messageId = 0;
    if (size) {
      this._awaitingDecoder = createWorker2 ? Promise.resolve(createWorker2) : new Promise((resolve2) => {
        Promise.resolve().then(function() {
          return decoder;
        }).then((module) => {
          resolve2(module.create);
        });
      });
      this._awaitingDecoder.then((create3) => {
        this._awaitingDecoder = null;
        this.workers = [];
        for (let i2 = 0; i2 < size; i2++) {
          this.workers.push({ worker: create3(), idle: true });
        }
      });
    }
  }
  async decode(fileDirectory, buffer2) {
    if (this._awaitingDecoder) {
      await this._awaitingDecoder;
    }
    return this.size === 0 ? getDecoder(fileDirectory).then((decoder2) => decoder2.decode(fileDirectory, buffer2)) : new Promise((resolve2) => {
      const worker2 = this.workers.find((candidate) => candidate.idle) || this.workers[Math.floor(Math.random() * this.size)];
      worker2.idle = false;
      const id = this.messageId++;
      const onMessage = (e2) => {
        if (e2.data.id === id) {
          worker2.idle = true;
          resolve2(e2.data.decoded);
          worker2.worker.removeEventListener("message", onMessage);
        }
      };
      worker2.worker.addEventListener("message", onMessage);
      worker2.worker.postMessage({ fileDirectory, buffer: buffer2, id }, [buffer2]);
    });
  }
  destroy() {
    if (this.workers) {
      this.workers.forEach((worker2) => {
        worker2.worker.terminate();
      });
      this.workers = null;
    }
  }
}
var Pool$1 = Pool;
const CRLFCRLF = "\r\n\r\n";
function itemsToObject(items) {
  if (typeof Object.fromEntries !== "undefined") {
    return Object.fromEntries(items);
  }
  const obj = {};
  for (const [key, value] of items) {
    obj[key.toLowerCase()] = value;
  }
  return obj;
}
function parseHeaders(text2) {
  const items = text2.split("\r\n").map((line) => {
    const kv = line.split(":").map((str) => str.trim());
    kv[0] = kv[0].toLowerCase();
    return kv;
  });
  return itemsToObject(items);
}
function parseContentType(rawContentType) {
  const [type, ...rawParams] = rawContentType.split(";").map((s2) => s2.trim());
  const paramsItems = rawParams.map((param) => param.split("="));
  return { type, params: itemsToObject(paramsItems) };
}
function parseContentRange(rawContentRange) {
  let start2;
  let end;
  let total;
  if (rawContentRange) {
    [, start2, end, total] = rawContentRange.match(/bytes (\d+)-(\d+)\/(\d+)/);
    start2 = parseInt(start2, 10);
    end = parseInt(end, 10);
    total = parseInt(total, 10);
  }
  return { start: start2, end, total };
}
function parseByteRanges(responseArrayBuffer, boundary) {
  let offset2 = null;
  const decoder2 = new TextDecoder("ascii");
  const out = [];
  const startBoundary = `--${boundary}`;
  const endBoundary = `${startBoundary}--`;
  for (let i2 = 0; i2 < 10; ++i2) {
    const text2 = decoder2.decode(new Uint8Array(responseArrayBuffer, i2, startBoundary.length));
    if (text2 === startBoundary) {
      offset2 = i2;
    }
  }
  if (offset2 === null) {
    throw new Error("Could not find initial boundary");
  }
  while (offset2 < responseArrayBuffer.byteLength) {
    const text2 = decoder2.decode(new Uint8Array(responseArrayBuffer, offset2, Math.min(startBoundary.length + 1024, responseArrayBuffer.byteLength - offset2)));
    if (text2.length === 0 || text2.startsWith(endBoundary)) {
      break;
    }
    if (!text2.startsWith(startBoundary)) {
      throw new Error("Part does not start with boundary");
    }
    const innerText = text2.substr(startBoundary.length + 2);
    if (innerText.length === 0) {
      break;
    }
    const endOfHeaders = innerText.indexOf(CRLFCRLF);
    const headers = parseHeaders(innerText.substr(0, endOfHeaders));
    const { start: start2, end, total } = parseContentRange(headers["content-range"]);
    const startOfData = offset2 + startBoundary.length + endOfHeaders + CRLFCRLF.length;
    const length = parseInt(end, 10) + 1 - parseInt(start2, 10);
    out.push({
      headers,
      data: responseArrayBuffer.slice(startOfData, startOfData + length),
      offset: start2,
      length,
      fileSize: total
    });
    offset2 = startOfData + length + 4;
  }
  return out;
}
class BaseSource {
  async fetch(slices, signal = void 0) {
    return Promise.all(slices.map((slice2) => this.fetchSlice(slice2, signal)));
  }
  async fetchSlice(slice2) {
    throw new Error(`fetching of slice ${slice2} not possible, not implemented`);
  }
  get fileSize() {
    return null;
  }
  async close() {
  }
}
var yallist = Yallist$1;
Yallist$1.Node = Node$2;
Yallist$1.create = Yallist$1;
function Yallist$1(list) {
  var self2 = this;
  if (!(self2 instanceof Yallist$1)) {
    self2 = new Yallist$1();
  }
  self2.tail = null;
  self2.head = null;
  self2.length = 0;
  if (list && typeof list.forEach === "function") {
    list.forEach(function(item) {
      self2.push(item);
    });
  } else if (arguments.length > 0) {
    for (var i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
      self2.push(arguments[i2]);
    }
  }
  return self2;
}
Yallist$1.prototype.removeNode = function(node2) {
  if (node2.list !== this) {
    throw new Error("removing node which does not belong to this list");
  }
  var next3 = node2.next;
  var prev = node2.prev;
  if (next3) {
    next3.prev = prev;
  }
  if (prev) {
    prev.next = next3;
  }
  if (node2 === this.head) {
    this.head = next3;
  }
  if (node2 === this.tail) {
    this.tail = prev;
  }
  node2.list.length--;
  node2.next = null;
  node2.prev = null;
  node2.list = null;
  return next3;
};
Yallist$1.prototype.unshiftNode = function(node2) {
  if (node2 === this.head) {
    return;
  }
  if (node2.list) {
    node2.list.removeNode(node2);
  }
  var head2 = this.head;
  node2.list = this;
  node2.next = head2;
  if (head2) {
    head2.prev = node2;
  }
  this.head = node2;
  if (!this.tail) {
    this.tail = node2;
  }
  this.length++;
};
Yallist$1.prototype.pushNode = function(node2) {
  if (node2 === this.tail) {
    return;
  }
  if (node2.list) {
    node2.list.removeNode(node2);
  }
  var tail = this.tail;
  node2.list = this;
  node2.prev = tail;
  if (tail) {
    tail.next = node2;
  }
  this.tail = node2;
  if (!this.head) {
    this.head = node2;
  }
  this.length++;
};
Yallist$1.prototype.push = function() {
  for (var i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
    push$3(this, arguments[i2]);
  }
  return this.length;
};
Yallist$1.prototype.unshift = function() {
  for (var i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
    unshift(this, arguments[i2]);
  }
  return this.length;
};
Yallist$1.prototype.pop = function() {
  if (!this.tail) {
    return void 0;
  }
  var res = this.tail.value;
  this.tail = this.tail.prev;
  if (this.tail) {
    this.tail.next = null;
  } else {
    this.head = null;
  }
  this.length--;
  return res;
};
Yallist$1.prototype.shift = function() {
  if (!this.head) {
    return void 0;
  }
  var res = this.head.value;
  this.head = this.head.next;
  if (this.head) {
    this.head.prev = null;
  } else {
    this.tail = null;
  }
  this.length--;
  return res;
};
Yallist$1.prototype.forEach = function(fn, thisp) {
  thisp = thisp || this;
  for (var walker = this.head, i2 = 0; walker !== null; i2++) {
    fn.call(thisp, walker.value, i2, this);
    walker = walker.next;
  }
};
Yallist$1.prototype.forEachReverse = function(fn, thisp) {
  thisp = thisp || this;
  for (var walker = this.tail, i2 = this.length - 1; walker !== null; i2--) {
    fn.call(thisp, walker.value, i2, this);
    walker = walker.prev;
  }
};
Yallist$1.prototype.get = function(n2) {
  for (var i2 = 0, walker = this.head; walker !== null && i2 < n2; i2++) {
    walker = walker.next;
  }
  if (i2 === n2 && walker !== null) {
    return walker.value;
  }
};
Yallist$1.prototype.getReverse = function(n2) {
  for (var i2 = 0, walker = this.tail; walker !== null && i2 < n2; i2++) {
    walker = walker.prev;
  }
  if (i2 === n2 && walker !== null) {
    return walker.value;
  }
};
Yallist$1.prototype.map = function(fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist$1();
  for (var walker = this.head; walker !== null; ) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.next;
  }
  return res;
};
Yallist$1.prototype.mapReverse = function(fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist$1();
  for (var walker = this.tail; walker !== null; ) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.prev;
  }
  return res;
};
Yallist$1.prototype.reduce = function(fn, initial) {
  var acc;
  var walker = this.head;
  if (arguments.length > 1) {
    acc = initial;
  } else if (this.head) {
    walker = this.head.next;
    acc = this.head.value;
  } else {
    throw new TypeError("Reduce of empty list with no initial value");
  }
  for (var i2 = 0; walker !== null; i2++) {
    acc = fn(acc, walker.value, i2);
    walker = walker.next;
  }
  return acc;
};
Yallist$1.prototype.reduceReverse = function(fn, initial) {
  var acc;
  var walker = this.tail;
  if (arguments.length > 1) {
    acc = initial;
  } else if (this.tail) {
    walker = this.tail.prev;
    acc = this.tail.value;
  } else {
    throw new TypeError("Reduce of empty list with no initial value");
  }
  for (var i2 = this.length - 1; walker !== null; i2--) {
    acc = fn(acc, walker.value, i2);
    walker = walker.prev;
  }
  return acc;
};
Yallist$1.prototype.toArray = function() {
  var arr = new Array(this.length);
  for (var i2 = 0, walker = this.head; walker !== null; i2++) {
    arr[i2] = walker.value;
    walker = walker.next;
  }
  return arr;
};
Yallist$1.prototype.toArrayReverse = function() {
  var arr = new Array(this.length);
  for (var i2 = 0, walker = this.tail; walker !== null; i2++) {
    arr[i2] = walker.value;
    walker = walker.prev;
  }
  return arr;
};
Yallist$1.prototype.slice = function(from, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from = from || 0;
  if (from < 0) {
    from += this.length;
  }
  var ret = new Yallist$1();
  if (to < from || to < 0) {
    return ret;
  }
  if (from < 0) {
    from = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (var i2 = 0, walker = this.head; walker !== null && i2 < from; i2++) {
    walker = walker.next;
  }
  for (; walker !== null && i2 < to; i2++, walker = walker.next) {
    ret.push(walker.value);
  }
  return ret;
};
Yallist$1.prototype.sliceReverse = function(from, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from = from || 0;
  if (from < 0) {
    from += this.length;
  }
  var ret = new Yallist$1();
  if (to < from || to < 0) {
    return ret;
  }
  if (from < 0) {
    from = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (var i2 = this.length, walker = this.tail; walker !== null && i2 > to; i2--) {
    walker = walker.prev;
  }
  for (; walker !== null && i2 > from; i2--, walker = walker.prev) {
    ret.push(walker.value);
  }
  return ret;
};
Yallist$1.prototype.splice = function(start2, deleteCount, ...nodes) {
  if (start2 > this.length) {
    start2 = this.length - 1;
  }
  if (start2 < 0) {
    start2 = this.length + start2;
  }
  for (var i2 = 0, walker = this.head; walker !== null && i2 < start2; i2++) {
    walker = walker.next;
  }
  var ret = [];
  for (var i2 = 0; walker && i2 < deleteCount; i2++) {
    ret.push(walker.value);
    walker = this.removeNode(walker);
  }
  if (walker === null) {
    walker = this.tail;
  }
  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev;
  }
  for (var i2 = 0; i2 < nodes.length; i2++) {
    walker = insert(this, walker, nodes[i2]);
  }
  return ret;
};
Yallist$1.prototype.reverse = function() {
  var head2 = this.head;
  var tail = this.tail;
  for (var walker = head2; walker !== null; walker = walker.prev) {
    var p5 = walker.prev;
    walker.prev = walker.next;
    walker.next = p5;
  }
  this.head = tail;
  this.tail = head2;
  return this;
};
function insert(self2, node2, value) {
  var inserted = node2 === self2.head ? new Node$2(value, null, node2, self2) : new Node$2(value, node2, node2.next, self2);
  if (inserted.next === null) {
    self2.tail = inserted;
  }
  if (inserted.prev === null) {
    self2.head = inserted;
  }
  self2.length++;
  return inserted;
}
function push$3(self2, item) {
  self2.tail = new Node$2(item, self2.tail, null, self2);
  if (!self2.head) {
    self2.head = self2.tail;
  }
  self2.length++;
}
function unshift(self2, item) {
  self2.head = new Node$2(item, null, self2.head, self2);
  if (!self2.tail) {
    self2.tail = self2.head;
  }
  self2.length++;
}
function Node$2(value, prev, next3, list) {
  if (!(this instanceof Node$2)) {
    return new Node$2(value, prev, next3, list);
  }
  this.list = list;
  this.value = value;
  if (prev) {
    prev.next = this;
    this.prev = prev;
  } else {
    this.prev = null;
  }
  if (next3) {
    next3.prev = this;
    this.next = next3;
  } else {
    this.next = null;
  }
}
try {
  require("./iterator.js")(Yallist$1);
} catch (er) {
}
const Yallist = yallist;
const MAX = Symbol("max");
const LENGTH$1 = Symbol("length");
const LENGTH_CALCULATOR = Symbol("lengthCalculator");
const ALLOW_STALE = Symbol("allowStale");
const MAX_AGE = Symbol("maxAge");
const DISPOSE = Symbol("dispose");
const NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
const LRU_LIST = Symbol("lruList");
const CACHE = Symbol("cache");
const UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
const naiveLength = () => 1;
class LRUCache {
  constructor(options) {
    if (typeof options === "number")
      options = { max: options };
    if (!options)
      options = {};
    if (options.max && (typeof options.max !== "number" || options.max < 0))
      throw new TypeError("max must be a non-negative number");
    this[MAX] = options.max || Infinity;
    const lc2 = options.length || naiveLength;
    this[LENGTH_CALCULATOR] = typeof lc2 !== "function" ? naiveLength : lc2;
    this[ALLOW_STALE] = options.stale || false;
    if (options.maxAge && typeof options.maxAge !== "number")
      throw new TypeError("maxAge must be a number");
    this[MAX_AGE] = options.maxAge || 0;
    this[DISPOSE] = options.dispose;
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
    this.reset();
  }
  set max(mL) {
    if (typeof mL !== "number" || mL < 0)
      throw new TypeError("max must be a non-negative number");
    this[MAX] = mL || Infinity;
    trim(this);
  }
  get max() {
    return this[MAX];
  }
  set allowStale(allowStale) {
    this[ALLOW_STALE] = !!allowStale;
  }
  get allowStale() {
    return this[ALLOW_STALE];
  }
  set maxAge(mA) {
    if (typeof mA !== "number")
      throw new TypeError("maxAge must be a non-negative number");
    this[MAX_AGE] = mA;
    trim(this);
  }
  get maxAge() {
    return this[MAX_AGE];
  }
  set lengthCalculator(lC) {
    if (typeof lC !== "function")
      lC = naiveLength;
    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC;
      this[LENGTH$1] = 0;
      this[LRU_LIST].forEach((hit) => {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
        this[LENGTH$1] += hit.length;
      });
    }
    trim(this);
  }
  get lengthCalculator() {
    return this[LENGTH_CALCULATOR];
  }
  get length() {
    return this[LENGTH$1];
  }
  get itemCount() {
    return this[LRU_LIST].length;
  }
  rforEach(fn, thisp) {
    thisp = thisp || this;
    for (let walker = this[LRU_LIST].tail; walker !== null; ) {
      const prev = walker.prev;
      forEachStep(this, fn, walker, thisp);
      walker = prev;
    }
  }
  forEach(fn, thisp) {
    thisp = thisp || this;
    for (let walker = this[LRU_LIST].head; walker !== null; ) {
      const next3 = walker.next;
      forEachStep(this, fn, walker, thisp);
      walker = next3;
    }
  }
  keys() {
    return this[LRU_LIST].toArray().map((k2) => k2.key);
  }
  values() {
    return this[LRU_LIST].toArray().map((k2) => k2.value);
  }
  reset() {
    if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
      this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
    }
    this[CACHE] = /* @__PURE__ */ new Map();
    this[LRU_LIST] = new Yallist();
    this[LENGTH$1] = 0;
  }
  dump() {
    return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
      k: hit.key,
      v: hit.value,
      e: hit.now + (hit.maxAge || 0)
    }).toArray().filter((h2) => h2);
  }
  dumpLru() {
    return this[LRU_LIST];
  }
  set(key, value, maxAge) {
    maxAge = maxAge || this[MAX_AGE];
    if (maxAge && typeof maxAge !== "number")
      throw new TypeError("maxAge must be a number");
    const now2 = maxAge ? Date.now() : 0;
    const len = this[LENGTH_CALCULATOR](value, key);
    if (this[CACHE].has(key)) {
      if (len > this[MAX]) {
        del(this, this[CACHE].get(key));
        return false;
      }
      const node2 = this[CACHE].get(key);
      const item = node2.value;
      if (this[DISPOSE]) {
        if (!this[NO_DISPOSE_ON_SET])
          this[DISPOSE](key, item.value);
      }
      item.now = now2;
      item.maxAge = maxAge;
      item.value = value;
      this[LENGTH$1] += len - item.length;
      item.length = len;
      this.get(key);
      trim(this);
      return true;
    }
    const hit = new Entry(key, value, len, now2, maxAge);
    if (hit.length > this[MAX]) {
      if (this[DISPOSE])
        this[DISPOSE](key, value);
      return false;
    }
    this[LENGTH$1] += hit.length;
    this[LRU_LIST].unshift(hit);
    this[CACHE].set(key, this[LRU_LIST].head);
    trim(this);
    return true;
  }
  has(key) {
    if (!this[CACHE].has(key))
      return false;
    const hit = this[CACHE].get(key).value;
    return !isStale(this, hit);
  }
  get(key) {
    return get$1(this, key, true);
  }
  peek(key) {
    return get$1(this, key, false);
  }
  pop() {
    const node2 = this[LRU_LIST].tail;
    if (!node2)
      return null;
    del(this, node2);
    return node2.value;
  }
  del(key) {
    del(this, this[CACHE].get(key));
  }
  load(arr) {
    this.reset();
    const now2 = Date.now();
    for (let l2 = arr.length - 1; l2 >= 0; l2--) {
      const hit = arr[l2];
      const expiresAt = hit.e || 0;
      if (expiresAt === 0)
        this.set(hit.k, hit.v);
      else {
        const maxAge = expiresAt - now2;
        if (maxAge > 0) {
          this.set(hit.k, hit.v, maxAge);
        }
      }
    }
  }
  prune() {
    this[CACHE].forEach((value, key) => get$1(this, key, false));
  }
}
const get$1 = (self2, key, doUse) => {
  const node2 = self2[CACHE].get(key);
  if (node2) {
    const hit = node2.value;
    if (isStale(self2, hit)) {
      del(self2, node2);
      if (!self2[ALLOW_STALE])
        return void 0;
    } else {
      if (doUse) {
        if (self2[UPDATE_AGE_ON_GET])
          node2.value.now = Date.now();
        self2[LRU_LIST].unshiftNode(node2);
      }
    }
    return hit.value;
  }
};
const isStale = (self2, hit) => {
  if (!hit || !hit.maxAge && !self2[MAX_AGE])
    return false;
  const diff = Date.now() - hit.now;
  return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
};
const trim = (self2) => {
  if (self2[LENGTH$1] > self2[MAX]) {
    for (let walker = self2[LRU_LIST].tail; self2[LENGTH$1] > self2[MAX] && walker !== null; ) {
      const prev = walker.prev;
      del(self2, walker);
      walker = prev;
    }
  }
};
const del = (self2, node2) => {
  if (node2) {
    const hit = node2.value;
    if (self2[DISPOSE])
      self2[DISPOSE](hit.key, hit.value);
    self2[LENGTH$1] -= hit.length;
    self2[CACHE].delete(hit.key);
    self2[LRU_LIST].removeNode(node2);
  }
};
class Entry {
  constructor(key, value, length, now2, maxAge) {
    this.key = key;
    this.value = value;
    this.length = length;
    this.now = now2;
    this.maxAge = maxAge || 0;
  }
}
const forEachStep = (self2, fn, node2, thisp) => {
  let hit = node2.value;
  if (isStale(self2, hit)) {
    del(self2, node2);
    if (!self2[ALLOW_STALE])
      hit = void 0;
  }
  if (hit)
    fn.call(thisp, hit.value, hit.key, self2);
};
var lruCache = LRUCache;
async function wait(milliseconds) {
  return new Promise((resolve2) => setTimeout(resolve2, milliseconds));
}
function zip(a2, b2) {
  const A2 = Array.isArray(a2) ? a2 : Array.from(a2);
  const B3 = Array.isArray(b2) ? b2 : Array.from(b2);
  return A2.map((k2, i2) => [k2, B3[i2]]);
}
class AbortError extends Error {
  constructor(params2) {
    super(params2);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, AbortError);
    }
    this.name = "AbortError";
  }
}
class CustomAggregateError extends Error {
  constructor(errors, message) {
    super(message);
    this.errors = errors;
    this.message = message;
    this.name = "AggregateError";
  }
}
const AggregateError = CustomAggregateError;
class Block {
  constructor(offset2, length, data2 = null) {
    this.offset = offset2;
    this.length = length;
    this.data = data2;
  }
  get top() {
    return this.offset + this.length;
  }
}
class BlockGroup {
  constructor(offset2, length, blockIds) {
    this.offset = offset2;
    this.length = length;
    this.blockIds = blockIds;
  }
}
class BlockedSource extends BaseSource {
  constructor(source, { blockSize = 65536, cacheSize = 100 } = {}) {
    super();
    this.source = source;
    this.blockSize = blockSize;
    this.blockCache = new lruCache({ max: cacheSize });
    this.blockRequests = /* @__PURE__ */ new Map();
    this.blockIdsToFetch = /* @__PURE__ */ new Set();
  }
  get fileSize() {
    return this.source.fileSize;
  }
  async fetch(slices, signal) {
    const cachedBlocks = /* @__PURE__ */ new Map();
    const blockRequests = /* @__PURE__ */ new Map();
    const missingBlockIds = /* @__PURE__ */ new Set();
    for (const { offset: offset2, length } of slices) {
      let top = offset2 + length;
      const { fileSize } = this;
      if (fileSize !== null) {
        top = Math.min(top, fileSize);
      }
      const firstBlockOffset = Math.floor(offset2 / this.blockSize) * this.blockSize;
      for (let current = firstBlockOffset; current < top; current += this.blockSize) {
        const blockId = Math.floor(current / this.blockSize);
        if (this.blockCache.has(blockId)) {
          cachedBlocks.set(blockId, this.blockCache.get(blockId));
        } else if (this.blockRequests.has(blockId)) {
          blockRequests.set(blockId, this.blockRequests.get(blockId));
        } else if (this.blockIdsToFetch.has(blockId)) {
          missingBlockIds.add(blockId);
        } else {
          this.blockIdsToFetch.add(blockId);
          missingBlockIds.add(blockId);
        }
      }
    }
    await wait();
    this.fetchBlocks(signal);
    for (const blockId of missingBlockIds) {
      const block = this.blockRequests.get(blockId);
      const cachedBlock = this.blockCache.get(blockId);
      if (block) {
        blockRequests.set(blockId, block);
      } else if (cachedBlock) {
        cachedBlocks.set(blockId, cachedBlock);
      } else {
        throw new Error(`Block ${blockId} is not in the block requests`);
      }
    }
    let results = await Promise.allSettled(Array.from(blockRequests.values()));
    if (results.some((result) => result.status === "rejected")) {
      const retriedBlockRequests = /* @__PURE__ */ new Set();
      for (const [blockId, result] of zip(blockRequests.keys(), results)) {
        const { rejected, reason } = result;
        if (rejected) {
          if (reason.name === "AbortError" && reason.signal !== signal) {
            this.blockIdsToFetch.add(blockId);
            retriedBlockRequests.add(blockId);
          }
        }
      }
      if (this.blockIdsToFetch.length > 0) {
        this.fetchBlocks(signal);
        for (const blockId of retriedBlockRequests) {
          const block = this.blockRequests.get(blockId);
          if (!block) {
            throw new Error(`Block ${blockId} is not in the block requests`);
          }
          blockRequests.set(blockId, block);
        }
        results = await Promise.allSettled(Array.from(blockRequests.values()));
      }
    }
    if (results.some((result) => result.status === "rejected")) {
      if (signal && signal.aborted) {
        throw new AbortError("Request was aborted");
      }
      throw new AggregateError(results.filter((result) => result.status === "rejected").map((result) => result.reason), "Request failed");
    }
    const values3 = results.map((result) => result.value);
    const requiredBlocks = new Map(zip(Array.from(blockRequests.keys()), values3));
    for (const [blockId, block] of cachedBlocks) {
      requiredBlocks.set(blockId, block);
    }
    return this.readSliceData(slices, requiredBlocks);
  }
  fetchBlocks(signal) {
    if (this.blockIdsToFetch.size > 0) {
      const groups = this.groupBlocks(this.blockIdsToFetch);
      const groupRequests = this.source.fetch(groups, signal);
      for (let groupIndex = 0; groupIndex < groups.length; ++groupIndex) {
        const group = groups[groupIndex];
        for (const blockId of group.blockIds) {
          const blockRequest = (async () => {
            try {
              const response = (await groupRequests)[groupIndex];
              const blockOffset = blockId * this.blockSize;
              const o2 = blockOffset - response.offset;
              const t3 = Math.min(o2 + this.blockSize, response.data.byteLength);
              const data2 = response.data.slice(o2, t3);
              const block = new Block(blockOffset, data2.byteLength, data2);
              this.blockCache.set(blockId, block);
              return block;
            } catch (err2) {
              if (err2.name === "AbortError") {
                err2.signal = signal;
              }
              throw err2;
            } finally {
              this.blockRequests.delete(blockId);
            }
          })();
          this.blockRequests.set(blockId, blockRequest);
        }
      }
      this.blockIdsToFetch.clear();
    }
  }
  groupBlocks(blockIds) {
    const sortedBlockIds = Array.from(blockIds).sort((a2, b2) => a2 - b2);
    if (sortedBlockIds.length === 0) {
      return [];
    }
    let current = [];
    let lastBlockId = null;
    const groups = [];
    for (const blockId of sortedBlockIds) {
      if (lastBlockId === null || lastBlockId + 1 === blockId) {
        current.push(blockId);
        lastBlockId = blockId;
      } else {
        groups.push(new BlockGroup(current[0] * this.blockSize, current.length * this.blockSize, current));
        current = [blockId];
        lastBlockId = blockId;
      }
    }
    groups.push(new BlockGroup(current[0] * this.blockSize, current.length * this.blockSize, current));
    return groups;
  }
  readSliceData(slices, blocks) {
    return slices.map((slice2) => {
      const top = slice2.offset + slice2.length;
      const blockIdLow = Math.floor(slice2.offset / this.blockSize);
      const blockIdHigh = Math.floor((slice2.offset + slice2.length) / this.blockSize);
      const sliceData = new ArrayBuffer(slice2.length);
      const sliceView = new Uint8Array(sliceData);
      for (let blockId = blockIdLow; blockId <= blockIdHigh; ++blockId) {
        const block = blocks.get(blockId);
        const delta = block.offset - slice2.offset;
        const topDelta = block.top - top;
        let blockInnerOffset = 0;
        let rangeInnerOffset = 0;
        let usedBlockLength;
        if (delta < 0) {
          blockInnerOffset = -delta;
        } else if (delta > 0) {
          rangeInnerOffset = delta;
        }
        if (topDelta < 0) {
          usedBlockLength = block.length - blockInnerOffset;
        } else {
          usedBlockLength = top - block.offset - blockInnerOffset;
        }
        const blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);
        sliceView.set(blockView, rangeInnerOffset);
      }
      return sliceData;
    });
  }
}
class BaseResponse {
  get ok() {
    return this.status >= 200 && this.status <= 299;
  }
  get status() {
    throw new Error("not implemented");
  }
  getHeader(headerName) {
    throw new Error("not implemented");
  }
  async getData() {
    throw new Error("not implemented");
  }
}
class BaseClient {
  constructor(url) {
    this.url = url;
  }
  async request({ headers, credentials, signal } = {}) {
    throw new Error("request is not implemented");
  }
}
class FetchResponse extends BaseResponse {
  constructor(response) {
    super();
    this.response = response;
  }
  get status() {
    return this.response.status;
  }
  getHeader(name) {
    return this.response.headers.get(name);
  }
  async getData() {
    const data2 = this.response.arrayBuffer ? await this.response.arrayBuffer() : (await this.response.buffer()).buffer;
    return data2;
  }
}
class FetchClient extends BaseClient {
  constructor(url, credentials) {
    super(url);
    this.credentials = credentials;
  }
  async request({ headers, credentials, signal } = {}) {
    const response = await fetch(this.url, {
      headers,
      credentials,
      signal
    });
    return new FetchResponse(response);
  }
}
class XHRResponse extends BaseResponse {
  constructor(xhr2, data2) {
    super();
    this.xhr = xhr2;
    this.data = data2;
  }
  get status() {
    return this.xhr.status;
  }
  getHeader(name) {
    return this.xhr.getResponseHeader(name);
  }
  async getData() {
    return this.data;
  }
}
class XHRClient extends BaseClient {
  constructRequest(headers, signal) {
    return new Promise((resolve2, reject2) => {
      const xhr2 = new XMLHttpRequest();
      xhr2.open("GET", this.url);
      xhr2.responseType = "arraybuffer";
      for (const [key, value] of Object.entries(headers)) {
        xhr2.setRequestHeader(key, value);
      }
      xhr2.onload = () => {
        const data2 = xhr2.response;
        resolve2(new XHRResponse(xhr2, data2));
      };
      xhr2.onerror = reject2;
      xhr2.onabort = () => reject2(new AbortError("Request aborted"));
      xhr2.send();
      if (signal) {
        if (signal.aborted) {
          xhr2.abort();
        }
        signal.addEventListener("abort", () => xhr2.abort());
      }
    });
  }
  async request({ headers, signal } = {}) {
    const response = await this.constructRequest(headers, signal);
    return response;
  }
}
var fs = {};
class HttpResponse extends BaseResponse {
  constructor(response, dataPromise) {
    super();
    this.response = response;
    this.dataPromise = dataPromise;
  }
  get status() {
    return this.response.statusCode;
  }
  getHeader(name) {
    return this.response.headers[name];
  }
  async getData() {
    const data2 = await this.dataPromise;
    return data2;
  }
}
class HttpClient extends BaseClient {
  constructor(url) {
    super(url);
    this.parsedUrl = fs.parse(this.url);
    this.httpApi = this.parsedUrl.protocol === "http:" ? fs : fs;
  }
  constructRequest(headers, signal) {
    return new Promise((resolve2, reject2) => {
      const request = this.httpApi.get(__spreadProps(__spreadValues({}, this.parsedUrl), {
        headers
      }), (response) => {
        const dataPromise = new Promise((resolveData) => {
          const chunks = [];
          response.on("data", (chunk) => {
            chunks.push(chunk);
          });
          response.on("end", () => {
            const data2 = Buffer.concat(chunks).buffer;
            resolveData(data2);
          });
          response.on("error", reject2);
        });
        resolve2(new HttpResponse(response, dataPromise));
      });
      request.on("error", reject2);
      if (signal) {
        if (signal.aborted) {
          request.destroy(new AbortError("Request aborted"));
        }
        signal.addEventListener("abort", () => request.destroy(new AbortError("Request aborted")));
      }
    });
  }
  async request({ headers, signal } = {}) {
    const response = await this.constructRequest(headers, signal);
    return response;
  }
}
class RemoteSource extends BaseSource {
  constructor(client, headers, maxRanges, allowFullFile) {
    super();
    this.client = client;
    this.headers = headers;
    this.maxRanges = maxRanges;
    this.allowFullFile = allowFullFile;
    this._fileSize = null;
  }
  async fetch(slices, signal) {
    if (this.maxRanges >= slices.length) {
      return this.fetchSlices(slices, signal);
    } else if (this.maxRanges > 0 && slices.length > 1)
      ;
    return Promise.all(slices.map((slice2) => this.fetchSlice(slice2, signal)));
  }
  async fetchSlices(slices, signal) {
    const response = await this.client.request({
      headers: __spreadProps(__spreadValues({}, this.headers), {
        Range: `bytes=${slices.map(({ offset: offset2, length }) => `${offset2}-${offset2 + length}`).join(",")}`
      }),
      signal
    });
    if (!response.ok) {
      throw new Error("Error fetching data.");
    } else if (response.status === 206) {
      const { type, params: params2 } = parseContentType(response.getHeader("content-type"));
      if (type === "multipart/byteranges") {
        const byteRanges = parseByteRanges(await response.getData(), params2.boundary);
        this._fileSize = byteRanges[0].fileSize || null;
        return byteRanges;
      }
      const data2 = await response.getData();
      const { start: start2, end, total } = parseContentRange(response.getHeader("content-range"));
      this._fileSize = total || null;
      const first = [{
        data: data2,
        offset: start2,
        length: end - start2
      }];
      if (slices.length > 1) {
        const others = await Promise.all(slices.slice(1).map((slice2) => this.fetchSlice(slice2, signal)));
        return first.concat(others);
      }
      return first;
    } else {
      if (!this.allowFullFile) {
        throw new Error("Server responded with full file");
      }
      const data2 = await response.getData();
      this._fileSize = data2.byteLength;
      return [{
        data: data2,
        offset: 0,
        length: data2.byteLength
      }];
    }
  }
  async fetchSlice(slice2, signal) {
    const { offset: offset2, length } = slice2;
    const response = await this.client.request({
      headers: __spreadProps(__spreadValues({}, this.headers), {
        Range: `bytes=${offset2}-${offset2 + length}`
      }),
      signal
    });
    if (!response.ok) {
      throw new Error("Error fetching data.");
    } else if (response.status === 206) {
      const data2 = await response.getData();
      const { total } = parseContentRange(response.getHeader("content-range"));
      this._fileSize = total || null;
      return {
        data: data2,
        offset: offset2,
        length
      };
    } else {
      if (!this.allowFullFile) {
        throw new Error("Server responded with full file");
      }
      const data2 = await response.getData();
      this._fileSize = data2.byteLength;
      return {
        data: data2,
        offset: 0,
        length: data2.byteLength
      };
    }
  }
  get fileSize() {
    return this._fileSize;
  }
}
function maybeWrapInBlockedSource(source, { blockSize, cacheSize }) {
  if (blockSize === null) {
    return source;
  }
  return new BlockedSource(source, blockSize, cacheSize);
}
function makeFetchSource(url, _a2 = {}) {
  var _b2 = _a2, { headers = {}, credentials, maxRanges = 0, allowFullFile = false } = _b2, blockOptions = __objRest(_b2, ["headers", "credentials", "maxRanges", "allowFullFile"]);
  const client = new FetchClient(url, credentials);
  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);
  return maybeWrapInBlockedSource(source, blockOptions);
}
function makeXHRSource(url, _c = {}) {
  var _d = _c, { headers = {}, maxRanges = 0, allowFullFile = false } = _d, blockOptions = __objRest(_d, ["headers", "maxRanges", "allowFullFile"]);
  const client = new XHRClient(url);
  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);
  return maybeWrapInBlockedSource(source, blockOptions);
}
function makeHttpSource(url, _e = {}) {
  var _f = _e, { headers = {}, maxRanges = 0, allowFullFile = false } = _f, blockOptions = __objRest(_f, ["headers", "maxRanges", "allowFullFile"]);
  const client = new HttpClient(url);
  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);
  return maybeWrapInBlockedSource(source, blockOptions);
}
function makeRemoteSource(url, _g = {}) {
  var _h = _g, { forceXHR = false } = _h, clientOptions = __objRest(_h, ["forceXHR"]);
  if (typeof fetch === "function" && !forceXHR) {
    return makeFetchSource(url, clientOptions);
  }
  if (typeof XMLHttpRequest !== "undefined") {
    return makeXHRSource(url, clientOptions);
  }
  return makeHttpSource(url, clientOptions);
}
class FileReaderSource extends BaseSource {
  constructor(file) {
    super();
    this.file = file;
  }
  async fetchSlice(slice2, signal) {
    return new Promise((resolve2, reject2) => {
      const blob = this.file.slice(slice2.offset, slice2.offset + slice2.length);
      const reader = new FileReader();
      reader.onload = (event) => resolve2(event.target.result);
      reader.onerror = reject2;
      reader.onabort = reject2;
      reader.readAsArrayBuffer(blob);
      if (signal) {
        signal.addEventListener("abort", () => reader.abort());
      }
    });
  }
}
function makeFileReaderSource(file) {
  return new FileReaderSource(file);
}
function getFieldTypeLength(fieldType) {
  switch (fieldType) {
    case fieldTypes.BYTE:
    case fieldTypes.ASCII:
    case fieldTypes.SBYTE:
    case fieldTypes.UNDEFINED:
      return 1;
    case fieldTypes.SHORT:
    case fieldTypes.SSHORT:
      return 2;
    case fieldTypes.LONG:
    case fieldTypes.SLONG:
    case fieldTypes.FLOAT:
    case fieldTypes.IFD:
      return 4;
    case fieldTypes.RATIONAL:
    case fieldTypes.SRATIONAL:
    case fieldTypes.DOUBLE:
    case fieldTypes.LONG8:
    case fieldTypes.SLONG8:
    case fieldTypes.IFD8:
      return 8;
    default:
      throw new RangeError(`Invalid field type: ${fieldType}`);
  }
}
function parseGeoKeyDirectory(fileDirectory) {
  const rawGeoKeyDirectory = fileDirectory.GeoKeyDirectory;
  if (!rawGeoKeyDirectory) {
    return null;
  }
  const geoKeyDirectory = {};
  for (let i2 = 4; i2 <= rawGeoKeyDirectory[3] * 4; i2 += 4) {
    const key = geoKeyNames[rawGeoKeyDirectory[i2]];
    const location2 = rawGeoKeyDirectory[i2 + 1] ? fieldTagNames[rawGeoKeyDirectory[i2 + 1]] : null;
    const count = rawGeoKeyDirectory[i2 + 2];
    const offset2 = rawGeoKeyDirectory[i2 + 3];
    let value = null;
    if (!location2) {
      value = offset2;
    } else {
      value = fileDirectory[location2];
      if (typeof value === "undefined" || value === null) {
        throw new Error(`Could not get value of geoKey '${key}'.`);
      } else if (typeof value === "string") {
        value = value.substring(offset2, offset2 + count - 1);
      } else if (value.subarray) {
        value = value.subarray(offset2, offset2 + count);
        if (count === 1) {
          value = value[0];
        }
      }
    }
    geoKeyDirectory[key] = value;
  }
  return geoKeyDirectory;
}
function getValues(dataSlice, fieldType, count, offset2) {
  let values3 = null;
  let readMethod = null;
  const fieldTypeLength = getFieldTypeLength(fieldType);
  switch (fieldType) {
    case fieldTypes.BYTE:
    case fieldTypes.ASCII:
    case fieldTypes.UNDEFINED:
      values3 = new Uint8Array(count);
      readMethod = dataSlice.readUint8;
      break;
    case fieldTypes.SBYTE:
      values3 = new Int8Array(count);
      readMethod = dataSlice.readInt8;
      break;
    case fieldTypes.SHORT:
      values3 = new Uint16Array(count);
      readMethod = dataSlice.readUint16;
      break;
    case fieldTypes.SSHORT:
      values3 = new Int16Array(count);
      readMethod = dataSlice.readInt16;
      break;
    case fieldTypes.LONG:
    case fieldTypes.IFD:
      values3 = new Uint32Array(count);
      readMethod = dataSlice.readUint32;
      break;
    case fieldTypes.SLONG:
      values3 = new Int32Array(count);
      readMethod = dataSlice.readInt32;
      break;
    case fieldTypes.LONG8:
    case fieldTypes.IFD8:
      values3 = new Array(count);
      readMethod = dataSlice.readUint64;
      break;
    case fieldTypes.SLONG8:
      values3 = new Array(count);
      readMethod = dataSlice.readInt64;
      break;
    case fieldTypes.RATIONAL:
      values3 = new Uint32Array(count * 2);
      readMethod = dataSlice.readUint32;
      break;
    case fieldTypes.SRATIONAL:
      values3 = new Int32Array(count * 2);
      readMethod = dataSlice.readInt32;
      break;
    case fieldTypes.FLOAT:
      values3 = new Float32Array(count);
      readMethod = dataSlice.readFloat32;
      break;
    case fieldTypes.DOUBLE:
      values3 = new Float64Array(count);
      readMethod = dataSlice.readFloat64;
      break;
    default:
      throw new RangeError(`Invalid field type: ${fieldType}`);
  }
  if (!(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {
    for (let i2 = 0; i2 < count; ++i2) {
      values3[i2] = readMethod.call(dataSlice, offset2 + i2 * fieldTypeLength);
    }
  } else {
    for (let i2 = 0; i2 < count; i2 += 2) {
      values3[i2] = readMethod.call(dataSlice, offset2 + i2 * fieldTypeLength);
      values3[i2 + 1] = readMethod.call(dataSlice, offset2 + (i2 * fieldTypeLength + 4));
    }
  }
  if (fieldType === fieldTypes.ASCII) {
    return new TextDecoder("utf-8").decode(values3);
  }
  return values3;
}
class ImageFileDirectory {
  constructor(fileDirectory, geoKeyDirectory, nextIFDByteOffset) {
    this.fileDirectory = fileDirectory;
    this.geoKeyDirectory = geoKeyDirectory;
    this.nextIFDByteOffset = nextIFDByteOffset;
  }
}
class GeoTIFFImageIndexError extends Error {
  constructor(index2) {
    super(`No image at index ${index2}`);
    this.index = index2;
  }
}
class GeoTIFFBase {
  async readRasters(options = {}) {
    const { window: imageWindow, width, height } = options;
    let { resX, resY, bbox: bbox2 } = options;
    const firstImage = await this.getImage();
    let usedImage = firstImage;
    const imageCount = await this.getImageCount();
    const imgBBox = firstImage.getBoundingBox();
    if (imageWindow && bbox2) {
      throw new Error('Both "bbox" and "window" passed.');
    }
    if (width || height) {
      if (imageWindow) {
        const [oX, oY] = firstImage.getOrigin();
        const [rX, rY] = firstImage.getResolution();
        bbox2 = [
          oX + imageWindow[0] * rX,
          oY + imageWindow[1] * rY,
          oX + imageWindow[2] * rX,
          oY + imageWindow[3] * rY
        ];
      }
      const usedBBox = bbox2 || imgBBox;
      if (width) {
        if (resX) {
          throw new Error("Both width and resX passed");
        }
        resX = (usedBBox[2] - usedBBox[0]) / width;
      }
      if (height) {
        if (resY) {
          throw new Error("Both width and resY passed");
        }
        resY = (usedBBox[3] - usedBBox[1]) / height;
      }
    }
    if (resX || resY) {
      const allImages = [];
      for (let i2 = 0; i2 < imageCount; ++i2) {
        const image2 = await this.getImage(i2);
        const { SubfileType: subfileType, NewSubfileType: newSubfileType } = image2.fileDirectory;
        if (i2 === 0 || subfileType === 2 || newSubfileType & 1) {
          allImages.push(image2);
        }
      }
      allImages.sort((a2, b2) => a2.getWidth() - b2.getWidth());
      for (let i2 = 0; i2 < allImages.length; ++i2) {
        const image2 = allImages[i2];
        const imgResX = (imgBBox[2] - imgBBox[0]) / image2.getWidth();
        const imgResY = (imgBBox[3] - imgBBox[1]) / image2.getHeight();
        usedImage = image2;
        if (resX && resX > imgResX || resY && resY > imgResY) {
          break;
        }
      }
    }
    let wnd = imageWindow;
    if (bbox2) {
      const [oX, oY] = firstImage.getOrigin();
      const [imageResX, imageResY] = usedImage.getResolution(firstImage);
      wnd = [
        Math.round((bbox2[0] - oX) / imageResX),
        Math.round((bbox2[1] - oY) / imageResY),
        Math.round((bbox2[2] - oX) / imageResX),
        Math.round((bbox2[3] - oY) / imageResY)
      ];
      wnd = [
        Math.min(wnd[0], wnd[2]),
        Math.min(wnd[1], wnd[3]),
        Math.max(wnd[0], wnd[2]),
        Math.max(wnd[1], wnd[3])
      ];
    }
    return usedImage.readRasters(__spreadProps(__spreadValues({}, options), { window: wnd }));
  }
}
class GeoTIFF extends GeoTIFFBase {
  constructor(source, littleEndian, bigTiff, firstIFDOffset, options = {}) {
    super();
    this.source = source;
    this.littleEndian = littleEndian;
    this.bigTiff = bigTiff;
    this.firstIFDOffset = firstIFDOffset;
    this.cache = options.cache || false;
    this.ifdRequests = [];
    this.ghostValues = null;
  }
  async getSlice(offset2, size) {
    const fallbackSize = this.bigTiff ? 4048 : 1024;
    return new DataSlice((await this.source.fetch([{
      offset: offset2,
      length: typeof size !== "undefined" ? size : fallbackSize
    }]))[0], offset2, this.littleEndian, this.bigTiff);
  }
  async parseFileDirectoryAt(offset2) {
    const entrySize = this.bigTiff ? 20 : 12;
    const offsetSize = this.bigTiff ? 8 : 2;
    let dataSlice = await this.getSlice(offset2);
    const numDirEntries = this.bigTiff ? dataSlice.readUint64(offset2) : dataSlice.readUint16(offset2);
    const byteSize = numDirEntries * entrySize + (this.bigTiff ? 16 : 6);
    if (!dataSlice.covers(offset2, byteSize)) {
      dataSlice = await this.getSlice(offset2, byteSize);
    }
    const fileDirectory = {};
    let i2 = offset2 + (this.bigTiff ? 8 : 2);
    for (let entryCount = 0; entryCount < numDirEntries; i2 += entrySize, ++entryCount) {
      const fieldTag = dataSlice.readUint16(i2);
      const fieldType = dataSlice.readUint16(i2 + 2);
      const typeCount = this.bigTiff ? dataSlice.readUint64(i2 + 4) : dataSlice.readUint32(i2 + 4);
      let fieldValues;
      let value;
      const fieldTypeLength = getFieldTypeLength(fieldType);
      const valueOffset = i2 + (this.bigTiff ? 12 : 8);
      if (fieldTypeLength * typeCount <= (this.bigTiff ? 8 : 4)) {
        fieldValues = getValues(dataSlice, fieldType, typeCount, valueOffset);
      } else {
        const actualOffset = dataSlice.readOffset(valueOffset);
        const length = getFieldTypeLength(fieldType) * typeCount;
        if (dataSlice.covers(actualOffset, length)) {
          fieldValues = getValues(dataSlice, fieldType, typeCount, actualOffset);
        } else {
          const fieldDataSlice = await this.getSlice(actualOffset, length);
          fieldValues = getValues(fieldDataSlice, fieldType, typeCount, actualOffset);
        }
      }
      if (typeCount === 1 && arrayFields.indexOf(fieldTag) === -1 && !(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {
        value = fieldValues[0];
      } else {
        value = fieldValues;
      }
      fileDirectory[fieldTagNames[fieldTag]] = value;
    }
    const geoKeyDirectory = parseGeoKeyDirectory(fileDirectory);
    const nextIFDByteOffset = dataSlice.readOffset(offset2 + offsetSize + entrySize * numDirEntries);
    return new ImageFileDirectory(fileDirectory, geoKeyDirectory, nextIFDByteOffset);
  }
  async requestIFD(index2) {
    if (this.ifdRequests[index2]) {
      return this.ifdRequests[index2];
    } else if (index2 === 0) {
      this.ifdRequests[index2] = this.parseFileDirectoryAt(this.firstIFDOffset);
      return this.ifdRequests[index2];
    } else if (!this.ifdRequests[index2 - 1]) {
      try {
        this.ifdRequests[index2 - 1] = this.requestIFD(index2 - 1);
      } catch (e2) {
        if (e2 instanceof GeoTIFFImageIndexError) {
          throw new GeoTIFFImageIndexError(index2);
        }
        throw e2;
      }
    }
    this.ifdRequests[index2] = (async () => {
      const previousIfd = await this.ifdRequests[index2 - 1];
      if (previousIfd.nextIFDByteOffset === 0) {
        throw new GeoTIFFImageIndexError(index2);
      }
      return this.parseFileDirectoryAt(previousIfd.nextIFDByteOffset);
    })();
    return this.ifdRequests[index2];
  }
  async getImage(index2 = 0) {
    const ifd = await this.requestIFD(index2);
    return new GeoTIFFImage$1(ifd.fileDirectory, ifd.geoKeyDirectory, this.dataView, this.littleEndian, this.cache, this.source);
  }
  async getImageCount() {
    let index2 = 0;
    let hasNext = true;
    while (hasNext) {
      try {
        await this.requestIFD(index2);
        ++index2;
      } catch (e2) {
        if (e2 instanceof GeoTIFFImageIndexError) {
          hasNext = false;
        } else {
          throw e2;
        }
      }
    }
    return index2;
  }
  async getGhostValues() {
    const offset2 = this.bigTiff ? 16 : 8;
    if (this.ghostValues) {
      return this.ghostValues;
    }
    const detectionString = "GDAL_STRUCTURAL_METADATA_SIZE=";
    const heuristicAreaSize = detectionString.length + 100;
    let slice2 = await this.getSlice(offset2, heuristicAreaSize);
    if (detectionString === getValues(slice2, fieldTypes.ASCII, detectionString.length, offset2)) {
      const valuesString = getValues(slice2, fieldTypes.ASCII, heuristicAreaSize, offset2);
      const firstLine = valuesString.split("\n")[0];
      const metadataSize = Number(firstLine.split("=")[1].split(" ")[0]) + firstLine.length;
      if (metadataSize > heuristicAreaSize) {
        slice2 = await this.getSlice(offset2, metadataSize);
      }
      const fullString = getValues(slice2, fieldTypes.ASCII, metadataSize, offset2);
      this.ghostValues = {};
      fullString.split("\n").filter((line) => line.length > 0).map((line) => line.split("=")).forEach(([key, value]) => {
        this.ghostValues[key] = value;
      });
    }
    return this.ghostValues;
  }
  static async fromSource(source, options, signal) {
    const headerData = (await source.fetch([{ offset: 0, length: 1024 }], signal))[0];
    const dataView = new DataView64(headerData);
    const BOM = dataView.getUint16(0, 0);
    let littleEndian;
    if (BOM === 18761) {
      littleEndian = true;
    } else if (BOM === 19789) {
      littleEndian = false;
    } else {
      throw new TypeError("Invalid byte order value.");
    }
    const magicNumber = dataView.getUint16(2, littleEndian);
    let bigTiff;
    if (magicNumber === 42) {
      bigTiff = false;
    } else if (magicNumber === 43) {
      bigTiff = true;
      const offsetByteSize = dataView.getUint16(4, littleEndian);
      if (offsetByteSize !== 8) {
        throw new Error("Unsupported offset byte-size.");
      }
    } else {
      throw new TypeError("Invalid magic number.");
    }
    const firstIFDOffset = bigTiff ? dataView.getUint64(8, littleEndian) : dataView.getUint32(4, littleEndian);
    return new GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset, options);
  }
  close() {
    if (typeof this.source.close === "function") {
      return this.source.close();
    }
    return false;
  }
}
class MultiGeoTIFF extends GeoTIFFBase {
  constructor(mainFile, overviewFiles) {
    super();
    this.mainFile = mainFile;
    this.overviewFiles = overviewFiles;
    this.imageFiles = [mainFile].concat(overviewFiles);
    this.fileDirectoriesPerFile = null;
    this.fileDirectoriesPerFileParsing = null;
    this.imageCount = null;
  }
  async parseFileDirectoriesPerFile() {
    const requests = [this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)].concat(this.overviewFiles.map((file) => file.parseFileDirectoryAt(file.firstIFDOffset)));
    this.fileDirectoriesPerFile = await Promise.all(requests);
    return this.fileDirectoriesPerFile;
  }
  async getImage(index2 = 0) {
    await this.getImageCount();
    await this.parseFileDirectoriesPerFile();
    let visited = 0;
    let relativeIndex = 0;
    for (let i2 = 0; i2 < this.imageFiles.length; i2++) {
      const imageFile = this.imageFiles[i2];
      for (let ii = 0; ii < this.imageCounts[i2]; ii++) {
        if (index2 === visited) {
          const ifd = await imageFile.requestIFD(relativeIndex);
          return new GeoTIFFImage$1(ifd.fileDirectory, ifd.geoKeyDirectory, imageFile.dataView, imageFile.littleEndian, imageFile.cache, imageFile.source);
        }
        visited++;
        relativeIndex++;
      }
      relativeIndex = 0;
    }
    throw new RangeError("Invalid image index");
  }
  async getImageCount() {
    if (this.imageCount !== null) {
      return this.imageCount;
    }
    const requests = [this.mainFile.getImageCount()].concat(this.overviewFiles.map((file) => file.getImageCount()));
    this.imageCounts = await Promise.all(requests);
    this.imageCount = this.imageCounts.reduce((count, ifds) => count + ifds, 0);
    return this.imageCount;
  }
}
async function fromUrl(url, options = {}, signal) {
  return GeoTIFF.fromSource(makeRemoteSource(url, options), signal);
}
async function fromBlob(blob, signal) {
  return GeoTIFF.fromSource(makeFileReaderSource(blob), signal);
}
async function fromUrls(mainUrl, overviewUrls = [], options = {}, signal) {
  const mainFile = await GeoTIFF.fromSource(makeRemoteSource(mainUrl, options), signal);
  const overviewFiles = await Promise.all(overviewUrls.map((url) => GeoTIFF.fromSource(makeRemoteSource(url, options))));
  return new MultiGeoTIFF(mainFile, overviewFiles);
}
function isMask(image2) {
  const fileDirectory = image2.fileDirectory;
  const type = fileDirectory.NewSubfileType || 0;
  return (type & 4) === 4;
}
function readRGB(preference, image2) {
  if (!preference) {
    return false;
  }
  if (preference === true) {
    return true;
  }
  if (image2.getSamplesPerPixel() !== 3) {
    return false;
  }
  const interpretation = image2.fileDirectory.PhotometricInterpretation;
  const interpretations = photometricInterpretations;
  return interpretation === interpretations.CMYK || interpretation === interpretations.YCbCr || interpretation === interpretations.CIELab || interpretation === interpretations.ICCLab;
}
const STATISTICS_MAXIMUM = "STATISTICS_MAXIMUM";
const STATISTICS_MINIMUM = "STATISTICS_MINIMUM";
let workerPool;
function getWorkerPool() {
  if (!workerPool) {
    workerPool = new Pool$1();
  }
  return workerPool;
}
function getBoundingBox(image2) {
  try {
    return image2.getBoundingBox();
  } catch (_2) {
    const fileDirectory = image2.fileDirectory;
    return [0, 0, fileDirectory.ImageWidth, fileDirectory.ImageLength];
  }
}
function getOrigin(image2) {
  try {
    return image2.getOrigin().slice(0, 2);
  } catch (_2) {
    return [0, image2.fileDirectory.ImageLength];
  }
}
function getResolutions(image2, referenceImage) {
  try {
    return image2.getResolution(referenceImage);
  } catch (_2) {
    return [
      referenceImage.fileDirectory.ImageWidth / image2.fileDirectory.ImageWidth,
      referenceImage.fileDirectory.ImageHeight / image2.fileDirectory.ImageHeight
    ];
  }
}
function getProjection(image2) {
  const geoKeys = image2.geoKeys;
  if (!geoKeys) {
    return null;
  }
  if (geoKeys.ProjectedCSTypeGeoKey) {
    const code = "EPSG:" + geoKeys.ProjectedCSTypeGeoKey;
    let projection = get$4(code);
    if (!projection) {
      const units2 = fromCode(geoKeys.ProjLinearUnitsGeoKey);
      if (units2) {
        projection = new Projection$2({
          code,
          units: units2
        });
      }
    }
    return projection;
  }
  if (geoKeys.GeographicTypeGeoKey) {
    const code = "EPSG:" + geoKeys.GeographicTypeGeoKey;
    let projection = get$4(code);
    if (!projection) {
      const units2 = fromCode(geoKeys.GeogAngularUnitsGeoKey);
      if (units2) {
        projection = new Projection$2({
          code,
          units: units2
        });
      }
    }
    return projection;
  }
  return null;
}
function getImagesForTIFF(tiff) {
  return tiff.getImageCount().then(function(count) {
    const requests = new Array(count);
    for (let i2 = 0; i2 < count; ++i2) {
      requests[i2] = tiff.getImage(i2);
    }
    return Promise.all(requests);
  });
}
function getImagesForSource(source, options) {
  let request;
  if (source.blob) {
    request = fromBlob(source.blob);
  } else if (source.overviews) {
    request = fromUrls(source.url, source.overviews, options);
  } else {
    request = fromUrl(source.url, options);
  }
  return request.then(getImagesForTIFF);
}
function assertEqual(expected, got, tolerance, message, rejector) {
  if (Array.isArray(expected)) {
    const length = expected.length;
    if (!Array.isArray(got) || length != got.length) {
      const error = new Error(message);
      rejector(error);
      throw error;
    }
    for (let i2 = 0; i2 < length; ++i2) {
      assertEqual(expected[i2], got[i2], tolerance, message, rejector);
    }
    return;
  }
  got = got;
  if (Math.abs(expected - got) > tolerance * expected) {
    throw new Error(message);
  }
}
function getMinForDataType(array) {
  if (array instanceof Int8Array) {
    return -128;
  }
  if (array instanceof Int16Array) {
    return -32768;
  }
  if (array instanceof Int32Array) {
    return -2147483648;
  }
  if (array instanceof Float32Array) {
    return 12e-39;
  }
  return 0;
}
function getMaxForDataType(array) {
  if (array instanceof Int8Array) {
    return 127;
  }
  if (array instanceof Uint8Array) {
    return 255;
  }
  if (array instanceof Uint8ClampedArray) {
    return 255;
  }
  if (array instanceof Int16Array) {
    return 32767;
  }
  if (array instanceof Uint16Array) {
    return 65535;
  }
  if (array instanceof Int32Array) {
    return 2147483647;
  }
  if (array instanceof Uint32Array) {
    return 4294967295;
  }
  if (array instanceof Float32Array) {
    return 34e37;
  }
  return 255;
}
class GeoTIFFSource extends DataTileSource {
  constructor(options) {
    super({
      state: "loading",
      tileGrid: null,
      projection: null,
      opaque: options.opaque,
      transition: options.transition,
      interpolate: options.interpolate !== false,
      wrapX: options.wrapX
    });
    this.sourceInfo_ = options.sources;
    const numSources = this.sourceInfo_.length;
    this.sourceOptions_ = options.sourceOptions;
    this.sourceImagery_ = new Array(numSources);
    this.sourceMasks_ = new Array(numSources);
    this.resolutionFactors_ = new Array(numSources);
    this.samplesPerPixel_;
    this.nodataValues_;
    this.metadata_;
    this.normalize_ = options.normalize !== false;
    this.addAlpha_ = false;
    this.error_ = null;
    this.convertToRGB_ = options.convertToRGB || false;
    this.setKey(this.sourceInfo_.map((source) => source.url).join(","));
    const self2 = this;
    const requests = new Array(numSources);
    for (let i2 = 0; i2 < numSources; ++i2) {
      requests[i2] = getImagesForSource(this.sourceInfo_[i2], this.sourceOptions_);
    }
    Promise.all(requests).then(function(sources) {
      self2.configure_(sources);
    }).catch(function(error) {
      console.error(error);
      self2.error_ = error;
      self2.setState("error");
    });
  }
  getError() {
    return this.error_;
  }
  configure_(sources) {
    let extent2;
    let origin;
    let commonRenderTileSizes;
    let commonSourceTileSizes;
    let resolutions;
    const samplesPerPixel = new Array(sources.length);
    const nodataValues = new Array(sources.length);
    const metadata = new Array(sources.length);
    let minZoom = 0;
    const sourceCount = sources.length;
    for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {
      const images = [];
      const masks = [];
      sources[sourceIndex].forEach((item) => {
        if (isMask(item)) {
          masks.push(item);
        } else {
          images.push(item);
        }
      });
      const imageCount = images.length;
      if (masks.length > 0 && masks.length !== imageCount) {
        throw new Error(`Expected one mask per image found ${masks.length} masks and ${imageCount} images`);
      }
      let sourceExtent;
      let sourceOrigin;
      const sourceTileSizes = new Array(imageCount);
      const renderTileSizes = new Array(imageCount);
      const sourceResolutions = new Array(imageCount);
      nodataValues[sourceIndex] = new Array(imageCount);
      metadata[sourceIndex] = new Array(imageCount);
      for (let imageIndex = 0; imageIndex < imageCount; ++imageIndex) {
        const image2 = images[imageIndex];
        const nodataValue = image2.getGDALNoData();
        metadata[sourceIndex][imageIndex] = image2.getGDALMetadata(0);
        nodataValues[sourceIndex][imageIndex] = nodataValue;
        const wantedSamples = this.sourceInfo_[sourceIndex].bands;
        samplesPerPixel[sourceIndex] = wantedSamples ? wantedSamples.length : image2.getSamplesPerPixel();
        const level = imageCount - (imageIndex + 1);
        if (!sourceExtent) {
          sourceExtent = getBoundingBox(image2);
        }
        if (!sourceOrigin) {
          sourceOrigin = getOrigin(image2);
        }
        const imageResolutions = getResolutions(image2, images[0]);
        sourceResolutions[level] = imageResolutions[0];
        const sourceTileSize = [image2.getTileWidth(), image2.getTileHeight()];
        sourceTileSizes[level] = sourceTileSize;
        const aspectRatio = imageResolutions[0] / Math.abs(imageResolutions[1]);
        renderTileSizes[level] = [
          sourceTileSize[0],
          sourceTileSize[1] / aspectRatio
        ];
      }
      if (!extent2) {
        extent2 = sourceExtent;
      } else {
        getIntersection(extent2, sourceExtent, extent2);
      }
      if (!origin) {
        origin = sourceOrigin;
      } else {
        const message = `Origin mismatch for source ${sourceIndex}, got [${sourceOrigin}] but expected [${origin}]`;
        assertEqual(origin, sourceOrigin, 0, message, this.viewRejector);
      }
      if (!resolutions) {
        resolutions = sourceResolutions;
        this.resolutionFactors_[sourceIndex] = 1;
      } else {
        if (resolutions.length - minZoom > sourceResolutions.length) {
          minZoom = resolutions.length - sourceResolutions.length;
        }
        const resolutionFactor = resolutions[resolutions.length - 1] / sourceResolutions[sourceResolutions.length - 1];
        this.resolutionFactors_[sourceIndex] = resolutionFactor;
        const scaledSourceResolutions = sourceResolutions.map((resolution) => resolution *= resolutionFactor);
        const message = `Resolution mismatch for source ${sourceIndex}, got [${scaledSourceResolutions}] but expected [${resolutions}]`;
        assertEqual(resolutions.slice(minZoom, resolutions.length), scaledSourceResolutions, 0.02, message, this.viewRejector);
      }
      if (!commonRenderTileSizes) {
        commonRenderTileSizes = renderTileSizes;
      } else {
        assertEqual(commonRenderTileSizes.slice(minZoom, commonRenderTileSizes.length), renderTileSizes, 0.01, `Tile size mismatch for source ${sourceIndex}`, this.viewRejector);
      }
      if (!commonSourceTileSizes) {
        commonSourceTileSizes = sourceTileSizes;
      } else {
        assertEqual(commonSourceTileSizes.slice(minZoom, commonSourceTileSizes.length), sourceTileSizes, 0, `Tile size mismatch for source ${sourceIndex}`, this.viewRejector);
      }
      this.sourceImagery_[sourceIndex] = images.reverse();
      this.sourceMasks_[sourceIndex] = masks.reverse();
    }
    for (let i2 = 0, ii = this.sourceImagery_.length; i2 < ii; ++i2) {
      const sourceImagery = this.sourceImagery_[i2];
      while (sourceImagery.length < resolutions.length) {
        sourceImagery.unshift(void 0);
      }
    }
    if (!this.getProjection()) {
      const firstSource = sources[0];
      for (let i2 = firstSource.length - 1; i2 >= 0; --i2) {
        const image2 = firstSource[i2];
        const projection = getProjection(image2);
        if (projection) {
          this.projection = projection;
          break;
        }
      }
    }
    this.samplesPerPixel_ = samplesPerPixel;
    this.nodataValues_ = nodataValues;
    this.metadata_ = metadata;
    outer:
      for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {
        if (this.sourceInfo_[sourceIndex].nodata !== void 0) {
          this.addAlpha_ = true;
          break;
        }
        if (this.sourceMasks_[sourceIndex].length) {
          this.addAlpha_ = true;
          break;
        }
        const values3 = nodataValues[sourceIndex];
        const bands = this.sourceInfo_[sourceIndex].bands;
        if (bands) {
          for (let i2 = 0; i2 < bands.length; ++i2) {
            if (values3[bands[i2] - 1] !== null) {
              this.addAlpha_ = true;
              break outer;
            }
          }
          continue;
        }
        for (let imageIndex = 0; imageIndex < values3.length; ++imageIndex) {
          if (values3[imageIndex] !== null) {
            this.addAlpha_ = true;
            break outer;
          }
        }
      }
    let bandCount = this.addAlpha_ ? 1 : 0;
    for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {
      bandCount += samplesPerPixel[sourceIndex];
    }
    this.bandCount = bandCount;
    const tileGrid = new TileGrid({
      extent: extent2,
      minZoom,
      origin,
      resolutions,
      tileSizes: commonRenderTileSizes
    });
    this.tileGrid = tileGrid;
    this.setTileSizes(commonSourceTileSizes);
    this.setLoader(this.loadTile_.bind(this));
    this.setState("ready");
    let zoom = 0;
    if (resolutions.length === 1) {
      resolutions = [resolutions[0] * 2, resolutions[0]];
      zoom = 1;
    }
    this.viewResolver({
      showFullExtent: true,
      projection: this.projection,
      resolutions,
      center: toUserCoordinate(getCenter(extent2), this.projection),
      extent: toUserExtent(extent2, this.projection),
      zoom
    });
  }
  loadTile_(z2, x2, y2) {
    const sourceTileSize = this.getTileSize(z2);
    const sourceCount = this.sourceImagery_.length;
    const requests = new Array(sourceCount * 2);
    const nodataValues = this.nodataValues_;
    const sourceInfo = this.sourceInfo_;
    const pool = getWorkerPool();
    for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {
      const source = sourceInfo[sourceIndex];
      const resolutionFactor = this.resolutionFactors_[sourceIndex];
      const pixelBounds = [
        Math.round(x2 * (sourceTileSize[0] * resolutionFactor)),
        Math.round(y2 * (sourceTileSize[1] * resolutionFactor)),
        Math.round((x2 + 1) * (sourceTileSize[0] * resolutionFactor)),
        Math.round((y2 + 1) * (sourceTileSize[1] * resolutionFactor))
      ];
      const image2 = this.sourceImagery_[sourceIndex][z2];
      let samples;
      if (source.bands) {
        samples = source.bands.map(function(bandNumber) {
          return bandNumber - 1;
        });
      }
      let fillValue;
      if ("nodata" in source && source.nodata !== null) {
        fillValue = source.nodata;
      } else {
        if (!samples) {
          fillValue = nodataValues[sourceIndex];
        } else {
          fillValue = samples.map(function(sampleIndex) {
            return nodataValues[sourceIndex][sampleIndex];
          });
        }
      }
      const readOptions = {
        window: pixelBounds,
        width: sourceTileSize[0],
        height: sourceTileSize[1],
        samples,
        fillValue,
        pool,
        interleave: false
      };
      if (readRGB(this.convertToRGB_, image2)) {
        requests[sourceIndex] = image2.readRGB(readOptions);
      } else {
        requests[sourceIndex] = image2.readRasters(readOptions);
      }
      const maskIndex = sourceCount + sourceIndex;
      const mask = this.sourceMasks_[sourceIndex][z2];
      if (!mask) {
        requests[maskIndex] = Promise.resolve(null);
        continue;
      }
      requests[maskIndex] = mask.readRasters({
        window: pixelBounds,
        width: sourceTileSize[0],
        height: sourceTileSize[1],
        samples: [0],
        pool,
        interleave: false
      });
    }
    return Promise.all(requests).then(this.composeTile_.bind(this, sourceTileSize)).catch(function(error) {
      console.error(error);
      throw error;
    });
  }
  composeTile_(sourceTileSize, sourceSamples) {
    const metadata = this.metadata_;
    const sourceInfo = this.sourceInfo_;
    const sourceCount = this.sourceImagery_.length;
    const bandCount = this.bandCount;
    const samplesPerPixel = this.samplesPerPixel_;
    const nodataValues = this.nodataValues_;
    const normalize2 = this.normalize_;
    const addAlpha = this.addAlpha_;
    const pixelCount = sourceTileSize[0] * sourceTileSize[1];
    const dataLength = pixelCount * bandCount;
    let data2;
    if (normalize2) {
      data2 = new Uint8Array(dataLength);
    } else {
      data2 = new Float32Array(dataLength);
    }
    let dataIndex = 0;
    for (let pixelIndex = 0; pixelIndex < pixelCount; ++pixelIndex) {
      let transparent = addAlpha;
      for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {
        const source = sourceInfo[sourceIndex];
        let min2 = source.min;
        let max2 = source.max;
        let gain, bias;
        if (normalize2) {
          const stats = metadata[sourceIndex][0];
          if (min2 === void 0) {
            if (stats && STATISTICS_MINIMUM in stats) {
              min2 = parseFloat(stats[STATISTICS_MINIMUM]);
            } else {
              min2 = getMinForDataType(sourceSamples[sourceIndex][0]);
            }
          }
          if (max2 === void 0) {
            if (stats && STATISTICS_MAXIMUM in stats) {
              max2 = parseFloat(stats[STATISTICS_MAXIMUM]);
            } else {
              max2 = getMaxForDataType(sourceSamples[sourceIndex][0]);
            }
          }
          gain = 255 / (max2 - min2);
          bias = -min2 * gain;
        }
        for (let sampleIndex = 0; sampleIndex < samplesPerPixel[sourceIndex]; ++sampleIndex) {
          const sourceValue = sourceSamples[sourceIndex][sampleIndex][pixelIndex];
          let value;
          if (normalize2) {
            value = clamp(gain * sourceValue + bias, 0, 255);
          } else {
            value = sourceValue;
          }
          if (!addAlpha) {
            data2[dataIndex] = value;
          } else {
            let nodata = source.nodata;
            if (nodata === void 0) {
              let bandIndex;
              if (source.bands) {
                bandIndex = source.bands[sampleIndex] - 1;
              } else {
                bandIndex = sampleIndex;
              }
              nodata = nodataValues[sourceIndex][bandIndex];
            }
            const nodataIsNaN = isNaN(nodata);
            if (!nodataIsNaN && sourceValue !== nodata || nodataIsNaN && !isNaN(sourceValue)) {
              transparent = false;
              data2[dataIndex] = value;
            }
          }
          dataIndex++;
        }
        if (!transparent) {
          const maskIndex = sourceCount + sourceIndex;
          const mask = sourceSamples[maskIndex];
          if (mask && !mask[0][pixelIndex]) {
            transparent = true;
          }
        }
      }
      if (addAlpha) {
        if (!transparent) {
          data2[dataIndex] = 255;
        }
        dataIndex++;
      }
    }
    return data2;
  }
}
GeoTIFFSource.prototype.getView;
const Versions = {
  VERSION1: "version1",
  VERSION2: "version2",
  VERSION3: "version3"
};
const IIIF_PROFILE_VALUES = {};
IIIF_PROFILE_VALUES[Versions.VERSION1] = {
  "level0": {
    supports: [],
    formats: [],
    qualities: ["native"]
  },
  "level1": {
    supports: ["regionByPx", "sizeByW", "sizeByH", "sizeByPct"],
    formats: ["jpg"],
    qualities: ["native"]
  },
  "level2": {
    supports: [
      "regionByPx",
      "regionByPct",
      "sizeByW",
      "sizeByH",
      "sizeByPct",
      "sizeByConfinedWh",
      "sizeByWh"
    ],
    formats: ["jpg", "png"],
    qualities: ["native", "color", "grey", "bitonal"]
  }
};
IIIF_PROFILE_VALUES[Versions.VERSION2] = {
  "level0": {
    supports: [],
    formats: ["jpg"],
    qualities: ["default"]
  },
  "level1": {
    supports: ["regionByPx", "sizeByW", "sizeByH", "sizeByPct"],
    formats: ["jpg"],
    qualities: ["default"]
  },
  "level2": {
    supports: [
      "regionByPx",
      "regionByPct",
      "sizeByW",
      "sizeByH",
      "sizeByPct",
      "sizeByConfinedWh",
      "sizeByDistortedWh",
      "sizeByWh"
    ],
    formats: ["jpg", "png"],
    qualities: ["default", "bitonal"]
  }
};
IIIF_PROFILE_VALUES[Versions.VERSION3] = {
  "level0": {
    supports: [],
    formats: ["jpg"],
    qualities: ["default"]
  },
  "level1": {
    supports: ["regionByPx", "regionSquare", "sizeByW", "sizeByH", "sizeByWh"],
    formats: ["jpg"],
    qualities: ["default"]
  },
  "level2": {
    supports: [
      "regionByPx",
      "regionSquare",
      "regionByPct",
      "sizeByW",
      "sizeByH",
      "sizeByPct",
      "sizeByConfinedWh",
      "sizeByWh"
    ],
    formats: ["jpg", "png"],
    qualities: ["default"]
  }
};
IIIF_PROFILE_VALUES["none"] = {
  "none": {
    supports: [],
    formats: [],
    qualities: []
  }
};
const COMPLIANCE_VERSION1 = /^https?:\/\/library\.stanford\.edu\/iiif\/image-api\/(?:1\.1\/)?compliance\.html#level[0-2]$/;
const COMPLIANCE_VERSION2 = /^https?:\/\/iiif\.io\/api\/image\/2\/level[0-2](?:\.json)?$/;
const COMPLIANCE_VERSION3 = /(^https?:\/\/iiif\.io\/api\/image\/3\/level[0-2](?:\.json)?$)|(^level[0-2]$)/;
function generateVersion1Options(iiifInfo) {
  let levelProfile = iiifInfo.getComplianceLevelSupportedFeatures();
  if (levelProfile === void 0) {
    levelProfile = IIIF_PROFILE_VALUES[Versions.VERSION1]["level0"];
  }
  return {
    url: iiifInfo.imageInfo["@id"] === void 0 ? void 0 : iiifInfo.imageInfo["@id"].replace(/\/?(?:info\.json)?$/g, ""),
    supports: levelProfile.supports,
    formats: [
      ...levelProfile.formats,
      iiifInfo.imageInfo.formats === void 0 ? [] : iiifInfo.imageInfo.formats
    ],
    qualities: [
      ...levelProfile.qualities,
      iiifInfo.imageInfo.qualities === void 0 ? [] : iiifInfo.imageInfo.qualities
    ],
    resolutions: iiifInfo.imageInfo.scale_factors,
    tileSize: iiifInfo.imageInfo.tile_width !== void 0 ? iiifInfo.imageInfo.tile_height !== void 0 ? [iiifInfo.imageInfo.tile_width, iiifInfo.imageInfo.tile_height] : [iiifInfo.imageInfo.tile_width, iiifInfo.imageInfo.tile_width] : iiifInfo.imageInfo.tile_height != void 0 ? [iiifInfo.imageInfo.tile_height, iiifInfo.imageInfo.tile_height] : void 0
  };
}
function generateVersion2Options(iiifInfo) {
  const levelProfile = iiifInfo.getComplianceLevelSupportedFeatures(), additionalProfile = Array.isArray(iiifInfo.imageInfo.profile) && iiifInfo.imageInfo.profile.length > 1, profileSupports = additionalProfile && iiifInfo.imageInfo.profile[1].supports ? iiifInfo.imageInfo.profile[1].supports : [], profileFormats = additionalProfile && iiifInfo.imageInfo.profile[1].formats ? iiifInfo.imageInfo.profile[1].formats : [], profileQualities = additionalProfile && iiifInfo.imageInfo.profile[1].qualities ? iiifInfo.imageInfo.profile[1].qualities : [];
  return {
    url: iiifInfo.imageInfo["@id"].replace(/\/?(?:info\.json)?$/g, ""),
    sizes: iiifInfo.imageInfo.sizes === void 0 ? void 0 : iiifInfo.imageInfo.sizes.map(function(size) {
      return [size.width, size.height];
    }),
    tileSize: iiifInfo.imageInfo.tiles === void 0 ? void 0 : [
      iiifInfo.imageInfo.tiles.map(function(tile2) {
        return tile2.width;
      })[0],
      iiifInfo.imageInfo.tiles.map(function(tile2) {
        return tile2.height === void 0 ? tile2.width : tile2.height;
      })[0]
    ],
    resolutions: iiifInfo.imageInfo.tiles === void 0 ? void 0 : iiifInfo.imageInfo.tiles.map(function(tile2) {
      return tile2.scaleFactors;
    })[0],
    supports: [...levelProfile.supports, ...profileSupports],
    formats: [...levelProfile.formats, ...profileFormats],
    qualities: [...levelProfile.qualities, ...profileQualities]
  };
}
function generateVersion3Options(iiifInfo) {
  const levelProfile = iiifInfo.getComplianceLevelSupportedFeatures(), formats = iiifInfo.imageInfo.extraFormats === void 0 ? levelProfile.formats : [...levelProfile.formats, ...iiifInfo.imageInfo.extraFormats], preferredFormat = iiifInfo.imageInfo.preferredFormats !== void 0 && Array.isArray(iiifInfo.imageInfo.preferredFormats) && iiifInfo.imageInfo.preferredFormats.length > 0 ? iiifInfo.imageInfo.preferredFormats.filter(function(format2) {
    return ["jpg", "png", "gif"].includes(format2);
  }).reduce(function(acc, format2) {
    return acc === void 0 && formats.includes(format2) ? format2 : acc;
  }, void 0) : void 0;
  return {
    url: iiifInfo.imageInfo["id"],
    sizes: iiifInfo.imageInfo.sizes === void 0 ? void 0 : iiifInfo.imageInfo.sizes.map(function(size) {
      return [size.width, size.height];
    }),
    tileSize: iiifInfo.imageInfo.tiles === void 0 ? void 0 : [
      iiifInfo.imageInfo.tiles.map(function(tile2) {
        return tile2.width;
      })[0],
      iiifInfo.imageInfo.tiles.map(function(tile2) {
        return tile2.height;
      })[0]
    ],
    resolutions: iiifInfo.imageInfo.tiles === void 0 ? void 0 : iiifInfo.imageInfo.tiles.map(function(tile2) {
      return tile2.scaleFactors;
    })[0],
    supports: iiifInfo.imageInfo.extraFeatures === void 0 ? levelProfile.supports : [...levelProfile.supports, ...iiifInfo.imageInfo.extraFeatures],
    formats,
    qualities: iiifInfo.imageInfo.extraQualities === void 0 ? levelProfile.qualities : [...levelProfile.qualities, ...iiifInfo.imageInfo.extraQualities],
    preferredFormat
  };
}
const versionFunctions = {};
versionFunctions[Versions.VERSION1] = generateVersion1Options;
versionFunctions[Versions.VERSION2] = generateVersion2Options;
versionFunctions[Versions.VERSION3] = generateVersion3Options;
class IIIFInfo {
  constructor(imageInfo) {
    this.setImageInfo(imageInfo);
  }
  setImageInfo(imageInfo) {
    if (typeof imageInfo == "string") {
      this.imageInfo = JSON.parse(imageInfo);
    } else {
      this.imageInfo = imageInfo;
    }
  }
  getImageApiVersion() {
    if (this.imageInfo === void 0) {
      return;
    }
    let context2 = this.imageInfo["@context"] || "ol-no-context";
    if (typeof context2 == "string") {
      context2 = [context2];
    }
    for (let i2 = 0; i2 < context2.length; i2++) {
      switch (context2[i2]) {
        case "http://library.stanford.edu/iiif/image-api/1.1/context.json":
        case "http://iiif.io/api/image/1/context.json":
          return Versions.VERSION1;
        case "http://iiif.io/api/image/2/context.json":
          return Versions.VERSION2;
        case "http://iiif.io/api/image/3/context.json":
          return Versions.VERSION3;
        case "ol-no-context":
          if (this.getComplianceLevelEntryFromProfile(Versions.VERSION1) && this.imageInfo.identifier) {
            return Versions.VERSION1;
          }
          break;
      }
    }
    assert(false, 61);
  }
  getComplianceLevelEntryFromProfile(version2) {
    if (this.imageInfo === void 0 || this.imageInfo.profile === void 0) {
      return;
    }
    if (version2 === void 0) {
      version2 = this.getImageApiVersion();
    }
    switch (version2) {
      case Versions.VERSION1:
        if (COMPLIANCE_VERSION1.test(this.imageInfo.profile)) {
          return this.imageInfo.profile;
        }
        break;
      case Versions.VERSION3:
        if (COMPLIANCE_VERSION3.test(this.imageInfo.profile)) {
          return this.imageInfo.profile;
        }
        break;
      case Versions.VERSION2:
        if (typeof this.imageInfo.profile === "string" && COMPLIANCE_VERSION2.test(this.imageInfo.profile)) {
          return this.imageInfo.profile;
        }
        if (Array.isArray(this.imageInfo.profile) && this.imageInfo.profile.length > 0 && typeof this.imageInfo.profile[0] === "string" && COMPLIANCE_VERSION2.test(this.imageInfo.profile[0])) {
          return this.imageInfo.profile[0];
        }
        break;
    }
  }
  getComplianceLevelFromProfile(version2) {
    const complianceLevel = this.getComplianceLevelEntryFromProfile(version2);
    if (complianceLevel === void 0) {
      return void 0;
    }
    const level = complianceLevel.match(/level[0-2](?:\.json)?$/g);
    return Array.isArray(level) ? level[0].replace(".json", "") : void 0;
  }
  getComplianceLevelSupportedFeatures() {
    if (this.imageInfo === void 0) {
      return;
    }
    const version2 = this.getImageApiVersion();
    const level = this.getComplianceLevelFromProfile(version2);
    if (level === void 0) {
      return IIIF_PROFILE_VALUES["none"]["none"];
    }
    return IIIF_PROFILE_VALUES[version2][level];
  }
  getTileSourceOptions(preferredOptions) {
    const options = preferredOptions || {}, version2 = this.getImageApiVersion();
    if (version2 === void 0) {
      return;
    }
    const imageOptions = version2 === void 0 ? void 0 : versionFunctions[version2](this);
    if (imageOptions === void 0) {
      return;
    }
    return {
      url: imageOptions.url,
      version: version2,
      size: [this.imageInfo.width, this.imageInfo.height],
      sizes: imageOptions.sizes,
      format: options.format !== void 0 && imageOptions.formats.includes(options.format) ? options.format : imageOptions.preferredFormat !== void 0 ? imageOptions.preferredFormat : "jpg",
      supports: imageOptions.supports,
      quality: options.quality && imageOptions.qualities.includes(options.quality) ? options.quality : imageOptions.qualities.includes("native") ? "native" : "default",
      resolutions: Array.isArray(imageOptions.resolutions) ? imageOptions.resolutions.sort(function(a2, b2) {
        return b2 - a2;
      }) : void 0,
      tileSize: imageOptions.tileSize
    };
  }
}
class ReprojImage extends ImageBase {
  constructor(sourceProj, targetProj, targetExtent, targetResolution, pixelRatio, getImageFunction, interpolate) {
    const maxSourceExtent = sourceProj.getExtent();
    const maxTargetExtent = targetProj.getExtent();
    const limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;
    const targetCenter = getCenter(limitedTargetExtent);
    const sourceResolution = calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);
    const errorThresholdInPixels = ERROR_THRESHOLD;
    const triangulation = new Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);
    const sourceExtent = triangulation.calculateSourceExtent();
    const sourceImage = getImageFunction(sourceExtent, sourceResolution, pixelRatio);
    const state = sourceImage ? ImageState.IDLE : ImageState.EMPTY;
    const sourcePixelRatio = sourceImage ? sourceImage.getPixelRatio() : 1;
    super(targetExtent, targetResolution, sourcePixelRatio, state);
    this.targetProj_ = targetProj;
    this.maxSourceExtent_ = maxSourceExtent;
    this.triangulation_ = triangulation;
    this.targetResolution_ = targetResolution;
    this.targetExtent_ = targetExtent;
    this.sourceImage_ = sourceImage;
    this.sourcePixelRatio_ = sourcePixelRatio;
    this.interpolate_ = interpolate;
    this.canvas_ = null;
    this.sourceListenerKey_ = null;
  }
  disposeInternal() {
    if (this.state == ImageState.LOADING) {
      this.unlistenSource_();
    }
    super.disposeInternal();
  }
  getImage() {
    return this.canvas_;
  }
  getProjection() {
    return this.targetProj_;
  }
  reproject_() {
    const sourceState = this.sourceImage_.getState();
    if (sourceState == ImageState.LOADED) {
      const width = getWidth(this.targetExtent_) / this.targetResolution_;
      const height = getHeight(this.targetExtent_) / this.targetResolution_;
      this.canvas_ = render(width, height, this.sourcePixelRatio_, this.sourceImage_.getResolution(), this.maxSourceExtent_, this.targetResolution_, this.targetExtent_, this.triangulation_, [
        {
          extent: this.sourceImage_.getExtent(),
          image: this.sourceImage_.getImage()
        }
      ], 0, void 0, this.interpolate_);
    }
    this.state = sourceState;
    this.changed();
  }
  load() {
    if (this.state == ImageState.IDLE) {
      this.state = ImageState.LOADING;
      this.changed();
      const sourceState = this.sourceImage_.getState();
      if (sourceState == ImageState.LOADED || sourceState == ImageState.ERROR) {
        this.reproject_();
      } else {
        this.sourceListenerKey_ = listen(this.sourceImage_, EventType.CHANGE, function(e2) {
          const sourceState2 = this.sourceImage_.getState();
          if (sourceState2 == ImageState.LOADED || sourceState2 == ImageState.ERROR) {
            this.unlistenSource_();
            this.reproject_();
          }
        }, this);
        this.sourceImage_.load();
      }
    }
  }
  unlistenSource_() {
    unlistenByKey(this.sourceListenerKey_);
    this.sourceListenerKey_ = null;
  }
}
const ImageSourceEventType = {
  IMAGELOADSTART: "imageloadstart",
  IMAGELOADEND: "imageloadend",
  IMAGELOADERROR: "imageloaderror"
};
class ImageSourceEvent extends BaseEvent {
  constructor(type, image2) {
    super(type);
    this.image = image2;
  }
}
class ImageSource extends Source {
  constructor(options) {
    super({
      attributions: options.attributions,
      projection: options.projection,
      state: options.state,
      interpolate: options.interpolate !== void 0 ? options.interpolate : true
    });
    this.on;
    this.once;
    this.un;
    this.resolutions_ = options.resolutions !== void 0 ? options.resolutions : null;
    this.reprojectedImage_ = null;
    this.reprojectedRevision_ = 0;
  }
  getResolutions() {
    return this.resolutions_;
  }
  findNearestResolution(resolution) {
    if (this.resolutions_) {
      const idx = linearFindNearest(this.resolutions_, resolution, 0);
      resolution = this.resolutions_[idx];
    }
    return resolution;
  }
  getImage(extent2, resolution, pixelRatio, projection) {
    const sourceProjection = this.getProjection();
    if (!sourceProjection || !projection || equivalent(sourceProjection, projection)) {
      if (sourceProjection) {
        projection = sourceProjection;
      }
      return this.getImageInternal(extent2, resolution, pixelRatio, projection);
    }
    if (this.reprojectedImage_) {
      if (this.reprojectedRevision_ == this.getRevision() && equivalent(this.reprojectedImage_.getProjection(), projection) && this.reprojectedImage_.getResolution() == resolution && equals$2(this.reprojectedImage_.getExtent(), extent2)) {
        return this.reprojectedImage_;
      }
      this.reprojectedImage_.dispose();
      this.reprojectedImage_ = null;
    }
    this.reprojectedImage_ = new ReprojImage(sourceProjection, projection, extent2, resolution, pixelRatio, (extent3, resolution2, pixelRatio2) => this.getImageInternal(extent3, resolution2, pixelRatio2, sourceProjection), this.getInterpolate());
    this.reprojectedRevision_ = this.getRevision();
    return this.reprojectedImage_;
  }
  getImageInternal(extent2, resolution, pixelRatio, projection) {
    return abstract();
  }
  handleImageChange(event) {
    const image2 = event.target;
    let type;
    switch (image2.getState()) {
      case ImageState.LOADING:
        this.loading = true;
        type = ImageSourceEventType.IMAGELOADSTART;
        break;
      case ImageState.LOADED:
        this.loading = false;
        type = ImageSourceEventType.IMAGELOADEND;
        break;
      case ImageState.ERROR:
        this.loading = false;
        type = ImageSourceEventType.IMAGELOADERROR;
        break;
      default:
        return;
    }
    if (this.hasListener(type)) {
      this.dispatchEvent(new ImageSourceEvent(type, image2));
    }
  }
}
function defaultImageLoadFunction(image2, src) {
  image2.getImage().src = src;
}
function appendParams(uri, params2) {
  const keyParams = [];
  Object.keys(params2).forEach(function(k2) {
    if (params2[k2] !== null && params2[k2] !== void 0) {
      keyParams.push(k2 + "=" + encodeURIComponent(params2[k2]));
    }
  });
  const qs = keyParams.join("&");
  uri = uri.replace(/[?&]$/, "");
  uri += uri.includes("?") ? "&" : "?";
  return uri + qs;
}
class ImageCanvas extends ImageBase {
  constructor(extent2, resolution, pixelRatio, canvas, loader) {
    const state = loader !== void 0 ? ImageState.IDLE : ImageState.LOADED;
    super(extent2, resolution, pixelRatio, state);
    this.loader_ = loader !== void 0 ? loader : null;
    this.canvas_ = canvas;
    this.error_ = null;
  }
  getError() {
    return this.error_;
  }
  handleLoad_(err2) {
    if (err2) {
      this.error_ = err2;
      this.state = ImageState.ERROR;
    } else {
      this.state = ImageState.LOADED;
    }
    this.changed();
  }
  load() {
    if (this.state == ImageState.IDLE) {
      this.state = ImageState.LOADING;
      this.changed();
      this.loader_(this.handleLoad_.bind(this));
    }
  }
  getImage() {
    return this.canvas_;
  }
}
class Static extends ImageSource {
  constructor(options) {
    const crossOrigin = options.crossOrigin !== void 0 ? options.crossOrigin : null;
    const imageLoadFunction = options.imageLoadFunction !== void 0 ? options.imageLoadFunction : defaultImageLoadFunction;
    super({
      attributions: options.attributions,
      interpolate: options.interpolate,
      projection: get$4(options.projection)
    });
    this.url_ = options.url;
    this.imageExtent_ = options.imageExtent;
    this.image_ = new ImageWrapper(this.imageExtent_, void 0, 1, this.url_, crossOrigin, imageLoadFunction);
    this.imageSize_ = options.imageSize ? options.imageSize : null;
    this.image_.addEventListener(EventType.CHANGE, this.handleImageChange.bind(this));
  }
  getImageExtent() {
    return this.imageExtent_;
  }
  getImageInternal(extent2, resolution, pixelRatio, projection) {
    if (intersects$2(extent2, this.image_.getExtent())) {
      return this.image_;
    }
    return null;
  }
  getUrl() {
    return this.url_;
  }
  handleImageChange(evt) {
    if (this.image_.getState() == ImageState.LOADED) {
      const imageExtent = this.image_.getExtent();
      const image2 = this.image_.getImage();
      let imageWidth, imageHeight;
      if (this.imageSize_) {
        imageWidth = this.imageSize_[0];
        imageHeight = this.imageSize_[1];
      } else {
        imageWidth = image2.width;
        imageHeight = image2.height;
      }
      const extentWidth = getWidth(imageExtent);
      const extentHeight = getHeight(imageExtent);
      const xResolution = extentWidth / imageWidth;
      const yResolution = extentHeight / imageHeight;
      let targetWidth = imageWidth;
      let targetHeight = imageHeight;
      if (xResolution > yResolution) {
        targetWidth = Math.round(extentWidth / yResolution);
      } else {
        targetHeight = Math.round(extentHeight / xResolution);
      }
      if (targetWidth !== imageWidth || targetHeight !== imageHeight) {
        const context2 = createCanvasContext2D(targetWidth, targetHeight);
        if (!this.getInterpolate()) {
          context2.imageSmoothingEnabled = false;
        }
        const canvas = context2.canvas;
        context2.drawImage(image2, 0, 0, imageWidth, imageHeight, 0, 0, canvas.width, canvas.height);
        this.image_.setImage(canvas);
      }
    }
    super.handleImageChange(evt);
  }
}
const DEFAULT_VERSION$1 = "1.3.0";
const DECIMALS = 4;
const GETFEATUREINFO_IMAGE_SIZE = [101, 101];
class ImageWMS extends ImageSource {
  constructor(options) {
    options = options ? options : {};
    super({
      attributions: options.attributions,
      interpolate: options.interpolate,
      projection: options.projection,
      resolutions: options.resolutions
    });
    this.crossOrigin_ = options.crossOrigin !== void 0 ? options.crossOrigin : null;
    this.url_ = options.url;
    this.imageLoadFunction_ = options.imageLoadFunction !== void 0 ? options.imageLoadFunction : defaultImageLoadFunction;
    this.params_ = Object.assign({}, options.params);
    this.v13_ = true;
    this.updateV13_();
    this.serverType_ = options.serverType;
    this.hidpi_ = options.hidpi !== void 0 ? options.hidpi : true;
    this.image_ = null;
    this.imageSize_ = [0, 0];
    this.renderedRevision_ = 0;
    this.ratio_ = options.ratio !== void 0 ? options.ratio : 1.5;
  }
  getFeatureInfoUrl(coordinate, resolution, projection, params2) {
    if (this.url_ === void 0) {
      return void 0;
    }
    const projectionObj = get$4(projection);
    const sourceProjectionObj = this.getProjection();
    if (sourceProjectionObj && sourceProjectionObj !== projectionObj) {
      resolution = calculateSourceResolution(sourceProjectionObj, projectionObj, coordinate, resolution);
      coordinate = transform$3(coordinate, projectionObj, sourceProjectionObj);
    }
    const extent2 = getForViewAndSize(coordinate, resolution, 0, GETFEATUREINFO_IMAGE_SIZE);
    const baseParams = {
      "SERVICE": "WMS",
      "VERSION": DEFAULT_VERSION$1,
      "REQUEST": "GetFeatureInfo",
      "FORMAT": "image/png",
      "TRANSPARENT": true,
      "QUERY_LAYERS": this.params_["LAYERS"]
    };
    Object.assign(baseParams, this.params_, params2);
    const x2 = floor$2((coordinate[0] - extent2[0]) / resolution, DECIMALS);
    const y2 = floor$2((extent2[3] - coordinate[1]) / resolution, DECIMALS);
    baseParams[this.v13_ ? "I" : "X"] = x2;
    baseParams[this.v13_ ? "J" : "Y"] = y2;
    return this.getRequestUrl_(extent2, GETFEATUREINFO_IMAGE_SIZE, 1, sourceProjectionObj || projectionObj, baseParams);
  }
  getLegendUrl(resolution, params2) {
    if (this.url_ === void 0) {
      return void 0;
    }
    const baseParams = {
      "SERVICE": "WMS",
      "VERSION": DEFAULT_VERSION$1,
      "REQUEST": "GetLegendGraphic",
      "FORMAT": "image/png"
    };
    if (params2 === void 0 || params2["LAYER"] === void 0) {
      const layers = this.params_.LAYERS;
      const isSingleLayer = !Array.isArray(layers) || layers.length === 1;
      if (!isSingleLayer) {
        return void 0;
      }
      baseParams["LAYER"] = layers;
    }
    if (resolution !== void 0) {
      const mpu = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1;
      const pixelSize = 28e-5;
      baseParams["SCALE"] = resolution * mpu / pixelSize;
    }
    Object.assign(baseParams, params2);
    return appendParams(this.url_, baseParams);
  }
  getParams() {
    return this.params_;
  }
  getImageInternal(extent2, resolution, pixelRatio, projection) {
    if (this.url_ === void 0) {
      return null;
    }
    resolution = this.findNearestResolution(resolution);
    if (pixelRatio != 1 && (!this.hidpi_ || this.serverType_ === void 0)) {
      pixelRatio = 1;
    }
    const imageResolution = resolution / pixelRatio;
    const center = getCenter(extent2);
    const viewWidth = ceil$1(getWidth(extent2) / imageResolution, DECIMALS);
    const viewHeight = ceil$1(getHeight(extent2) / imageResolution, DECIMALS);
    const viewExtent = getForViewAndSize(center, imageResolution, 0, [
      viewWidth,
      viewHeight
    ]);
    const requestWidth = ceil$1(this.ratio_ * getWidth(extent2) / imageResolution, DECIMALS);
    const requestHeight = ceil$1(this.ratio_ * getHeight(extent2) / imageResolution, DECIMALS);
    const requestExtent = getForViewAndSize(center, imageResolution, 0, [
      requestWidth,
      requestHeight
    ]);
    const image2 = this.image_;
    if (image2 && this.renderedRevision_ == this.getRevision() && image2.getResolution() == resolution && image2.getPixelRatio() == pixelRatio && containsExtent(image2.getExtent(), viewExtent)) {
      return image2;
    }
    const params2 = {
      "SERVICE": "WMS",
      "VERSION": DEFAULT_VERSION$1,
      "REQUEST": "GetMap",
      "FORMAT": "image/png",
      "TRANSPARENT": true
    };
    Object.assign(params2, this.params_);
    this.imageSize_[0] = round(getWidth(requestExtent) / imageResolution, DECIMALS);
    this.imageSize_[1] = round(getHeight(requestExtent) / imageResolution, DECIMALS);
    const url = this.getRequestUrl_(requestExtent, this.imageSize_, pixelRatio, projection, params2);
    this.image_ = new ImageWrapper(requestExtent, resolution, pixelRatio, url, this.crossOrigin_, this.imageLoadFunction_);
    this.renderedRevision_ = this.getRevision();
    this.image_.addEventListener(EventType.CHANGE, this.handleImageChange.bind(this));
    return this.image_;
  }
  getImageLoadFunction() {
    return this.imageLoadFunction_;
  }
  getRequestUrl_(extent2, size, pixelRatio, projection, params2) {
    assert(this.url_ !== void 0, 9);
    params2[this.v13_ ? "CRS" : "SRS"] = projection.getCode();
    if (!("STYLES" in this.params_)) {
      params2["STYLES"] = "";
    }
    if (pixelRatio != 1) {
      switch (this.serverType_) {
        case "geoserver":
          const dpi = 90 * pixelRatio + 0.5 | 0;
          if ("FORMAT_OPTIONS" in params2) {
            params2["FORMAT_OPTIONS"] += ";dpi:" + dpi;
          } else {
            params2["FORMAT_OPTIONS"] = "dpi:" + dpi;
          }
          break;
        case "mapserver":
          params2["MAP_RESOLUTION"] = 90 * pixelRatio;
          break;
        case "carmentaserver":
        case "qgis":
          params2["DPI"] = 90 * pixelRatio;
          break;
        default:
          assert(false, 8);
          break;
      }
    }
    params2["WIDTH"] = size[0];
    params2["HEIGHT"] = size[1];
    const axisOrientation = projection.getAxisOrientation();
    let bbox2;
    if (this.v13_ && axisOrientation.substr(0, 2) == "ne") {
      bbox2 = [extent2[1], extent2[0], extent2[3], extent2[2]];
    } else {
      bbox2 = extent2;
    }
    params2["BBOX"] = bbox2.join(",");
    return appendParams(this.url_, params2);
  }
  getUrl() {
    return this.url_;
  }
  setImageLoadFunction(imageLoadFunction) {
    this.image_ = null;
    this.imageLoadFunction_ = imageLoadFunction;
    this.changed();
  }
  setUrl(url) {
    if (url != this.url_) {
      this.url_ = url;
      this.image_ = null;
      this.changed();
    }
  }
  updateParams(params2) {
    Object.assign(this.params_, params2);
    this.updateV13_();
    this.image_ = null;
    this.changed();
  }
  updateV13_() {
    const version2 = this.params_["VERSION"] || DEFAULT_VERSION$1;
    this.v13_ = compareVersions(version2, "1.3") >= 0;
  }
}
const ATTRIBUTION = '&#169; <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors.';
class OSM extends XYZ {
  constructor(options) {
    options = options || {};
    let attributions;
    if (options.attributions !== void 0) {
      attributions = options.attributions;
    } else {
      attributions = [ATTRIBUTION];
    }
    const crossOrigin = options.crossOrigin !== void 0 ? options.crossOrigin : "anonymous";
    const url = options.url !== void 0 ? options.url : "https://tile.openstreetmap.org/{z}/{x}/{y}.png";
    super({
      attributions,
      attributionsCollapsible: false,
      cacheSize: options.cacheSize,
      crossOrigin,
      interpolate: options.interpolate,
      maxZoom: options.maxZoom !== void 0 ? options.maxZoom : 19,
      opaque: options.opaque !== void 0 ? options.opaque : true,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileLoadFunction: options.tileLoadFunction,
      transition: options.transition,
      url,
      wrapX: options.wrapX,
      zDirection: options.zDirection
    });
  }
}
let hasImageData = true;
try {
  new ImageData(10, 10);
} catch (_2) {
  hasImageData = false;
}
let context;
function newImageData(data2, width, height) {
  if (hasImageData) {
    return new ImageData(data2, width, height);
  }
  if (!context) {
    context = document.createElement("canvas").getContext("2d");
  }
  const imageData = context.createImageData(width, height);
  imageData.data.set(data2);
  return imageData;
}
function createMinion(operation) {
  let workerHasImageData = true;
  try {
    new ImageData(10, 10);
  } catch (_2) {
    workerHasImageData = false;
  }
  function newWorkerImageData(data2, width, height) {
    if (workerHasImageData) {
      return new ImageData(data2, width, height);
    }
    return { data: data2, width, height };
  }
  return function(data2) {
    const buffers = data2["buffers"];
    const meta = data2["meta"];
    const imageOps = data2["imageOps"];
    const width = data2["width"];
    const height = data2["height"];
    const numBuffers = buffers.length;
    const numBytes = buffers[0].byteLength;
    if (imageOps) {
      const images = new Array(numBuffers);
      for (let b2 = 0; b2 < numBuffers; ++b2) {
        images[b2] = newWorkerImageData(new Uint8ClampedArray(buffers[b2]), width, height);
      }
      const output2 = operation(images, meta).data;
      return output2.buffer;
    }
    const output = new Uint8ClampedArray(numBytes);
    const arrays = new Array(numBuffers);
    const pixels = new Array(numBuffers);
    for (let b2 = 0; b2 < numBuffers; ++b2) {
      arrays[b2] = new Uint8ClampedArray(buffers[b2]);
      pixels[b2] = [0, 0, 0, 0];
    }
    for (let i2 = 0; i2 < numBytes; i2 += 4) {
      for (let j2 = 0; j2 < numBuffers; ++j2) {
        const array = arrays[j2];
        pixels[j2][0] = array[i2];
        pixels[j2][1] = array[i2 + 1];
        pixels[j2][2] = array[i2 + 2];
        pixels[j2][3] = array[i2 + 3];
      }
      const pixel = operation(pixels, meta);
      output[i2] = pixel[0];
      output[i2 + 1] = pixel[1];
      output[i2 + 2] = pixel[2];
      output[i2 + 3] = pixel[3];
    }
    return output.buffer;
  };
}
function createWorker(config, onMessage) {
  const lib = Object.keys(config.lib || {}).map(function(name) {
    return "const " + name + " = " + config.lib[name].toString() + ";";
  });
  const lines = lib.concat([
    "const __minion__ = (" + createMinion.toString() + ")(",
    config.operation.toString(),
    ");",
    'self.addEventListener("message", function(event) {',
    "  const buffer = __minion__(event.data);",
    "  self.postMessage({buffer: buffer, meta: event.data.meta}, [buffer]);",
    "});"
  ]);
  const worker2 = new Worker(typeof Blob === "undefined" ? "data:text/javascript;base64," + Buffer.from(lines.join("\n"), "binary").toString("base64") : URL.createObjectURL(new Blob(lines, { type: "text/javascript" })));
  worker2.addEventListener("message", onMessage);
  return worker2;
}
function createFauxWorker(config, onMessage) {
  const minion = createMinion(config.operation);
  let terminated = false;
  return {
    postMessage: function(data2) {
      setTimeout(function() {
        if (terminated) {
          return;
        }
        onMessage({ data: { buffer: minion(data2), meta: data2["meta"] } });
      }, 0);
    },
    terminate: function() {
      terminated = true;
    }
  };
}
class Processor extends Disposable {
  constructor(config) {
    super();
    this._imageOps = !!config.imageOps;
    let threads;
    if (config.threads === 0) {
      threads = 0;
    } else if (this._imageOps) {
      threads = 1;
    } else {
      threads = config.threads || 1;
    }
    const workers = new Array(threads);
    if (threads) {
      for (let i2 = 0; i2 < threads; ++i2) {
        workers[i2] = createWorker(config, this._onWorkerMessage.bind(this, i2));
      }
    } else {
      workers[0] = createFauxWorker(config, this._onWorkerMessage.bind(this, 0));
    }
    this._workers = workers;
    this._queue = [];
    this._maxQueueLength = config.queue || Infinity;
    this._running = 0;
    this._dataLookup = {};
    this._job = null;
  }
  process(inputs, meta, callback) {
    this._enqueue({
      inputs,
      meta,
      callback
    });
    this._dispatch();
  }
  _enqueue(job) {
    this._queue.push(job);
    while (this._queue.length > this._maxQueueLength) {
      this._queue.shift().callback(null, null);
    }
  }
  _dispatch() {
    if (this._running || this._queue.length === 0) {
      return;
    }
    const job = this._queue.shift();
    this._job = job;
    const width = job.inputs[0].width;
    const height = job.inputs[0].height;
    const buffers = job.inputs.map(function(input) {
      return input.data.buffer;
    });
    const threads = this._workers.length;
    this._running = threads;
    if (threads === 1) {
      this._workers[0].postMessage({
        buffers,
        meta: job.meta,
        imageOps: this._imageOps,
        width,
        height
      }, buffers);
      return;
    }
    const length = job.inputs[0].data.length;
    const segmentLength = 4 * Math.ceil(length / 4 / threads);
    for (let i2 = 0; i2 < threads; ++i2) {
      const offset2 = i2 * segmentLength;
      const slices = [];
      for (let j2 = 0, jj = buffers.length; j2 < jj; ++j2) {
        slices.push(buffers[j2].slice(offset2, offset2 + segmentLength));
      }
      this._workers[i2].postMessage({
        buffers: slices,
        meta: job.meta,
        imageOps: this._imageOps,
        width,
        height
      }, slices);
    }
  }
  _onWorkerMessage(index2, event) {
    if (this.disposed) {
      return;
    }
    this._dataLookup[index2] = event.data;
    --this._running;
    if (this._running === 0) {
      this._resolveJob();
    }
  }
  _resolveJob() {
    const job = this._job;
    const threads = this._workers.length;
    let data2, meta;
    if (threads === 1) {
      data2 = new Uint8ClampedArray(this._dataLookup[0]["buffer"]);
      meta = this._dataLookup[0]["meta"];
    } else {
      const length = job.inputs[0].data.length;
      data2 = new Uint8ClampedArray(length);
      meta = new Array(threads);
      const segmentLength = 4 * Math.ceil(length / 4 / threads);
      for (let i2 = 0; i2 < threads; ++i2) {
        const buffer2 = this._dataLookup[i2]["buffer"];
        const offset2 = i2 * segmentLength;
        data2.set(new Uint8ClampedArray(buffer2), offset2);
        meta[i2] = this._dataLookup[i2]["meta"];
      }
    }
    this._job = null;
    this._dataLookup = {};
    job.callback(null, newImageData(data2, job.inputs[0].width, job.inputs[0].height), meta);
    this._dispatch();
  }
  disposeInternal() {
    for (let i2 = 0; i2 < this._workers.length; ++i2) {
      this._workers[i2].terminate();
    }
    this._workers.length = 0;
  }
}
const RasterEventType = {
  BEFOREOPERATIONS: "beforeoperations",
  AFTEROPERATIONS: "afteroperations"
};
class RasterSourceEvent extends BaseEvent {
  constructor(type, frameState, data2) {
    super(type);
    this.extent = frameState.extent;
    this.resolution = frameState.viewState.resolution / frameState.pixelRatio;
    this.data = data2;
  }
}
class RasterSource extends ImageSource {
  constructor(options) {
    super({
      projection: null
    });
    this.on;
    this.once;
    this.un;
    this.processor_ = null;
    this.operationType_ = options.operationType !== void 0 ? options.operationType : "pixel";
    this.threads_ = options.threads !== void 0 ? options.threads : 1;
    this.layers_ = createLayers(options.sources);
    const changed = this.changed.bind(this);
    for (let i2 = 0, ii = this.layers_.length; i2 < ii; ++i2) {
      this.layers_[i2].addEventListener(EventType.CHANGE, changed);
    }
    this.tileQueue_ = new TileQueue(function() {
      return 1;
    }, this.changed.bind(this));
    this.requestedFrameState_;
    this.renderedImageCanvas_ = null;
    this.renderedRevision_;
    this.frameState_ = {
      animate: false,
      coordinateToPixelTransform: create$7(),
      declutterTree: null,
      extent: null,
      index: 0,
      layerIndex: 0,
      layerStatesArray: getLayerStatesArray(this.layers_),
      pixelRatio: 1,
      pixelToCoordinateTransform: create$7(),
      postRenderFunctions: [],
      size: [0, 0],
      tileQueue: this.tileQueue_,
      time: Date.now(),
      usedTiles: {},
      viewState: {
        rotation: 0
      },
      viewHints: [],
      wantedTiles: {},
      mapId: getUid(this),
      renderTargets: {}
    };
    this.setAttributions(function(frameState) {
      const attributions = [];
      for (let index2 = 0, iMax = options.sources.length; index2 < iMax; ++index2) {
        const sourceOrLayer = options.sources[index2];
        const source = sourceOrLayer instanceof Source ? sourceOrLayer : sourceOrLayer.getSource();
        const attributionGetter = source.getAttributions();
        if (typeof attributionGetter === "function") {
          const sourceAttribution = attributionGetter(frameState);
          attributions.push.apply(attributions, sourceAttribution);
        }
      }
      return attributions.length !== 0 ? attributions : null;
    });
    if (options.operation !== void 0) {
      this.setOperation(options.operation, options.lib);
    }
  }
  setOperation(operation, lib) {
    if (this.processor_) {
      this.processor_.dispose();
    }
    this.processor_ = new Processor({
      operation,
      imageOps: this.operationType_ === "image",
      queue: 1,
      lib,
      threads: this.threads_
    });
    this.changed();
  }
  updateFrameState_(extent2, resolution, projection) {
    const frameState = Object.assign({}, this.frameState_);
    frameState.viewState = Object.assign({}, frameState.viewState);
    const center = getCenter(extent2);
    frameState.extent = extent2.slice();
    frameState.size[0] = Math.round(getWidth(extent2) / resolution);
    frameState.size[1] = Math.round(getHeight(extent2) / resolution);
    frameState.time = Date.now();
    const viewState = frameState.viewState;
    viewState.center = center;
    viewState.projection = projection;
    viewState.resolution = resolution;
    return frameState;
  }
  allSourcesReady_() {
    let ready = true;
    let source;
    for (let i2 = 0, ii = this.layers_.length; i2 < ii; ++i2) {
      source = this.layers_[i2].getSource();
      if (source.getState() !== "ready") {
        ready = false;
        break;
      }
    }
    return ready;
  }
  getImage(extent2, resolution, pixelRatio, projection) {
    if (!this.allSourcesReady_()) {
      return null;
    }
    const frameState = this.updateFrameState_(extent2, resolution, projection);
    this.requestedFrameState_ = frameState;
    if (this.renderedImageCanvas_) {
      const renderedResolution = this.renderedImageCanvas_.getResolution();
      const renderedExtent = this.renderedImageCanvas_.getExtent();
      if (resolution !== renderedResolution || !equals$2(extent2, renderedExtent)) {
        this.renderedImageCanvas_ = null;
      }
    }
    if (!this.renderedImageCanvas_ || this.getRevision() !== this.renderedRevision_) {
      this.processSources_();
    }
    frameState.tileQueue.loadMoreTiles(16, 16);
    if (frameState.animate) {
      requestAnimationFrame(this.changed.bind(this));
    }
    return this.renderedImageCanvas_;
  }
  processSources_() {
    const frameState = this.requestedFrameState_;
    const len = this.layers_.length;
    const imageDatas = new Array(len);
    for (let i2 = 0; i2 < len; ++i2) {
      frameState.layerIndex = i2;
      const imageData = getImageData(this.layers_[i2], frameState);
      if (imageData) {
        imageDatas[i2] = imageData;
      } else {
        return;
      }
    }
    const data2 = {};
    this.dispatchEvent(new RasterSourceEvent(RasterEventType.BEFOREOPERATIONS, frameState, data2));
    this.processor_.process(imageDatas, data2, this.onWorkerComplete_.bind(this, frameState));
  }
  onWorkerComplete_(frameState, err2, output, data2) {
    if (err2 || !output) {
      return;
    }
    const extent2 = frameState.extent;
    const resolution = frameState.viewState.resolution;
    if (resolution !== this.requestedFrameState_.viewState.resolution || !equals$2(extent2, this.requestedFrameState_.extent)) {
      return;
    }
    let context2;
    if (this.renderedImageCanvas_) {
      context2 = this.renderedImageCanvas_.getImage().getContext("2d");
    } else {
      const width = Math.round(getWidth(extent2) / resolution);
      const height = Math.round(getHeight(extent2) / resolution);
      context2 = createCanvasContext2D(width, height);
      this.renderedImageCanvas_ = new ImageCanvas(extent2, resolution, 1, context2.canvas);
    }
    context2.putImageData(output, 0, 0);
    this.changed();
    this.renderedRevision_ = this.getRevision();
    this.dispatchEvent(new RasterSourceEvent(RasterEventType.AFTEROPERATIONS, frameState, data2));
    if (frameState.animate) {
      requestAnimationFrame(this.changed.bind(this));
    }
  }
  disposeInternal() {
    if (this.processor_) {
      this.processor_.dispose();
    }
    super.disposeInternal();
  }
}
RasterSource.prototype.dispose;
let sharedContext = null;
function getImageData(layer, frameState) {
  const renderer = layer.getRenderer();
  if (!renderer) {
    throw new Error("Unsupported layer type: " + layer);
  }
  if (!renderer.prepareFrame(frameState)) {
    return null;
  }
  const width = frameState.size[0];
  const height = frameState.size[1];
  if (width === 0 || height === 0) {
    return null;
  }
  const container = renderer.renderFrame(frameState, null);
  let element;
  if (container instanceof HTMLCanvasElement) {
    element = container;
  } else {
    if (container) {
      element = container.firstElementChild;
    }
    if (!(element instanceof HTMLCanvasElement)) {
      throw new Error("Unsupported rendered element: " + element);
    }
    if (element.width === width && element.height === height) {
      const context2 = element.getContext("2d");
      return context2.getImageData(0, 0, width, height);
    }
  }
  if (!sharedContext) {
    sharedContext = createCanvasContext2D(width, height);
  } else {
    const canvas = sharedContext.canvas;
    if (canvas.width !== width || canvas.height !== height) {
      sharedContext = createCanvasContext2D(width, height);
    } else {
      sharedContext.clearRect(0, 0, width, height);
    }
  }
  sharedContext.drawImage(element, 0, 0, width, height);
  return sharedContext.getImageData(0, 0, width, height);
}
function getLayerStatesArray(layers) {
  return layers.map(function(layer) {
    return layer.getLayerState();
  });
}
function createLayers(sources) {
  const len = sources.length;
  const layers = new Array(len);
  for (let i2 = 0; i2 < len; ++i2) {
    layers[i2] = createLayer(sources[i2]);
  }
  return layers;
}
function createLayer(layerOrSource) {
  let layer;
  if (layerOrSource instanceof Source) {
    if (layerOrSource instanceof TileSource) {
      layer = new TileLayer$1({ source: layerOrSource });
    } else if (layerOrSource instanceof ImageSource) {
      layer = new ImageLayer$1({ source: layerOrSource });
    }
  } else {
    layer = layerOrSource;
  }
  return layer;
}
class TileWMS extends TileImage {
  constructor(options) {
    options = options ? options : {};
    const params2 = Object.assign({}, options.params);
    const transparent = "TRANSPARENT" in params2 ? params2["TRANSPARENT"] : true;
    super({
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      interpolate: options.interpolate,
      opaque: !transparent,
      projection: options.projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileClass: options.tileClass,
      tileGrid: options.tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX !== void 0 ? options.wrapX : true,
      transition: options.transition,
      zDirection: options.zDirection
    });
    this.gutter_ = options.gutter !== void 0 ? options.gutter : 0;
    this.params_ = params2;
    this.v13_ = true;
    this.serverType_ = options.serverType;
    this.hidpi_ = options.hidpi !== void 0 ? options.hidpi : true;
    this.tmpExtent_ = createEmpty();
    this.updateV13_();
    this.setKey(this.getKeyForParams_());
  }
  getFeatureInfoUrl(coordinate, resolution, projection, params2) {
    const projectionObj = get$4(projection);
    const sourceProjectionObj = this.getProjection();
    let tileGrid = this.getTileGrid();
    if (!tileGrid) {
      tileGrid = this.getTileGridForProjection(projectionObj);
    }
    const z2 = tileGrid.getZForResolution(resolution, this.zDirection);
    const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z2);
    if (tileGrid.getResolutions().length <= tileCoord[0]) {
      return void 0;
    }
    let tileResolution = tileGrid.getResolution(tileCoord[0]);
    let tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);
    let tileSize = toSize(tileGrid.getTileSize(tileCoord[0]), this.tmpSize);
    const gutter = this.gutter_;
    if (gutter !== 0) {
      tileSize = buffer$1(tileSize, gutter, this.tmpSize);
      tileExtent = buffer$2(tileExtent, tileResolution * gutter, tileExtent);
    }
    if (sourceProjectionObj && sourceProjectionObj !== projectionObj) {
      tileResolution = calculateSourceResolution(sourceProjectionObj, projectionObj, coordinate, tileResolution);
      tileExtent = transformExtent(tileExtent, projectionObj, sourceProjectionObj);
      coordinate = transform$3(coordinate, projectionObj, sourceProjectionObj);
    }
    const baseParams = {
      "SERVICE": "WMS",
      "VERSION": DEFAULT_VERSION$1,
      "REQUEST": "GetFeatureInfo",
      "FORMAT": "image/png",
      "TRANSPARENT": true,
      "QUERY_LAYERS": this.params_["LAYERS"]
    };
    Object.assign(baseParams, this.params_, params2);
    const x2 = Math.floor((coordinate[0] - tileExtent[0]) / tileResolution);
    const y2 = Math.floor((tileExtent[3] - coordinate[1]) / tileResolution);
    baseParams[this.v13_ ? "I" : "X"] = x2;
    baseParams[this.v13_ ? "J" : "Y"] = y2;
    return this.getRequestUrl_(tileCoord, tileSize, tileExtent, 1, sourceProjectionObj || projectionObj, baseParams);
  }
  getLegendUrl(resolution, params2) {
    if (this.urls[0] === void 0) {
      return void 0;
    }
    const baseParams = {
      "SERVICE": "WMS",
      "VERSION": DEFAULT_VERSION$1,
      "REQUEST": "GetLegendGraphic",
      "FORMAT": "image/png"
    };
    if (params2 === void 0 || params2["LAYER"] === void 0) {
      const layers = this.params_.LAYERS;
      const isSingleLayer = !Array.isArray(layers) || layers.length === 1;
      if (!isSingleLayer) {
        return void 0;
      }
      baseParams["LAYER"] = layers;
    }
    if (resolution !== void 0) {
      const mpu = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1;
      const pixelSize = 28e-5;
      baseParams["SCALE"] = resolution * mpu / pixelSize;
    }
    Object.assign(baseParams, params2);
    return appendParams(this.urls[0], baseParams);
  }
  getGutter() {
    return this.gutter_;
  }
  getParams() {
    return this.params_;
  }
  getRequestUrl_(tileCoord, tileSize, tileExtent, pixelRatio, projection, params2) {
    const urls = this.urls;
    if (!urls) {
      return void 0;
    }
    params2["WIDTH"] = tileSize[0];
    params2["HEIGHT"] = tileSize[1];
    params2[this.v13_ ? "CRS" : "SRS"] = projection.getCode();
    if (!("STYLES" in this.params_)) {
      params2["STYLES"] = "";
    }
    if (pixelRatio != 1) {
      switch (this.serverType_) {
        case "geoserver":
          const dpi = 90 * pixelRatio + 0.5 | 0;
          if ("FORMAT_OPTIONS" in params2) {
            params2["FORMAT_OPTIONS"] += ";dpi:" + dpi;
          } else {
            params2["FORMAT_OPTIONS"] = "dpi:" + dpi;
          }
          break;
        case "mapserver":
          params2["MAP_RESOLUTION"] = 90 * pixelRatio;
          break;
        case "carmentaserver":
        case "qgis":
          params2["DPI"] = 90 * pixelRatio;
          break;
        default:
          assert(false, 52);
          break;
      }
    }
    const axisOrientation = projection.getAxisOrientation();
    const bbox2 = tileExtent;
    if (this.v13_ && axisOrientation.substr(0, 2) == "ne") {
      let tmp;
      tmp = tileExtent[0];
      bbox2[0] = tileExtent[1];
      bbox2[1] = tmp;
      tmp = tileExtent[2];
      bbox2[2] = tileExtent[3];
      bbox2[3] = tmp;
    }
    params2["BBOX"] = bbox2.join(",");
    let url;
    if (urls.length == 1) {
      url = urls[0];
    } else {
      const index2 = modulo(hash(tileCoord), urls.length);
      url = urls[index2];
    }
    return appendParams(url, params2);
  }
  getTilePixelRatio(pixelRatio) {
    return !this.hidpi_ || this.serverType_ === void 0 ? 1 : pixelRatio;
  }
  getKeyForParams_() {
    let i2 = 0;
    const res = [];
    for (const key in this.params_) {
      res[i2++] = key + "-" + this.params_[key];
    }
    return res.join("/");
  }
  updateParams(params2) {
    Object.assign(this.params_, params2);
    this.updateV13_();
    this.setKey(this.getKeyForParams_());
  }
  updateV13_() {
    const version2 = this.params_["VERSION"] || DEFAULT_VERSION$1;
    this.v13_ = compareVersions(version2, "1.3") >= 0;
  }
  tileUrlFunction(tileCoord, pixelRatio, projection) {
    let tileGrid = this.getTileGrid();
    if (!tileGrid) {
      tileGrid = this.getTileGridForProjection(projection);
    }
    if (tileGrid.getResolutions().length <= tileCoord[0]) {
      return void 0;
    }
    if (pixelRatio != 1 && (!this.hidpi_ || this.serverType_ === void 0)) {
      pixelRatio = 1;
    }
    const tileResolution = tileGrid.getResolution(tileCoord[0]);
    let tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);
    let tileSize = toSize(tileGrid.getTileSize(tileCoord[0]), this.tmpSize);
    const gutter = this.gutter_;
    if (gutter !== 0) {
      tileSize = buffer$1(tileSize, gutter, this.tmpSize);
      tileExtent = buffer$2(tileExtent, tileResolution * gutter, tileExtent);
    }
    if (pixelRatio != 1) {
      tileSize = scale(tileSize, pixelRatio, this.tmpSize);
    }
    const baseParams = {
      "SERVICE": "WMS",
      "VERSION": DEFAULT_VERSION$1,
      "REQUEST": "GetMap",
      "FORMAT": "image/png",
      "TRANSPARENT": true
    };
    Object.assign(baseParams, this.params_);
    return this.getRequestUrl_(tileCoord, tileSize, tileExtent, pixelRatio, projection, baseParams);
  }
}
class WMTSTileGrid extends TileGrid {
  constructor(options) {
    super({
      extent: options.extent,
      origin: options.origin,
      origins: options.origins,
      resolutions: options.resolutions,
      tileSize: options.tileSize,
      tileSizes: options.tileSizes,
      sizes: options.sizes
    });
    this.matrixIds_ = options.matrixIds;
  }
  getMatrixId(z2) {
    return this.matrixIds_[z2];
  }
  getMatrixIds() {
    return this.matrixIds_;
  }
}
class WMTS extends TileImage {
  constructor(options) {
    const requestEncoding = options.requestEncoding !== void 0 ? options.requestEncoding : "KVP";
    const tileGrid = options.tileGrid;
    let urls = options.urls;
    if (urls === void 0 && options.url !== void 0) {
      urls = expandUrl(options.url);
    }
    super({
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      interpolate: options.interpolate,
      projection: options.projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileClass: options.tileClass,
      tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      urls,
      wrapX: options.wrapX !== void 0 ? options.wrapX : false,
      transition: options.transition,
      zDirection: options.zDirection
    });
    this.version_ = options.version !== void 0 ? options.version : "1.0.0";
    this.format_ = options.format !== void 0 ? options.format : "image/jpeg";
    this.dimensions_ = options.dimensions !== void 0 ? options.dimensions : {};
    this.layer_ = options.layer;
    this.matrixSet_ = options.matrixSet;
    this.style_ = options.style;
    this.requestEncoding_ = requestEncoding;
    this.setKey(this.getKeyForDimensions_());
    if (urls && urls.length > 0) {
      this.tileUrlFunction = createFromTileUrlFunctions(urls.map(this.createFromWMTSTemplate.bind(this)));
    }
  }
  setUrls(urls) {
    this.urls = urls;
    const key = urls.join("\n");
    this.setTileUrlFunction(createFromTileUrlFunctions(urls.map(this.createFromWMTSTemplate.bind(this))), key);
  }
  getDimensions() {
    return this.dimensions_;
  }
  getFormat() {
    return this.format_;
  }
  getLayer() {
    return this.layer_;
  }
  getMatrixSet() {
    return this.matrixSet_;
  }
  getRequestEncoding() {
    return this.requestEncoding_;
  }
  getStyle() {
    return this.style_;
  }
  getVersion() {
    return this.version_;
  }
  getKeyForDimensions_() {
    const res = this.urls ? this.urls.slice(0) : [];
    for (const key in this.dimensions_) {
      res.push(key + "-" + this.dimensions_[key]);
    }
    return res.join("/");
  }
  updateDimensions(dimensions) {
    Object.assign(this.dimensions_, dimensions);
    this.setKey(this.getKeyForDimensions_());
  }
  createFromWMTSTemplate(template) {
    const requestEncoding = this.requestEncoding_;
    const context2 = {
      "layer": this.layer_,
      "style": this.style_,
      "tilematrixset": this.matrixSet_
    };
    if (requestEncoding == "KVP") {
      Object.assign(context2, {
        "Service": "WMTS",
        "Request": "GetTile",
        "Version": this.version_,
        "Format": this.format_
      });
    }
    template = requestEncoding == "KVP" ? appendParams(template, context2) : template.replace(/\{(\w+?)\}/g, function(m2, p5) {
      return p5.toLowerCase() in context2 ? context2[p5.toLowerCase()] : m2;
    });
    const tileGrid = this.tileGrid;
    const dimensions = this.dimensions_;
    return function(tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return void 0;
      }
      const localContext = {
        "TileMatrix": tileGrid.getMatrixId(tileCoord[0]),
        "TileCol": tileCoord[1],
        "TileRow": tileCoord[2]
      };
      Object.assign(localContext, dimensions);
      let url = template;
      if (requestEncoding == "KVP") {
        url = appendParams(url, localContext);
      } else {
        url = url.replace(/\{(\w+?)\}/g, function(m2, p5) {
          return localContext[p5];
        });
      }
      return url;
    };
  }
}
if (window.ol && !ol.ext) {
  ol.ext = {};
}
var ol_ext_inherits = function(child, parent) {
  child.prototype = Object.create(parent.prototype);
  child.prototype.constructor = child;
};
if (window.ol) {
  if (!ol.inherits)
    ol.inherits = ol_ext_inherits;
}
if (window.NodeList && !NodeList.prototype.forEach) {
  NodeList.prototype.forEach = Array.prototype.forEach;
}
if (window.Element && !Element.prototype.remove) {
  Element.prototype.remove = function() {
    if (this.parentNode)
      this.parentNode.removeChild(this);
  };
}
function getVectorContext(event) {
  const frameState = event.frameState;
  const transform2 = multiply(event.inversePixelTransform.slice(), frameState.coordinateToPixelTransform);
  return new CanvasImmediateRenderer(event.context, frameState.pixelRatio, frameState.extent, transform2, frameState.viewState.rotation);
}
if (window.ol) {
  if (!ol.util) {
    ol.util = {
      VERSION: ol.VERSION || "5.3.0"
    };
  } else if (!ol.util.VERSION) {
    ol.util.VERSION = ol.VERSION || "6.1.0";
  }
}
var ol_ext_olVersion = VERSION.split(".");
ol_ext_olVersion = parseInt(ol_ext_olVersion[0]) * 100 + parseInt(ol_ext_olVersion[1]);
var ol_ext_getVectorContextStyle = function(e2, s2) {
  var ratio = e2.frameState.pixelRatio;
  if (ol_ext_olVersion > 605 && ratio !== 1 && s2.getImage() instanceof Icon$1) {
    s2 = s2.clone();
    var img = s2.getImage();
    img.setScale(img.getScale() * ratio);
    var anchor = img.getAnchor();
    if (img.setDisplacement) {
      var disp = img.getDisplacement();
      if (disp) {
        disp[0] -= anchor[0] / ratio;
        disp[1] += anchor[1] / ratio;
        img.setAnchor([0, 0]);
      }
    } else {
      if (anchor) {
        anchor[0] /= ratio;
        anchor[1] /= ratio;
      }
    }
  }
  return s2;
};
var ol_layer_AnimatedCluster = function(opt_options) {
  var options = opt_options || {};
  VectorLayer$1.call(this, options);
  this.oldcluster = new VectorSource();
  this.clusters = [];
  this.animation = { start: false };
  this.set("animationDuration", typeof options.animationDuration == "number" ? options.animationDuration : 700);
  this.set("animationMethod", options.animationMethod || easeOut);
  this.getSource().on("change", this.saveCluster.bind(this));
  this.on(["precompose", "prerender"], this.animate.bind(this));
  this.on(["postcompose", "postrender"], this.postanimate.bind(this));
};
ol_ext_inherits(ol_layer_AnimatedCluster, VectorLayer$1);
ol_layer_AnimatedCluster.prototype.saveCluster = function() {
  if (this.oldcluster) {
    this.oldcluster.clear();
    if (!this.get("animationDuration"))
      return;
    var features = this.getSource().getFeatures();
    if (features.length && features[0].get("features")) {
      this.oldcluster.addFeatures(this.clusters);
      this.clusters = features.slice(0);
      this.sourceChanged = true;
    }
  }
};
ol_layer_AnimatedCluster.prototype.getClusterForFeature = function(f2, cluster) {
  for (var j2 = 0, c2; c2 = cluster[j2]; j2++) {
    var features = c2.get("features");
    if (features && features.length) {
      for (var k2 = 0, f22; f22 = features[k2]; k2++) {
        if (f2 === f22) {
          return c2;
        }
      }
    }
  }
  return false;
};
ol_layer_AnimatedCluster.prototype.stopAnimation = function() {
  this.animation.start = false;
  this.animation.cA = [];
  this.animation.cB = [];
};
ol_layer_AnimatedCluster.prototype.animate = function(e2) {
  var duration2 = this.get("animationDuration");
  if (!duration2)
    return;
  var resolution = e2.frameState.viewState.resolution;
  var i2, c0, a2 = this.animation;
  var time2 = e2.frameState.time;
  if (a2.resolution != resolution && this.sourceChanged) {
    var extent2 = e2.frameState.extent;
    if (a2.resolution < resolution) {
      extent2 = buffer$2(extent2, 100 * resolution);
      a2.cA = this.oldcluster.getFeaturesInExtent(extent2);
      a2.cB = this.getSource().getFeaturesInExtent(extent2);
      a2.revers = false;
    } else {
      extent2 = buffer$2(extent2, 100 * resolution);
      a2.cA = this.getSource().getFeaturesInExtent(extent2);
      a2.cB = this.oldcluster.getFeaturesInExtent(extent2);
      a2.revers = true;
    }
    a2.clusters = [];
    for (i2 = 0, c0; c0 = a2.cA[i2]; i2++) {
      var f2 = c0.get("features");
      if (f2 && f2.length) {
        var c2 = this.getClusterForFeature(f2[0], a2.cB);
        if (c2)
          a2.clusters.push({ f: c0, pt: c2.getGeometry().getCoordinates() });
      }
    }
    a2.resolution = resolution;
    this.sourceChanged = false;
    if (!a2.clusters.length || a2.clusters.length > 1e3) {
      this.stopAnimation();
      return;
    }
    time2 = a2.start = new Date().getTime();
  }
  if (a2.start) {
    var vectorContext = e2.vectorContext || getVectorContext(e2);
    var d2 = (time2 - a2.start) / duration2;
    if (d2 > 1) {
      this.stopAnimation();
      d2 = 1;
    }
    d2 = this.get("animationMethod")(d2);
    var style2 = this.getStyle();
    var stylefn = typeof style2 == "function" ? style2 : style2.length ? function() {
      return style2;
    } : function() {
      return [style2];
    };
    e2.context.save();
    e2.context.globalAlpha = this.getOpacity();
    for (i2 = 0, c2; c2 = a2.clusters[i2]; i2++) {
      var pt2 = c2.f.getGeometry().getCoordinates();
      var dx = pt2[0] - c2.pt[0];
      var dy = pt2[1] - c2.pt[1];
      if (a2.revers) {
        pt2[0] = c2.pt[0] + d2 * dx;
        pt2[1] = c2.pt[1] + d2 * dy;
      } else {
        pt2[0] = pt2[0] - d2 * dx;
        pt2[1] = pt2[1] - d2 * dy;
      }
      var st2 = stylefn(c2.f, resolution, true);
      if (!st2.length)
        st2 = [st2];
      if (c2.f.get("features").length === 1 && !dx && !dy) {
        f2 = c2.f.get("features")[0];
      } else {
        var geo = new Point$3(pt2);
        f2 = new Feature$1(geo);
      }
      for (var k2 = 0, s2; s2 = st2[k2]; k2++) {
        if (s2.getText() && /\n/.test(s2.getText().getText())) {
          var offsetX = s2.getText().getOffsetX();
          var offsetY = s2.getText().getOffsetY();
          var rot = s2.getText().getRotation() || 0;
          var fontSize2 = Number((s2.getText().getFont() || "10px").match(/\d+/)) * 1.2;
          var str = s2.getText().getText().split("\n");
          var dl, nb = str.length - 1;
          var s22 = s2.clone();
          str.forEach(function(t3, i3) {
            if (i3 == 1) {
              s22.setImage();
              s22.setFill();
              s22.setStroke();
            }
            switch (s2.getText().getTextBaseline()) {
              case "alphabetic":
              case "ideographic":
              case "bottom": {
                dl = nb;
                break;
              }
              case "hanging":
              case "top": {
                dl = 0;
                break;
              }
              default: {
                dl = nb / 2;
                break;
              }
            }
            s22.getText().setOffsetX(offsetX - Math.sin(rot) * fontSize2 * (i3 - dl));
            s22.getText().setOffsetY(offsetY + Math.cos(rot) * fontSize2 * (i3 - dl));
            s22.getText().setText(t3);
            vectorContext.drawFeature(f2, ol_ext_getVectorContextStyle(e2, s22));
          });
        } else {
          vectorContext.drawFeature(f2, ol_ext_getVectorContextStyle(e2, s2));
        }
      }
    }
    e2.context.restore();
    e2.frameState.animate = true;
    e2.context.save();
    e2.context.beginPath();
    e2.context.rect(0, 0, 0, 0);
    e2.context.clip();
    this.clip_ = true;
  }
  return;
};
ol_layer_AnimatedCluster.prototype.postanimate = function(e2) {
  if (this.clip_) {
    e2.context.restore();
    this.clip_ = false;
  }
};
const _sfc_main$X = {
  extends: BaseLayer,
  name: "ol-animated-clusterlayer",
  setup(props) {
    const map = inject("map");
    const {
      properties
    } = usePropsAsObjectProperties(props);
    const vectorLayer = computed(() => {
      let ac = new ol_layer_AnimatedCluster(__spreadProps(__spreadValues({}, properties), {
        source: new Cluster({
          distance: properties.distance,
          geometryFunction: (feature) => feature.getGeometry()
        })
      }));
      return ac;
    });
    const source = computed(() => vectorLayer.value.getSource());
    watch(properties, () => {
      vectorLayer.value.setProperties(properties);
      vectorLayer.value.changed();
    });
    onMounted(() => {
      map.addLayer(vectorLayer.value);
      vectorLayer.value.changed();
      map.changed();
    });
    onUnmounted(() => {
      map.removeLayer(vectorLayer.value);
    });
    provide("vectorLayer", source);
    provide("stylable", vectorLayer);
    return {
      vectorLayer,
      map
    };
  },
  props: {
    animationDuration: {
      type: Number,
      default: 700
    },
    distance: {
      type: Number,
      default: 20
    },
    animationMethod: {
      type: Function,
      default: easeOut
    },
    updateWhileAnimating: {
      type: Boolean,
      default: false
    },
    updateWhileInteracting: {
      type: Boolean,
      default: false
    }
  }
};
function _sfc_render$X(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var AnimatedClusterLayer = /* @__PURE__ */ _export_sfc(_sfc_main$X, [["render", _sfc_render$X]]);
const tmpArray4 = new Uint8Array(4);
class WebGLRenderTarget {
  constructor(helper, size) {
    this.helper_ = helper;
    const gl = helper.getGL();
    this.texture_ = gl.createTexture();
    this.framebuffer_ = gl.createFramebuffer();
    this.size_ = size || [1, 1];
    this.data_ = new Uint8Array(0);
    this.dataCacheDirty_ = true;
    this.updateSize_();
  }
  setSize(size) {
    if (equals$3(size, this.size_)) {
      return;
    }
    this.size_[0] = size[0];
    this.size_[1] = size[1];
    this.updateSize_();
  }
  getSize() {
    return this.size_;
  }
  clearCachedData() {
    this.dataCacheDirty_ = true;
  }
  readAll() {
    if (this.dataCacheDirty_) {
      const size = this.size_;
      const gl = this.helper_.getGL();
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer_);
      gl.readPixels(0, 0, size[0], size[1], gl.RGBA, gl.UNSIGNED_BYTE, this.data_);
      this.dataCacheDirty_ = false;
    }
    return this.data_;
  }
  readPixel(x2, y2) {
    if (x2 < 0 || y2 < 0 || x2 > this.size_[0] || y2 >= this.size_[1]) {
      tmpArray4[0] = 0;
      tmpArray4[1] = 0;
      tmpArray4[2] = 0;
      tmpArray4[3] = 0;
      return tmpArray4;
    }
    this.readAll();
    const index2 = Math.floor(x2) + (this.size_[1] - Math.floor(y2) - 1) * this.size_[0];
    tmpArray4[0] = this.data_[index2 * 4];
    tmpArray4[1] = this.data_[index2 * 4 + 1];
    tmpArray4[2] = this.data_[index2 * 4 + 2];
    tmpArray4[3] = this.data_[index2 * 4 + 3];
    return tmpArray4;
  }
  getTexture() {
    return this.texture_;
  }
  getFramebuffer() {
    return this.framebuffer_;
  }
  updateSize_() {
    const size = this.size_;
    const gl = this.helper_.getGL();
    this.texture_ = this.helper_.createTexture(size, null, this.texture_);
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer_);
    gl.viewport(0, 0, size[0], size[1]);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture_, 0);
    this.data_ = new Uint8Array(size[0] * size[1] * 4);
  }
}
const WebGLWorkerMessageType = {
  GENERATE_POLYGON_BUFFERS: "GENERATE_POLYGON_BUFFERS",
  GENERATE_POINT_BUFFERS: "GENERATE_POINT_BUFFERS",
  GENERATE_LINE_STRING_BUFFERS: "GENERATE_LINE_STRING_BUFFERS"
};
var earcut$2 = { exports: {} };
earcut$2.exports = earcut;
earcut$2.exports.default = earcut;
function earcut(data2, holeIndices, dim) {
  dim = dim || 2;
  var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data2.length, outerNode = linkedList(data2, 0, outerLen, dim, true), triangles = [];
  if (!outerNode || outerNode.next === outerNode.prev)
    return triangles;
  var minX, minY, maxX, maxY, x2, y2, invSize;
  if (hasHoles)
    outerNode = eliminateHoles(data2, holeIndices, outerNode, dim);
  if (data2.length > 80 * dim) {
    minX = maxX = data2[0];
    minY = maxY = data2[1];
    for (var i2 = dim; i2 < outerLen; i2 += dim) {
      x2 = data2[i2];
      y2 = data2[i2 + 1];
      if (x2 < minX)
        minX = x2;
      if (y2 < minY)
        minY = y2;
      if (x2 > maxX)
        maxX = x2;
      if (y2 > maxY)
        maxY = y2;
    }
    invSize = Math.max(maxX - minX, maxY - minY);
    invSize = invSize !== 0 ? 32767 / invSize : 0;
  }
  earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
  return triangles;
}
function linkedList(data2, start2, end, dim, clockwise) {
  var i2, last;
  if (clockwise === signedArea(data2, start2, end, dim) > 0) {
    for (i2 = start2; i2 < end; i2 += dim)
      last = insertNode(i2, data2[i2], data2[i2 + 1], last);
  } else {
    for (i2 = end - dim; i2 >= start2; i2 -= dim)
      last = insertNode(i2, data2[i2], data2[i2 + 1], last);
  }
  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}
function filterPoints(start2, end) {
  if (!start2)
    return start2;
  if (!end)
    end = start2;
  var p5 = start2, again;
  do {
    again = false;
    if (!p5.steiner && (equals(p5, p5.next) || area(p5.prev, p5, p5.next) === 0)) {
      removeNode(p5);
      p5 = end = p5.prev;
      if (p5 === p5.next)
        break;
      again = true;
    } else {
      p5 = p5.next;
    }
  } while (again || p5 !== end);
  return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear)
    return;
  if (!pass && invSize)
    indexCurve(ear, minX, minY, invSize);
  var stop = ear, prev, next3;
  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next3 = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev.i / dim | 0);
      triangles.push(ear.i / dim | 0);
      triangles.push(next3.i / dim | 0);
      removeNode(ear);
      ear = next3.next;
      stop = next3.next;
      continue;
    }
    ear = next3;
    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  var a2 = ear.prev, b2 = ear, c2 = ear.next;
  if (area(a2, b2, c2) >= 0)
    return false;
  var ax = a2.x, bx = b2.x, cx = c2.x, ay = a2.y, by = b2.y, cy = c2.y;
  var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  var p5 = c2.next;
  while (p5 !== a2) {
    if (p5.x >= x0 && p5.x <= x1 && p5.y >= y0 && p5.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p5.x, p5.y) && area(p5.prev, p5, p5.next) >= 0)
      return false;
    p5 = p5.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  var a2 = ear.prev, b2 = ear, c2 = ear.next;
  if (area(a2, b2, c2) >= 0)
    return false;
  var ax = a2.x, bx = b2.x, cx = c2.x, ay = a2.y, by = b2.y, cy = c2.y;
  var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
  var p5 = ear.prevZ, n2 = ear.nextZ;
  while (p5 && p5.z >= minZ && n2 && n2.z <= maxZ) {
    if (p5.x >= x0 && p5.x <= x1 && p5.y >= y0 && p5.y <= y1 && p5 !== a2 && p5 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, p5.x, p5.y) && area(p5.prev, p5, p5.next) >= 0)
      return false;
    p5 = p5.prevZ;
    if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
      return false;
    n2 = n2.nextZ;
  }
  while (p5 && p5.z >= minZ) {
    if (p5.x >= x0 && p5.x <= x1 && p5.y >= y0 && p5.y <= y1 && p5 !== a2 && p5 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, p5.x, p5.y) && area(p5.prev, p5, p5.next) >= 0)
      return false;
    p5 = p5.prevZ;
  }
  while (n2 && n2.z <= maxZ) {
    if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
      return false;
    n2 = n2.nextZ;
  }
  return true;
}
function cureLocalIntersections(start2, triangles, dim) {
  var p5 = start2;
  do {
    var a2 = p5.prev, b2 = p5.next.next;
    if (!equals(a2, b2) && intersects(a2, p5, p5.next, b2) && locallyInside(a2, b2) && locallyInside(b2, a2)) {
      triangles.push(a2.i / dim | 0);
      triangles.push(p5.i / dim | 0);
      triangles.push(b2.i / dim | 0);
      removeNode(p5);
      removeNode(p5.next);
      p5 = start2 = b2;
    }
    p5 = p5.next;
  } while (p5 !== start2);
  return filterPoints(p5);
}
function splitEarcut(start2, triangles, dim, minX, minY, invSize) {
  var a2 = start2;
  do {
    var b2 = a2.next.next;
    while (b2 !== a2.prev) {
      if (a2.i !== b2.i && isValidDiagonal(a2, b2)) {
        var c2 = splitPolygon(a2, b2);
        a2 = filterPoints(a2, a2.next);
        c2 = filterPoints(c2, c2.next);
        earcutLinked(a2, triangles, dim, minX, minY, invSize, 0);
        earcutLinked(c2, triangles, dim, minX, minY, invSize, 0);
        return;
      }
      b2 = b2.next;
    }
    a2 = a2.next;
  } while (a2 !== start2);
}
function eliminateHoles(data2, holeIndices, outerNode, dim) {
  var queue = [], i2, len, start2, end, list;
  for (i2 = 0, len = holeIndices.length; i2 < len; i2++) {
    start2 = holeIndices[i2] * dim;
    end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data2.length;
    list = linkedList(data2, start2, end, dim, false);
    if (list === list.next)
      list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareX);
  for (i2 = 0; i2 < queue.length; i2++) {
    outerNode = eliminateHole(queue[i2], outerNode);
  }
  return outerNode;
}
function compareX(a2, b2) {
  return a2.x - b2.x;
}
function eliminateHole(hole, outerNode) {
  var bridge = findHoleBridge(hole, outerNode);
  if (!bridge) {
    return outerNode;
  }
  var bridgeReverse = splitPolygon(bridge, hole);
  filterPoints(bridgeReverse, bridgeReverse.next);
  return filterPoints(bridge, bridge.next);
}
function findHoleBridge(hole, outerNode) {
  var p5 = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m2;
  do {
    if (hy <= p5.y && hy >= p5.next.y && p5.next.y !== p5.y) {
      var x2 = p5.x + (hy - p5.y) * (p5.next.x - p5.x) / (p5.next.y - p5.y);
      if (x2 <= hx && x2 > qx) {
        qx = x2;
        m2 = p5.x < p5.next.x ? p5 : p5.next;
        if (x2 === hx)
          return m2;
      }
    }
    p5 = p5.next;
  } while (p5 !== outerNode);
  if (!m2)
    return null;
  var stop = m2, mx = m2.x, my = m2.y, tanMin = Infinity, tan;
  p5 = m2;
  do {
    if (hx >= p5.x && p5.x >= mx && hx !== p5.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p5.x, p5.y)) {
      tan = Math.abs(hy - p5.y) / (hx - p5.x);
      if (locallyInside(p5, hole) && (tan < tanMin || tan === tanMin && (p5.x > m2.x || p5.x === m2.x && sectorContainsSector(m2, p5)))) {
        m2 = p5;
        tanMin = tan;
      }
    }
    p5 = p5.next;
  } while (p5 !== stop);
  return m2;
}
function sectorContainsSector(m2, p5) {
  return area(m2.prev, m2, p5.prev) < 0 && area(p5.next, m2, m2.next) < 0;
}
function indexCurve(start2, minX, minY, invSize) {
  var p5 = start2;
  do {
    if (p5.z === 0)
      p5.z = zOrder(p5.x, p5.y, minX, minY, invSize);
    p5.prevZ = p5.prev;
    p5.nextZ = p5.next;
    p5 = p5.next;
  } while (p5 !== start2);
  p5.prevZ.nextZ = null;
  p5.prevZ = null;
  sortLinked(p5);
}
function sortLinked(list) {
  var i2, p5, q2, e2, tail, numMerges, pSize, qSize, inSize = 1;
  do {
    p5 = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p5) {
      numMerges++;
      q2 = p5;
      pSize = 0;
      for (i2 = 0; i2 < inSize; i2++) {
        pSize++;
        q2 = q2.nextZ;
        if (!q2)
          break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q2) {
        if (pSize !== 0 && (qSize === 0 || !q2 || p5.z <= q2.z)) {
          e2 = p5;
          p5 = p5.nextZ;
          pSize--;
        } else {
          e2 = q2;
          q2 = q2.nextZ;
          qSize--;
        }
        if (tail)
          tail.nextZ = e2;
        else
          list = e2;
        e2.prevZ = tail;
        tail = e2;
      }
      p5 = q2;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x2, y2, minX, minY, invSize) {
  x2 = (x2 - minX) * invSize | 0;
  y2 = (y2 - minY) * invSize | 0;
  x2 = (x2 | x2 << 8) & 16711935;
  x2 = (x2 | x2 << 4) & 252645135;
  x2 = (x2 | x2 << 2) & 858993459;
  x2 = (x2 | x2 << 1) & 1431655765;
  y2 = (y2 | y2 << 8) & 16711935;
  y2 = (y2 | y2 << 4) & 252645135;
  y2 = (y2 | y2 << 2) & 858993459;
  y2 = (y2 | y2 << 1) & 1431655765;
  return x2 | y2 << 1;
}
function getLeftmost(start2) {
  var p5 = start2, leftmost = start2;
  do {
    if (p5.x < leftmost.x || p5.x === leftmost.x && p5.y < leftmost.y)
      leftmost = p5;
    p5 = p5.next;
  } while (p5 !== start2);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
  return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
}
function isValidDiagonal(a2, b2) {
  return a2.next.i !== b2.i && a2.prev.i !== b2.i && !intersectsPolygon(a2, b2) && (locallyInside(a2, b2) && locallyInside(b2, a2) && middleInside(a2, b2) && (area(a2.prev, a2, b2.prev) || area(a2, b2.prev, b2)) || equals(a2, b2) && area(a2.prev, a2, a2.next) > 0 && area(b2.prev, b2, b2.next) > 0);
}
function area(p5, q2, r2) {
  return (q2.y - p5.y) * (r2.x - q2.x) - (q2.x - p5.x) * (r2.y - q2.y);
}
function equals(p12, p22) {
  return p12.x === p22.x && p12.y === p22.y;
}
function intersects(p12, q1, p22, q2) {
  var o1 = sign(area(p12, q1, p22));
  var o2 = sign(area(p12, q1, q2));
  var o3 = sign(area(p22, q2, p12));
  var o4 = sign(area(p22, q2, q1));
  if (o1 !== o2 && o3 !== o4)
    return true;
  if (o1 === 0 && onSegment(p12, p22, q1))
    return true;
  if (o2 === 0 && onSegment(p12, q2, q1))
    return true;
  if (o3 === 0 && onSegment(p22, p12, q2))
    return true;
  if (o4 === 0 && onSegment(p22, q1, q2))
    return true;
  return false;
}
function onSegment(p5, q2, r2) {
  return q2.x <= Math.max(p5.x, r2.x) && q2.x >= Math.min(p5.x, r2.x) && q2.y <= Math.max(p5.y, r2.y) && q2.y >= Math.min(p5.y, r2.y);
}
function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a2, b2) {
  var p5 = a2;
  do {
    if (p5.i !== a2.i && p5.next.i !== a2.i && p5.i !== b2.i && p5.next.i !== b2.i && intersects(p5, p5.next, a2, b2))
      return true;
    p5 = p5.next;
  } while (p5 !== a2);
  return false;
}
function locallyInside(a2, b2) {
  return area(a2.prev, a2, a2.next) < 0 ? area(a2, b2, a2.next) >= 0 && area(a2, a2.prev, b2) >= 0 : area(a2, b2, a2.prev) < 0 || area(a2, a2.next, b2) < 0;
}
function middleInside(a2, b2) {
  var p5 = a2, inside = false, px = (a2.x + b2.x) / 2, py = (a2.y + b2.y) / 2;
  do {
    if (p5.y > py !== p5.next.y > py && p5.next.y !== p5.y && px < (p5.next.x - p5.x) * (py - p5.y) / (p5.next.y - p5.y) + p5.x)
      inside = !inside;
    p5 = p5.next;
  } while (p5 !== a2);
  return inside;
}
function splitPolygon(a2, b2) {
  var a22 = new Node$1(a2.i, a2.x, a2.y), b22 = new Node$1(b2.i, b2.x, b2.y), an = a2.next, bp = b2.prev;
  a2.next = b2;
  b2.prev = a2;
  a22.next = an;
  an.prev = a22;
  b22.next = a22;
  a22.prev = b22;
  bp.next = b22;
  b22.prev = bp;
  return b22;
}
function insertNode(i2, x2, y2, last) {
  var p5 = new Node$1(i2, x2, y2);
  if (!last) {
    p5.prev = p5;
    p5.next = p5;
  } else {
    p5.next = last.next;
    p5.prev = last;
    last.next.prev = p5;
    last.next = p5;
  }
  return p5;
}
function removeNode(p5) {
  p5.next.prev = p5.prev;
  p5.prev.next = p5.next;
  if (p5.prevZ)
    p5.prevZ.nextZ = p5.nextZ;
  if (p5.nextZ)
    p5.nextZ.prevZ = p5.prevZ;
}
function Node$1(i2, x2, y2) {
  this.i = i2;
  this.x = x2;
  this.y = y2;
  this.prev = null;
  this.next = null;
  this.z = 0;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
earcut.deviation = function(data2, holeIndices, dim, triangles) {
  var hasHoles = holeIndices && holeIndices.length;
  var outerLen = hasHoles ? holeIndices[0] * dim : data2.length;
  var polygonArea = Math.abs(signedArea(data2, 0, outerLen, dim));
  if (hasHoles) {
    for (var i2 = 0, len = holeIndices.length; i2 < len; i2++) {
      var start2 = holeIndices[i2] * dim;
      var end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data2.length;
      polygonArea -= Math.abs(signedArea(data2, start2, end, dim));
    }
  }
  var trianglesArea = 0;
  for (i2 = 0; i2 < triangles.length; i2 += 3) {
    var a2 = triangles[i2] * dim;
    var b2 = triangles[i2 + 1] * dim;
    var c2 = triangles[i2 + 2] * dim;
    trianglesArea += Math.abs((data2[a2] - data2[c2]) * (data2[b2 + 1] - data2[a2 + 1]) - (data2[a2] - data2[b2]) * (data2[c2 + 1] - data2[a2 + 1]));
  }
  return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
};
function signedArea(data2, start2, end, dim) {
  var sum2 = 0;
  for (var i2 = start2, j2 = end - dim; i2 < end; i2 += dim) {
    sum2 += (data2[j2] - data2[i2]) * (data2[i2 + 1] + data2[j2 + 1]);
    j2 = i2;
  }
  return sum2;
}
earcut.flatten = function(data2) {
  var dim = data2[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
  for (var i2 = 0; i2 < data2.length; i2++) {
    for (var j2 = 0; j2 < data2[i2].length; j2++) {
      for (var d2 = 0; d2 < dim; d2++)
        result.vertices.push(data2[i2][j2][d2]);
    }
    if (i2 > 0) {
      holeIndex += data2[i2 - 1].length;
      result.holes.push(holeIndex);
    }
  }
  return result;
};
var earcut$1 = earcut$2.exports;
const tmpArray_ = [];
const bufferPositions_ = { vertexPosition: 0, indexPosition: 0 };
function writePointVertex(buffer2, pos, x2, y2, index2) {
  buffer2[pos + 0] = x2;
  buffer2[pos + 1] = y2;
  buffer2[pos + 2] = index2;
}
function writePointFeatureToBuffers(instructions, elementIndex, vertexBuffer, indexBuffer, customAttributesCount, bufferPositions) {
  const baseVertexAttrsCount = 3;
  const baseInstructionsCount = 2;
  const stride = baseVertexAttrsCount + customAttributesCount;
  const x2 = instructions[elementIndex + 0];
  const y2 = instructions[elementIndex + 1];
  const customAttrs = tmpArray_;
  customAttrs.length = customAttributesCount;
  for (let i2 = 0; i2 < customAttrs.length; i2++) {
    customAttrs[i2] = instructions[elementIndex + baseInstructionsCount + i2];
  }
  let vPos = bufferPositions ? bufferPositions.vertexPosition : 0;
  let iPos = bufferPositions ? bufferPositions.indexPosition : 0;
  const baseIndex = vPos / stride;
  writePointVertex(vertexBuffer, vPos, x2, y2, 0);
  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);
  vPos += stride;
  writePointVertex(vertexBuffer, vPos, x2, y2, 1);
  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);
  vPos += stride;
  writePointVertex(vertexBuffer, vPos, x2, y2, 2);
  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);
  vPos += stride;
  writePointVertex(vertexBuffer, vPos, x2, y2, 3);
  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);
  vPos += stride;
  indexBuffer[iPos++] = baseIndex;
  indexBuffer[iPos++] = baseIndex + 1;
  indexBuffer[iPos++] = baseIndex + 3;
  indexBuffer[iPos++] = baseIndex + 1;
  indexBuffer[iPos++] = baseIndex + 2;
  indexBuffer[iPos++] = baseIndex + 3;
  bufferPositions_.vertexPosition = vPos;
  bufferPositions_.indexPosition = iPos;
  return bufferPositions_;
}
function writeLineSegmentToBuffers(instructions, segmentStartIndex, segmentEndIndex, beforeSegmentIndex, afterSegmentIndex, vertexArray, indexArray, customAttributes, instructionsTransform, invertInstructionsTransform) {
  const baseVertexAttrsCount = 5;
  const stride = baseVertexAttrsCount + customAttributes.length;
  const baseIndex = vertexArray.length / stride;
  const p0 = [
    instructions[segmentStartIndex + 0],
    instructions[segmentStartIndex + 1]
  ];
  const p12 = [instructions[segmentEndIndex], instructions[segmentEndIndex + 1]];
  const p0world = apply$5(invertInstructionsTransform, [...p0]);
  const p1world = apply$5(invertInstructionsTransform, [...p12]);
  function computeVertexParameters(vertexNumber, joinAngle1, joinAngle2) {
    const shift = 1e4;
    const anglePrecision = 1500;
    return Math.round(joinAngle1 * anglePrecision) + Math.round(joinAngle2 * anglePrecision) * shift + vertexNumber * shift * shift;
  }
  function angleBetween(p02, pA, pB) {
    const lenA = Math.sqrt((pA[0] - p02[0]) * (pA[0] - p02[0]) + (pA[1] - p02[1]) * (pA[1] - p02[1]));
    const tangentA = [(pA[0] - p02[0]) / lenA, (pA[1] - p02[1]) / lenA];
    const orthoA = [-tangentA[1], tangentA[0]];
    const lenB = Math.sqrt((pB[0] - p02[0]) * (pB[0] - p02[0]) + (pB[1] - p02[1]) * (pB[1] - p02[1]));
    const tangentB = [(pB[0] - p02[0]) / lenB, (pB[1] - p02[1]) / lenB];
    const angle2 = lenA === 0 || lenB === 0 ? 0 : Math.acos(clamp(tangentB[0] * tangentA[0] + tangentB[1] * tangentA[1], -1, 1));
    const isClockwise = tangentB[0] * orthoA[0] + tangentB[1] * orthoA[1] > 0;
    return !isClockwise ? Math.PI * 2 - angle2 : angle2;
  }
  const joinBefore = beforeSegmentIndex !== null;
  const joinAfter = afterSegmentIndex !== null;
  let angle0 = 0;
  let angle1 = 0;
  if (joinBefore) {
    const pB = [
      instructions[beforeSegmentIndex],
      instructions[beforeSegmentIndex + 1]
    ];
    const pBworld = apply$5(invertInstructionsTransform, [...pB]);
    angle0 = angleBetween(p0world, p1world, pBworld);
  }
  if (joinAfter) {
    const pA = [
      instructions[afterSegmentIndex],
      instructions[afterSegmentIndex + 1]
    ];
    const pAworld = apply$5(invertInstructionsTransform, [...pA]);
    angle1 = angleBetween(p1world, p0world, pAworld);
  }
  vertexArray.push(p0[0], p0[1], p12[0], p12[1], computeVertexParameters(0, angle0, angle1));
  vertexArray.push(...customAttributes);
  vertexArray.push(p0[0], p0[1], p12[0], p12[1], computeVertexParameters(1, angle0, angle1));
  vertexArray.push(...customAttributes);
  vertexArray.push(p0[0], p0[1], p12[0], p12[1], computeVertexParameters(2, angle0, angle1));
  vertexArray.push(...customAttributes);
  vertexArray.push(p0[0], p0[1], p12[0], p12[1], computeVertexParameters(3, angle0, angle1));
  vertexArray.push(...customAttributes);
  indexArray.push(baseIndex, baseIndex + 1, baseIndex + 2, baseIndex + 1, baseIndex + 3, baseIndex + 2);
}
function writePolygonTrianglesToBuffers(instructions, polygonStartIndex, vertexArray, indexArray, customAttributesCount) {
  const instructionsPerVertex = 2;
  const attributesPerVertex = 2 + customAttributesCount;
  let instructionsIndex = polygonStartIndex;
  const customAttributes = instructions.slice(instructionsIndex, instructionsIndex + customAttributesCount);
  instructionsIndex += customAttributesCount;
  const ringsCount = instructions[instructionsIndex++];
  let verticesCount = 0;
  const holes = new Array(ringsCount - 1);
  for (let i2 = 0; i2 < ringsCount; i2++) {
    verticesCount += instructions[instructionsIndex++];
    if (i2 < ringsCount - 1) {
      holes[i2] = verticesCount;
    }
  }
  const flatCoords = instructions.slice(instructionsIndex, instructionsIndex + verticesCount * instructionsPerVertex);
  const result = earcut$1(flatCoords, holes, instructionsPerVertex);
  for (let i2 = 0; i2 < result.length; i2++) {
    indexArray.push(result[i2] + vertexArray.length / attributesPerVertex);
  }
  for (let i2 = 0; i2 < flatCoords.length; i2 += 2) {
    vertexArray.push(flatCoords[i2], flatCoords[i2 + 1], ...customAttributes);
  }
  return instructionsIndex + verticesCount * instructionsPerVertex;
}
function colorEncodeId(id, array) {
  array = array || [];
  const radix = 256;
  const divide = radix - 1;
  array[0] = Math.floor(id / radix / radix / radix) / divide;
  array[1] = Math.floor(id / radix / radix) % radix / divide;
  array[2] = Math.floor(id / radix) % radix / divide;
  array[3] = id % radix / divide;
  return array;
}
function colorDecodeId(color2) {
  let id = 0;
  const radix = 256;
  const mult = radix - 1;
  id += Math.round(color2[0] * radix * radix * radix * mult);
  id += Math.round(color2[1] * radix * radix * mult);
  id += Math.round(color2[2] * radix * mult);
  id += Math.round(color2[3] * mult);
  return id;
}
const worker = self;
worker.onmessage = (event) => {
  const received = event.data;
  switch (received.type) {
    case WebGLWorkerMessageType.GENERATE_POINT_BUFFERS: {
      const baseVertexAttrsCount = 3;
      const baseInstructionsCount = 2;
      const customAttrsCount = received.customAttributesCount;
      const instructionsCount = baseInstructionsCount + customAttrsCount;
      const renderInstructions = new Float32Array(received.renderInstructions);
      const elementsCount = renderInstructions.length / instructionsCount;
      const indicesCount = elementsCount * 6;
      const verticesCount = elementsCount * 4 * (customAttrsCount + baseVertexAttrsCount);
      const indexBuffer = new Uint32Array(indicesCount);
      const vertexBuffer = new Float32Array(verticesCount);
      let bufferPositions;
      for (let i2 = 0; i2 < renderInstructions.length; i2 += instructionsCount) {
        bufferPositions = writePointFeatureToBuffers(renderInstructions, i2, vertexBuffer, indexBuffer, customAttrsCount, bufferPositions);
      }
      const message = Object.assign({
        vertexBuffer: vertexBuffer.buffer,
        indexBuffer: indexBuffer.buffer,
        renderInstructions: renderInstructions.buffer
      }, received);
      worker.postMessage(message, [
        vertexBuffer.buffer,
        indexBuffer.buffer,
        renderInstructions.buffer
      ]);
      break;
    }
    case WebGLWorkerMessageType.GENERATE_LINE_STRING_BUFFERS: {
      const vertices = [];
      const indices = [];
      const customAttrsCount = received.customAttributesCount;
      const instructionsPerVertex = 2;
      const renderInstructions = new Float32Array(received.renderInstructions);
      let currentInstructionsIndex = 0;
      const transform2 = received.renderInstructionsTransform;
      const invertTransform = create$7();
      makeInverse(invertTransform, transform2);
      let verticesCount, customAttributes;
      while (currentInstructionsIndex < renderInstructions.length) {
        customAttributes = Array.from(renderInstructions.slice(currentInstructionsIndex, currentInstructionsIndex + customAttrsCount));
        currentInstructionsIndex += customAttrsCount;
        verticesCount = renderInstructions[currentInstructionsIndex++];
        for (let i2 = 0; i2 < verticesCount - 1; i2++) {
          writeLineSegmentToBuffers(renderInstructions, currentInstructionsIndex + i2 * instructionsPerVertex, currentInstructionsIndex + (i2 + 1) * instructionsPerVertex, i2 > 0 ? currentInstructionsIndex + (i2 - 1) * instructionsPerVertex : null, i2 < verticesCount - 2 ? currentInstructionsIndex + (i2 + 2) * instructionsPerVertex : null, vertices, indices, customAttributes, transform2, invertTransform);
        }
        currentInstructionsIndex += verticesCount * instructionsPerVertex;
      }
      const indexBuffer = Uint32Array.from(indices);
      const vertexBuffer = Float32Array.from(vertices);
      const message = Object.assign({
        vertexBuffer: vertexBuffer.buffer,
        indexBuffer: indexBuffer.buffer,
        renderInstructions: renderInstructions.buffer
      }, received);
      worker.postMessage(message, [
        vertexBuffer.buffer,
        indexBuffer.buffer,
        renderInstructions.buffer
      ]);
      break;
    }
    case WebGLWorkerMessageType.GENERATE_POLYGON_BUFFERS: {
      const vertices = [];
      const indices = [];
      const customAttrsCount = received.customAttributesCount;
      const renderInstructions = new Float32Array(received.renderInstructions);
      let currentInstructionsIndex = 0;
      while (currentInstructionsIndex < renderInstructions.length) {
        currentInstructionsIndex = writePolygonTrianglesToBuffers(renderInstructions, currentInstructionsIndex, vertices, indices, customAttrsCount);
      }
      const indexBuffer = Uint32Array.from(indices);
      const vertexBuffer = Float32Array.from(vertices);
      const message = Object.assign({
        vertexBuffer: vertexBuffer.buffer,
        indexBuffer: indexBuffer.buffer,
        renderInstructions: renderInstructions.buffer
      }, received);
      worker.postMessage(message, [
        vertexBuffer.buffer,
        indexBuffer.buffer,
        renderInstructions.buffer
      ]);
      break;
    }
  }
};
let create$5;
class WebGLPointsLayerRenderer extends WebGLLayerRenderer {
  constructor(layer, options) {
    const uniforms = options.uniforms || {};
    const projectionMatrixTransform = create$7();
    uniforms[DefaultUniform.PROJECTION_MATRIX] = projectionMatrixTransform;
    super(layer, {
      uniforms,
      postProcesses: options.postProcesses
    });
    this.ready = false;
    this.sourceRevision_ = -1;
    this.verticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);
    this.hitVerticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);
    this.indicesBuffer_ = new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER, DYNAMIC_DRAW);
    this.vertexShader_ = options.vertexShader;
    this.fragmentShader_ = options.fragmentShader;
    this.program_;
    this.hitDetectionEnabled_ = options.hitFragmentShader && options.hitVertexShader ? true : false;
    this.hitVertexShader_ = options.hitVertexShader;
    this.hitFragmentShader_ = options.hitFragmentShader;
    this.hitProgram_;
    const customAttributes = options.attributes ? options.attributes.map(function(attribute) {
      return {
        name: "a_" + attribute.name,
        size: 1,
        type: AttributeType.FLOAT
      };
    }) : [];
    this.attributes = [
      {
        name: "a_position",
        size: 2,
        type: AttributeType.FLOAT
      },
      {
        name: "a_index",
        size: 1,
        type: AttributeType.FLOAT
      }
    ].concat(customAttributes);
    this.hitDetectionAttributes = [
      {
        name: "a_position",
        size: 2,
        type: AttributeType.FLOAT
      },
      {
        name: "a_index",
        size: 1,
        type: AttributeType.FLOAT
      },
      {
        name: "a_hitColor",
        size: 4,
        type: AttributeType.FLOAT
      },
      {
        name: "a_featureUid",
        size: 1,
        type: AttributeType.FLOAT
      }
    ].concat(customAttributes);
    this.customAttributes = options.attributes ? options.attributes : [];
    this.previousExtent_ = createEmpty();
    this.currentTransform_ = projectionMatrixTransform;
    this.renderTransform_ = create$7();
    this.invertRenderTransform_ = create$7();
    this.renderInstructions_ = new Float32Array(0);
    this.hitRenderInstructions_ = new Float32Array(0);
    this.hitRenderTarget_;
    this.generateBuffersRun_ = 0;
    this.worker_ = create$5();
    this.worker_.addEventListener("message", (event) => {
      const received = event.data;
      if (received.type === WebGLWorkerMessageType.GENERATE_POINT_BUFFERS) {
        const projectionTransform = received.projectionTransform;
        if (received.hitDetection) {
          this.hitVerticesBuffer_.fromArrayBuffer(received.vertexBuffer);
          this.helper.flushBufferData(this.hitVerticesBuffer_);
        } else {
          this.verticesBuffer_.fromArrayBuffer(received.vertexBuffer);
          this.helper.flushBufferData(this.verticesBuffer_);
        }
        this.indicesBuffer_.fromArrayBuffer(received.indexBuffer);
        this.helper.flushBufferData(this.indicesBuffer_);
        this.renderTransform_ = projectionTransform;
        makeInverse(this.invertRenderTransform_, this.renderTransform_);
        if (received.hitDetection) {
          this.hitRenderInstructions_ = new Float32Array(event.data.renderInstructions);
        } else {
          this.renderInstructions_ = new Float32Array(event.data.renderInstructions);
          if (received.generateBuffersRun === this.generateBuffersRun_) {
            this.ready = true;
          }
        }
        this.getLayer().changed();
      }
    });
    this.featureCache_ = {};
    this.featureCount_ = 0;
    const source = this.getLayer().getSource();
    this.sourceListenKeys_ = [
      listen(source, VectorEventType.ADDFEATURE, this.handleSourceFeatureAdded_, this),
      listen(source, VectorEventType.CHANGEFEATURE, this.handleSourceFeatureChanged_, this),
      listen(source, VectorEventType.REMOVEFEATURE, this.handleSourceFeatureDelete_, this),
      listen(source, VectorEventType.CLEAR, this.handleSourceFeatureClear_, this)
    ];
    source.forEachFeature((feature) => {
      this.featureCache_[getUid(feature)] = {
        feature,
        properties: feature.getProperties(),
        geometry: feature.getGeometry()
      };
      this.featureCount_++;
    });
  }
  afterHelperCreated() {
    this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);
    if (this.hitDetectionEnabled_) {
      this.hitProgram_ = this.helper.getProgram(this.hitFragmentShader_, this.hitVertexShader_);
      this.hitRenderTarget_ = new WebGLRenderTarget(this.helper);
    }
  }
  handleSourceFeatureAdded_(event) {
    const feature = event.feature;
    this.featureCache_[getUid(feature)] = {
      feature,
      properties: feature.getProperties(),
      geometry: feature.getGeometry()
    };
    this.featureCount_++;
  }
  handleSourceFeatureChanged_(event) {
    const feature = event.feature;
    this.featureCache_[getUid(feature)] = {
      feature,
      properties: feature.getProperties(),
      geometry: feature.getGeometry()
    };
  }
  handleSourceFeatureDelete_(event) {
    const feature = event.feature;
    delete this.featureCache_[getUid(feature)];
    this.featureCount_--;
  }
  handleSourceFeatureClear_() {
    this.featureCache_ = {};
    this.featureCount_ = 0;
  }
  renderFrame(frameState) {
    const gl = this.helper.getGL();
    this.preRender(gl, frameState);
    const projection = frameState.viewState.projection;
    const layer = this.getLayer();
    const vectorSource = layer.getSource();
    const multiWorld = vectorSource.getWrapX() && projection.canWrapX();
    const projectionExtent = projection.getExtent();
    const extent2 = frameState.extent;
    const worldWidth = multiWorld ? getWidth(projectionExtent) : null;
    const endWorld = multiWorld ? Math.ceil((extent2[2] - projectionExtent[2]) / worldWidth) + 1 : 1;
    const startWorld = multiWorld ? Math.floor((extent2[0] - projectionExtent[0]) / worldWidth) : 0;
    let world = startWorld;
    const renderCount = this.indicesBuffer_.getSize();
    do {
      this.helper.makeProjectionTransform(frameState, this.currentTransform_);
      translate$1(this.currentTransform_, world * worldWidth, 0);
      multiply(this.currentTransform_, this.invertRenderTransform_);
      this.helper.applyUniforms(frameState);
      this.helper.drawElements(0, renderCount);
    } while (++world < endWorld);
    this.helper.finalizeDraw(frameState, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent);
    const canvas = this.helper.getCanvas();
    if (this.hitDetectionEnabled_) {
      this.renderHitDetection(frameState, startWorld, endWorld, worldWidth);
      this.hitRenderTarget_.clearCachedData();
    }
    this.postRender(gl, frameState);
    return canvas;
  }
  prepareFrameInternal(frameState) {
    const layer = this.getLayer();
    const vectorSource = layer.getSource();
    const viewState = frameState.viewState;
    const viewNotMoving = !frameState.viewHints[ViewHint.ANIMATING] && !frameState.viewHints[ViewHint.INTERACTING];
    const extentChanged = !equals$2(this.previousExtent_, frameState.extent);
    const sourceChanged = this.sourceRevision_ < vectorSource.getRevision();
    if (sourceChanged) {
      this.sourceRevision_ = vectorSource.getRevision();
    }
    if (viewNotMoving && (extentChanged || sourceChanged)) {
      const projection = viewState.projection;
      const resolution = viewState.resolution;
      const renderBuffer = layer instanceof BaseVectorLayer ? layer.getRenderBuffer() : 0;
      const extent2 = buffer$2(frameState.extent, renderBuffer * resolution);
      vectorSource.loadFeatures(extent2, resolution, projection);
      this.rebuildBuffers_(frameState);
      this.previousExtent_ = frameState.extent.slice();
    }
    this.helper.useProgram(this.program_, frameState);
    this.helper.prepareDraw(frameState);
    this.helper.bindBuffer(this.verticesBuffer_);
    this.helper.bindBuffer(this.indicesBuffer_);
    this.helper.enableAttributes(this.attributes);
    return true;
  }
  rebuildBuffers_(frameState) {
    const projectionTransform = create$7();
    this.helper.makeProjectionTransform(frameState, projectionTransform);
    const totalInstructionsCount = (2 + this.customAttributes.length) * this.featureCount_;
    if (!this.renderInstructions_ || this.renderInstructions_.length !== totalInstructionsCount) {
      this.renderInstructions_ = new Float32Array(totalInstructionsCount);
    }
    if (this.hitDetectionEnabled_) {
      const totalHitInstructionsCount = (7 + this.customAttributes.length) * this.featureCount_;
      if (!this.hitRenderInstructions_ || this.hitRenderInstructions_.length !== totalHitInstructionsCount) {
        this.hitRenderInstructions_ = new Float32Array(totalHitInstructionsCount);
      }
    }
    let featureCache, geometry;
    const tmpCoords = [];
    const tmpColor = [];
    let renderIndex = 0;
    let hitIndex = 0;
    let hitColor;
    for (const featureUid in this.featureCache_) {
      featureCache = this.featureCache_[featureUid];
      geometry = featureCache.geometry;
      if (!geometry || geometry.getType() !== "Point") {
        continue;
      }
      tmpCoords[0] = geometry.getFlatCoordinates()[0];
      tmpCoords[1] = geometry.getFlatCoordinates()[1];
      apply$5(projectionTransform, tmpCoords);
      hitColor = colorEncodeId(hitIndex + 6, tmpColor);
      this.renderInstructions_[renderIndex++] = tmpCoords[0];
      this.renderInstructions_[renderIndex++] = tmpCoords[1];
      if (this.hitDetectionEnabled_) {
        this.hitRenderInstructions_[hitIndex++] = tmpCoords[0];
        this.hitRenderInstructions_[hitIndex++] = tmpCoords[1];
        this.hitRenderInstructions_[hitIndex++] = hitColor[0];
        this.hitRenderInstructions_[hitIndex++] = hitColor[1];
        this.hitRenderInstructions_[hitIndex++] = hitColor[2];
        this.hitRenderInstructions_[hitIndex++] = hitColor[3];
        this.hitRenderInstructions_[hitIndex++] = Number(featureUid);
      }
      let value;
      for (let j2 = 0; j2 < this.customAttributes.length; j2++) {
        value = this.customAttributes[j2].callback(featureCache.feature, featureCache.properties);
        this.renderInstructions_[renderIndex++] = value;
        if (this.hitDetectionEnabled_) {
          this.hitRenderInstructions_[hitIndex++] = value;
        }
      }
    }
    const message = {
      id: 0,
      type: WebGLWorkerMessageType.GENERATE_POINT_BUFFERS,
      renderInstructions: this.renderInstructions_.buffer,
      customAttributesCount: this.customAttributes.length
    };
    message["projectionTransform"] = projectionTransform;
    message["generateBuffersRun"] = ++this.generateBuffersRun_;
    this.ready = false;
    this.worker_.postMessage(message, [this.renderInstructions_.buffer]);
    this.renderInstructions_ = null;
    if (this.hitDetectionEnabled_) {
      const hitMessage = {
        id: 0,
        type: WebGLWorkerMessageType.GENERATE_POINT_BUFFERS,
        renderInstructions: this.hitRenderInstructions_.buffer,
        customAttributesCount: 5 + this.customAttributes.length
      };
      hitMessage["projectionTransform"] = projectionTransform;
      hitMessage["hitDetection"] = true;
      this.worker_.postMessage(hitMessage, [
        this.hitRenderInstructions_.buffer
      ]);
      this.hitRenderInstructions_ = null;
    }
  }
  forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {
    assert(this.hitDetectionEnabled_, 66);
    if (!this.hitRenderInstructions_) {
      return void 0;
    }
    const pixel = apply$5(frameState.coordinateToPixelTransform, coordinate.slice());
    const data2 = this.hitRenderTarget_.readPixel(pixel[0] / 2, pixel[1] / 2);
    const color2 = [data2[0] / 255, data2[1] / 255, data2[2] / 255, data2[3] / 255];
    const index2 = colorDecodeId(color2);
    const opacity2 = this.hitRenderInstructions_[index2];
    const uid2 = Math.floor(opacity2).toString();
    const source = this.getLayer().getSource();
    const feature = source.getFeatureByUid(uid2);
    if (feature) {
      return callback(feature, this.getLayer(), null);
    }
    return void 0;
  }
  renderHitDetection(frameState, startWorld, endWorld, worldWidth) {
    if (!this.hitVerticesBuffer_.getSize()) {
      return;
    }
    let world = startWorld;
    this.hitRenderTarget_.setSize([
      Math.floor(frameState.size[0] / 2),
      Math.floor(frameState.size[1] / 2)
    ]);
    this.helper.useProgram(this.hitProgram_, frameState);
    this.helper.prepareDrawToRenderTarget(frameState, this.hitRenderTarget_, true);
    this.helper.bindBuffer(this.hitVerticesBuffer_);
    this.helper.bindBuffer(this.indicesBuffer_);
    this.helper.enableAttributes(this.hitDetectionAttributes);
    do {
      this.helper.makeProjectionTransform(frameState, this.currentTransform_);
      translate$1(this.currentTransform_, world * worldWidth, 0);
      multiply(this.currentTransform_, this.invertRenderTransform_);
      this.helper.applyUniforms(frameState);
      const renderCount = this.indicesBuffer_.getSize();
      this.helper.drawElements(0, renderCount);
    } while (++world < endWorld);
  }
  disposeInternal() {
    this.worker_.terminate();
    this.layer_ = null;
    this.sourceListenKeys_.forEach(function(key) {
      unlistenByKey(key);
    });
    this.sourceListenKeys_ = null;
    super.disposeInternal();
  }
}
class ShaderBuilder {
  constructor() {
    this.uniforms = [];
    this.attributes = [];
    this.varyings = [];
    this.sizeExpression = "vec2(1.0)";
    this.rotationExpression = "0.0";
    this.offsetExpression = "vec2(0.0)";
    this.colorExpression = "vec4(1.0)";
    this.texCoordExpression = "vec4(0.0, 0.0, 1.0, 1.0)";
    this.discardExpression = "false";
    this.rotateWithView = false;
  }
  addUniform(name) {
    this.uniforms.push(name);
    return this;
  }
  addAttribute(name) {
    this.attributes.push(name);
    return this;
  }
  addVarying(name, type, expression) {
    this.varyings.push({
      name,
      type,
      expression
    });
    return this;
  }
  setSizeExpression(expression) {
    this.sizeExpression = expression;
    return this;
  }
  setRotationExpression(expression) {
    this.rotationExpression = expression;
    return this;
  }
  setSymbolOffsetExpression(expression) {
    this.offsetExpression = expression;
    return this;
  }
  setColorExpression(expression) {
    this.colorExpression = expression;
    return this;
  }
  setTextureCoordinateExpression(expression) {
    this.texCoordExpression = expression;
    return this;
  }
  setFragmentDiscardExpression(expression) {
    this.discardExpression = expression;
    return this;
  }
  setSymbolRotateWithView(rotateWithView) {
    this.rotateWithView = rotateWithView;
    return this;
  }
  getSizeExpression() {
    return this.sizeExpression;
  }
  getOffsetExpression() {
    return this.offsetExpression;
  }
  getColorExpression() {
    return this.colorExpression;
  }
  getTextureCoordinateExpression() {
    return this.texCoordExpression;
  }
  getFragmentDiscardExpression() {
    return this.discardExpression;
  }
  getSymbolVertexShader(forHitDetection) {
    const offsetMatrix = this.rotateWithView ? "u_offsetScaleMatrix * u_offsetRotateMatrix" : "u_offsetScaleMatrix";
    let attributes = this.attributes;
    let varyings = this.varyings;
    if (forHitDetection) {
      attributes = attributes.concat("vec4 a_hitColor");
      varyings = varyings.concat({
        name: "v_hitColor",
        type: "vec4",
        expression: "a_hitColor"
      });
    }
    return `precision mediump float;
uniform mat4 u_projectionMatrix;
uniform mat4 u_offsetScaleMatrix;
uniform mat4 u_offsetRotateMatrix;
uniform float u_time;
uniform float u_zoom;
uniform float u_resolution;
${this.uniforms.map(function(uniform) {
      return "uniform " + uniform + ";";
    }).join("\n")}
attribute vec2 a_position;
attribute float a_index;
${attributes.map(function(attribute) {
      return "attribute " + attribute + ";";
    }).join("\n")}
varying vec2 v_texCoord;
varying vec2 v_quadCoord;
${varyings.map(function(varying) {
      return "varying " + varying.type + " " + varying.name + ";";
    }).join("\n")}
void main(void) {
  mat4 offsetMatrix = ${offsetMatrix};
  vec2 halfSize = ${this.sizeExpression} * 0.5;
  vec2 offset = ${this.offsetExpression};
  float angle = ${this.rotationExpression};
  float offsetX;
  float offsetY;
  if (a_index == 0.0) {
    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);
    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);
  } else if (a_index == 1.0) {
    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);
    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);
  } else if (a_index == 2.0) {
    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);
    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);
  } else {
    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);
    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);
  }
  vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);
  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;
  vec4 texCoord = ${this.texCoordExpression};
  float u = a_index == 0.0 || a_index == 3.0 ? texCoord.s : texCoord.p;
  float v = a_index == 2.0 || a_index == 3.0 ? texCoord.t : texCoord.q;
  v_texCoord = vec2(u, v);
  u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;
  v = a_index == 2.0 || a_index == 3.0 ? 0.0 : 1.0;
  v_quadCoord = vec2(u, v);
${varyings.map(function(varying) {
      return "  " + varying.name + " = " + varying.expression + ";";
    }).join("\n")}
}`;
  }
  getSymbolFragmentShader(forHitDetection) {
    const hitDetectionBypass = forHitDetection ? "  if (gl_FragColor.a < 0.1) { discard; } gl_FragColor = v_hitColor;" : "";
    let varyings = this.varyings;
    if (forHitDetection) {
      varyings = varyings.concat({
        name: "v_hitColor",
        type: "vec4",
        expression: "a_hitColor"
      });
    }
    return `precision mediump float;
uniform float u_time;
uniform float u_zoom;
uniform float u_resolution;
${this.uniforms.map(function(uniform) {
      return "uniform " + uniform + ";";
    }).join("\n")}
varying vec2 v_texCoord;
varying vec2 v_quadCoord;
${varyings.map(function(varying) {
      return "varying " + varying.type + " " + varying.name + ";";
    }).join("\n")}
void main(void) {
  if (${this.discardExpression}) { discard; }
  gl_FragColor = ${this.colorExpression};
  gl_FragColor.rgb *= gl_FragColor.a;
${hitDetectionBypass}
}`;
  }
}
function parseLiteralStyle(style2) {
  const symbStyle = style2.symbol;
  const size = symbStyle.size !== void 0 ? symbStyle.size : 1;
  const color2 = symbStyle.color || "white";
  const texCoord = symbStyle.textureCoord || [0, 0, 1, 1];
  const offset2 = symbStyle.offset || [0, 0];
  const opacity2 = symbStyle.opacity !== void 0 ? symbStyle.opacity : 1;
  const rotation = symbStyle.rotation !== void 0 ? symbStyle.rotation : 0;
  const vertContext = {
    inFragmentShader: false,
    variables: [],
    attributes: [],
    stringLiteralsMap: {},
    functions: {}
  };
  const parsedSize = expressionToGlsl(vertContext, size, ValueTypes.NUMBER_ARRAY | ValueTypes.NUMBER);
  const parsedOffset = expressionToGlsl(vertContext, offset2, ValueTypes.NUMBER_ARRAY);
  const parsedTexCoord = expressionToGlsl(vertContext, texCoord, ValueTypes.NUMBER_ARRAY);
  const parsedRotation = expressionToGlsl(vertContext, rotation, ValueTypes.NUMBER);
  const fragContext = {
    inFragmentShader: true,
    variables: vertContext.variables,
    attributes: [],
    stringLiteralsMap: vertContext.stringLiteralsMap,
    functions: {}
  };
  const parsedColor = expressionToGlsl(fragContext, color2, ValueTypes.COLOR);
  const parsedOpacity = expressionToGlsl(fragContext, opacity2, ValueTypes.NUMBER);
  let opacityFilter = "1.0";
  const visibleSize = `vec2(${expressionToGlsl(fragContext, size, ValueTypes.NUMBER_ARRAY | ValueTypes.NUMBER)}).x`;
  switch (symbStyle.symbolType) {
    case "square":
      break;
    case "image":
      break;
    case "circle":
      opacityFilter = `(1.0-smoothstep(1.-4./${visibleSize},1.,dot(v_quadCoord-.5,v_quadCoord-.5)*4.))`;
      break;
    case "triangle":
      const st2 = "(v_quadCoord*2.-1.)";
      const a2 = `(atan(${st2}.x,${st2}.y))`;
      opacityFilter = `(1.0-smoothstep(.5-3./${visibleSize},.5,cos(floor(.5+${a2}/2.094395102)*2.094395102-${a2})*length(${st2})))`;
      break;
    default:
      throw new Error("Unexpected symbol type: " + symbStyle.symbolType);
  }
  const builder = new ShaderBuilder().setSizeExpression(`vec2(${parsedSize})`).setRotationExpression(parsedRotation).setSymbolOffsetExpression(parsedOffset).setTextureCoordinateExpression(parsedTexCoord).setSymbolRotateWithView(!!symbStyle.rotateWithView).setColorExpression(`vec4(${parsedColor}.rgb, ${parsedColor}.a * ${parsedOpacity} * ${opacityFilter})`);
  if (style2.filter) {
    const parsedFilter = expressionToGlsl(fragContext, style2.filter, ValueTypes.BOOLEAN);
    builder.setFragmentDiscardExpression(`!${parsedFilter}`);
  }
  const uniforms = {};
  fragContext.variables.forEach(function(varName) {
    const uniformName = uniformNameForVariable(varName);
    builder.addUniform(`float ${uniformName}`);
    uniforms[uniformName] = function() {
      if (!style2.variables || style2.variables[varName] === void 0) {
        throw new Error(`The following variable is missing from the style: ${varName}`);
      }
      let value = style2.variables[varName];
      if (typeof value === "string") {
        value = getStringNumberEquivalent(vertContext, value);
      }
      return value !== void 0 ? value : -9999999;
    };
  });
  if (symbStyle.symbolType === "image" && symbStyle.src) {
    const texture = new Image();
    texture.crossOrigin = symbStyle.crossOrigin === void 0 ? "anonymous" : symbStyle.crossOrigin;
    texture.src = symbStyle.src;
    builder.addUniform("sampler2D u_texture").setColorExpression(builder.getColorExpression() + " * texture2D(u_texture, v_texCoord)");
    uniforms["u_texture"] = texture;
  }
  fragContext.attributes.forEach(function(attrName) {
    if (!vertContext.attributes.includes(attrName)) {
      vertContext.attributes.push(attrName);
    }
    builder.addVarying(`v_${attrName}`, "float", `a_${attrName}`);
  });
  vertContext.attributes.forEach(function(attrName) {
    builder.addAttribute(`float a_${attrName}`);
  });
  return {
    builder,
    attributes: vertContext.attributes.map(function(attributeName) {
      return {
        name: attributeName,
        callback: function(feature, props) {
          let value = props[attributeName];
          if (typeof value === "string") {
            value = getStringNumberEquivalent(vertContext, value);
          }
          return value !== void 0 ? value : -9999999;
        }
      };
    }),
    uniforms
  };
}
class WebGLPointsLayer extends Layer {
  constructor(options) {
    const baseOptions = Object.assign({}, options);
    super(baseOptions);
    this.parseResult_ = parseLiteralStyle(options.style);
    this.styleVariables_ = options.style.variables || {};
    this.hitDetectionDisabled_ = !!options.disableHitDetection;
  }
  createRenderer() {
    return new WebGLPointsLayerRenderer(this, {
      vertexShader: this.parseResult_.builder.getSymbolVertexShader(),
      fragmentShader: this.parseResult_.builder.getSymbolFragmentShader(),
      hitVertexShader: !this.hitDetectionDisabled_ && this.parseResult_.builder.getSymbolVertexShader(true),
      hitFragmentShader: !this.hitDetectionDisabled_ && this.parseResult_.builder.getSymbolFragmentShader(true),
      uniforms: this.parseResult_.uniforms,
      attributes: this.parseResult_.attributes
    });
  }
  updateStyleVariables(variables) {
    Object.assign(this.styleVariables_, variables);
    this.changed();
  }
}
const _sfc_main$W = {
  extends: BaseLayer,
  name: "ol-webglpoints-layer",
  setup(props) {
    const map = inject("map");
    const {
      properties
    } = usePropsAsObjectProperties(props);
    const webglPointsLayer = computed(() => new WebGLPointsLayer(properties));
    watch(properties, () => {
      webglPointsLayer.value.setProperties(properties);
    });
    onMounted(() => {
      map.addLayer(webglPointsLayer.value);
    });
    onUnmounted(() => {
      map.removeLayer(webglPointsLayer.value);
    });
    provide("webglPointsLayer", webglPointsLayer);
    return {
      webglPointsLayer
    };
  },
  props: {
    disableHitDetection: {
      type: Boolean,
      default: false
    },
    style: {
      type: Object,
      default: () => ({
        symbol: {
          symbolType: "circle",
          size: 8,
          color: "#33AAFF",
          opacity: 0.9
        }
      })
    }
  }
};
function _sfc_render$W(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var WebglPointsLayer = /* @__PURE__ */ _export_sfc(_sfc_main$W, [["render", _sfc_render$W]]);
const Property$1 = {
  BLUR: "blur",
  GRADIENT: "gradient",
  RADIUS: "radius"
};
const DEFAULT_GRADIENT = ["#00f", "#0ff", "#0f0", "#ff0", "#f00"];
class Heatmap extends BaseVectorLayer {
  constructor(options) {
    options = options ? options : {};
    const baseOptions = Object.assign({}, options);
    delete baseOptions.gradient;
    delete baseOptions.radius;
    delete baseOptions.blur;
    delete baseOptions.weight;
    super(baseOptions);
    this.gradient_ = null;
    this.addChangeListener(Property$1.GRADIENT, this.handleGradientChanged_);
    this.setGradient(options.gradient ? options.gradient : DEFAULT_GRADIENT);
    this.setBlur(options.blur !== void 0 ? options.blur : 15);
    this.setRadius(options.radius !== void 0 ? options.radius : 8);
    const weight = options.weight ? options.weight : "weight";
    if (typeof weight === "string") {
      this.weightFunction_ = function(feature) {
        return feature.get(weight);
      };
    } else {
      this.weightFunction_ = weight;
    }
    this.setRenderOrder(null);
  }
  getBlur() {
    return this.get(Property$1.BLUR);
  }
  getGradient() {
    return this.get(Property$1.GRADIENT);
  }
  getRadius() {
    return this.get(Property$1.RADIUS);
  }
  handleGradientChanged_() {
    this.gradient_ = createGradient(this.getGradient());
  }
  setBlur(blur) {
    this.set(Property$1.BLUR, blur);
  }
  setGradient(colors) {
    this.set(Property$1.GRADIENT, colors);
  }
  setRadius(radius) {
    this.set(Property$1.RADIUS, radius);
  }
  createRenderer() {
    return new WebGLPointsLayerRenderer(this, {
      className: this.getClassName(),
      attributes: [
        {
          name: "weight",
          callback: (feature) => {
            const weight = this.weightFunction_(feature);
            return weight !== void 0 ? clamp(weight, 0, 1) : 1;
          }
        }
      ],
      vertexShader: `
        precision mediump float;
        uniform mat4 u_projectionMatrix;
        uniform mat4 u_offsetScaleMatrix;
        uniform float u_size;
        attribute vec2 a_position;
        attribute float a_index;
        attribute float a_weight;

        varying vec2 v_texCoord;
        varying float v_weight;

        void main(void) {
          mat4 offsetMatrix = u_offsetScaleMatrix;
          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;
          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;
          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);
          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;
          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;
          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;
          v_texCoord = vec2(u, v);
          v_weight = a_weight;
        }`,
      fragmentShader: `
        precision mediump float;
        uniform float u_blurSlope;

        varying vec2 v_texCoord;
        varying float v_weight;

        void main(void) {
          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);
          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;
          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;
          float alpha = smoothstep(0.0, 1.0, value) * v_weight;
          gl_FragColor = vec4(alpha, alpha, alpha, alpha);
        }`,
      hitVertexShader: `
        precision mediump float;
        uniform mat4 u_projectionMatrix;
        uniform mat4 u_offsetScaleMatrix;
        uniform float u_size;
        attribute vec2 a_position;
        attribute float a_index;
        attribute float a_weight;
        attribute vec4 a_hitColor;

        varying vec2 v_texCoord;
        varying float v_weight;
        varying vec4 v_hitColor;

        void main(void) {
          mat4 offsetMatrix = u_offsetScaleMatrix;
          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;
          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;
          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);
          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;
          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;
          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;
          v_texCoord = vec2(u, v);
          v_hitColor = a_hitColor;
          v_weight = a_weight;
        }`,
      hitFragmentShader: `
        precision mediump float;
        uniform float u_blurSlope;

        varying vec2 v_texCoord;
        varying float v_weight;
        varying vec4 v_hitColor;

        void main(void) {
          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);
          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;
          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;
          float alpha = smoothstep(0.0, 1.0, value) * v_weight;
          if (alpha < 0.05) {
            discard;
          }

          gl_FragColor = v_hitColor;
        }`,
      uniforms: {
        u_size: () => {
          return (this.get(Property$1.RADIUS) + this.get(Property$1.BLUR)) * 2;
        },
        u_blurSlope: () => {
          return this.get(Property$1.RADIUS) / Math.max(1, this.get(Property$1.BLUR));
        }
      },
      postProcesses: [
        {
          fragmentShader: `
            precision mediump float;

            uniform sampler2D u_image;
            uniform sampler2D u_gradientTexture;
            uniform float u_opacity;

            varying vec2 v_texCoord;

            void main() {
              vec4 color = texture2D(u_image, v_texCoord);
              gl_FragColor.a = color.a * u_opacity;
              gl_FragColor.rgb = texture2D(u_gradientTexture, vec2(0.5, color.a)).rgb;
              gl_FragColor.rgb *= gl_FragColor.a;
            }`,
          uniforms: {
            u_gradientTexture: () => {
              return this.gradient_;
            },
            u_opacity: () => {
              return this.getOpacity();
            }
          }
        }
      ]
    });
  }
  renderDeclutter() {
  }
}
function createGradient(colors) {
  const width = 1;
  const height = 256;
  const context2 = createCanvasContext2D(width, height);
  const gradient = context2.createLinearGradient(0, 0, width, height);
  const step = 1 / (colors.length - 1);
  for (let i2 = 0, ii = colors.length; i2 < ii; ++i2) {
    gradient.addColorStop(i2 * step, colors[i2]);
  }
  context2.fillStyle = gradient;
  context2.fillRect(0, 0, width, height);
  return context2.canvas;
}
const _sfc_main$V = {
  extends: BaseLayer,
  name: "ol-heatmap-layer",
  setup(props) {
    const map = inject("map");
    const {
      properties
    } = usePropsAsObjectProperties(props);
    const heatmapLayer = computed(() => new Heatmap(properties));
    watch(properties, () => {
      hetmapLayer.value.setProperties(properties);
    });
    onMounted(() => {
      map.addLayer(heatmapLayer.value);
    });
    onUnmounted(() => {
      map.removeLayer(heatmapLayer.value);
    });
    provide("heatmapLayer", heatmapLayer);
    provide("stylable", heatmapLayer);
    return {
      heatmapLayer
    };
  },
  props: {
    weight: {
      type: Function
    },
    extent: {
      type: Array
    },
    blur: {
      type: Number
    },
    radius: {
      type: Number
    }
  }
};
function _sfc_render$V(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var HeatmapLayer = /* @__PURE__ */ _export_sfc(_sfc_main$V, [["render", _sfc_render$V]]);
function install$7(app) {
  if (install$7.installed) {
    return;
  }
  install$7.installed = true;
  app.component(TileLayer.name, TileLayer);
  app.component(WebGLTileLayer.name, WebGLTileLayer);
  app.component(ImageLayer.name, ImageLayer);
  app.component(VectorLayer.name, VectorLayer);
  app.component(AnimatedClusterLayer.name, AnimatedClusterLayer);
  app.component(WebglPointsLayer.name, WebglPointsLayer);
  app.component(HeatmapLayer.name, HeatmapLayer);
}
var Layers = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": install$7,
  install: install$7,
  TileLayer,
  WebGLTileLayer,
  ImageLayer,
  VectorLayer,
  AnimatedClusterLayer,
  WebglPointsLayer,
  HeatmapLayer
}, Symbol.toStringTag, { value: "Module" }));
const _sfc_main$U = {
  name: "ol-source-xyz",
  setup(props) {
    const layer = inject("tileLayer");
    const {
      properties
    } = usePropsAsObjectProperties(props);
    let source = computed(() => new XYZ(properties));
    watch(source, () => {
      layer.value.setSource(source.value);
    });
    watch(layer, () => {
      layer.value.setSource(source.value);
    });
    onMounted(() => {
      layer.value.setSource(source.value);
    });
    onUnmounted(() => {
      layer.value.setSource(null);
    });
    return {
      layer,
      source
    };
  },
  props: {
    attributions: {
      type: [String, Array]
    },
    url: {
      type: String
    },
    cacheSize: {
      type: Number,
      default: 2048
    },
    crossOrigin: {
      type: String
    },
    maxZoom: {
      type: Number,
      default: 28
    },
    minZoom: {
      type: Number,
      default: 0
    },
    opaque: {
      type: Boolean
    },
    projection: {
      type: String,
      default: "EPSG:3857"
    },
    reprojectionErrorThreshold: {
      type: Number,
      default: 0.5
    },
    tileSize: {
      type: Array,
      default: () => [256, 256]
    },
    tilePixelRatio: {
      type: Number,
      default: 1
    },
    tileKey: {
      type: String
    },
    transition: {
      type: Number
    },
    tileGrid: {
      type: Object
    }
  }
};
function _sfc_render$U(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var SourceXYZ = /* @__PURE__ */ _export_sfc(_sfc_main$U, [["render", _sfc_render$U]]);
const _sfc_main$T = {
  name: "ol-source-osm",
  setup(props) {
    const layer = inject("tileLayer");
    const {
      properties
    } = usePropsAsObjectProperties(props);
    let source = computed(() => new OSM(properties));
    watch(source, () => {
      layer.value.setSource(source.value);
    });
    watch(layer, () => {
      layer.value.setSource(source.value);
    });
    onMounted(() => {
      layer.value.setSource(source.value);
    });
    onUnmounted(() => {
      layer.value.setSource(null);
    });
    return {
      layer,
      source
    };
  },
  props: {
    attributions: {
      type: String
    },
    cacheSize: {
      type: Number,
      default: 2048
    },
    crossOrigin: {
      type: String,
      default: "anonymous"
    },
    imageSmoothing: {
      type: Boolean,
      default: true
    },
    minZoom: {
      type: Number,
      default: 0
    },
    maxZoom: {
      type: Number,
      default: 19
    },
    opaque: {
      type: Boolean,
      default: true
    },
    reprojectionErrorThreshold: {
      type: Number,
      default: 0.5
    },
    transition: {
      type: Number,
      default: 250
    },
    url: {
      type: String,
      default: "https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png"
    },
    wrapX: {
      type: Boolean,
      default: true
    }
  }
};
function _sfc_render$T(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var SourceOSM = /* @__PURE__ */ _export_sfc(_sfc_main$T, [["render", _sfc_render$T]]);
const _sfc_main$S = {
  name: "ol-source-image-static",
  setup(props) {
    const layer = inject("imageLayer");
    const {
      properties
    } = usePropsAsObjectProperties(props);
    const createSource = () => {
      return new Static(__spreadProps(__spreadValues({}, properties), {
        projection: typeof properties.projection == "string" ? properties.projection : new Projection$2(__spreadValues({}, properties.projection))
      }));
    };
    let source = createSource();
    watch(properties, () => {
      layer.setSource(null);
      source = createSource();
      layer.setSource(source);
    });
    onMounted(() => {
      layer.setSource(source);
    });
    onUnmounted(() => {
      layer.setSource(null);
    });
    return {
      layer,
      source
    };
  },
  props: {
    attributions: {
      type: String
    },
    crossOrigin: {
      type: String
    },
    imageExtent: {
      type: Array
    },
    projection: {
      type: [String, Object]
    },
    imageSmoothing: {
      type: Boolean,
      default: true
    },
    imageSize: {
      type: Array
    },
    url: {
      type: String
    }
  }
};
function _sfc_render$S(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var SourceImageStatic = /* @__PURE__ */ _export_sfc(_sfc_main$S, [["render", _sfc_render$S]]);
const _sfc_main$R = {
  name: "ol-source-wmts",
  setup(props) {
    const tileLayer = inject("tileLayer");
    const {
      properties
    } = usePropsAsObjectProperties(props);
    const extent2 = computed(() => get$4(properties.projection).getExtent());
    const origin = computed(() => getTopLeft(extent2.value));
    const size = computed(() => getWidth(extent2.value) / 256);
    const getTileGrid = computed(() => {
      const resolutions = new Array(properties.tileZoomLevel);
      const matrixIds = new Array(properties.tileZoomLevel);
      for (var z2 = 0; z2 < properties.tileZoomLevel; ++z2) {
        resolutions[z2] = size.value / Math.pow(2, z2);
        matrixIds[z2] = z2;
      }
      return new WMTSTileGrid({
        origin: origin.value,
        resolutions,
        matrixIds
      });
    });
    const source = computed(() => new WMTS(__spreadProps(__spreadValues({}, properties), {
      projection: typeof properties.projection == "string" ? properties.projection : new Projection$2(__spreadValues({}, properties.projection)),
      tileGrid: getTileGrid.value
    })));
    watch(source, () => {
      tileLayer.value.setSource(source.value);
    });
    watch(tileLayer, () => {
      tileLayer.value.setSource(source.value);
    });
    onMounted(() => {
      tileLayer.value.setSource(source.value);
    });
    onUnmounted(() => {
      tileLayer.value.setSource(null);
    });
    return {
      tileLayer,
      source
    };
  },
  props: {
    tileZoomLevel: {
      type: Number,
      default: 30
    },
    attributions: {
      type: String
    },
    cacheSize: {
      type: Number
    },
    crossOrigin: {
      type: String
    },
    imageSmoothing: {
      type: Boolean,
      default: true
    },
    projection: {
      type: [String, Object],
      default: "EPSG:3857"
    },
    reprojectionErrorThreshold: {
      type: Number,
      default: 0.5
    },
    tilePixelRatio: {
      type: Number,
      default: 1
    },
    format: {
      type: String,
      default: "image/jpeg"
    },
    version: {
      type: String,
      default: "1.0.0"
    },
    matrixSet: {
      type: String
    },
    dimensions: {
      type: Object
    },
    requestEncoding: {
      type: String,
      default: "KVP"
    },
    url: {
      type: String
    },
    urls: {
      type: Array
    },
    wrapX: {
      type: Boolean,
      default: false
    },
    transition: {
      type: Number
    },
    layer: {
      type: String
    },
    style: {
      type: String
    }
  }
};
function _sfc_render$R(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var SourceWMTS = /* @__PURE__ */ _export_sfc(_sfc_main$R, [["render", _sfc_render$R]]);
const _sfc_main$Q = {
  name: "ol-source-vector",
  setup(props) {
    const layer = inject("vectorLayer") || inject("heatmapLayer");
    const {
      properties
    } = usePropsAsObjectProperties(props);
    let source = computed(() => new VectorSource(properties));
    const applySource = () => {
      layer.value.setSource(null);
      layer.value.setSource(source.value);
      layer.value.changed();
    };
    watch(properties, () => {
      applySource();
    });
    watch(layer, () => {
      applySource();
    });
    onMounted(() => {
      layer.value.setSource(source.value);
    });
    onUnmounted(() => {
      layer.value.setSource(null);
    });
    provide("vectorSource", source);
    return {
      layer,
      source
    };
  },
  props: {
    attributions: {
      type: [String, Array]
    },
    features: {
      type: Array,
      default: () => []
    },
    format: {
      type: Object
    },
    loader: {
      type: Function
    },
    overlaps: {
      type: Boolean,
      default: true
    },
    projection: {
      type: String,
      default: "EPSG:3857"
    },
    strategy: {
      type: Function
    },
    url: {
      type: [String, Function]
    },
    useSpatialIndex: {
      type: Boolean,
      default: true
    },
    wrapX: {
      type: Boolean,
      default: true
    }
  }
};
function _sfc_render$Q(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var SourceVector = /* @__PURE__ */ _export_sfc(_sfc_main$Q, [["render", _sfc_render$Q]]);
const _sfc_main$P = {
  name: "ol-source-cluster",
  setup(props) {
    const layer = inject("vectorLayer");
    const {
      properties
    } = usePropsAsObjectProperties(props);
    let source = computed(() => {
      let c2 = new Cluster(properties);
      return c2;
    });
    const applySource = () => {
      layer.value.setSource(null);
      layer.value.setSource(source.value);
      layer.value.changed();
    };
    watch(properties, () => {
      applySource();
    });
    watch(layer, () => {
      applySource();
    });
    onMounted(() => {
      layer.value.setSource(source.value);
      layer.value.changed();
    });
    onUnmounted(() => {
      layer.value.setSource(null);
    });
    provide("vectorLayer", source);
    return {
      layer,
      source
    };
  },
  props: {
    attributions: {
      type: [String, Array]
    },
    distance: {
      type: Number,
      default: 20
    },
    geometryFunction: {
      type: Function,
      default: (feature) => feature.getGeometry()
    },
    wrapX: {
      type: Boolean,
      default: true
    }
  }
};
function _sfc_render$P(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var SourceCluster = /* @__PURE__ */ _export_sfc(_sfc_main$P, [["render", _sfc_render$P]]);
const _sfc_main$O = {
  name: "ol-source-bingmaps",
  setup(props) {
    const layer = inject("tileLayer");
    const {
      properties
    } = usePropsAsObjectProperties(props);
    let source = computed(() => new BingMaps(__spreadProps(__spreadValues({}, properties), {
      key: properties.apiKey
    })));
    watch(source, () => {
      layer.value.setSource(source.value);
    });
    watch(layer, () => {
      layer.value.setSource(source.value);
    });
    onMounted(() => {
      layer.value.setSource(source.value);
    });
    onUnmounted(() => {
      layer.value.setSource(null);
    });
    return {
      layer,
      source
    };
  },
  props: {
    cacheSize: {
      type: Number
    },
    hidpi: {
      type: Boolean,
      default: false
    },
    culture: {
      type: String,
      default: "en-us"
    },
    apiKey: {
      type: String
    },
    imagerySet: {
      type: String
    },
    imageSmoothing: {
      type: Boolean,
      default: true
    },
    maxZoom: {
      type: Number,
      default: 21
    },
    reprojectionErrorThreshold: {
      type: Number,
      default: 0.5
    },
    tileLoadFunction: {
      type: Function,
      default: (imageTile, src) => imageTile.getImage().src = src
    },
    wrapX: {
      type: Boolean,
      default: true
    },
    transition: {
      type: Number
    }
  }
};
function _sfc_render$O(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var SourceBingMaps = /* @__PURE__ */ _export_sfc(_sfc_main$O, [["render", _sfc_render$O]]);
class Tianditu extends WMTS {
  constructor(opt_options) {
    Tianditu.layerLabelMap = {
      vec: "cva",
      ter: "cta",
      img: "cia"
    };
    Tianditu.layerZoomMap = {
      vec: 18,
      ter: 14,
      img: 18
    };
    let options = opt_options || {};
    options.layerType = options.layerType || "vec";
    options.layerType = options.isLabel ? Tianditu.layerLabelMap[options.layerType] : options.layerType;
    options.matrixSet = options.projection === "EPSG:4326" || options.projection === "EPSG:4490" ? "c" : "w";
    if (!options.url && !options.urls) {
      options.url = "https://t{0-7}.tianditu.gov.cn/{layer}_{proj}/wmts?";
    }
    if (options.tk) {
      options.url = `${options.url}tk=${options.tk}`;
    }
    options.url = options.url.replace("{layer}", options.layerType).replace("{proj}", options.matrixSet);
    let tileGrid = options.tileGrid || Tianditu.getTileGrid(options.projection || "EPSG:3857");
    let crossOrigin = options.crossOrigin !== void 0 ? options.crossOrigin : "anonymous";
    let superOptions = {
      version: options.version || "1.0.0",
      format: options.format || "tiles",
      dimensions: options.dimensions || {},
      layer: options.layerType,
      matrixSet: options.matrixSet,
      tileGrid,
      style: options.style || "default",
      cacheSize: options.cacheSize,
      crossOrigin,
      opaque: options.opaque === void 0 ? true : options.opaque,
      maxZoom: Tianditu.layerZoomMap[options.layerType],
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      url: options.url,
      urls: options.urls,
      projection: options.projection || "EPSG:3857",
      wrapX: options.wrapX
    };
    if (options.tileProxy) {
      superOptions.tileLoadFunction = tileLoadFunction;
    }
    super(superOptions);
    if (options.tileProxy) {
      this.tileProxy = options.tileProxy;
    }
    let me2 = this;
    function tileLoadFunction(imageTile, src) {
      imageTile.getImage().src = me2.tileProxy + encodeURIComponent(src);
    }
  }
  static getTileGrid(projection) {
    if (projection === "EPSG:4326" || projection === "EPSG:4490") {
      return Tianditu.default4326TileGrid();
    }
    return Tianditu.default3857TileGrid();
  }
  static default4326TileGrid() {
    let tdt_WGS84_resolutions = [];
    let matrixIds = [];
    for (let i2 = 1; i2 < 19; i2++) {
      tdt_WGS84_resolutions.push(0.703125 * 2 / Math.pow(2, i2));
      matrixIds.push(i2);
    }
    let tileGird = new WMTSTileGrid({
      extent: [-180, -90, 180, 90],
      resolutions: tdt_WGS84_resolutions,
      origin: [-180, 90],
      matrixIds,
      minZoom: 1
    });
    return tileGird;
  }
  static default3857TileGrid() {
    let tdt_Mercator_resolutions = [];
    let matrixIds = [];
    for (let i2 = 1; i2 < 19; i2++) {
      tdt_Mercator_resolutions.push(78271.51696402031 * 2 / Math.pow(2, i2));
      matrixIds.push(i2);
    }
    let tileGird = new WMTSTileGrid({
      extent: [
        -200375083427892e-7,
        -200375083427892e-7,
        200375083427892e-7,
        200375083427892e-7
      ],
      resolutions: tdt_Mercator_resolutions,
      matrixIds,
      origin: [-200375083427892e-7, 200375083427892e-7],
      minZoom: 1
    });
    return tileGird;
  }
}
const _sfc_main$N = {
  name: "ol-source-tianditu",
  setup(props) {
    const layer = inject("tileLayer");
    const { properties } = usePropsAsObjectProperties(props);
    let source = computed(() => {
      return new Tianditu(properties);
    });
    watch(source, () => {
      layer.value.setSource(source.value);
    });
    watch(layer, () => {
      layer.value.setSource(source.value);
    });
    onMounted(() => {
      layer.value.setSource(source.value);
    });
    onUnmounted(() => {
      layer.value.setSource(null);
    });
    return {
      layer,
      source
    };
  },
  props: {
    layerType: {
      type: String,
      default: "img"
    },
    tk: {
      type: String
    },
    isLabel: {
      type: Boolean,
      default: false
    },
    cacheSize: {
      type: Number
    },
    crossOrigin: {
      type: String
    },
    projection: {
      Type: String,
      default: "EPSG:3857"
    },
    hidpi: {
      type: Boolean,
      default: false
    },
    requestEncoding: {
      type: String,
      default: "KVP"
    },
    format: {
      type: String
    },
    version: {
      type: String,
      default: "1.0.0"
    },
    culture: {
      type: String,
      default: "en-us"
    },
    matrixSet: {
      type: String
    },
    dimensions: {
      type: Object,
      default: () => {
      }
    },
    imageSmoothing: {
      type: Boolean,
      default: true
    },
    maxZoom: {
      type: Number,
      default: 21
    },
    reprojectionErrorThreshold: {
      type: Number
    },
    tileLoadFunction: {
      type: Function,
      default: (imageTile, src) => imageTile.getImage().src = src
    },
    wrapX: {
      type: Boolean,
      default: true
    },
    transition: {
      type: Number
    }
  }
};
function _sfc_render$N(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var SourceTianDiTu = /* @__PURE__ */ _export_sfc(_sfc_main$N, [["render", _sfc_render$N]]);
const _sfc_main$M = {
  name: "ol-source-image-wms",
  setup(props) {
    const layer = inject("imageLayer");
    const {
      properties
    } = usePropsAsObjectProperties(props);
    const createSource = () => {
      return new ImageWMS(__spreadProps(__spreadValues({}, properties), {
        params: {
          "LAYERS": props.layers,
          "STYLES": props.styles,
          "TIME": props.time
        },
        projection: typeof properties.projection == "string" ? properties.projection : new Projection$2(__spreadValues({}, properties.projection))
      }));
    };
    let source = createSource();
    watch(properties, () => {
      layer.setSource(null);
      source = createSource();
      layer.setSource(source);
    });
    onMounted(() => {
      layer.setSource(source);
    });
    onUnmounted(() => {
      layer.setSource(null);
    });
    return {
      layer,
      source
    };
  },
  props: {
    attributions: {
      type: String
    },
    crossOrigin: {
      type: String
    },
    imageExtent: {
      type: Array
    },
    projection: {
      type: [String, Object],
      default: "EPSG:3857"
    },
    reprojectionErrorThreshold: {
      type: Number,
      default: 0.5
    },
    format: {
      type: String,
      default: "image/png"
    },
    version: {
      type: String,
      default: "1.3.0"
    },
    matrixSet: {
      type: String
    },
    serverType: {
      type: String,
      default: "mapserver"
    },
    imageSmoothing: {
      type: Boolean,
      default: true
    },
    layers: {
      type: [String, Array],
      required: true
    },
    styles: {
      type: [String, Array],
      default: ""
    },
    time: {
      type: String
    },
    ratio: {
      type: Number,
      default: 1
    },
    imageSize: {
      type: Array
    },
    url: {
      type: String
    },
    params: {
      type: Object
    },
    imageLoadFunction: {
      type: Function
    }
  }
};
function _sfc_render$M(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var SourceImageWMS = /* @__PURE__ */ _export_sfc(_sfc_main$M, [["render", _sfc_render$M]]);
const _sfc_main$L = {
  name: "ol-source-webglpoints",
  setup(props) {
    const layer = inject("webglPointsLayer");
    const {
      properties
    } = usePropsAsObjectProperties(props);
    let source = computed(() => new VectorSource(properties));
    const applySource = () => {
      layer.value.setSource(null);
      layer.value.setSource(source.value);
      layer.value.changed();
    };
    watch(properties, () => {
      applySource();
    });
    watch(layer, () => {
      applySource();
    });
    onMounted(() => {
      layer.value.setSource(source.value);
    });
    onUnmounted(() => {
      layer.value.setSource(null);
    });
    provide("vectorSource", source);
    return {
      layer,
      source
    };
  },
  props: {
    attributions: {
      type: [String, Array]
    },
    features: {
      type: Array,
      default: () => []
    },
    format: {
      type: Object
    },
    loader: {
      type: Function
    },
    overlaps: {
      type: Boolean,
      default: true
    },
    projection: {
      type: String,
      default: "EPSG:3857"
    },
    strategy: {
      type: Function
    },
    url: {
      type: [String, Function]
    },
    useSpatialIndex: {
      type: Boolean,
      default: true
    },
    wrapX: {
      type: Boolean,
      default: true
    }
  }
};
function _sfc_render$L(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var SourceWebglPoints = /* @__PURE__ */ _export_sfc(_sfc_main$L, [["render", _sfc_render$L]]);
function install$6(app) {
  if (install$6.installed) {
    return;
  }
  install$6.installed = true;
  app.component(SourceXYZ.name, SourceXYZ);
  app.component(SourceOSM.name, SourceOSM);
  app.component(SourceImageStatic.name, SourceImageStatic);
  app.component(SourceWMTS.name, SourceWMTS);
  app.component(SourceVector.name, SourceVector);
  app.component(SourceCluster.name, SourceCluster);
  app.component(SourceBingMaps.name, SourceBingMaps);
  app.component(SourceTianDiTu.name, SourceTianDiTu);
  app.component(SourceImageWMS.name, SourceImageWMS);
  app.component(SourceWebglPoints.name, SourceWebglPoints);
}
var Sources = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": install$6,
  install: install$6,
  SourceXYZ,
  SourceOSM,
  SourceImageStatic,
  SourceWMTS,
  SourceVector,
  SourceCluster,
  SourceTianDiTu,
  SourceImageWMS,
  SourceWebglPoints,
  SourceBingMaps
}, Symbol.toStringTag, { value: "Module" }));
const events = [
  "fullscreenchange",
  "webkitfullscreenchange",
  "MSFullscreenChange"
];
const FullScreenEventType = {
  ENTERFULLSCREEN: "enterfullscreen",
  LEAVEFULLSCREEN: "leavefullscreen"
};
class FullScreen extends Control$1 {
  constructor(options) {
    options = options ? options : {};
    super({
      element: document.createElement("div"),
      target: options.target
    });
    this.on;
    this.once;
    this.un;
    this.keys_ = options.keys !== void 0 ? options.keys : false;
    this.source_ = options.source;
    this.isInFullscreen_ = false;
    this.boundHandleMapTargetChange_ = this.handleMapTargetChange_.bind(this);
    this.cssClassName_ = options.className !== void 0 ? options.className : "ol-full-screen";
    this.documentListeners_ = [];
    this.activeClassName_ = options.activeClassName !== void 0 ? options.activeClassName.split(" ") : [this.cssClassName_ + "-true"];
    this.inactiveClassName_ = options.inactiveClassName !== void 0 ? options.inactiveClassName.split(" ") : [this.cssClassName_ + "-false"];
    const label = options.label !== void 0 ? options.label : "\u2922";
    this.labelNode_ = typeof label === "string" ? document.createTextNode(label) : label;
    const labelActive = options.labelActive !== void 0 ? options.labelActive : "\xD7";
    this.labelActiveNode_ = typeof labelActive === "string" ? document.createTextNode(labelActive) : labelActive;
    const tipLabel = options.tipLabel ? options.tipLabel : "Toggle full-screen";
    this.button_ = document.createElement("button");
    this.button_.title = tipLabel;
    this.button_.setAttribute("type", "button");
    this.button_.appendChild(this.labelNode_);
    this.button_.addEventListener(EventType.CLICK, this.handleClick_.bind(this), false);
    this.setClassName_(this.button_, this.isInFullscreen_);
    this.element.className = `${this.cssClassName_} ${CLASS_UNSELECTABLE} ${CLASS_CONTROL}`;
    this.element.appendChild(this.button_);
  }
  handleClick_(event) {
    event.preventDefault();
    this.handleFullScreen_();
  }
  handleFullScreen_() {
    const map = this.getMap();
    if (!map) {
      return;
    }
    const doc = map.getOwnerDocument();
    if (!isFullScreenSupported(doc)) {
      return;
    }
    if (isFullScreen(doc)) {
      exitFullScreen(doc);
    } else {
      let element;
      if (this.source_) {
        element = typeof this.source_ === "string" ? doc.getElementById(this.source_) : this.source_;
      } else {
        element = map.getTargetElement();
      }
      if (this.keys_) {
        requestFullScreenWithKeys(element);
      } else {
        requestFullScreen(element);
      }
    }
  }
  handleFullScreenChange_() {
    const map = this.getMap();
    if (!map) {
      return;
    }
    const wasInFullscreen = this.isInFullscreen_;
    this.isInFullscreen_ = isFullScreen(map.getOwnerDocument());
    if (wasInFullscreen !== this.isInFullscreen_) {
      this.setClassName_(this.button_, this.isInFullscreen_);
      if (this.isInFullscreen_) {
        replaceNode(this.labelActiveNode_, this.labelNode_);
        this.dispatchEvent(FullScreenEventType.ENTERFULLSCREEN);
      } else {
        replaceNode(this.labelNode_, this.labelActiveNode_);
        this.dispatchEvent(FullScreenEventType.LEAVEFULLSCREEN);
      }
      map.updateSize();
    }
  }
  setClassName_(element, fullscreen) {
    if (fullscreen) {
      element.classList.remove(...this.inactiveClassName_);
      element.classList.add(...this.activeClassName_);
    } else {
      element.classList.remove(...this.activeClassName_);
      element.classList.add(...this.inactiveClassName_);
    }
  }
  setMap(map) {
    const oldMap = this.getMap();
    if (oldMap) {
      oldMap.removeChangeListener(MapProperty.TARGET, this.boundHandleMapTargetChange_);
    }
    super.setMap(map);
    this.handleMapTargetChange_();
    if (map) {
      map.addChangeListener(MapProperty.TARGET, this.boundHandleMapTargetChange_);
    }
  }
  handleMapTargetChange_() {
    const listeners = this.documentListeners_;
    for (let i2 = 0, ii = listeners.length; i2 < ii; ++i2) {
      unlistenByKey(listeners[i2]);
    }
    listeners.length = 0;
    const map = this.getMap();
    if (map) {
      const doc = map.getOwnerDocument();
      if (isFullScreenSupported(doc)) {
        this.element.classList.remove(CLASS_UNSUPPORTED);
      } else {
        this.element.classList.add(CLASS_UNSUPPORTED);
      }
      for (let i2 = 0, ii = events.length; i2 < ii; ++i2) {
        listeners.push(listen(doc, events[i2], this.handleFullScreenChange_, this));
      }
      this.handleFullScreenChange_();
    }
  }
}
function isFullScreenSupported(doc) {
  const body = doc.body;
  return !!(body["webkitRequestFullscreen"] || body.requestFullscreen && doc.fullscreenEnabled);
}
function isFullScreen(doc) {
  return !!(doc["webkitIsFullScreen"] || doc.fullscreenElement);
}
function requestFullScreen(element) {
  if (element.requestFullscreen) {
    element.requestFullscreen();
  } else if (element["webkitRequestFullscreen"]) {
    element["webkitRequestFullscreen"]();
  }
}
function requestFullScreenWithKeys(element) {
  if (element["webkitRequestFullscreen"]) {
    element["webkitRequestFullscreen"]();
  } else {
    requestFullScreen(element);
  }
}
function exitFullScreen(doc) {
  if (doc.exitFullscreen) {
    doc.exitFullscreen();
  } else if (doc["webkitExitFullscreen"]) {
    doc["webkitExitFullscreen"]();
  }
}
const PROJECTION = "projection";
const COORDINATE_FORMAT = "coordinateFormat";
class MousePosition extends Control$1 {
  constructor(options) {
    options = options ? options : {};
    const element = document.createElement("div");
    element.className = options.className !== void 0 ? options.className : "ol-mouse-position";
    super({
      element,
      render: options.render,
      target: options.target
    });
    this.on;
    this.once;
    this.un;
    this.addChangeListener(PROJECTION, this.handleProjectionChanged_);
    if (options.coordinateFormat) {
      this.setCoordinateFormat(options.coordinateFormat);
    }
    if (options.projection) {
      this.setProjection(options.projection);
    }
    this.renderOnMouseOut_ = options.placeholder !== void 0;
    this.placeholder_ = this.renderOnMouseOut_ ? options.placeholder : "&#160;";
    this.renderedHTML_ = element.innerHTML;
    this.mapProjection_ = null;
    this.transform_ = null;
  }
  handleProjectionChanged_() {
    this.transform_ = null;
  }
  getCoordinateFormat() {
    return this.get(COORDINATE_FORMAT);
  }
  getProjection() {
    return this.get(PROJECTION);
  }
  handleMouseMove(event) {
    const map = this.getMap();
    this.updateHTML_(map.getEventPixel(event));
  }
  handleMouseOut(event) {
    this.updateHTML_(null);
  }
  setMap(map) {
    super.setMap(map);
    if (map) {
      const viewport = map.getViewport();
      this.listenerKeys.push(listen(viewport, PointerEventType.POINTERMOVE, this.handleMouseMove, this));
      if (this.renderOnMouseOut_) {
        this.listenerKeys.push(listen(viewport, PointerEventType.POINTEROUT, this.handleMouseOut, this));
      }
      this.updateHTML_(null);
    }
  }
  setCoordinateFormat(format2) {
    this.set(COORDINATE_FORMAT, format2);
  }
  setProjection(projection) {
    this.set(PROJECTION, get$4(projection));
  }
  updateHTML_(pixel) {
    let html2 = this.placeholder_;
    if (pixel && this.mapProjection_) {
      if (!this.transform_) {
        const projection = this.getProjection();
        if (projection) {
          this.transform_ = getTransformFromProjections(this.mapProjection_, projection);
        } else {
          this.transform_ = identityTransform;
        }
      }
      const map = this.getMap();
      const coordinate = map.getCoordinateFromPixelInternal(pixel);
      if (coordinate) {
        this.transform_(coordinate, coordinate);
        const coordinateFormat = this.getCoordinateFormat();
        if (coordinateFormat) {
          html2 = coordinateFormat(coordinate);
        } else {
          html2 = coordinate.toString();
        }
      }
    }
    if (!this.renderedHTML_ || html2 !== this.renderedHTML_) {
      this.element.innerHTML = html2;
      this.renderedHTML_ = html2;
    }
  }
  render(mapEvent) {
    const frameState = mapEvent.frameState;
    if (!frameState) {
      this.mapProjection_ = null;
    } else {
      if (this.mapProjection_ != frameState.viewState.projection) {
        this.mapProjection_ = frameState.viewState.projection;
        this.transform_ = null;
      }
    }
  }
}
const MAX_RATIO = 0.75;
const MIN_RATIO = 0.1;
class OverviewMap extends Control$1 {
  constructor(options) {
    options = options ? options : {};
    super({
      element: document.createElement("div"),
      render: options.render,
      target: options.target
    });
    this.boundHandleRotationChanged_ = this.handleRotationChanged_.bind(this);
    this.collapsed_ = options.collapsed !== void 0 ? options.collapsed : true;
    this.collapsible_ = options.collapsible !== void 0 ? options.collapsible : true;
    if (!this.collapsible_) {
      this.collapsed_ = false;
    }
    this.rotateWithView_ = options.rotateWithView !== void 0 ? options.rotateWithView : false;
    this.viewExtent_ = void 0;
    const className = options.className !== void 0 ? options.className : "ol-overviewmap";
    const tipLabel = options.tipLabel !== void 0 ? options.tipLabel : "Overview map";
    const collapseLabel = options.collapseLabel !== void 0 ? options.collapseLabel : "\u2039";
    if (typeof collapseLabel === "string") {
      this.collapseLabel_ = document.createElement("span");
      this.collapseLabel_.textContent = collapseLabel;
    } else {
      this.collapseLabel_ = collapseLabel;
    }
    const label = options.label !== void 0 ? options.label : "\u203A";
    if (typeof label === "string") {
      this.label_ = document.createElement("span");
      this.label_.textContent = label;
    } else {
      this.label_ = label;
    }
    const activeLabel = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;
    const button = document.createElement("button");
    button.setAttribute("type", "button");
    button.title = tipLabel;
    button.appendChild(activeLabel);
    button.addEventListener(EventType.CLICK, this.handleClick_.bind(this), false);
    this.ovmapDiv_ = document.createElement("div");
    this.ovmapDiv_.className = "ol-overviewmap-map";
    this.view_ = options.view;
    const ovmap = new Map$3({
      view: options.view,
      controls: new Collection(),
      interactions: new Collection()
    });
    this.ovmap_ = ovmap;
    if (options.layers) {
      options.layers.forEach(function(layer) {
        ovmap.addLayer(layer);
      });
    }
    const box = document.createElement("div");
    box.className = "ol-overviewmap-box";
    box.style.boxSizing = "border-box";
    this.boxOverlay_ = new Overlay$1({
      position: [0, 0],
      positioning: "center-center",
      element: box
    });
    this.ovmap_.addOverlay(this.boxOverlay_);
    const cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL + (this.collapsed_ && this.collapsible_ ? " " + CLASS_COLLAPSED : "") + (this.collapsible_ ? "" : " ol-uncollapsible");
    const element = this.element;
    element.className = cssClasses;
    element.appendChild(this.ovmapDiv_);
    element.appendChild(button);
    const scope = this;
    const overlay = this.boxOverlay_;
    const overlayBox = this.boxOverlay_.getElement();
    const computeDesiredMousePosition = function(mousePosition) {
      return {
        clientX: mousePosition.clientX,
        clientY: mousePosition.clientY
      };
    };
    const move = function(event) {
      const position2 = computeDesiredMousePosition(event);
      const coordinates2 = ovmap.getEventCoordinateInternal(position2);
      overlay.setPosition(coordinates2);
    };
    const endMoving = function(event) {
      const coordinates2 = ovmap.getEventCoordinateInternal(event);
      scope.getMap().getView().setCenterInternal(coordinates2);
      window.removeEventListener("mousemove", move);
      window.removeEventListener("mouseup", endMoving);
    };
    overlayBox.addEventListener("mousedown", function() {
      window.addEventListener("mousemove", move);
      window.addEventListener("mouseup", endMoving);
    });
  }
  setMap(map) {
    const oldMap = this.getMap();
    if (map === oldMap) {
      return;
    }
    if (oldMap) {
      const oldView = oldMap.getView();
      if (oldView) {
        this.unbindView_(oldView);
      }
      this.ovmap_.setTarget(null);
    }
    super.setMap(map);
    if (map) {
      this.ovmap_.setTarget(this.ovmapDiv_);
      this.listenerKeys.push(listen(map, ObjectEventType.PROPERTYCHANGE, this.handleMapPropertyChange_, this));
      const view = map.getView();
      if (view) {
        this.bindView_(view);
        if (view.isDef()) {
          this.ovmap_.updateSize();
          this.resetExtent_();
        }
      }
      if (!this.ovmap_.isRendered()) {
        this.updateBoxAfterOvmapIsRendered_();
      }
    }
  }
  handleMapPropertyChange_(event) {
    if (event.key === MapProperty.VIEW) {
      const oldView = event.oldValue;
      if (oldView) {
        this.unbindView_(oldView);
      }
      const newView = this.getMap().getView();
      this.bindView_(newView);
    } else if (!this.ovmap_.isRendered() && (event.key === MapProperty.TARGET || event.key === MapProperty.SIZE)) {
      this.ovmap_.updateSize();
    }
  }
  bindView_(view) {
    if (!this.view_) {
      const newView = new View$1({
        projection: view.getProjection()
      });
      this.ovmap_.setView(newView);
    }
    view.addChangeListener(ViewProperty.ROTATION, this.boundHandleRotationChanged_);
    this.handleRotationChanged_();
  }
  unbindView_(view) {
    view.removeChangeListener(ViewProperty.ROTATION, this.boundHandleRotationChanged_);
  }
  handleRotationChanged_() {
    if (this.rotateWithView_) {
      this.ovmap_.getView().setRotation(this.getMap().getView().getRotation());
    }
  }
  validateExtent_() {
    const map = this.getMap();
    const ovmap = this.ovmap_;
    if (!map.isRendered() || !ovmap.isRendered()) {
      return;
    }
    const mapSize = map.getSize();
    const view = map.getView();
    const extent2 = view.calculateExtentInternal(mapSize);
    if (this.viewExtent_ && equals$2(extent2, this.viewExtent_)) {
      return;
    }
    this.viewExtent_ = extent2;
    const ovmapSize = ovmap.getSize();
    const ovview = ovmap.getView();
    const ovextent = ovview.calculateExtentInternal(ovmapSize);
    const topLeftPixel = ovmap.getPixelFromCoordinateInternal(getTopLeft(extent2));
    const bottomRightPixel = ovmap.getPixelFromCoordinateInternal(getBottomRight(extent2));
    const boxWidth = Math.abs(topLeftPixel[0] - bottomRightPixel[0]);
    const boxHeight = Math.abs(topLeftPixel[1] - bottomRightPixel[1]);
    const ovmapWidth = ovmapSize[0];
    const ovmapHeight = ovmapSize[1];
    if (boxWidth < ovmapWidth * MIN_RATIO || boxHeight < ovmapHeight * MIN_RATIO || boxWidth > ovmapWidth * MAX_RATIO || boxHeight > ovmapHeight * MAX_RATIO) {
      this.resetExtent_();
    } else if (!containsExtent(ovextent, extent2)) {
      this.recenter_();
    }
  }
  resetExtent_() {
    const map = this.getMap();
    const ovmap = this.ovmap_;
    const mapSize = map.getSize();
    const view = map.getView();
    const extent2 = view.calculateExtentInternal(mapSize);
    const ovview = ovmap.getView();
    const steps = Math.log(MAX_RATIO / MIN_RATIO) / Math.LN2;
    const ratio = 1 / (Math.pow(2, steps / 2) * MIN_RATIO);
    scaleFromCenter(extent2, ratio);
    ovview.fitInternal(fromExtent(extent2));
  }
  recenter_() {
    const map = this.getMap();
    const ovmap = this.ovmap_;
    const view = map.getView();
    const ovview = ovmap.getView();
    ovview.setCenterInternal(view.getCenterInternal());
  }
  updateBox_() {
    const map = this.getMap();
    const ovmap = this.ovmap_;
    if (!map.isRendered() || !ovmap.isRendered()) {
      return;
    }
    const mapSize = map.getSize();
    const view = map.getView();
    const ovview = ovmap.getView();
    const rotation = this.rotateWithView_ ? 0 : -view.getRotation();
    const overlay = this.boxOverlay_;
    const box = this.boxOverlay_.getElement();
    const center = view.getCenterInternal();
    const resolution = view.getResolution();
    const ovresolution = ovview.getResolution();
    const width = mapSize[0] * resolution / ovresolution;
    const height = mapSize[1] * resolution / ovresolution;
    overlay.setPosition(center);
    if (box) {
      box.style.width = width + "px";
      box.style.height = height + "px";
      const transform2 = "rotate(" + rotation + "rad)";
      box.style.transform = transform2;
    }
  }
  updateBoxAfterOvmapIsRendered_() {
    if (this.ovmapPostrenderKey_) {
      return;
    }
    this.ovmapPostrenderKey_ = listenOnce(this.ovmap_, MapEventType.POSTRENDER, function(event) {
      delete this.ovmapPostrenderKey_;
      this.updateBox_();
    }, this);
  }
  handleClick_(event) {
    event.preventDefault();
    this.handleToggle_();
  }
  handleToggle_() {
    this.element.classList.toggle(CLASS_COLLAPSED);
    if (this.collapsed_) {
      replaceNode(this.collapseLabel_, this.label_);
    } else {
      replaceNode(this.label_, this.collapseLabel_);
    }
    this.collapsed_ = !this.collapsed_;
    const ovmap = this.ovmap_;
    if (!this.collapsed_) {
      if (ovmap.isRendered()) {
        this.viewExtent_ = void 0;
        ovmap.render();
        return;
      }
      ovmap.updateSize();
      this.resetExtent_();
      this.updateBoxAfterOvmapIsRendered_();
    }
  }
  getCollapsible() {
    return this.collapsible_;
  }
  setCollapsible(collapsible) {
    if (this.collapsible_ === collapsible) {
      return;
    }
    this.collapsible_ = collapsible;
    this.element.classList.toggle("ol-uncollapsible");
    if (!collapsible && this.collapsed_) {
      this.handleToggle_();
    }
  }
  setCollapsed(collapsed) {
    if (!this.collapsible_ || this.collapsed_ === collapsed) {
      return;
    }
    this.handleToggle_();
  }
  getCollapsed() {
    return this.collapsed_;
  }
  getRotateWithView() {
    return this.rotateWithView_;
  }
  setRotateWithView(rotateWithView) {
    if (this.rotateWithView_ === rotateWithView) {
      return;
    }
    this.rotateWithView_ = rotateWithView;
    if (this.getMap().getView().getRotation() !== 0) {
      if (this.rotateWithView_) {
        this.handleRotationChanged_();
      } else {
        this.ovmap_.getView().setRotation(0);
      }
      this.viewExtent_ = void 0;
      this.validateExtent_();
      this.updateBox_();
    }
  }
  getOverviewMap() {
    return this.ovmap_;
  }
  render(mapEvent) {
    this.validateExtent_();
    this.updateBox_();
  }
}
const UNITS_PROP = "units";
const LEADING_DIGITS = [1, 2, 5];
const DEFAULT_DPI = 25.4 / 0.28;
class ScaleLine extends Control$1 {
  constructor(options) {
    options = options ? options : {};
    const element = document.createElement("div");
    element.style.pointerEvents = "none";
    super({
      element,
      render: options.render,
      target: options.target
    });
    this.on;
    this.once;
    this.un;
    const className = options.className !== void 0 ? options.className : options.bar ? "ol-scale-bar" : "ol-scale-line";
    this.innerElement_ = document.createElement("div");
    this.innerElement_.className = className + "-inner";
    this.element.className = className + " " + CLASS_UNSELECTABLE;
    this.element.appendChild(this.innerElement_);
    this.viewState_ = null;
    this.minWidth_ = options.minWidth !== void 0 ? options.minWidth : 64;
    this.maxWidth_ = options.maxWidth;
    this.renderedVisible_ = false;
    this.renderedWidth_ = void 0;
    this.renderedHTML_ = "";
    this.addChangeListener(UNITS_PROP, this.handleUnitsChanged_);
    this.setUnits(options.units || "metric");
    this.scaleBar_ = options.bar || false;
    this.scaleBarSteps_ = options.steps || 4;
    this.scaleBarText_ = options.text || false;
    this.dpi_ = options.dpi || void 0;
  }
  getUnits() {
    return this.get(UNITS_PROP);
  }
  handleUnitsChanged_() {
    this.updateElement_();
  }
  setUnits(units2) {
    this.set(UNITS_PROP, units2);
  }
  setDpi(dpi) {
    this.dpi_ = dpi;
  }
  updateElement_() {
    const viewState = this.viewState_;
    if (!viewState) {
      if (this.renderedVisible_) {
        this.element.style.display = "none";
        this.renderedVisible_ = false;
      }
      return;
    }
    const center = viewState.center;
    const projection = viewState.projection;
    const units2 = this.getUnits();
    const pointResolutionUnits = units2 == "degrees" ? "degrees" : "m";
    let pointResolution = getPointResolution(projection, viewState.resolution, center, pointResolutionUnits);
    const minWidth = this.minWidth_ * (this.dpi_ || DEFAULT_DPI) / DEFAULT_DPI;
    const maxWidth = this.maxWidth_ !== void 0 ? this.maxWidth_ * (this.dpi_ || DEFAULT_DPI) / DEFAULT_DPI : void 0;
    let nominalCount = minWidth * pointResolution;
    let suffix2 = "";
    if (units2 == "degrees") {
      const metersPerDegree = METERS_PER_UNIT$1.degrees;
      nominalCount *= metersPerDegree;
      if (nominalCount < metersPerDegree / 60) {
        suffix2 = "\u2033";
        pointResolution *= 3600;
      } else if (nominalCount < metersPerDegree) {
        suffix2 = "\u2032";
        pointResolution *= 60;
      } else {
        suffix2 = "\xB0";
      }
    } else if (units2 == "imperial") {
      if (nominalCount < 0.9144) {
        suffix2 = "in";
        pointResolution /= 0.0254;
      } else if (nominalCount < 1609.344) {
        suffix2 = "ft";
        pointResolution /= 0.3048;
      } else {
        suffix2 = "mi";
        pointResolution /= 1609.344;
      }
    } else if (units2 == "nautical") {
      pointResolution /= 1852;
      suffix2 = "NM";
    } else if (units2 == "metric") {
      if (nominalCount < 1e-3) {
        suffix2 = "\u03BCm";
        pointResolution *= 1e6;
      } else if (nominalCount < 1) {
        suffix2 = "mm";
        pointResolution *= 1e3;
      } else if (nominalCount < 1e3) {
        suffix2 = "m";
      } else {
        suffix2 = "km";
        pointResolution /= 1e3;
      }
    } else if (units2 == "us") {
      if (nominalCount < 0.9144) {
        suffix2 = "in";
        pointResolution *= 39.37;
      } else if (nominalCount < 1609.344) {
        suffix2 = "ft";
        pointResolution /= 0.30480061;
      } else {
        suffix2 = "mi";
        pointResolution /= 1609.3472;
      }
    } else {
      assert(false, 33);
    }
    let i2 = 3 * Math.floor(Math.log(minWidth * pointResolution) / Math.log(10));
    let count, width, decimalCount;
    let previousCount, previousWidth, previousDecimalCount;
    while (true) {
      decimalCount = Math.floor(i2 / 3);
      const decimal = Math.pow(10, decimalCount);
      count = LEADING_DIGITS[(i2 % 3 + 3) % 3] * decimal;
      width = Math.round(count / pointResolution);
      if (isNaN(width)) {
        this.element.style.display = "none";
        this.renderedVisible_ = false;
        return;
      }
      if (maxWidth !== void 0 && width >= maxWidth) {
        count = previousCount;
        width = previousWidth;
        decimalCount = previousDecimalCount;
        break;
      } else if (width >= minWidth) {
        break;
      }
      previousCount = count;
      previousWidth = width;
      previousDecimalCount = decimalCount;
      ++i2;
    }
    const html2 = this.scaleBar_ ? this.createScaleBar(width, count, suffix2) : count.toFixed(decimalCount < 0 ? -decimalCount : 0) + " " + suffix2;
    if (this.renderedHTML_ != html2) {
      this.innerElement_.innerHTML = html2;
      this.renderedHTML_ = html2;
    }
    if (this.renderedWidth_ != width) {
      this.innerElement_.style.width = width + "px";
      this.renderedWidth_ = width;
    }
    if (!this.renderedVisible_) {
      this.element.style.display = "";
      this.renderedVisible_ = true;
    }
  }
  createScaleBar(width, scale2, suffix2) {
    const resolutionScale = this.getScaleForResolution();
    const mapScale = resolutionScale < 1 ? Math.round(1 / resolutionScale).toLocaleString() + " : 1" : "1 : " + Math.round(resolutionScale).toLocaleString();
    const steps = this.scaleBarSteps_;
    const stepWidth = width / steps;
    const scaleSteps = [this.createMarker("absolute")];
    for (let i2 = 0; i2 < steps; ++i2) {
      const cls = i2 % 2 === 0 ? "ol-scale-singlebar-odd" : "ol-scale-singlebar-even";
      scaleSteps.push(`<div><div class="ol-scale-singlebar ${cls}" style="width: ${stepWidth}px;"></div>` + this.createMarker("relative") + (i2 % 2 === 0 || steps === 2 ? this.createStepText(i2, width, false, scale2, suffix2) : "") + "</div>");
    }
    scaleSteps.push(this.createStepText(steps, width, true, scale2, suffix2));
    const scaleBarText = this.scaleBarText_ ? `<div class="ol-scale-text" style="width: ${width}px;">` + mapScale + "</div>" : "";
    return scaleBarText + scaleSteps.join("");
  }
  createMarker(position2) {
    const top = position2 === "absolute" ? 3 : -10;
    return `<div class="ol-scale-step-marker" style="position: ${position2}; top: ${top}px;"></div>`;
  }
  createStepText(i2, width, isLast, scale2, suffix2) {
    const length = i2 === 0 ? 0 : Math.round(scale2 / this.scaleBarSteps_ * i2 * 100) / 100;
    const lengthString = length + (i2 === 0 ? "" : " " + suffix2);
    const margin = i2 === 0 ? -3 : width / this.scaleBarSteps_ * -1;
    const minWidth = i2 === 0 ? 0 : width / this.scaleBarSteps_ * 2;
    return `<div class="ol-scale-step-text" style="margin-left: ${margin}px;text-align: ${i2 === 0 ? "left" : "center"};min-width: ${minWidth}px;left: ${isLast ? width + "px" : "unset"};">` + lengthString + "</div>";
  }
  getScaleForResolution() {
    const resolution = getPointResolution(this.viewState_.projection, this.viewState_.resolution, this.viewState_.center, "m");
    const dpi = this.dpi_ || DEFAULT_DPI;
    const inchesPerMeter = 1e3 / 25.4;
    return resolution * inchesPerMeter * dpi;
  }
  render(mapEvent) {
    const frameState = mapEvent.frameState;
    if (!frameState) {
      this.viewState_ = null;
    } else {
      this.viewState_ = frameState.viewState;
    }
    this.updateElement_();
  }
}
const Direction = {
  VERTICAL: 0,
  HORIZONTAL: 1
};
class ZoomSlider extends Control$1 {
  constructor(options) {
    options = options ? options : {};
    super({
      element: document.createElement("div"),
      render: options.render
    });
    this.dragListenerKeys_ = [];
    this.currentResolution_ = void 0;
    this.direction_ = Direction.VERTICAL;
    this.dragging_;
    this.heightLimit_ = 0;
    this.widthLimit_ = 0;
    this.startX_;
    this.startY_;
    this.thumbSize_ = null;
    this.sliderInitialized_ = false;
    this.duration_ = options.duration !== void 0 ? options.duration : 200;
    const className = options.className !== void 0 ? options.className : "ol-zoomslider";
    const thumbElement = document.createElement("button");
    thumbElement.setAttribute("type", "button");
    thumbElement.className = className + "-thumb " + CLASS_UNSELECTABLE;
    const containerElement = this.element;
    containerElement.className = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL;
    containerElement.appendChild(thumbElement);
    containerElement.addEventListener(PointerEventType.POINTERDOWN, this.handleDraggerStart_.bind(this), false);
    containerElement.addEventListener(PointerEventType.POINTERMOVE, this.handleDraggerDrag_.bind(this), false);
    containerElement.addEventListener(PointerEventType.POINTERUP, this.handleDraggerEnd_.bind(this), false);
    containerElement.addEventListener(EventType.CLICK, this.handleContainerClick_.bind(this), false);
    thumbElement.addEventListener(EventType.CLICK, stopPropagation, false);
  }
  setMap(map) {
    super.setMap(map);
    if (map) {
      map.render();
    }
  }
  initSlider_() {
    const container = this.element;
    let containerWidth = container.offsetWidth;
    let containerHeight = container.offsetHeight;
    if (containerWidth === 0 && containerHeight === 0) {
      return this.sliderInitialized_ = false;
    }
    const containerStyle = getComputedStyle(container);
    containerWidth -= parseFloat(containerStyle["paddingRight"]) + parseFloat(containerStyle["paddingLeft"]);
    containerHeight -= parseFloat(containerStyle["paddingTop"]) + parseFloat(containerStyle["paddingBottom"]);
    const thumb = container.firstElementChild;
    const thumbStyle = getComputedStyle(thumb);
    const thumbWidth = thumb.offsetWidth + parseFloat(thumbStyle["marginRight"]) + parseFloat(thumbStyle["marginLeft"]);
    const thumbHeight = thumb.offsetHeight + parseFloat(thumbStyle["marginTop"]) + parseFloat(thumbStyle["marginBottom"]);
    this.thumbSize_ = [thumbWidth, thumbHeight];
    if (containerWidth > containerHeight) {
      this.direction_ = Direction.HORIZONTAL;
      this.widthLimit_ = containerWidth - thumbWidth;
    } else {
      this.direction_ = Direction.VERTICAL;
      this.heightLimit_ = containerHeight - thumbHeight;
    }
    return this.sliderInitialized_ = true;
  }
  handleContainerClick_(event) {
    const view = this.getMap().getView();
    const relativePosition = this.getRelativePosition_(event.offsetX - this.thumbSize_[0] / 2, event.offsetY - this.thumbSize_[1] / 2);
    const resolution = this.getResolutionForPosition_(relativePosition);
    const zoom = view.getConstrainedZoom(view.getZoomForResolution(resolution));
    view.animateInternal({
      zoom,
      duration: this.duration_,
      easing: easeOut
    });
  }
  handleDraggerStart_(event) {
    if (!this.dragging_ && event.target === this.element.firstElementChild) {
      const element = this.element.firstElementChild;
      this.getMap().getView().beginInteraction();
      this.startX_ = event.clientX - parseFloat(element.style.left);
      this.startY_ = event.clientY - parseFloat(element.style.top);
      this.dragging_ = true;
      if (this.dragListenerKeys_.length === 0) {
        const drag = this.handleDraggerDrag_;
        const end = this.handleDraggerEnd_;
        const doc = this.getMap().getOwnerDocument();
        this.dragListenerKeys_.push(listen(doc, PointerEventType.POINTERMOVE, drag, this), listen(doc, PointerEventType.POINTERUP, end, this));
      }
    }
  }
  handleDraggerDrag_(event) {
    if (this.dragging_) {
      const deltaX = event.clientX - this.startX_;
      const deltaY = event.clientY - this.startY_;
      const relativePosition = this.getRelativePosition_(deltaX, deltaY);
      this.currentResolution_ = this.getResolutionForPosition_(relativePosition);
      this.getMap().getView().setResolution(this.currentResolution_);
    }
  }
  handleDraggerEnd_(event) {
    if (this.dragging_) {
      const view = this.getMap().getView();
      view.endInteraction();
      this.dragging_ = false;
      this.startX_ = void 0;
      this.startY_ = void 0;
      this.dragListenerKeys_.forEach(unlistenByKey);
      this.dragListenerKeys_.length = 0;
    }
  }
  setThumbPosition_(res) {
    const position2 = this.getPositionForResolution_(res);
    const thumb = this.element.firstElementChild;
    if (this.direction_ == Direction.HORIZONTAL) {
      thumb.style.left = this.widthLimit_ * position2 + "px";
    } else {
      thumb.style.top = this.heightLimit_ * position2 + "px";
    }
  }
  getRelativePosition_(x2, y2) {
    let amount;
    if (this.direction_ === Direction.HORIZONTAL) {
      amount = x2 / this.widthLimit_;
    } else {
      amount = y2 / this.heightLimit_;
    }
    return clamp(amount, 0, 1);
  }
  getResolutionForPosition_(position2) {
    const fn = this.getMap().getView().getResolutionForValueFunction();
    return fn(1 - position2);
  }
  getPositionForResolution_(res) {
    const fn = this.getMap().getView().getValueForResolutionFunction();
    return clamp(1 - fn(res), 0, 1);
  }
  render(mapEvent) {
    if (!mapEvent.frameState) {
      return;
    }
    if (!this.sliderInitialized_ && !this.initSlider_()) {
      return;
    }
    const res = mapEvent.frameState.viewState.resolution;
    this.currentResolution_ = res;
    this.setThumbPosition_(res);
  }
}
class ZoomToExtent extends Control$1 {
  constructor(options) {
    options = options ? options : {};
    super({
      element: document.createElement("div"),
      target: options.target
    });
    this.extent = options.extent ? options.extent : null;
    const className = options.className !== void 0 ? options.className : "ol-zoom-extent";
    const label = options.label !== void 0 ? options.label : "E";
    const tipLabel = options.tipLabel !== void 0 ? options.tipLabel : "Fit to extent";
    const button = document.createElement("button");
    button.setAttribute("type", "button");
    button.title = tipLabel;
    button.appendChild(typeof label === "string" ? document.createTextNode(label) : label);
    button.addEventListener(EventType.CLICK, this.handleClick_.bind(this), false);
    const cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL;
    const element = this.element;
    element.className = cssClasses;
    element.appendChild(button);
  }
  handleClick_(event) {
    event.preventDefault();
    this.handleZoomToExtent();
  }
  handleZoomToExtent() {
    const map = this.getMap();
    const view = map.getView();
    const extent2 = !this.extent ? view.getProjection().getExtent() : this.extent;
    view.fitInternal(fromExtent(extent2));
  }
}
function useControl(ControlType, props, context2) {
  const map = inject("map");
  const controlBar = inject("controlBar", null);
  const parent = controlBar != null ? controlBar.value : map;
  const {
    properties
  } = usePropsAsObjectProperties(props);
  let control = computed(() => new ControlType(__spreadValues({}, properties)));
  control.value.set("order", context2.attrs.order == void 0 ? 0 : context2.attrs.order);
  watch(control, (newVal, oldVal) => {
    if (parent.removeControl) {
      parent.removeControl(oldVal);
      parent.addControl(newVal);
      map.changed();
    }
  });
  onMounted(() => {
    parent.addControl(control.value);
    if (parent.controls_ != void 0) {
      let sortedControls = [...parent.controls_];
      sortedControls.sort((a2, b2) => a2.get("order") - b2.get("order"));
      parent.controls_ = [];
      sortedControls.forEach((c2) => {
        parent.addControl(c2);
      });
      parent.changed();
    }
    map.changed();
  });
  onUnmounted(() => {
    if (parent.removeControl) {
      parent.removeControl(control.value);
    } else {
      let index2 = parent.controls_.findIndex((a2) => a2 == control.value);
      parent.controls_.splice(index2, 1);
      control.value.dispose();
    }
    map.changed();
  });
  return {
    map,
    control
  };
}
const _sfc_main$K = {
  name: "ol-fullscreen-control",
  setup(props, context2) {
    const {
      control
    } = useControl(FullScreen, props, context2);
    return {
      control
    };
  },
  props: {
    className: {
      type: String,
      default: "ol-full-screen"
    },
    label: {
      type: String,
      default: "\u2922"
    },
    labelActive: {
      type: String,
      default: "\xD7"
    },
    activeClassName: {
      type: String,
      default: "ol-full-screen-true"
    },
    inactiveClassName: {
      type: String,
      default: "ol-full-screen-false"
    },
    tipLabel: {
      type: String,
      default: "Toggle full-screen"
    },
    keys: {
      type: Boolean,
      default: false
    },
    target: {
      type: Object,
      default: void 0
    },
    source: {
      type: Object,
      default: void 0
    }
  }
};
function _sfc_render$K(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var FullScreenControl = /* @__PURE__ */ _export_sfc(_sfc_main$K, [["render", _sfc_render$K]]);
const _sfc_main$J = {
  name: "ol-mouseposition-control",
  setup(props, context2) {
    const {
      control
    } = useControl(MousePosition, props, context2);
    return {
      control
    };
  },
  props: {
    className: {
      type: String,
      default: "ol-mouse-position"
    },
    coordinateFormat: {
      type: [String, Function]
    },
    projection: {
      type: String
    },
    render: {
      type: Function
    },
    target: {
      type: HTMLElement
    },
    undefinedHTML: {
      type: String,
      default: "&#160;"
    }
  }
};
function _sfc_render$J(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var MousePositionControl = /* @__PURE__ */ _export_sfc(_sfc_main$J, [["render", _sfc_render$J]]);
const _sfc_main$I = {
  name: "ol-attribution-control",
  setup(props, context2) {
    const {
      control
    } = useControl(Attribution, props, context2);
    return {
      control
    };
  },
  props: {
    className: {
      type: String,
      default: "ol-attribution"
    },
    target: {
      type: HTMLElement
    },
    collapsible: {
      type: Boolean
    },
    collapsed: {
      type: Boolean,
      default: true
    },
    tipLabel: {
      type: String,
      default: "Attributions"
    },
    label: {
      type: String,
      default: "i"
    },
    expandClassName: {
      type: String,
      default: "ol-attribution-expand"
    },
    collapseLabel: {
      type: String,
      default: "\xBB"
    },
    collapseClassName: {
      type: String,
      default: "ol-attribution-collapse"
    },
    render: {
      type: Function
    }
  }
};
function _sfc_render$I(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var AttributionControl = /* @__PURE__ */ _export_sfc(_sfc_main$I, [["render", _sfc_render$I]]);
const _sfc_main$H = {
  name: "ol-overviewmap-control",
  setup(props, context2) {
    const map = inject("map");
    const {
      control
    } = useControl(OverviewMap, props, context2);
    onMounted(() => {
      control.value.setMap(map);
    });
    onUnmounted(() => {
      control.value.setMap(null);
    });
    provide("overviewMap", control);
    return {
      control
    };
  },
  props: {
    className: {
      type: String,
      default: "ol-overviewmap"
    },
    collapsed: {
      type: Boolean,
      default: true
    },
    collapseLabel: {
      type: String,
      default: "\xAB"
    },
    collapsible: {
      type: Boolean,
      default: true
    },
    label: {
      type: String,
      default: "\xBB"
    },
    render: {
      type: Function
    },
    rotateWithView: {
      type: Boolean,
      default: false
    },
    target: {
      type: HTMLElement
    },
    tipLabel: {
      type: String,
      default: "Overview map"
    }
  }
};
function _sfc_render$H(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var OverviewMapControl = /* @__PURE__ */ _export_sfc(_sfc_main$H, [["render", _sfc_render$H]]);
const _sfc_main$G = {
  name: "ol-scaleline-control",
  setup(props, context2) {
    const {
      control
    } = useControl(ScaleLine, props, context2);
    return {
      control
    };
  },
  props: {
    className: {
      type: String,
      default: "ol-scale-line"
    },
    minWidth: {
      type: Number,
      default: 64
    },
    render: {
      type: Function
    },
    target: {
      type: HTMLElement
    },
    units: {
      type: String,
      default: "metric"
    },
    bar: {
      type: Boolean,
      default: false
    },
    steps: {
      type: Number,
      default: 4
    },
    text: {
      type: Boolean,
      default: false
    },
    dpi: {
      type: Number,
      default: void 0
    }
  }
};
function _sfc_render$G(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var ScaleLineControl = /* @__PURE__ */ _export_sfc(_sfc_main$G, [["render", _sfc_render$G]]);
const _sfc_main$F = {
  name: "ol-zoom-control",
  setup(props, context2) {
    const {
      control
    } = useControl(Zoom, props, context2);
    return {
      control
    };
  },
  props: {
    duration: {
      type: Number,
      default: 250
    },
    className: {
      type: String,
      default: "ol-zoom"
    },
    zoomInClassName: {
      type: String,
      default: "ol-zoom-in"
    },
    zoomOutClassName: {
      type: String,
      default: "ol-zoom-out"
    },
    zoomInLabel: {
      type: String,
      default: "+"
    },
    zoomOutLabel: {
      type: String,
      default: "-"
    },
    zoomInTipLabel: {
      type: String,
      default: "Zoom in"
    },
    zoomOutTipLabel: {
      type: String,
      default: "Zoom Out"
    },
    delta: {
      type: Number,
      default: 1
    },
    target: {
      type: HTMLElement
    }
  }
};
function _sfc_render$F(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var ZoomControl = /* @__PURE__ */ _export_sfc(_sfc_main$F, [["render", _sfc_render$F]]);
const _sfc_main$E = {
  name: "ol-zoomslider-control",
  setup(props, context2) {
    const {
      control
    } = useControl(ZoomSlider, props, context2);
    return {
      control
    };
  },
  props: {
    duration: {
      type: Number,
      default: 200
    },
    className: {
      type: String,
      default: "ol-zoomslider"
    },
    render: {
      type: Function
    }
  }
};
function _sfc_render$E(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var ZoomSliderControl = /* @__PURE__ */ _export_sfc(_sfc_main$E, [["render", _sfc_render$E]]);
const _sfc_main$D = {
  name: "ol-zoomtoextent-control",
  setup(props, context2) {
    const {
      control
    } = useControl(ZoomToExtent, props, context2);
    return {
      control
    };
  },
  props: {
    className: {
      type: String,
      default: "ol-zoom-extent"
    },
    target: {
      type: HTMLElement
    },
    label: {
      type: String,
      default: "E"
    },
    tipLabel: {
      type: String,
      default: "Fit to extent"
    },
    extent: {
      type: Array
    }
  }
};
function _sfc_render$D(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var ZoomToExtentControl = /* @__PURE__ */ _export_sfc(_sfc_main$D, [["render", _sfc_render$D]]);
const _sfc_main$C = {
  name: "ol-rotate-control",
  setup(props, context2) {
    const {
      control
    } = useControl(Rotate$1, props, context2);
    return {
      control
    };
  },
  props: {
    className: {
      type: String,
      default: "ol-rotate"
    },
    label: {
      type: String,
      default: "\u21E7"
    },
    tipLabel: {
      type: String,
      default: "Reset rotation"
    },
    compassClassName: {
      type: String,
      default: "ol-compass"
    },
    duration: {
      type: Number,
      default: 250
    },
    autoHide: {
      type: Boolean,
      default: false
    },
    render: {
      type: Function
    },
    resetNorth: {
      type: Function
    },
    target: {
      type: HTMLElement
    }
  }
};
function _sfc_render$C(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var RotateControl = /* @__PURE__ */ _export_sfc(_sfc_main$C, [["render", _sfc_render$C]]);
var olContextmenu$1 = { exports: {} };
var require$$0 = /* @__PURE__ */ getAugmentedNamespace(Control$2);
/*!
  * ol-contextmenu - v4.1.0
  * https://github.com/jonataswalker/ol-contextmenu
  * Built: Sat Aug 15 2020 10:43:26 GMT-0300 (Brasilia Standard Time)
  */
(function(module, exports2) {
  !function(t3, e2) {
    module.exports = e2(require$$0);
  }(commonjsGlobal, function(t3) {
    function e2(t4) {
      return t4 && typeof t4 == "object" && "default" in t4 ? t4 : { default: t4 };
    }
    var n2 = e2(t3), i2 = "ol-ctx-menu", o2 = { namespace: i2, container: i2 + "-container", separator: i2 + "-separator", submenu: i2 + "-submenu", hidden: i2 + "-hidden", icon: i2 + "-icon", zoomIn: i2 + "-zoom-in", zoomOut: i2 + "-zoom-out", unselectable: "ol-unselectable" }, s2 = o2, a2 = "beforeopen", r2 = "open", l2 = "close", c2 = "contextmenu", h2 = { width: 150, scrollAt: 4, eventType: c2, defaultItems: true }, p5 = [{ text: "Zoom In", classname: o2.zoomIn + " " + o2.icon, callback: function(t4, e3) {
      var n3 = e3.getView();
      n3.animate({ zoom: +n3.getZoom() + 1, duration: 700, center: t4.coordinate });
    } }, { text: "Zoom Out", classname: o2.zoomOut + " " + o2.icon, callback: function(t4, e3) {
      var n3 = e3.getView();
      n3.animate({ zoom: +n3.getZoom() - 1, duration: 700, center: t4.coordinate });
    } }];
    function u2(t4, e3) {
      if (e3 === void 0 && (e3 = "Assertion failed"), !t4) {
        if (typeof Error != "undefined")
          throw new Error(e3);
        throw e3;
      }
    }
    function d2(t4) {
      return /^\d+$/.test(t4);
    }
    function m2(t4, e3) {
      return t4.classList ? t4.classList.contains(e3) : g2(e3).test(t4.className);
    }
    function f2(t4, e3, n3) {
      e3 === void 0 && (e3 = window.document);
      var i3 = Array.prototype.slice, o3 = [];
      if (/^(#?[\w-]+|\.[\w-.]+)$/.test(t4))
        switch (t4[0]) {
          case "#":
            o3 = [y2(t4.substr(1))];
            break;
          case ".":
            o3 = i3.call(e3.getElementsByClassName(t4.substr(1).replace(/\./g, " ")));
            break;
          default:
            o3 = i3.call(e3.getElementsByTagName(t4));
        }
      else
        o3 = i3.call(e3.querySelectorAll(t4));
      return n3 ? o3 : o3[0];
    }
    function y2(t4) {
      return t4 = t4[0] === "#" ? t4.substr(1, t4.length) : t4, document.getElementById(t4);
    }
    function v2(t4) {
      var e3 = document.createDocumentFragment(), n3 = document.createElement("div");
      for (n3.innerHTML = t4; n3.firstChild; )
        e3.appendChild(n3.firstChild);
      return e3;
    }
    function g2(t4) {
      return new RegExp("(^|\\s+) " + t4 + " (\\s+|$)");
    }
    function b2(t4, e3, n3) {
      t4.classList ? t4.classList.add(e3) : t4.className = (t4.className + " " + e3).trim(), n3 && d2(n3) && window.setTimeout(function() {
        return C2(t4, e3);
      }, n3);
    }
    function C2(t4, e3, n3) {
      t4.classList ? t4.classList.remove(e3) : t4.className = t4.className.replace(g2(e3), " ").trim(), n3 && d2(n3) && window.setTimeout(function() {
        return b2(t4, e3);
      }, n3);
    }
    var E2 = function(t4) {
      return this.Base = t4, this.map = void 0, this.viewport = void 0, this.coordinateClicked = void 0, this.pixelClicked = void 0, this.lineHeight = 0, this.items = {}, this.opened = false, this.submenu = { left: t4.options.width - 15 + "px", lastLeft: "" }, this.eventHandler = this.handleEvent.bind(this), this.eventMapMoveHandler = this.handleMapMoveEvent.bind(this), this;
    };
    E2.prototype.init = function(t4) {
      this.map = t4, this.viewport = t4.getViewport(), this.setListeners(), this.Base.Html.createMenu(), this.lineHeight = this.getItemsLength() > 0 ? this.Base.container.offsetHeight / this.getItemsLength() : this.Base.Html.cloneAndGetLineHeight();
    }, E2.prototype.getItemsLength = function() {
      var t4 = this, e3 = 0;
      return Object.keys(this.items).forEach(function(n3) {
        t4.items[n3].submenu || t4.items[n3].separator || e3++;
      }), e3;
    }, E2.prototype.getPixelClicked = function() {
      return this.pixelClicked;
    }, E2.prototype.getCoordinateClicked = function() {
      return this.coordinateClicked;
    }, E2.prototype.positionContainer = function(t4) {
      var e3 = this, n3 = this.Base.container, i3 = this.map.getSize(), o3 = i3[1] - t4[1], a3 = i3[0] - t4[0], r3 = n3.offsetWidth, l3 = Math.round(this.lineHeight * this.getItemsLength()), c3 = f2("li." + s2.submenu + ">div", n3, true);
      a3 >= r3 ? (n3.style.right = "auto", n3.style.left = t4[0] + 5 + "px") : (n3.style.left = "auto", n3.style.right = "15px"), o3 >= l3 ? (n3.style.bottom = "auto", n3.style.top = t4[1] - 10 + "px") : (n3.style.top = "auto", n3.style.bottom = 0), function t5(e4, n4, i4) {
        if (Array.isArray(e4))
          e4.forEach(function(e5) {
            return t5(e5, n4, i4);
          });
        else
          for (var o4 = Array.isArray(n4) ? n4 : n4.split(/\s+/), s3 = o4.length; s3--; )
            m2(e4, o4[s3]) && C2(e4, o4[s3], i4);
      }(n3, s2.hidden), c3.length && (this.submenu.lastLeft = a3 < 2 * r3 ? "-" + r3 + "px" : this.submenu.left, c3.forEach(function(t5) {
        var n4, i4, s3, a4 = { w: window.innerWidth || document.documentElement.clientWidth, h: window.innerHeight || document.documentElement.clientHeight }, r4 = (i4 = (n4 = t5).getBoundingClientRect(), s3 = document.documentElement, { left: i4.left + window.pageXOffset - s3.clientLeft, top: i4.top + window.pageYOffset - s3.clientTop, width: n4.offsetWidth, height: n4.offsetHeight }), l4 = r4.height, c4 = o3 - l4;
        c4 < 0 && (c4 = l4 - (a4.h - r4.top), t5.style.top = "-" + c4 + "px"), t5.style.left = e3.submenu.lastLeft;
      }));
    }, E2.prototype.openMenu = function(t4, e3) {
      this.Base.dispatchEvent({ type: r2, pixel: t4, coordinate: e3 }), this.opened = true, this.positionContainer(t4);
    }, E2.prototype.closeMenu = function() {
      this.opened = false, function t4(e3, n3, i3) {
        if (Array.isArray(e3))
          e3.forEach(function(e4) {
            return t4(e4, n3);
          });
        else
          for (var o3 = Array.isArray(n3) ? n3 : n3.split(/\s+/), s3 = o3.length; s3--; )
            m2(e3, o3[s3]) || b2(e3, o3[s3], i3);
      }(this.Base.container, s2.hidden), this.Base.dispatchEvent({ type: l2 });
    }, E2.prototype.setListeners = function() {
      this.viewport.addEventListener(this.Base.options.eventType, this.eventHandler, false), this.map.on("movestart", this.eventMapMoveHandler);
    }, E2.prototype.removeListeners = function() {
      this.viewport.removeEventListener(this.Base.options.eventType, this.eventHandler, false), this.map.un("movestart", this.eventMapMoveHandler);
    }, E2.prototype.handleEvent = function(t4) {
      var e3 = this;
      this.coordinateClicked = this.map.getEventCoordinate(t4), this.pixelClicked = this.map.getEventPixel(t4), this.Base.dispatchEvent({ type: a2, pixel: this.pixelClicked, coordinate: this.coordinateClicked }), this.Base.disabled || (this.Base.options.eventType === c2 && (t4.stopPropagation(), t4.preventDefault()), this.openMenu(this.pixelClicked, this.coordinateClicked), t4.target.addEventListener("pointerdown", { handleEvent: function(n3) {
        e3.opened && (e3.closeMenu(), n3.stopPropagation(), t4.target.removeEventListener(n3.type, this, false));
      } }, false));
    }, E2.prototype.handleMapMoveEvent = function(t4) {
      this.closeMenu();
    }, E2.prototype.setItemListener = function(t4, e3) {
      var n3, i3 = this;
      t4 && typeof this.items[e3].callback == "function" && (n3 = this.items[e3].callback, t4.addEventListener("click", function(t5) {
        t5.preventDefault();
        var o3 = { coordinate: i3.getCoordinateClicked(), data: i3.items[e3].data || null };
        i3.closeMenu(), n3(o3, i3.map);
      }, false));
    };
    var w2 = function(t4) {
      return this.Base = t4, this.Base.container = this.container = this.createContainer(true), this;
    };
    return w2.prototype.createContainer = function(t4) {
      var e3 = document.createElement("div"), n3 = document.createElement("ul"), i3 = [s2.container, s2.unselectable];
      return t4 && i3.push(s2.hidden), e3.className = i3.join(" "), e3.style.width = parseInt(this.Base.options.width, 10) + "px", e3.appendChild(n3), e3;
    }, w2.prototype.createMenu = function() {
      var t4 = [];
      if ("items" in this.Base.options ? t4 = this.Base.options.defaultItems ? this.Base.options.items.concat(p5) : this.Base.options.items : this.Base.options.defaultItems && (t4 = p5), t4.length === 0)
        return false;
      t4.forEach(this.addMenuEntry, this);
    }, w2.prototype.addMenuEntry = function(t4) {
      var e3, n3 = this;
      if (t4.items && Array.isArray(t4.items)) {
        t4.classname = t4.classname || "", e3 = s2.submenu, ~t4.classname.indexOf(e3) || (t4.classname = t4.classname.length ? " " + s2.submenu : s2.submenu);
        var i3 = this.generateHtmlAndPublish(this.container, t4), o3 = this.createContainer();
        o3.style.left = this.Base.Internal.submenu.lastLeft || this.Base.Internal.submenu.left, i3.appendChild(o3), t4.items.forEach(function(t5) {
          n3.generateHtmlAndPublish(o3, t5, true);
        });
      } else
        this.generateHtmlAndPublish(this.container, t4);
    }, w2.prototype.generateHtmlAndPublish = function(t4, e3, n3) {
      var i3, o3, a3 = "_" + Math.random().toString(36).substr(2, 9), r3 = false;
      return typeof e3 == "string" && e3.trim() === "-" ? (i3 = v2('<li id="' + a3 + '" class="' + s2.separator + '"><hr></li>'), o3 = [].slice.call(i3.childNodes, 0)[0], t4.firstChild.appendChild(i3), r3 = true) : (e3.classname = e3.classname || "", i3 = v2("<span>" + e3.text + "</span>"), o3 = document.createElement("li"), e3.icon && (e3.classname === "" ? e3.classname = s2.icon : e3.classname.indexOf(s2.icon) === -1 && (e3.classname += " " + s2.icon), o3.setAttribute("style", "background-image:url(" + e3.icon + ")")), o3.id = a3, o3.className = e3.classname, o3.appendChild(i3), t4.firstChild.appendChild(o3)), this.Base.Internal.items[a3] = { id: a3, submenu: n3 || 0, separator: r3, callback: e3.callback, data: e3.data || null }, this.Base.Internal.setItemListener(o3, a3), o3;
    }, w2.prototype.removeMenuEntry = function(t4) {
      var e3 = f2("#" + t4, this.container.firstChild);
      e3 && this.container.firstChild.removeChild(e3), delete this.Base.Internal.items[t4];
    }, w2.prototype.cloneAndGetLineHeight = function() {
      var t4 = this.container.cloneNode(), e3 = v2("<span>Foo</span>"), n3 = v2("<span>Foo</span>"), i3 = document.createElement("li"), o3 = document.createElement("li");
      i3.appendChild(e3), o3.appendChild(n3), t4.appendChild(i3), t4.appendChild(o3), this.container.parentNode.appendChild(t4);
      var s3 = t4.offsetHeight / 2;
      return this.container.parentNode.removeChild(t4), s3;
    }, function(t4) {
      function e3(e4) {
        e4 === void 0 && (e4 = {}), u2(typeof e4 == "object", "@param `opt_options` should be object type!"), this.options = function(t5, e5) {
          var n3 = {};
          for (var i3 in t5)
            n3[i3] = t5[i3];
          for (var o3 in e5)
            n3[o3] = e5[o3];
          return n3;
        }(h2, e4), this.disabled = false, this.Internal = new E2(this), this.Html = new w2(this), t4.call(this, { element: this.container });
      }
      return t4 && (e3.__proto__ = t4), e3.prototype = Object.create(t4 && t4.prototype), e3.prototype.constructor = e3, e3.prototype.clear = function() {
        Object.keys(this.Internal.items).forEach(this.Html.removeMenuEntry, this.Html);
      }, e3.prototype.close = function() {
        this.Internal.closeMenu();
      }, e3.prototype.enable = function() {
        this.disabled = false;
      }, e3.prototype.disable = function() {
        this.disabled = true;
      }, e3.prototype.getDefaultItems = function() {
        return p5;
      }, e3.prototype.countItems = function() {
        return Object.keys(this.Internal.items).length;
      }, e3.prototype.extend = function(t5) {
        u2(Array.isArray(t5), "@param `arr` should be an Array."), t5.forEach(this.push, this);
      }, e3.prototype.isOpen = function() {
        return this.Internal.opened;
      }, e3.prototype.updatePosition = function(t5) {
        u2(Array.isArray(t5), "@param `pixel` should be an Array."), this.isOpen() && this.Internal.positionContainer(t5);
      }, e3.prototype.pop = function() {
        var t5 = Object.keys(this.Internal.items);
        this.Html.removeMenuEntry(t5[t5.length - 1]);
      }, e3.prototype.push = function(t5) {
        u2(t5 != null, "@param `item` must be informed."), this.Html.addMenuEntry(t5);
      }, e3.prototype.shift = function() {
        this.Html.removeMenuEntry(Object.keys(this.Internal.items)[0]);
      }, e3.prototype.setMap = function(e4) {
        t4.prototype.setMap.call(this, e4), e4 ? this.Internal.init(e4, this) : this.Internal.removeListeners();
      }, e3;
    }(n2.default);
  });
})(olContextmenu$1);
var ContextMenu = olContextmenu$1.exports;
const _sfc_main$B = {
  name: "ol-context-menu",
  setup(props, context2) {
    const {
      control
    } = useControl(ContextMenu, props, context2);
    return {
      control
    };
  },
  props: {
    eventType: {
      type: String,
      default: "contextmenu"
    },
    defaultItems: {
      type: Boolean,
      default: true
    },
    width: {
      type: Number,
      default: 150
    },
    items: {
      type: Array,
      default: () => []
    }
  }
};
function _sfc_render$B(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var ContextMenuControl = /* @__PURE__ */ _export_sfc(_sfc_main$B, [["render", _sfc_render$B]]);
var ol_control_Swipe = function(options) {
  options = options || {};
  var button = document.createElement("button");
  var element = document.createElement("div");
  element.className = (options.className || "ol-swipe") + " ol-unselectable ol-control";
  element.appendChild(button);
  element.addEventListener("mousedown", this.move.bind(this));
  element.addEventListener("touchstart", this.move.bind(this));
  Control$1.call(this, {
    element
  });
  this.precomposeRight_ = this.precomposeRight.bind(this);
  this.precomposeLeft_ = this.precomposeLeft.bind(this);
  this.postcompose_ = this.postcompose.bind(this);
  this.layers = [];
  if (options.layers)
    this.addLayer(options.layers, false);
  if (options.rightLayers)
    this.addLayer(options.rightLayers, true);
  this.on("propertychange", function(e2) {
    if (this.getMap()) {
      try {
        this.getMap().renderSync();
      } catch (e3) {
      }
    }
    if (this.get("orientation") === "horizontal") {
      this.element.style.top = this.get("position") * 100 + "%";
      this.element.style.left = "";
    } else {
      if (this.get("orientation") !== "vertical")
        this.set("orientation", "vertical");
      this.element.style.left = this.get("position") * 100 + "%";
      this.element.style.top = "";
    }
    if (e2.key === "orientation") {
      this.element.classList.remove("horizontal", "vertical");
      this.element.classList.add(this.get("orientation"));
    }
    if (!this.isMoving) {
      this.layers.forEach(function(l2) {
        if (l2.layer.getImageRatio)
          l2.layer.changed();
      });
    }
  }.bind(this));
  this.set("position", options.position || 0.5);
  this.set("orientation", options.orientation || "vertical");
};
ol_ext_inherits(ol_control_Swipe, Control$1);
ol_control_Swipe.prototype.setMap = function(map) {
  var i2;
  var l2;
  if (this.getMap()) {
    for (i2 = 0; i2 < this.layers.length; i2++) {
      l2 = this.layers[i2];
      if (l2.right)
        l2.layer.un(["precompose", "prerender"], this.precomposeRight_);
      else
        l2.layer.un(["precompose", "prerender"], this.precomposeLeft_);
      l2.layer.un(["postcompose", "postrender"], this.postcompose_);
    }
    try {
      this.getMap().renderSync();
    } catch (e2) {
    }
  }
  Control$1.prototype.setMap.call(this, map);
  if (map) {
    this._listener = [];
    for (i2 = 0; i2 < this.layers.length; i2++) {
      l2 = this.layers[i2];
      if (l2.right)
        l2.layer.on(["precompose", "prerender"], this.precomposeRight_);
      else
        l2.layer.on(["precompose", "prerender"], this.precomposeLeft_);
      l2.layer.on(["postcompose", "postrender"], this.postcompose_);
    }
    try {
      map.renderSync();
    } catch (e2) {
    }
  }
};
ol_control_Swipe.prototype.isLayer_ = function(layer) {
  for (var k2 = 0; k2 < this.layers.length; k2++) {
    if (this.layers[k2].layer === layer)
      return k2;
  }
  return -1;
};
ol_control_Swipe.prototype.addLayer = function(layers, right) {
  if (!(layers instanceof Array))
    layers = [layers];
  for (var i2 = 0; i2 < layers.length; i2++) {
    var l2 = layers[i2];
    if (this.isLayer_(l2) < 0) {
      this.layers.push({ layer: l2, right });
      if (this.getMap()) {
        if (right)
          l2.on(["precompose", "prerender"], this.precomposeRight_);
        else
          l2.on(["precompose", "prerender"], this.precomposeLeft_);
        l2.on(["postcompose", "postrender"], this.postcompose_);
        try {
          this.getMap().renderSync();
        } catch (e2) {
        }
      }
    }
  }
};
ol_control_Swipe.prototype.removeLayers = function() {
  var layers = [];
  this.layers.forEach(function(l2) {
    layers.push(l2.layer);
  });
  this.removeLayer(layers);
};
ol_control_Swipe.prototype.removeLayer = function(layers) {
  if (!(layers instanceof Array))
    layers = [layers];
  for (var i2 = 0; i2 < layers.length; i2++) {
    var k2 = this.isLayer_(layers[i2]);
    if (k2 >= 0 && this.getMap()) {
      if (this.layers[k2].right)
        layers[i2].un(["precompose", "prerender"], this.precomposeRight_);
      else
        layers[i2].un(["precompose", "prerender"], this.precomposeLeft_);
      layers[i2].un(["postcompose", "postrender"], this.postcompose_);
      this.layers.splice(k2, 1);
    }
  }
  if (this.getMap()) {
    try {
      this.getMap().renderSync();
    } catch (e2) {
    }
  }
};
ol_control_Swipe.prototype.getRectangle = function() {
  var s2;
  if (this.get("orientation") === "vertical") {
    s2 = this.getMap().getSize();
    return [0, 0, s2[0] * this.get("position"), s2[1]];
  } else {
    s2 = this.getMap().getSize();
    return [0, 0, s2[0], s2[1] * this.get("position")];
  }
};
ol_control_Swipe.prototype.move = function(e2) {
  var self2 = this;
  var l2;
  if (!this._movefn)
    this._movefn = this.move.bind(this);
  switch (e2.type) {
    case "touchcancel":
    case "touchend":
    case "mouseup": {
      self2.isMoving = false;
      ["mouseup", "mousemove", "touchend", "touchcancel", "touchmove"].forEach(function(eventName) {
        document.removeEventListener(eventName, self2._movefn);
      });
      this.layers.forEach(function(l3) {
        if (l3.layer.getImageRatio)
          l3.layer.changed();
      });
      break;
    }
    case "mousedown":
    case "touchstart": {
      self2.isMoving = true;
      ["mouseup", "mousemove", "touchend", "touchcancel", "touchmove"].forEach(function(eventName) {
        document.addEventListener(eventName, self2._movefn);
      });
    }
    case "mousemove":
    case "touchmove": {
      if (self2.isMoving) {
        if (self2.get("orientation") === "vertical") {
          var pageX = e2.pageX || e2.touches && e2.touches.length && e2.touches[0].pageX || e2.changedTouches && e2.changedTouches.length && e2.changedTouches[0].pageX;
          if (!pageX)
            break;
          pageX -= self2.getMap().getTargetElement().getBoundingClientRect().left + window.pageXOffset - document.documentElement.clientLeft;
          l2 = self2.getMap().getSize()[0];
          var w2 = l2 - Math.min(Math.max(0, l2 - pageX), l2);
          l2 = w2 / l2;
          self2.set("position", l2);
          self2.dispatchEvent({ type: "moving", size: [w2, self2.getMap().getSize()[1]], position: [l2, 0] });
        } else {
          var pageY = e2.pageY || e2.touches && e2.touches.length && e2.touches[0].pageY || e2.changedTouches && e2.changedTouches.length && e2.changedTouches[0].pageY;
          if (!pageY)
            break;
          pageY -= self2.getMap().getTargetElement().getBoundingClientRect().top + window.pageYOffset - document.documentElement.clientTop;
          l2 = self2.getMap().getSize()[1];
          var h2 = l2 - Math.min(Math.max(0, l2 - pageY), l2);
          l2 = h2 / l2;
          self2.set("position", l2);
          self2.dispatchEvent({ type: "moving", size: [self2.getMap().getSize()[0], h2], position: [0, l2] });
        }
      }
      break;
    }
  }
};
ol_control_Swipe.prototype._transformPt = function(e2, pt2) {
  var tr = e2.inversePixelTransform;
  var x2 = pt2[0];
  var y2 = pt2[1];
  pt2[0] = tr[0] * x2 + tr[2] * y2 + tr[4];
  pt2[1] = tr[1] * x2 + tr[3] * y2 + tr[5];
  return pt2;
};
ol_control_Swipe.prototype._drawRect = function(e2, pts) {
  var tr = e2.inversePixelTransform;
  if (tr) {
    var r2 = [
      [pts[0][0], pts[0][1]],
      [pts[0][0], pts[1][1]],
      [pts[1][0], pts[1][1]],
      [pts[1][0], pts[0][1]],
      [pts[0][0], pts[0][1]]
    ];
    e2.context.save();
    if (e2.target.getImageRatio) {
      var rot = -Math.atan2(e2.frameState.pixelToCoordinateTransform[1], e2.frameState.pixelToCoordinateTransform[0]);
      e2.context.translate(e2.frameState.size[0] / 2, e2.frameState.size[1] / 2);
      e2.context.rotate(rot);
      e2.context.translate(-e2.frameState.size[0] / 2, -e2.frameState.size[1] / 2);
    }
    r2.forEach(function(pt2, i2) {
      pt2 = [
        pt2[0] * tr[0] - pt2[1] * tr[1] + tr[4],
        -pt2[0] * tr[2] + pt2[1] * tr[3] + tr[5]
      ];
      if (!i2) {
        e2.context.moveTo(pt2[0], pt2[1]);
      } else {
        e2.context.lineTo(pt2[0], pt2[1]);
      }
    });
    e2.context.restore();
  } else {
    var ratio = e2.frameState.pixelRatio;
    e2.context.rect(pts[0][0] * ratio, pts[0][1] * ratio, pts[1][0] * ratio, pts[1][1] * ratio);
  }
};
ol_control_Swipe.prototype.precomposeLeft = function(e2) {
  var ctx = e2.context;
  if (ctx instanceof WebGLRenderingContext) {
    if (e2.type === "prerender") {
      ctx.clearColor(0, 0, 0, 0);
      ctx.clear(ctx.COLOR_BUFFER_BIT);
      ctx.enable(ctx.SCISSOR_TEST);
      var mapSize = this.getMap().getSize();
      var bottomLeft = this._transformPt(e2, [0, mapSize[1]]);
      var topRight = this._transformPt(e2, [mapSize[0], 0]);
      var width = topRight[0] - bottomLeft[0];
      var height = topRight[1] - bottomLeft[1];
      if (this.get("orientation") === "vertical") {
        width = Math.round(width * this.get("position"));
      } else {
        height = Math.round(height * this.get("position"));
        bottomLeft[1] += mapSize[1] - height;
      }
      ctx.scissor(bottomLeft[0], bottomLeft[1], width, height);
    }
  } else {
    var size = e2.frameState.size;
    ctx.save();
    ctx.beginPath();
    var pts = [[0, 0], [size[0], size[1]]];
    if (this.get("orientation") === "vertical") {
      pts[1] = [
        size[0] * 0.5 + this.getMap().getSize()[0] * (this.get("position") - 0.5),
        size[1]
      ];
    } else {
      pts[1] = [
        size[0],
        size[1] * 0.5 + this.getMap().getSize()[1] * (this.get("position") - 0.5)
      ];
    }
    this._drawRect(e2, pts);
    ctx.clip();
  }
};
ol_control_Swipe.prototype.precomposeRight = function(e2) {
  var ctx = e2.context;
  if (ctx instanceof WebGLRenderingContext) {
    if (e2.type === "prerender") {
      ctx.clearColor(0, 0, 0, 0);
      ctx.clear(ctx.COLOR_BUFFER_BIT);
      ctx.enable(ctx.SCISSOR_TEST);
      var mapSize = this.getMap().getSize();
      var bottomLeft = this._transformPt(e2, [0, mapSize[1]]);
      var topRight = this._transformPt(e2, [mapSize[0], 0]);
      var width = topRight[0] - bottomLeft[0];
      var height = topRight[1] - bottomLeft[1];
      if (this.get("orientation") === "vertical") {
        width = Math.round(width * (1 - this.get("position")));
        bottomLeft[0] += mapSize[0] - width;
      } else {
        height = Math.round(height * (1 - this.get("position")));
      }
      ctx.scissor(bottomLeft[0], bottomLeft[1], width, height);
    }
  } else {
    var size = e2.frameState.size;
    ctx.save();
    ctx.beginPath();
    var pts = [[0, 0], [size[0], size[1]]];
    if (this.get("orientation") === "vertical") {
      pts[0] = [
        size[0] * 0.5 + this.getMap().getSize()[0] * (this.get("position") - 0.5),
        0
      ];
    } else {
      pts[0] = [
        0,
        size[1] * 0.5 + this.getMap().getSize()[1] * (this.get("position") - 0.5)
      ];
    }
    this._drawRect(e2, pts);
    ctx.clip();
  }
};
ol_control_Swipe.prototype.postcompose = function(e2) {
  if (e2.context instanceof WebGLRenderingContext) {
    if (e2.type === "postrender") {
      var gl = e2.context;
      gl.disable(gl.SCISSOR_TEST);
    }
  } else {
    if (e2.target.getClassName && e2.target.getClassName() !== "ol-layer" && e2.target.get("declutter")) {
      setTimeout(function() {
        e2.context.restore();
      }, 0);
    } else {
      e2.context.restore();
    }
  }
};
const _sfc_main$A = {
  name: "ol-swipe-control",
  setup(props, context2) {
    const {
      control
    } = useControl(ol_control_Swipe, props, context2);
    const {
      layerList
    } = toRefs(props);
    layerList.value.forEach((layer, index2) => {
      control.value.addLayer(layer, index2 == 1 ? true : false);
    });
    return {
      control
    };
  },
  props: {
    layerList: {
      type: Array
    },
    className: {
      type: String,
      default: "ol-swipe"
    },
    position: {
      type: Number,
      default: 0.5
    },
    orientation: {
      type: String,
      default: "vertical"
    }
  }
};
function _sfc_render$A(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var SwipeControl = /* @__PURE__ */ _export_sfc(_sfc_main$A, [["render", _sfc_render$A]]);
var ol_control_Bar = function(options) {
  if (!options)
    options = {};
  var element = document.createElement("div");
  element.classList.add("ol-unselectable", "ol-control", "ol-bar");
  if (options.className) {
    var classes = options.className.split(" ").filter(function(className) {
      return className.length > 0;
    });
    element.classList.add.apply(element.classList, classes);
  }
  if (options.group)
    element.classList.add("ol-group");
  Control$1.call(this, {
    element,
    target: options.target
  });
  this.set("toggleOne", options.toggleOne);
  this.set("autoDeactivate", options.autoDeactivate);
  this.controls_ = [];
  if (options.controls instanceof Array) {
    for (var i2 = 0; i2 < options.controls.length; i2++) {
      this.addControl(options.controls[i2]);
    }
  }
};
ol_ext_inherits(ol_control_Bar, Control$1);
ol_control_Bar.prototype.setVisible = function(val) {
  if (val)
    this.element.style.display = "";
  else
    this.element.style.display = "none";
};
ol_control_Bar.prototype.getVisible = function() {
  return this.element.style.display != "none";
};
ol_control_Bar.prototype.setMap = function(map) {
  Control$1.prototype.setMap.call(this, map);
  for (var i2 = 0; i2 < this.controls_.length; i2++) {
    var c2 = this.controls_[i2];
    c2.setMap(map);
  }
};
ol_control_Bar.prototype.getControls = function() {
  return this.controls_;
};
ol_control_Bar.prototype.setPosition = function(pos) {
  this.element.classList.remove("ol-left", "ol-top", "ol-bottom", "ol-right");
  pos = pos.split("-");
  for (var i2 = 0; i2 < pos.length; i2++) {
    switch (pos[i2]) {
      case "top":
      case "left":
      case "bottom":
      case "right":
        this.element.classList.add("ol-" + pos[i2]);
        break;
    }
  }
};
ol_control_Bar.prototype.addControl = function(c2) {
  this.controls_.push(c2);
  c2.setTarget(this.element);
  if (this.getMap()) {
    this.getMap().addControl(c2);
  }
  c2.on("change:active", function(e2) {
    this.onActivateControl_(e2, c2);
  }.bind(this));
  if (c2.getActive) {
    this.onActivateControl_({ target: c2, active: c2.getActive() }, c2);
  }
};
ol_control_Bar.prototype.deactivateControls = function(except) {
  for (var i2 = 0; i2 < this.controls_.length; i2++) {
    if (this.controls_[i2] !== except && this.controls_[i2].setActive) {
      this.controls_[i2].setActive(false);
    }
  }
};
ol_control_Bar.prototype.getActiveControls = function() {
  var active = [];
  for (var i2 = 0, c2; c2 = this.controls_[i2]; i2++) {
    if (c2.getActive && c2.getActive())
      active.push(c2);
  }
  return active;
};
ol_control_Bar.prototype.setActive = function(b2) {
  if (!b2 && this.get("autoDeactivate")) {
    this.deactivateControls();
  }
  if (b2) {
    var ctrls = this.getControls();
    for (var i2 = 0, sb; sb = ctrls[i2]; i2++) {
      if (sb.get("autoActivate"))
        sb.setActive(true);
    }
  }
};
ol_control_Bar.prototype.onActivateControl_ = function(e2, ctrl) {
  if (this.get("toggleOne")) {
    if (e2.active) {
      var n2;
      for (n2 = 0; n2 < this.controls_.length; n2++) {
        if (this.controls_[n2] === ctrl)
          break;
      }
      if (n2 == this.controls_.length)
        return;
      this.deactivateControls(this.controls_[n2]);
    } else {
      if (!this.getActiveControls().length) {
        for (var i2 = 0, c2; c2 = this.controls_[i2]; i2++) {
          if (c2.get("autoActivate")) {
            c2.setActive(true);
            break;
          }
        }
      }
    }
  }
};
ol_control_Bar.prototype.getControlsByName = function(name) {
  var controls = this.getControls();
  return controls.filter(function(control) {
    return control.get("name") === name;
  });
};
const _sfc_main$z = {
  name: "ol-control-bar",
  setup(props, context2) {
    const {
      control
    } = useControl(ol_control_Bar, props, context2);
    provide("controlBar", control);
    return {
      control
    };
  },
  props: {
    toggleOne: {
      type: Boolean,
      default: true
    },
    group: {
      type: Boolean,
      default: true
    }
  }
};
function _sfc_render$z(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}
var ControlBar = /* @__PURE__ */ _export_sfc(_sfc_main$z, [["render", _sfc_render$z]]);
if (window.ol) {
  ol.ext.input = {};
}
var ol_ext_input_Base = function(options) {
  options = options || {};
  BaseObject.call(this);
  var input = this.input = options.input;
  if (!input) {
    input = this.input = document.createElement("INPUT");
    if (options.type)
      input.setAttribute("type", options.type);
    if (options.min !== void 0)
      input.setAttribute("min", options.min);
    if (options.max !== void 0)
      input.setAttribute("max", options.max);
    if (options.step !== void 0)
      input.setAttribute("step", options.step);
    if (options.parent)
      options.parent.appendChild(input);
  }
  if (options.disabled)
    input.disabled = true;
  if (options.checked !== void 0)
    input.checked = !!options.checked;
  if (options.val !== void 0)
    input.value = options.val;
  if (options.hidden)
    input.style.display = "none";
  input.addEventListener("focus", function() {
    if (this.element)
      this.element.classList.add("ol-focus");
  }.bind(this));
  var tout;
  input.addEventListener("focusout", function() {
    if (this.element) {
      if (tout)
        clearTimeout(tout);
      tout = setTimeout(function() {
        this.element.classList.remove("ol-focus");
      }.bind(this), 0);
    }
  }.bind(this));
};
ol_ext_inherits(ol_ext_input_Base, BaseObject);
ol_ext_input_Base.prototype._listenDrag = function(elt, cback) {
  var handle = function(e2) {
    this.moving = true;
    var listen2 = function(e3) {
      if (e3.type === "pointerup") {
        document.removeEventListener("pointermove", listen2);
        document.removeEventListener("pointerup", listen2);
        document.removeEventListener("pointercancel", listen2);
        setTimeout(function() {
          this.moving = false;
        }.bind(this));
      }
      if (e3.target === elt)
        cback(e3);
      e3.stopPropagation();
      e3.preventDefault();
    }.bind(this);
    document.addEventListener("pointermove", listen2, false);
    document.addEventListener("pointerup", listen2, false);
    document.addEventListener("pointercancel", listen2, false);
    e2.stopPropagation();
    e2.preventDefault();
  }.bind(this);
  elt.addEventListener("mousedown", handle, false);
  elt.addEventListener("touchstart", handle, false);
};
ol_ext_input_Base.prototype.setValue = function(v2) {
  if (v2 !== void 0)
    this.input.value = v2;
  this.input.dispatchEvent(new Event("change"));
};
ol_ext_input_Base.prototype.getValue = function() {
  return this.input.value;
};
ol_ext_input_Base.prototype.getInputElement = function() {
  return this.input;
};
var ol_ext_input_Checkbox = function(options) {
  options = options || {};
  ol_ext_input_Base.call(this, options);
  var label = this.element = document.createElement("LABEL");
  if (options.html instanceof Element)
    label.appendChild(options.html);
  else if (options.html !== void 0)
    label.innerHTML = options.html;
  label.className = ("ol-ext-check ol-ext-checkbox " + (options.className || "")).trim();
  if (this.input.parentNode)
    this.input.parentNode.insertBefore(label, this.input);
  label.appendChild(this.input);
  label.appendChild(document.createElement("SPAN"));
  if (options.after) {
    label.appendChild(document.createTextNode(options.after));
  }
  this.input.addEventListener("change", function() {
    this.dispatchEvent({ type: "check", checked: this.input.checked, value: this.input.value });
  }.bind(this));
};
ol_ext_inherits(ol_ext_input_Checkbox, ol_ext_input_Base);
ol_ext_input_Checkbox.prototype.isChecked = function() {
  return this.input.checked;
};
var ol_ext_input_Switch = function(options) {
  options = options || {};
  ol_ext_input_Checkbox.call(this, options);
  this.element.className = ("ol-ext-toggle-switch " + (options.className || "")).trim();
};
ol_ext_inherits(ol_ext_input_Switch, ol_ext_input_Checkbox);
var ol_ext_input_Radio = function(options) {
  options = options || {};
  ol_ext_input_Checkbox.call(this, options);
  this.element.className = ("ol-ext-check ol-ext-radio " + (options.className || "")).trim();
};
ol_ext_inherits(ol_ext_input_Radio, ol_ext_input_Checkbox);
var ol_ext_element = {};
ol_ext_element.create = function(tagName, options) {
  options = options || {};
  var elt;
  if (tagName === "TEXT") {
    elt = document.createTextNode(options.html || "");
    if (options.parent)
      options.parent.appendChild(elt);
  } else {
    elt = document.createElement(tagName);
    if (/button/i.test(tagName))
      elt.setAttribute("type", "button");
    for (var attr in options) {
      switch (attr) {
        case "className": {
          if (options.className && options.className.trim)
            elt.setAttribute("class", options.className.trim());
          break;
        }
        case "text": {
          elt.innerText = options.text;
          break;
        }
        case "html": {
          if (options.html instanceof Element)
            elt.appendChild(options.html);
          else if (options.html !== void 0)
            elt.innerHTML = options.html;
          break;
        }
        case "parent": {
          if (options.parent)
            options.parent.appendChild(elt);
          break;
        }
        case "options": {
          if (/select/i.test(tagName)) {
            for (var i2 in options.options) {
              ol_ext_element.create("OPTION", {
                html: i2,
                value: options.options[i2],
                parent: elt
              });
            }
          }
          break;
        }
        case "style": {
          this.setStyle(elt, options.style);
          break;
        }
        case "change":
        case "click": {
          ol_ext_element.addListener(elt, attr, options[attr]);
          break;
        }
        case "on": {
          for (var e2 in options.on) {
            ol_ext_element.addListener(elt, e2, options.on[e2]);
          }
          break;
        }
        case "checked": {
          elt.checked = !!options.checked;
          break;
        }
        default: {
          elt.setAttribute(attr, options[attr]);
          break;
        }
      }
    }
  }
  return elt;
};
ol_ext_element.createSwitch = function(options) {
  var input = ol_ext_element.create("INPUT", {
    type: "checkbox",
    on: options.on,
    click: options.click,
    change: options.change,
    parent: options.parent
  });
  var opt = Object.assign({ input }, options || {});
  new ol_ext_input_Switch(opt);
  return input;
};
ol_ext_element.createCheck = function(options) {
  var input = ol_ext_element.create("INPUT", {
    name: options.name,
    type: options.type === "radio" ? "radio" : "checkbox",
    on: options.on,
    parent: options.parent
  });
  console.log(input);
  var opt = Object.assign({ input }, options || {});
  if (options.type === "radio") {
    new ol_ext_input_Radio(opt);
  } else {
    new ol_ext_input_Checkbox(opt);
  }
  return input;
};
ol_ext_element.setHTML = function(element, html2) {
  if (html2 instanceof Element)
    element.appendChild(html2);
  else if (html2 !== void 0)
    element.innerHTML = html2;
};
ol_ext_element.appendText = function(element, text2) {
  element.appendChild(document.createTextNode(text2 || ""));
};
ol_ext_element.addListener = function(element, eventType, fn, useCapture) {
  if (typeof eventType === "string")
    eventType = eventType.split(" ");
  eventType.forEach(function(e2) {
    element.addEventListener(e2, fn, useCapture);
  });
};
ol_ext_element.removeListener = function(element, eventType, fn) {
  if (typeof eventType === "string")
    eventType = eventType.split(" ");
  eventType.forEach(function(e2) {
    element.removeEventListener(e2, fn);
  });
};
ol_ext_element.show = function(element) {
  element.style.display = "";
};
ol_ext_element.hide = function(element) {
  element.style.display = "none";
};
ol_ext_element.hidden = function(element) {
  return ol_ext_element.getStyle(element, "display") === "none";
};
ol_ext_element.toggle = function(element) {
  element.style.display = element.style.display === "none" ? "" : "none";
};
ol_ext_element.setStyle = function(el, st2) {
  for (var s2 in st2) {
    switch (s2) {
      case "top":
      case "left":
      case "bottom":
      case "right":
      case "minWidth":
      case "maxWidth":
      case "width":
      case "height": {
        if (typeof st2[s2] === "number") {
          el.style[s2] = st2[s2] + "px";
        } else {
          el.style[s2] = st2[s2];
        }
        break;
      }
      default: {
        el.style[s2] = st2[s2];
      }
    }
  }
};
ol_ext_element.getStyle = function(el, styleProp) {
  var value, defaultView = (el.ownerDocument || document).defaultView;
  if (defaultView && defaultView.getComputedStyle) {
    styleProp = styleProp.replace(/([A-Z])/g, "-$1").toLowerCase();
    value = defaultView.getComputedStyle(el, null).getPropertyValue(styleProp);
  } else if (el.currentStyle) {
    styleProp = styleProp.replace(/-(\w)/g, function(str, letter) {
      return letter.toUpperCase();
    });
    value = el.currentStyle[styleProp];
    if (/^\d+(em|pt|%|ex)?$/i.test(value)) {
      return function(value2) {
        var oldLeft = el.style.left, oldRsLeft = el.runtimeStyle.left;
        el.runtimeStyle.left = el.currentStyle.left;
        el.style.left = value2 || 0;
        value2 = el.style.pixelLeft + "px";
        el.style.left = oldLeft;
        el.runtimeStyle.left = oldRsLeft;
        return value2;
      }(value);
    }
  }
  if (/px$/.test(value))
    return parseInt(value);
  return value;
};
ol_ext_element.outerHeight = function(elt) {
  return elt.offsetHeight + ol_ext_element.getStyle(elt, "marginBottom");
};
ol_ext_element.outerWidth = function(elt) {
  return elt.offsetWidth + ol_ext_element.getStyle(elt, "marginLeft");
};
ol_ext_element.offsetRect = function(elt) {
  var rect = elt.getBoundingClientRect();
  return {
    top: rect.top + (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0),
    left: rect.left + (window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0),
    height: rect.height || rect.bottom - rect.top,
    width: rect.width || rect.right - rect.left
  };
};
ol_ext_element.getFixedOffset = function(elt) {
  var offset2 = {
    left: 0,
    top: 0
  };
  var getOffset = function(parent) {
    if (!parent)
      return offset2;
    if (ol_ext_element.getStyle(parent, "position") === "absolute" && ol_ext_element.getStyle(parent, "transform") !== "none") {
      var r2 = parent.getBoundingClientRect();
      offset2.left += r2.left;
      offset2.top += r2.top;
      return offset2;
    }
    return getOffset(parent.offsetParent);
  };
  return getOffset(elt.offsetParent);
};
ol_ext_element.positionRect = function(elt, fixed) {
  var gleft = 0;
  var gtop = 0;
  var getRect = function(parent) {
    if (parent) {
      gleft += parent.offsetLeft;
      gtop += parent.offsetTop;
      return getRect(parent.offsetParent);
    } else {
      var r2 = {
        top: elt.offsetTop + gtop,
        left: elt.offsetLeft + gleft
      };
      if (fixed) {
        r2.top -= window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
        r2.left -= window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;
      }
      r2.bottom = r2.top + elt.offsetHeight;
      r2.right = r2.top + elt.offsetWidth;
      return r2;
    }
  };
  return getRect(elt.offsetParent);
};
ol_ext_element.scrollDiv = function(elt, options) {
  options = options || {};
  var pos = false;
  var speed = 0;
  var d2, dt2 = 0;
  var onmove = typeof options.onmove === "function" ? options.onmove : function() {
  };
  var page = options.vertical ? "screenY" : "screenX";
  var scroll = options.vertical ? "scrollTop" : "scrollLeft";
  var moving = false;
  var scale2, isbar;
  var updateCounter = 0;
  var updateMinibar = function() {
    if (scrollbar) {
      updateCounter++;
      setTimeout(updateMinibarDelay);
    }
  };
  var updateMinibarDelay = function() {
    if (scrollbar) {
      updateCounter--;
      if (updateCounter)
        return;
      var pheight = elt.clientHeight;
      var height = elt.scrollHeight;
      scale2 = pheight / height;
      scrollbar.style.height = scale2 * 100 + "%";
      scrollbar.style.top = elt.scrollTop / height * 100 + "%";
      scrollContainer.style.height = pheight + "px";
      if (pheight > height - 0.5)
        scrollContainer.classList.add("ol-100pc");
      else
        scrollContainer.classList.remove("ol-100pc");
    }
  };
  var onPointerDown = function(e2) {
    if (e2.target.classList.contains("ol-noscroll"))
      return;
    moving = false;
    pos = e2[page];
    dt2 = new Date();
    elt.classList.add("ol-move");
    e2.preventDefault();
    window.addEventListener("pointermove", onPointerMove);
    ol_ext_element.addListener(window, ["pointerup", "pointercancel"], onPointerUp);
  };
  var onPointerMove = function(e2) {
    moving = true;
    if (pos !== false) {
      var delta = (isbar ? -1 / scale2 : 1) * (pos - e2[page]);
      elt[scroll] += delta;
      d2 = new Date();
      if (d2 - dt2) {
        speed = (speed + delta / (d2 - dt2)) / 2;
      }
      pos = e2[page];
      dt2 = d2;
      if (delta)
        onmove(true);
    }
  };
  var animate = function(to) {
    var step = to > 0 ? Math.min(100, to / 2) : Math.max(-100, to / 2);
    to -= step;
    elt[scroll] += step;
    if (-1 < to && to < 1) {
      if (moving)
        setTimeout(function() {
          elt.classList.remove("ol-move");
        });
      else
        elt.classList.remove("ol-move");
      moving = false;
      onmove(false);
    } else {
      setTimeout(function() {
        animate(to);
      }, 40);
    }
  };
  var scrollContainer, scrollbar;
  if (options.vertical && options.minibar) {
    var init2 = function(b2) {
      elt.removeEventListener("pointermove", init2);
      elt.parentNode.classList.add("ol-miniscroll");
      scrollbar = ol_ext_element.create("DIV");
      scrollContainer = ol_ext_element.create("DIV", {
        className: "ol-scroll",
        html: scrollbar
      });
      elt.parentNode.insertBefore(scrollContainer, elt);
      scrollbar.addEventListener("pointerdown", function(e2) {
        isbar = true;
        onPointerDown(e2);
      });
      if (options.mousewheel) {
        ol_ext_element.addListener(scrollContainer, ["mousewheel", "DOMMouseScroll", "onmousewheel"], function(e2) {
          onMouseWheel(e2);
        });
        ol_ext_element.addListener(scrollbar, ["mousewheel", "DOMMouseScroll", "onmousewheel"], function(e2) {
          onMouseWheel(e2);
        });
      }
      elt.parentNode.addEventListener("pointerenter", updateMinibar);
      window.addEventListener("resize", updateMinibar);
      if (b2 !== false)
        updateMinibar();
    };
    if (elt.parentNode)
      init2(false);
    else
      elt.addEventListener("pointermove", init2);
    elt.addEventListener("scroll", function() {
      updateMinibar();
    });
  }
  elt.style["touch-action"] = "none";
  elt.style["overflow"] = "hidden";
  elt.classList.add("ol-scrolldiv");
  ol_ext_element.addListener(elt, ["pointerdown"], function(e2) {
    isbar = false;
    onPointerDown(e2);
  });
  elt.addEventListener("click", function(e2) {
    if (elt.classList.contains("ol-move")) {
      e2.preventDefault();
      e2.stopPropagation();
    }
  }, true);
  var onPointerUp = function(e2) {
    dt2 = new Date() - dt2;
    if (dt2 > 100 || isbar) {
      speed = 0;
    } else if (dt2 > 0) {
      speed = ((speed || 0) + (pos - e2[page]) / dt2) / 2;
    }
    animate(options.animate === false ? 0 : speed * 200);
    pos = false;
    speed = 0;
    dt2 = 0;
    if (!elt.classList.contains("ol-move")) {
      elt.classList.add("ol-hasClick");
      setTimeout(function() {
        elt.classList.remove("ol-hasClick");
      }, 500);
    } else {
      elt.classList.remove("ol-hasClick");
    }
    isbar = false;
    window.removeEventListener("pointermove", onPointerMove);
    ol_ext_element.removeListener(window, ["pointerup", "pointercancel"], onPointerUp);
  };
  var onMouseWheel = function(e2) {
    var delta = Math.max(-1, Math.min(1, e2.wheelDelta || -e2.detail));
    elt.classList.add("ol-move");
    elt[scroll] -= delta * 30;
    elt.classList.remove("ol-move");
    return false;
  };
  if (options.mousewheel) {
    ol_ext_element.addListener(elt, ["mousewheel", "DOMMouseScroll", "onmousewheel"], onMouseWheel);
  }
  return {
    refresh: updateMinibar
  };
};
ol_ext_element.dispatchEvent = function(eventName, element) {
  var event;
  try {
    event = new CustomEvent(eventName);
  } catch (e2) {
    event = document.createEvent("CustomEvent");
    event.initCustomEvent(eventName, true, true, {});
  }
  element.dispatchEvent(event);
};
var ol_control_Button = function(options) {
  options = options || {};
  var element = document.createElement("div");
  element.className = (options.className || "") + " ol-button ol-unselectable ol-control";
  var self2 = this;
  var bt2 = this.button_ = document.createElement(/ol-text-button/.test(options.className) ? "div" : "button");
  bt2.type = "button";
  if (options.title)
    bt2.title = options.title;
  if (options.name)
    bt2.name = options.name;
  if (options.html instanceof Element)
    bt2.appendChild(options.html);
  else
    bt2.innerHTML = options.html || "";
  var evtFunction = function(e2) {
    if (e2 && e2.preventDefault) {
      e2.preventDefault();
      e2.stopPropagation();
    }
    if (options.handleClick) {
      options.handleClick.call(self2, e2);
    }
  };
  bt2.addEventListener("click", evtFunction);
  element.appendChild(bt2);
  if (!options.title && bt2.firstElementChild) {
    bt2.title = bt2.firstElementChild.title;
  }
  Control$1.call(this, {
    element,
    target: options.target
  });
  if (options.title) {
    this.set("title", options.title);
  }
  if (options.title)
    this.set("title", options.title);
  if (options.name)
    this.set("name", options.name);
};
ol_ext_inherits(ol_control_Button, Control$1);
ol_control_Button.prototype.setVisible = function(val) {
  if (val)
    ol_ext_element.show(this.element);
  else
    ol_ext_element.hide(this.element);
};
ol_control_Button.prototype.setTitle = function(title) {
  this.button_.setAttribute("title", title);
};
ol_control_Button.prototype.setHtml = function(html2) {
  ol_ext_element.setHTML(this.button_, html2);
};
ol_control_Button.prototype.getButtonElement = function() {
  return this.button_;
};
var ol_control_Toggle = function(options) {
  options = options || {};
  var self2 = this;
  this.interaction_ = options.interaction;
  if (this.interaction_) {
    this.interaction_.setActive(options.active);
    this.interaction_.on("change:active", function() {
      self2.setActive(self2.interaction_.getActive());
    });
  }
  if (options.toggleFn)
    options.onToggle = options.toggleFn;
  options.handleClick = function() {
    self2.toggle();
    if (options.onToggle)
      options.onToggle.call(self2, self2.getActive());
  };
  options.className = (options.className || "") + " ol-toggle";
  ol_control_Button.call(this, options);
  this.set("title", options.title);
  this.set("autoActivate", options.autoActivate);
  if (options.bar)
    this.setSubBar(options.bar);
  this.setActive(options.active);
  this.setDisable(options.disable);
};
ol_ext_inherits(ol_control_Toggle, ol_control_Button);
ol_control_Toggle.prototype.setMap = function(map) {
  if (!map && this.getMap()) {
    if (this.interaction_) {
      this.getMap().removeInteraction(this.interaction_);
    }
    if (this.subbar_)
      this.getMap().removeControl(this.subbar_);
  }
  ol_control_Button.prototype.setMap.call(this, map);
  if (map) {
    if (this.interaction_)
      map.addInteraction(this.interaction_);
    if (this.subbar_)
      map.addControl(this.subbar_);
  }
};
ol_control_Toggle.prototype.getSubBar = function() {
  return this.subbar_;
};
ol_control_Toggle.prototype.setSubBar = function(bar) {
  var map = this.getMap();
  if (map && this.subbar_)
    map.removeControl(this.subbar_);
  this.subbar_ = bar;
  if (bar) {
    this.subbar_.setTarget(this.element);
    this.subbar_.element.classList.add("ol-option-bar");
    if (map)
      map.addControl(this.subbar_);
  }
};
ol_control_Toggle.prototype.getDisable = function() {
  var button = this.element.querySelector("button");
  return button && button.disabled;
};
ol_control_Toggle.prototype.setDisable = function(b2) {
  if (this.getDisable() == b2)
    return;
  this.element.querySelector("button").disabled = b2;
  if (b2 && this.getActive())
    this.setActive(false);
  this.dispatchEvent({ type: "change:disable", key: "disable", oldValue: !b2, disable: b2 });
};
ol_control_Toggle.prototype.getActive = function() {
  return this.element.classList.contains("ol-active");
};
ol_control_Toggle.prototype.toggle = function() {
  if (this.getActive())
    this.setActive(false);
  else
    this.setActive(true);
};
ol_control_Toggle.prototype.setActive = function(b2) {
  if (this.interaction_)
    this.interaction_.setActive(b2);
  if (this.subbar_)
    this.subbar_.setActive(b2);
  if (this.getActive() === b2)
    return;
  if (b2)
    this.element.classList.add("ol-active");
  else
    this.element.classList.remove("ol-active");
  this.dispatchEvent({ type: "change:active", key: "active", oldValue: !b2, active: b2 });
};
ol_control_Toggle.prototype.setInteraction = function(i2) {
  this.interaction_ = i2;
};
ol_control_Toggle.prototype.getInteraction = function() {
  return this.interaction_;
};
const _sfc_main$y = {
  name: "ol-control-toggle",
  setup(props, context2) {
    const {
      control
    } = useControl(ol_control_Toggle, props, context2);
    return {
      control
    };
  },
  props: {
    html: {
      type: String
    },
    interaction: {
      type: Object
    },
    className: {
      type: String
    },
    title: {
      type: String
    },
    onToggle: {
      type: Function
    }
  }
};
function _sfc_render$y(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var ToggleControl = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["render", _sfc_render$y]]);
const _sfc_main$x = {
  name: "ol-control-button",
  setup(props, context2) {
    const {
      control
    } = useControl(ol_control_Button, props, context2);
    return {
      control
    };
  },
  props: {
    html: {
      type: String
    },
    name: {
      type: String
    },
    className: {
      type: String
    },
    title: {
      type: String
    },
    handleClick: {
      type: Function
    }
  }
};
function _sfc_render$x(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var ButtonControl = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["render", _sfc_render$x]]);
var ol_control_Dialog = function(options) {
  options = options || {};
  if (options.fullscreen)
    options.target = document.body;
  var element = ol_ext_element.create("DIV", {
    className: ((options.className || "") + (options.zoom ? " ol-zoom" : "") + " ol-ext-dialog").trim(),
    click: function(e2) {
      if (this.get("hideOnBack") && e2.target === element)
        this.close();
      if (this.get("hideOnClick"))
        this.close();
    }.bind(this)
  });
  var form = ol_ext_element.create("FORM", {
    on: {
      submit: this._onButton("submit")
    },
    parent: element
  });
  ol_ext_element.create("H2", {
    parent: form
  });
  ol_ext_element.create("DIV", {
    className: "ol-closebox",
    click: this._onButton("cancel"),
    parent: form
  });
  ol_ext_element.create("DIV", {
    className: "ol-content",
    parent: form
  });
  this._progress = ol_ext_element.create("DIV", {
    style: { display: "none" },
    parent: form
  });
  var bar = ol_ext_element.create("DIV", {
    className: "ol-progress-bar",
    parent: this._progress
  });
  this._progressbar = ol_ext_element.create("DIV", {
    parent: bar
  });
  this._progressMessage = ol_ext_element.create("DIV", {
    className: "ol-progress-message",
    parent: this._progress
  });
  ol_ext_element.create("DIV", {
    className: "ol-buttons",
    parent: form
  });
  Control$1.call(this, {
    element,
    target: options.target
  });
  this.set("closeBox", options.closeBox !== false);
  this.set("zoom", !!options.zoom);
  this.set("hideOnClick", !!options.hideOnClick);
  this.set("hideOnBack", !!options.hideOnBack);
  this.set("className", element.className);
  this.set("closeOnSubmit", options.closeOnSubmit);
  this.set("buttons", options.buttons);
  this.setContent(options);
};
ol_ext_inherits(ol_control_Dialog, Control$1);
ol_control_Dialog.prototype.show = function(options) {
  if (options) {
    if (options instanceof Element || typeof options === "string") {
      options = { content: options };
    }
    this.setContent(options);
  }
  this.element.classList.add("ol-visible");
  var input = this.element.querySelector('input[type="text"],input[type="search"],input[type="number"]');
  if (input)
    input.focus();
  this.dispatchEvent({ type: "show" });
  if (options) {
    if (options.autoclose) {
      var listener2 = setTimeout(function() {
        this.hide();
      }.bind(this), options.autoclose);
      this.once("hide", function() {
        clearTimeout(listener2);
      });
    }
    if (options.hideOnBack) {
      var value = this.get("hideOnBack");
      this.set("hideOnBack", true);
      this.once("hide", function() {
        this.set("hideOnBack", value);
      }.bind(this));
    }
  }
};
ol_control_Dialog.prototype.open = function() {
  this.show();
};
ol_control_Dialog.prototype.setContentMessage = function(content2) {
  if (content2 !== void 0) {
    var elt = this.getContentElement();
    if (content2 instanceof Element)
      ol_ext_element.setHTML(elt, "");
    ol_ext_element.setHTML(elt, content2 || "");
  }
};
ol_control_Dialog.prototype.setTitle = function(title) {
  var form = this.element.querySelector("form");
  form.querySelector("h2").innerText = title || "";
  if (title) {
    form.classList.add("ol-title");
  } else {
    form.classList.remove("ol-title");
  }
};
ol_control_Dialog.prototype.setContent = function(options) {
  if (!options)
    return;
  this.element.className = this.get("className");
  if (typeof options === "string")
    options = { content: options };
  options = options || {};
  this.setProgress(false);
  if (options.max)
    this.setProgress(0, options.max);
  if (options.progress !== void 0)
    this.setProgress(options.progress);
  if (this.get("zoom"))
    this.element.classList.add("ol-zoom");
  else
    this.element.classList.remove("ol-zoom");
  if (options.className) {
    options.className.split(" ").forEach(function(c2) {
      this.element.classList.add(c2);
    }.bind(this));
  }
  var form = this.element.querySelector("form");
  if (options.content !== void 0) {
    if (options.content instanceof Element)
      ol_ext_element.setHTML(form.querySelector(".ol-content"), "");
    ol_ext_element.setHTML(form.querySelector(".ol-content"), options.content || "");
  }
  this.setTitle(options.title);
  if (options.closeBox || this.get("closeBox") && options.closeBox !== false) {
    form.classList.add("ol-closebox");
  } else {
    form.classList.remove("ol-closebox");
  }
  var buttons = this.element.querySelector(".ol-buttons");
  buttons.innerHTML = "";
  var btn = options.buttons || this.get("buttons");
  if (btn) {
    form.classList.add("ol-button");
    for (var i2 in btn) {
      ol_ext_element.create("INPUT", {
        type: i2 === "submit" ? "submit" : "button",
        value: btn[i2],
        click: this._onButton(i2, options.onButton),
        parent: buttons
      });
    }
  } else {
    form.classList.remove("ol-button");
  }
};
ol_control_Dialog.prototype.getContentElement = function() {
  return this.element.querySelector("form .ol-content");
};
ol_control_Dialog.prototype.setProgress = function(val, max2, message) {
  if (val === false) {
    ol_ext_element.setStyle(this._progress, { display: "none" });
    return;
  }
  if (max2 > 0) {
    this.set("max", Number(max2));
  } else {
    max2 = this.get("max");
  }
  if (!max2) {
    ol_ext_element.setStyle(this._progress, { display: "none" });
  } else {
    var p5 = Math.round(val / max2 * 100);
    ol_ext_element.setStyle(this._progress, { display: "" });
    this._progressbar.className = p5 ? "" : "notransition";
    ol_ext_element.setStyle(this._progressbar, { width: p5 + "%" });
  }
  this._progressMessage.innerHTML = "";
  ol_ext_element.setHTML(this._progressMessage, message || "");
};
ol_control_Dialog.prototype._onButton = function(button, callback) {
  var fn = function(e2) {
    e2.preventDefault();
    if (button !== "submit" || this.get("closeOnSubmit") !== false)
      this.hide();
    var inputs = this.getInputs();
    this.dispatchEvent({ type: "button", button, inputs });
    if (typeof callback === "function")
      callback(button, inputs);
  }.bind(this);
  return fn;
};
ol_control_Dialog.prototype.getInputs = function() {
  var inputs = {};
  ["input", "textarea", "select"].forEach(function(type) {
    this.element.querySelectorAll("form " + type).forEach(function(input) {
      if (input.className) {
        input.className.split(" ").forEach(function(n2) {
          inputs[n2] = input;
        });
      }
    });
  }.bind(this));
  return inputs;
};
ol_control_Dialog.prototype.hide = function() {
  this.element.classList.remove("ol-visible");
  this.dispatchEvent({ type: "hide" });
};
ol_control_Dialog.prototype.close = ol_control_Dialog.prototype.hide;
ol_control_Dialog.prototype.isOpen = function() {
  return this.element.classList.contains("ol-visible");
};
var ol_ext_getMapCanvas = function(map) {
  if (!map)
    return null;
  var canvas = map.getViewport().getElementsByClassName("ol-fixedoverlay")[0];
  if (!canvas) {
    if (map.getViewport().querySelector(".ol-layers")) {
      canvas = document.createElement("canvas");
      canvas.className = "ol-fixedoverlay";
      map.getViewport().querySelector(".ol-layers").after(canvas);
      map.on("precompose", function(e2) {
        canvas.width = map.getSize()[0] * e2.frameState.pixelRatio;
        canvas.height = map.getSize()[1] * e2.frameState.pixelRatio;
      });
    } else {
      canvas = map.getViewport().querySelector("canvas");
    }
  }
  return canvas;
};
var ol_control_CanvasBase = function(options) {
  if (!options)
    options = {};
  this.setStyle(options.style);
  Control$1.call(this, options);
};
ol_ext_inherits(ol_control_CanvasBase, Control$1);
ol_control_CanvasBase.prototype.setMap = function(map) {
  this.getCanvas(map);
  var oldmap = this.getMap();
  if (this._listener) {
    unByKey(this._listener);
    this._listener = null;
  }
  Control$1.prototype.setMap.call(this, map);
  if (oldmap) {
    try {
      oldmap.renderSync();
    } catch (e2) {
    }
  }
  if (map) {
    this._listener = map.on("postcompose", this._draw.bind(this));
  }
};
ol_control_CanvasBase.prototype.getCanvas = function(map) {
  return ol_ext_getMapCanvas(map);
};
ol_control_CanvasBase.prototype.getContext = function(e2) {
  var ctx = e2.context;
  if (!ctx && this.getMap()) {
    var c2 = this.getMap().getViewport().getElementsByClassName("ol-fixedoverlay")[0];
    ctx = c2 ? c2.getContext("2d") : null;
  }
  return ctx;
};
ol_control_CanvasBase.prototype.setStyle = function(style2) {
  this._style = style2 || new Style$1({});
};
ol_control_CanvasBase.prototype.getStyle = function() {
  return this._style;
};
ol_control_CanvasBase.prototype.getStroke = function() {
  var t3 = this._style.getStroke();
  if (!t3)
    this._style.setStroke(new Stroke$1({ color: "#000", width: 1.25 }));
  return this._style.getStroke();
};
ol_control_CanvasBase.prototype.getFill = function() {
  var t3 = this._style.getFill();
  if (!t3)
    this._style.setFill(new Fill$1({ color: "#fff" }));
  return this._style.getFill();
};
ol_control_CanvasBase.prototype.getTextStroke = function() {
  var t3 = this._style.getText();
  if (!t3)
    t3 = new Text$1({});
  if (!t3.getStroke())
    t3.setStroke(new Stroke$1({ color: "#fff", width: 3 }));
  return t3.getStroke();
};
ol_control_CanvasBase.prototype.getTextFill = function() {
  var t3 = this._style.getText();
  if (!t3)
    t3 = new Text$1({});
  if (!t3.getFill())
    t3.setFill(new Fill$1({ color: "#fff" }));
  return t3.getFill();
};
ol_control_CanvasBase.prototype.getTextFont = function() {
  var t3 = this._style.getText();
  if (!t3)
    t3 = new Text$1({});
  if (!t3.getFont())
    t3.setFont("12px sans-serif");
  return t3.getFont();
};
ol_control_CanvasBase.prototype._draw = function() {
  console.warn("[CanvasBase] draw function not implemented.");
};
function toContext(context2, options) {
  const canvas = context2.canvas;
  options = options ? options : {};
  const pixelRatio = options.pixelRatio || DEVICE_PIXEL_RATIO;
  const size = options.size;
  if (size) {
    canvas.width = size[0] * pixelRatio;
    canvas.height = size[1] * pixelRatio;
    canvas.style.width = size[0] + "px";
    canvas.style.height = size[1] + "px";
  }
  const extent2 = [0, 0, canvas.width, canvas.height];
  const transform2 = scale$3(create$7(), pixelRatio, pixelRatio);
  return new CanvasImmediateRenderer(context2, pixelRatio, extent2, transform2, 0);
}
function interpolatePoint(flatCoordinates, offset2, end, stride, fraction, dest, dimension) {
  let o2, t3;
  const n2 = (end - offset2) / stride;
  if (n2 === 1) {
    o2 = offset2;
  } else if (n2 === 2) {
    o2 = offset2;
    t3 = fraction;
  } else if (n2 !== 0) {
    let x1 = flatCoordinates[offset2];
    let y1 = flatCoordinates[offset2 + 1];
    let length = 0;
    const cumulativeLengths = [0];
    for (let i2 = offset2 + stride; i2 < end; i2 += stride) {
      const x2 = flatCoordinates[i2];
      const y2 = flatCoordinates[i2 + 1];
      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
      cumulativeLengths.push(length);
      x1 = x2;
      y1 = y2;
    }
    const target = fraction * length;
    const index2 = binarySearch(cumulativeLengths, target);
    if (index2 < 0) {
      t3 = (target - cumulativeLengths[-index2 - 2]) / (cumulativeLengths[-index2 - 1] - cumulativeLengths[-index2 - 2]);
      o2 = offset2 + (-index2 - 2) * stride;
    } else {
      o2 = offset2 + index2 * stride;
    }
  }
  dimension = dimension > 1 ? dimension : 2;
  dest = dest ? dest : new Array(dimension);
  for (let i2 = 0; i2 < dimension; ++i2) {
    dest[i2] = o2 === void 0 ? NaN : t3 === void 0 ? flatCoordinates[o2 + i2] : lerp$2(flatCoordinates[o2 + i2], flatCoordinates[o2 + stride + i2], t3);
  }
  return dest;
}
function lineStringCoordinateAtM(flatCoordinates, offset2, end, stride, m2, extrapolate) {
  if (end == offset2) {
    return null;
  }
  let coordinate;
  if (m2 < flatCoordinates[offset2 + stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(offset2, offset2 + stride);
      coordinate[stride - 1] = m2;
      return coordinate;
    }
    return null;
  } else if (flatCoordinates[end - 1] < m2) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(end - stride, end);
      coordinate[stride - 1] = m2;
      return coordinate;
    }
    return null;
  }
  if (m2 == flatCoordinates[offset2 + stride - 1]) {
    return flatCoordinates.slice(offset2, offset2 + stride);
  }
  let lo = offset2 / stride;
  let hi = end / stride;
  while (lo < hi) {
    const mid = lo + hi >> 1;
    if (m2 < flatCoordinates[(mid + 1) * stride - 1]) {
      hi = mid;
    } else {
      lo = mid + 1;
    }
  }
  const m0 = flatCoordinates[lo * stride - 1];
  if (m2 == m0) {
    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);
  }
  const m1 = flatCoordinates[(lo + 1) * stride - 1];
  const t3 = (m2 - m0) / (m1 - m0);
  coordinate = [];
  for (let i2 = 0; i2 < stride - 1; ++i2) {
    coordinate.push(lerp$2(flatCoordinates[(lo - 1) * stride + i2], flatCoordinates[lo * stride + i2], t3));
  }
  coordinate.push(m2);
  return coordinate;
}
function lineStringsCoordinateAtM(flatCoordinates, offset2, ends, stride, m2, extrapolate, interpolate) {
  if (interpolate) {
    return lineStringCoordinateAtM(flatCoordinates, offset2, ends[ends.length - 1], stride, m2, extrapolate);
  }
  let coordinate;
  if (m2 < flatCoordinates[stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(0, stride);
      coordinate[stride - 1] = m2;
      return coordinate;
    }
    return null;
  }
  if (flatCoordinates[flatCoordinates.length - 1] < m2) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);
      coordinate[stride - 1] = m2;
      return coordinate;
    }
    return null;
  }
  for (let i2 = 0, ii = ends.length; i2 < ii; ++i2) {
    const end = ends[i2];
    if (offset2 == end) {
      continue;
    }
    if (m2 < flatCoordinates[offset2 + stride - 1]) {
      return null;
    } else if (m2 <= flatCoordinates[end - 1]) {
      return lineStringCoordinateAtM(flatCoordinates, offset2, end, stride, m2, false);
    }
    offset2 = end;
  }
  return null;
}
class LineString$1 extends SimpleGeometry {
  constructor(coordinates2, layout) {
    super();
    this.flatMidpoint_ = null;
    this.flatMidpointRevision_ = -1;
    this.maxDelta_ = -1;
    this.maxDeltaRevision_ = -1;
    if (layout !== void 0 && !Array.isArray(coordinates2[0])) {
      this.setFlatCoordinates(layout, coordinates2);
    } else {
      this.setCoordinates(coordinates2, layout);
    }
  }
  appendCoordinate(coordinate) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = coordinate.slice();
    } else {
      extend$3(this.flatCoordinates, coordinate);
    }
    this.changed();
  }
  clone() {
    const lineString = new LineString$1(this.flatCoordinates.slice(), this.layout);
    lineString.applyProperties(this);
    return lineString;
  }
  closestPointXY(x2, y2, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x2, y2)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(maxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
      this.maxDeltaRevision_ = this.getRevision();
    }
    return assignClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, false, x2, y2, closestPoint, minSquaredDistance);
  }
  forEachSegment(callback) {
    return forEach(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback);
  }
  getCoordinateAtM(m2, extrapolate) {
    if (this.layout != "XYM" && this.layout != "XYZM") {
      return null;
    }
    extrapolate = extrapolate !== void 0 ? extrapolate : false;
    return lineStringCoordinateAtM(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, m2, extrapolate);
  }
  getCoordinates() {
    return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  }
  getCoordinateAt(fraction, dest) {
    return interpolatePoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, fraction, dest, this.stride);
  }
  getLength() {
    return lineStringLength(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  }
  getFlatMidpoint() {
    if (this.flatMidpointRevision_ != this.getRevision()) {
      this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);
      this.flatMidpointRevision_ = this.getRevision();
    }
    return this.flatMidpoint_;
  }
  getSimplifiedGeometryInternal(squaredTolerance) {
    const simplifiedFlatCoordinates = [];
    simplifiedFlatCoordinates.length = douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
    return new LineString$1(simplifiedFlatCoordinates, "XY");
  }
  getType() {
    return "LineString";
  }
  intersectsExtent(extent2) {
    return intersectsLineString(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent2);
  }
  setCoordinates(coordinates2, layout) {
    this.setLayout(layout, coordinates2, 1);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates2, this.stride);
    this.changed();
  }
}
var ol_legend_Item = function(options) {
  options = options || {};
  BaseObject.call(this, options);
  if (options.feature)
    this.set("feature", options.feature.clone());
};
ol_ext_inherits(ol_legend_Item, BaseObject);
ol_legend_Item.prototype.setTitle = function(title) {
  this.set("title", title || "");
  this.changed();
};
ol_legend_Item.prototype.getElement = function(size, onclick) {
  var element = ol_ext_element.create("LI", {
    className: this.get("className"),
    click: function(e2) {
      onclick(false);
      e2.stopPropagation();
    },
    style: { height: size[1] + "px" },
    "aria-label": this.get("title")
  });
  ol_ext_element.create("DIV", {
    click: function(e2) {
      onclick(true);
      e2.stopPropagation();
    },
    style: {
      width: size[0] + "px",
      height: size[1] + "px"
    },
    parent: element
  });
  return element;
};
if (window.ol && !ol.legend) {
  ol.legend = {};
}
var ol_legend_Legend = function(options) {
  options = options || {};
  BaseObject.call(this);
  this._items = new Collection();
  var listeners = [];
  var tout;
  this._items.on("add", function(e2) {
    listeners.push({
      item: e2.element,
      on: e2.element.on("change", function() {
        this.refresh();
      }.bind(this))
    });
    if (tout) {
      clearTimeout(tout);
      tout = null;
    }
    tout = setTimeout(function() {
      this.refresh();
    }.bind(this), 0);
  }.bind(this));
  this._items.on("remove", function(e2) {
    for (var i2 = 0; i2 < listeners; i2++) {
      if (e2.element === listeners[i2].item) {
        unByKey(listeners[i2].on);
        listeners.splice(i2, 1);
        break;
      }
    }
    if (tout) {
      clearTimeout(tout);
      tout = null;
    }
    tout = setTimeout(function() {
      this.refresh();
    }.bind(this), 0);
  }.bind(this));
  this._listElement = ol_ext_element.create("UL", {
    className: "ol-legend"
  });
  this._canvas = document.createElement("canvas");
  this.set("size", options.size || [40, 25], true);
  this.set("margin", options.margin === 0 ? 0 : options.margin || 10, true);
  this._textStyle = options.textStyle || new Text$1({
    font: "16px sans-serif",
    fill: new Fill$1({
      color: "#333"
    }),
    backgroundFill: new Fill$1({
      color: "rgba(255,255,255,.8)"
    })
  });
  this._title = new ol_legend_Item({ title: options.title || "", className: "ol-title" });
  if (options.titleStyle) {
    this._titleStyle = options.titleStyle;
  } else {
    this._titleStyle = this._textStyle.clone();
    this._titleStyle.setFont("bold " + this._titleStyle.getFont());
  }
  this.setStyle(options.style);
  if (options.items instanceof Array) {
    options.items.forEach(function(item) {
      this.addItem(item);
    }.bind(this));
  }
  this.refresh();
};
ol_ext_inherits(ol_legend_Legend, BaseObject);
ol_legend_Legend.prototype.setTitle = function(title) {
  this._title.setTitle(title);
  this.refresh();
};
ol_legend_Legend.prototype.getTitle = function() {
  return this._title.get("title");
};
ol_legend_Legend.prototype.getTextStyle = function() {
  return this._textStyle;
};
ol_legend_Legend.prototype.set = function(key, value, opt_silent) {
  BaseObject.prototype.set.call(this, key, value, opt_silent);
  if (!opt_silent)
    this.refresh();
};
ol_legend_Legend.prototype.getListElement = function() {
  return this._listElement;
};
ol_legend_Legend.prototype.getCanvas = function() {
  return this._canvas;
};
ol_legend_Legend.prototype.setStyle = function(style2) {
  this._style = style2;
  this.refresh();
};
ol_legend_Legend.prototype.addItem = function(item) {
  if (item instanceof ol_legend_Item) {
    this._items.push(item);
  } else {
    this._items.push(new ol_legend_Item(item));
  }
};
ol_legend_Legend.prototype.getItems = function() {
  return this._items;
};
ol_legend_Legend.prototype._drawText = function(ctx, text2, x2, y2) {
  ctx.save();
  ctx.scale(DEVICE_PIXEL_RATIO, DEVICE_PIXEL_RATIO);
  text2 = text2 || "";
  var txt = text2.split("\n");
  if (txt.length === 1) {
    ctx.fillText(text2, x2, y2);
  } else {
    ctx.textBaseline = "bottom";
    ctx.fillText(txt[0], x2, y2);
    ctx.textBaseline = "top";
    ctx.fillText(txt[1], x2, y2);
  }
  ctx.restore();
};
ol_legend_Legend.prototype._measureText = function(ctx, text2) {
  var txt = (text2 || "").split("\n");
  if (txt.length === 1) {
    return ctx.measureText(text2);
  } else {
    var m1 = ctx.measureText(txt[0]);
    var m2 = ctx.measureText(txt[1]);
    return { width: Math.max(m1.width, m2.width), height: m1.height + m2.height };
  }
};
ol_legend_Legend.prototype.refresh = function() {
  var table = this._listElement;
  table.innerHTML = "";
  var margin = this.get("margin");
  var width = this.get("size")[0] + 2 * margin;
  var height = this.get("lineHeight") || this.get("size")[1] + 2 * margin;
  var canvas = this.getCanvas();
  var ctx = canvas.getContext("2d");
  ctx.textAlign = "left";
  ctx.textBaseline = "middle";
  var ratio = DEVICE_PIXEL_RATIO;
  ctx.font = this._titleStyle.getFont();
  var textWidth = this._measureText(ctx, this.getTitle("title")).width;
  this._items.forEach(function(r2) {
    if (r2.get("feature") || r2.get("typeGeom")) {
      ctx.font = r2.get("textStyle") ? r2.get("textStyle").getFont() : this._textStyle.getFont();
      textWidth = Math.max(textWidth, this._measureText(ctx, r2.get("title")).width + width);
    } else {
      ctx.font = r2.get("textStyle") ? r2.get("textStyle").getFont() : this._titleStyle.getFont();
      textWidth = Math.max(textWidth, this._measureText(ctx, r2.get("title")).width);
    }
  }.bind(this));
  canvas.width = (textWidth + 2 * margin) * ratio;
  canvas.height = (this._items.getLength() + 1) * height * ratio;
  canvas.style.height = (this._items.getLength() + 1) * height + "px";
  ctx.textBaseline = "middle";
  ctx.fillStyle = asString$1(this._textStyle.getFill().getColor());
  if (this.getTitle()) {
    table.appendChild(this._title.getElement([width, height], function(b2) {
      this.dispatchEvent({
        type: "select",
        index: -1,
        symbol: b2,
        item: this._title
      });
    }.bind(this)));
    ctx.font = this._titleStyle.getFont();
    ctx.textAlign = "center";
    this._drawText(ctx, this.getTitle(), canvas.width / ratio / 2, height / 2);
  }
  this._items.forEach(function(r2, i2) {
    var index2 = i2 + (this.getTitle() ? 1 : 0);
    table.appendChild(r2.getElement([width, height], function(b2) {
      this.dispatchEvent({
        type: "select",
        index: i2,
        symbol: b2,
        item: r2
      });
    }.bind(this)));
    var item = r2.getProperties();
    ctx.textAlign = "left";
    if (item.feature || item.typeGeom) {
      canvas = this.getLegendImage(item, canvas, index2);
      ctx.font = r2.get("textStyle") ? r2.get("textStyle").getFont() : this._textStyle.getFont();
      this._drawText(ctx, r2.get("title"), width + margin, (i2 + 1.5) * height);
    } else {
      ctx.font = r2.get("textStyle") ? r2.get("textStyle").getFont() : this._titleStyle.getFont();
      if (/\bcenter\b/.test(item.className)) {
        ctx.textAlign = "center";
        this._drawText(ctx, r2.get("title"), canvas.width / ratio / 2, (i2 + 1.5) * height);
      } else {
        this._drawText(ctx, r2.get("title"), margin, (i2 + 1.5) * height);
      }
    }
  }.bind(this));
  this.dispatchEvent({
    type: "refresh",
    width,
    height: (this._items.length + 1) * height
  });
};
ol_legend_Legend.prototype.getLegendImage = function(options, canvas, row) {
  options = options || {};
  return ol_legend_Legend.getLegendImage({
    className: options.className,
    feature: options.feature,
    typeGeom: options.typeGeom,
    style: options.style || this._style,
    properties: options.properties,
    margin: options.margin || this.get("margin"),
    size: options.size || this.get("size"),
    lineHeight: options.lineHeight || this.get("lineHeight"),
    onload: function() {
      this.refresh();
    }.bind(this)
  }, canvas, row);
};
ol_legend_Legend.getLegendImage = function(item, canvas, row) {
  item = item || {};
  if (typeof item.margin === "undefined")
    item.margin = 10;
  var size = item.size || [40, 25];
  item.onload = item.onload || function() {
    setTimeout(function() {
      ol_legend_Legend.getLegendImage(item, canvas, row);
    }, 100);
  };
  var width = size[0] + 2 * item.margin;
  var height = item.lineHeight || size[1] + 2 * item.margin;
  var ratio = DEVICE_PIXEL_RATIO;
  if (!canvas) {
    row = 0;
    canvas = document.createElement("canvas");
    canvas.width = width * ratio;
    canvas.height = height * ratio;
  }
  var ctx = canvas.getContext("2d");
  ctx.save();
  var vectorContext = toContext(ctx, { pixelRatio: ratio });
  var typeGeom = item.typeGeom;
  var style2;
  var feature = item.feature;
  if (!feature && typeGeom) {
    if (/Point/.test(typeGeom))
      feature = new Feature$1(new Point$3([0, 0]));
    else if (/LineString/.test(typeGeom))
      feature = new Feature$1(new LineString$1([0, 0]));
    else
      feature = new Feature$1(new Polygon$1([[0, 0]]));
    if (item.properties)
      feature.setProperties(item.properties);
  }
  if (feature) {
    style2 = feature.getStyle();
    if (typeof style2 === "function")
      style2 = style2(feature);
    if (!style2) {
      style2 = typeof item.style === "function" ? item.style(feature) : item.style || [];
    }
    typeGeom = feature.getGeometry().getType();
  } else {
    style2 = [];
  }
  if (!(style2 instanceof Array))
    style2 = [style2];
  var cx = width / 2;
  var cy = height / 2;
  var sx = size[0] / 2;
  var sy = size[1] / 2;
  var i2, s2;
  if (typeGeom === "Point") {
    var extent2 = null;
    for (i2 = 0; s2 = style2[i2]; i2++) {
      var img = s2.getImage();
      if (img) {
        var imgElt = img.getImage();
        if (imgElt && imgElt.complete && !imgElt.naturalWidth) {
          if (typeof item.onload === "function") {
            imgElt.addEventListener("load", function() {
              setTimeout(function() {
                item.onload();
              }, 100);
            });
          }
          img.load();
        }
        if (img.getAnchor) {
          var anchor = img.getAnchor();
          if (anchor) {
            var si = img.getSize();
            var dx = anchor[0] - si[0];
            var dy = anchor[1] - si[1];
            if (!extent2) {
              extent2 = [dx, dy, dx + si[0], dy + si[1]];
            } else {
              extend$2(extent2, [dx, dy, dx + si[0], dy + si[1]]);
            }
          }
        }
      }
    }
    if (extent2) {
      cx = cx + (extent2[2] + extent2[0]) / 2;
      cy = cy + (extent2[3] + extent2[1]) / 2;
    }
  }
  cy += row * height || 0;
  for (i2 = 0; s2 = style2[i2]; i2++) {
    vectorContext.setStyle(s2);
    switch (typeGeom) {
      case Point$3:
      case "Point":
      case "MultiPoint":
        vectorContext.drawGeometry(new Point$3([cx, cy]));
        break;
      case LineString$1:
      case "LineString":
      case "MultiLineString":
        ctx.save();
        ctx.rect(item.margin * ratio, 0, size[0] * ratio, canvas.height);
        ctx.clip();
        vectorContext.drawGeometry(new LineString$1([[cx - sx, cy], [cx + sx, cy]]));
        ctx.restore();
        break;
      case Polygon$1:
      case "Polygon":
      case "MultiPolygon":
        vectorContext.drawGeometry(new Polygon$1([[[cx - sx, cy - sy], [cx + sx, cy - sy], [cx + sx, cy + sy], [cx - sx, cy + sy], [cx - sx, cy - sy]]]));
        break;
    }
  }
  ctx.restore();
  return canvas;
};
var ol_control_Legend = function(options) {
  options = options || {};
  var element = document.createElement("div");
  if (options.target) {
    element.className = options.className || "ol-legend";
  } else {
    element.className = (options.className || "ol-legend") + " ol-unselectable ol-control" + (options.collapsible === false ? " ol-uncollapsible" : " ol-collapsed");
    var button = document.createElement("button");
    button.setAttribute("type", "button");
    button.addEventListener("click", function() {
      this.toggle();
    }.bind(this));
    element.appendChild(button);
    button = document.createElement("button");
    button.setAttribute("type", "button");
    button.className = "ol-closebox";
    button.addEventListener("click", function() {
      this.toggle();
    }.bind(this));
    element.appendChild(button);
  }
  ol_control_CanvasBase.call(this, {
    element,
    target: options.target
  });
  this._legend = options.legend;
  this._legend.getCanvas().className = "ol-legendImg";
  element.appendChild(this._legend.getCanvas());
  element.appendChild(this._legend.getListElement());
  if (options.collapsible !== false && options.collapsed === false)
    this.show();
  this._legend.on("select", function(e2) {
    this.dispatchEvent(e2);
  }.bind(this));
  this._legend.on("refresh", function() {
    if (this._onCanvas && this.getMap()) {
      try {
        this.getMap().renderSync();
      } catch (e2) {
      }
    }
  }.bind(this));
};
ol_ext_inherits(ol_control_Legend, ol_control_CanvasBase);
ol_control_Legend.prototype.getLegend = function() {
  return this._legend;
};
ol_control_Legend.prototype.setCanvas = function(b2) {
  this._onCanvas = b2;
  this.element.style.visibility = b2 ? "hidden" : "visible";
  if (this.getMap()) {
    try {
      this.getMap().renderSync();
    } catch (e2) {
    }
  }
};
ol_control_Legend.prototype.onCanvas = function() {
  return !!this._onCanvas;
};
ol_control_Legend.prototype._draw = function(e2) {
  if (this._onCanvas && !this.element.classList.contains("ol-collapsed")) {
    var canvas = this._legend.getCanvas();
    var ctx = this.getContext(e2);
    var h2 = ctx.canvas.height - canvas.height;
    ctx.save();
    ctx.rect(0, h2, canvas.width, canvas.height);
    var col = "#fff";
    if (this._legend.getTextStyle().getBackgroundFill()) {
      col = asString$1(this._legend.getTextStyle().getBackgroundFill().getColor());
    }
    ctx.fillStyle = ctx.strokeStyle = col;
    ctx.lineWidth = 10;
    ctx.lineJoin = "round";
    ctx.stroke();
    ctx.clearRect(0, h2, canvas.width, canvas.height);
    ctx.fill();
    ctx.drawImage(canvas, 0, h2);
    ctx.restore();
  }
};
ol_control_Legend.prototype.show = function() {
  if (this.element.classList.contains("ol-collapsed")) {
    this.element.classList.remove("ol-collapsed");
    this.dispatchEvent({ type: "change:collapse", collapsed: false });
    if (this.getMap()) {
      try {
        this.getMap().renderSync();
      } catch (e2) {
      }
    }
  }
};
ol_control_Legend.prototype.hide = function() {
  if (!this.element.classList.contains("ol-collapsed")) {
    this.element.classList.add("ol-collapsed");
    this.dispatchEvent({ type: "change:collapse", collapsed: true });
    if (this.getMap()) {
      try {
        this.getMap().renderSync();
      } catch (e2) {
      }
    }
  }
};
ol_control_Legend.prototype.collapse = function(b2) {
  if (b2 === false)
    this.show();
  else
    this.hide();
};
ol_control_Legend.prototype.isCollapsed = function() {
  return this.element.classList.contains("ol-collapsed");
};
ol_control_Legend.prototype.toggle = function() {
  this.element.classList.toggle("ol-collapsed");
  this.dispatchEvent({ type: "change:collapse", collapsed: this.element.classList.contains("ol-collapsed") });
  if (this.getMap()) {
    try {
      this.getMap().renderSync();
    } catch (e2) {
    }
  }
};
var ol_control_Print = function(options) {
  if (!options)
    options = {};
  var element = ol_ext_element.create("DIV", {
    className: options.className || "ol-print"
  });
  if (!options.target) {
    element.classList.add("ol-unselectable", "ol-control");
    ol_ext_element.create("BUTTON", {
      type: "button",
      title: options.title || "Print",
      click: function() {
        this.print();
      }.bind(this),
      parent: element
    });
  }
  Control$1.call(this, {
    element,
    target: options.target
  });
  this.set("immediate", options.immediate);
  this.set("imageType", options.imageType || "image/jpeg");
  this.set("quality", options.quality || 0.8);
  this.set("orientation", options.orientation);
};
ol_ext_inherits(ol_control_Print, Control$1);
ol_control_Print.prototype.toClipboard = function(e2, callback) {
  try {
    e2.canvas.toBlob(function(blob) {
      try {
        navigator.clipboard.write([
          new window.ClipboardItem(Object.defineProperty({}, blob.type, {
            value: blob,
            enumerable: true
          }))
        ]);
        if (typeof callback === "function")
          callback(true);
      } catch (err2) {
        if (typeof callback === "function")
          callback(false);
      }
    });
  } catch (err2) {
    if (typeof callback === "function")
      callback(false);
  }
};
ol_control_Print.prototype.copyMap = function(options, callback) {
  this.once("print", function(e2) {
    this.toClipboard(e2, callback);
  }.bind(this));
  this.print(options);
};
ol_control_Print.prototype._getCanvas = function(event, imageType, canvas) {
  var ctx;
  if (event.context) {
    canvas = event.context.canvas;
  } else {
    if (!canvas) {
      canvas = document.createElement("canvas");
      var size = this.getMap().getSize();
      canvas.width = size[0];
      canvas.height = size[1];
      ctx = canvas.getContext("2d");
      if (/jp.*g$/.test(imageType)) {
        ctx.fillStyle = this.get("bgColor") || "white";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
    } else {
      ctx = canvas.getContext("2d");
    }
    this.getMap().getViewport().querySelectorAll(".ol-layers canvas, canvas.ol-fixedoverlay").forEach(function(c2) {
      if (c2.width) {
        ctx.save();
        if (c2.parentNode.style.opacity === "0")
          return;
        ctx.globalAlpha = parseFloat(c2.parentNode.style.opacity) || 1;
        if (ol_ext_element.getStyle(c2.parentNode, "mix-blend-mode") === "multiply") {
          ctx.globalCompositeOperation = "multiply";
        }
        var tr = ol_ext_element.getStyle(c2, "transform") || ol_ext_element.getStyle(c2, "-webkit-transform");
        if (/^matrix/.test(tr)) {
          tr = tr.replace(/^matrix\(|\)$/g, "").split(",");
          tr.forEach(function(t3, i2) {
            tr[i2] = parseFloat(t3);
          });
          ctx.transform(tr[0], tr[1], tr[2], tr[3], tr[4], tr[5]);
          ctx.drawImage(c2, 0, 0);
        } else {
          ctx.drawImage(c2, 0, 0, ol_ext_element.getStyle(c2, "width"), ol_ext_element.getStyle(c2, "height"));
        }
        ctx.restore();
      }
    }.bind(this));
  }
  return canvas;
};
ol_control_Print.prototype.fastPrint = function(options, callback) {
  options = options || {};
  if (this._ol6) {
    requestAnimationFrame(function() {
      callback(this._getCanvas({}, options.imageType, options.canvas));
    }.bind(this));
  } else {
    this.getMap().once("postcompose", function(event) {
      if (!event.context)
        this._ol6 = true;
      callback(this._getCanvas(event, options.imageType, options.canvas));
    }.bind(this));
    this.getMap().render();
  }
};
ol_control_Print.prototype.print = function(options) {
  options = options || {};
  var imageType = options.imageType || this.get("imageType");
  var quality = options.quality || this.get("quality");
  if (this.getMap()) {
    if (options.immediate !== "silent") {
      this.dispatchEvent(Object.assign({
        type: "printing"
      }, options));
    }
    if (!options.immediate) {
      setTimeout(function() {
        options = Object.assign({}, options);
        options.immediate = "silent";
        this.print(options);
      }.bind(this), 200);
      return;
    }
    this.getMap().once(this.get("immediate") ? "postcompose" : "rendercomplete", function(event) {
      var canvas = this._getCanvas(event, imageType);
      var size = options.size || [210, 297];
      var format2 = options.format || "a4";
      var w2, h2, position2;
      var orient = options.orient || this.get("orientation");
      var margin = typeof options.margin === "number" ? options.margin : 10;
      if (canvas) {
        if (orient !== "landscape" && orient !== "portrait") {
          orient = canvas.width > canvas.height ? "landscape" : "portrait";
        }
        if (orient === "landscape")
          size = [size[1], size[0]];
        var sc = Math.min((size[0] - 2 * margin) / canvas.width, (size[1] - 2 * margin) / canvas.height);
        w2 = sc * canvas.width;
        h2 = sc * canvas.height;
        position2 = [(size[0] - w2) / 2, (size[1] - h2) / 2];
      }
      var image2;
      try {
        image2 = canvas ? canvas.toDataURL(imageType, quality) : null;
      } catch (e3) {
        this.dispatchEvent({
          type: "error",
          canvas
        });
        return;
      }
      var e2 = Object.assign({
        type: "print",
        print: {
          format: format2,
          orientation: orient,
          unit: "mm",
          size,
          position: position2,
          imageWidth: w2,
          imageHeight: h2
        },
        image: image2,
        imageType,
        quality,
        canvas
      }, options);
      this.dispatchEvent(e2);
    }.bind(this));
    this.getMap().render();
  }
};
var ol_control_CanvasTitle = function(options) {
  if (!options)
    options = {};
  var elt = ol_ext_element.create("DIV", {
    className: (options.className || "") + " ol-control-title ol-unselectable",
    style: {
      display: "block",
      visibility: "hidden"
    }
  });
  ol_control_CanvasBase.call(this, {
    element: elt,
    style: options.style
  });
  this.setTitle(options.title || "");
  this.setVisible(options.visible);
  this.element.style.font = this.getTextFont();
};
ol_ext_inherits(ol_control_CanvasTitle, ol_control_CanvasBase);
ol_control_CanvasTitle.prototype.setStyle = function(style2) {
  ol_control_CanvasBase.prototype.setStyle.call(this, style2);
  if (this.element) {
    this.element.style.font = this.getTextFont();
  }
  if (this.getMap())
    this.getMap().render();
};
ol_control_CanvasTitle.prototype.setTitle = function(title) {
  this.element.textContent = title;
  this.set("title", title);
  if (this.getMap()) {
    try {
      this.getMap().renderSync();
    } catch (e2) {
    }
  }
};
ol_control_CanvasTitle.prototype.getTitle = function() {
  return this.get("title");
};
ol_control_CanvasTitle.prototype.setVisible = function(b2) {
  this.element.style.display = b2 ? "block" : "none";
  if (this.getMap()) {
    try {
      this.getMap().renderSync();
    } catch (e2) {
    }
  }
};
ol_control_CanvasTitle.prototype.getVisible = function() {
  return this.element.style.display !== "none";
};
ol_control_CanvasTitle.prototype._draw = function(e2) {
  if (!this.getVisible())
    return;
  var ctx = this.getContext(e2);
  if (!ctx)
    return;
  var ratio = e2.frameState.pixelRatio;
  ctx.save();
  ctx.scale(ratio, ratio);
  var eltRect = this.element.getBoundingClientRect();
  var mapRect = this.getMap().getViewport().getBoundingClientRect();
  var sc = this.getMap().getSize()[0] / mapRect.width;
  ctx.translate(Math.round((eltRect.left - mapRect.left) * sc), Math.round((eltRect.top - mapRect.top) * sc));
  var h2 = this.element.clientHeight;
  var w2 = this.element.clientWidth;
  var left = w2 / 2;
  ctx.beginPath();
  ctx.fillStyle = asString$1(this.getFill().getColor());
  ctx.rect(0, 0, w2, h2);
  ctx.fill();
  ctx.closePath();
  ctx.beginPath();
  ctx.fillStyle = asString$1(this.getTextFill().getColor());
  ctx.strokeStyle = asString$1(this.getTextStroke().getColor());
  ctx.lineWidth = this.getTextStroke().getWidth();
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.font = this.getTextFont();
  if (ctx.lineWidth)
    ctx.strokeText(this.getTitle(), left, h2 / 2);
  ctx.fillText(this.getTitle(), left, h2 / 2);
  ctx.closePath();
  ctx.restore();
};
var ol_sphere_getMapScale = function(map, dpi) {
  var view = map.getView();
  var proj = view.getProjection();
  var center = view.getCenter();
  var px = map.getPixelFromCoordinate(center);
  px[1] += 1;
  var coord = map.getCoordinateFromPixel(px);
  var d2 = getDistance(transform$3(center, proj, "EPSG:4326"), transform$3(coord, proj, "EPSG:4326"));
  d2 *= (dpi || 96) / 0.0254;
  return d2;
};
var ol_sphere_setMapScale = function(map, scale2, dpi) {
  if (map && scale2) {
    var fac = scale2;
    if (typeof scale2 === "string") {
      fac = scale2.split("/")[1];
      if (!fac)
        fac = scale2;
      fac = fac.replace(/[^\d]/g, "");
      fac = parseInt(fac);
    }
    if (!fac)
      return;
    var view = map.getView();
    var proj = view.getProjection();
    var center = view.getCenter();
    var px = map.getPixelFromCoordinate(center);
    px[1] += 1;
    var coord = map.getCoordinateFromPixel(px);
    var d2 = getDistance(transform$3(center, proj, "EPSG:4326"), transform$3(coord, proj, "EPSG:4326"));
    d2 *= (dpi || 96) / 0.0254;
    view.setResolution(view.getResolution() * fac / d2);
    return fac;
  }
};
var ol_control_Compass = function(options) {
  if (!options)
    options = {};
  var elt = document.createElement("div");
  elt.className = "ol-control ol-compassctrl ol-unselectable ol-hidden" + (options.className ? " " + options.className : "");
  elt.style.position = "absolute";
  elt.style.visibility = "hidden";
  var style2 = options.style instanceof Stroke$1 ? new Style$1({ stroke: options.style }) : options.style;
  if (!options.style) {
    style2 = new Style$1({ stroke: new Stroke$1({ width: 0 }) });
  }
  ol_control_CanvasBase.call(this, {
    element: elt,
    style: style2
  });
  this.set("rotateVithView", options.rotateWithView !== false);
  this.setVisible(options.visible !== false);
  this.setImage(options.image || options.src);
};
ol_ext_inherits(ol_control_Compass, ol_control_CanvasBase);
ol_control_Compass.prototype.setImage = function(img) {
  if (img instanceof Image) {
    this.img_ = img;
    this.img_.onload = function() {
      if (this.getMap()) {
        try {
          this.getMap().renderSync();
        } catch (e2) {
        }
      }
    }.bind(this);
  } else if (typeof img === "string") {
    switch (img) {
      case "compact": {
        this.img_ = this.compactCompass_(this.element.clientWidth, this.getStroke().getColor());
        break;
      }
      case "default": {
        this.img_ = this.defaultCompass_(this.element.clientWidth, this.getStroke().getColor());
        break;
      }
      default: {
        this.img_ = new Image();
        this.img_.onload = function() {
          if (this.getMap()) {
            try {
              this.getMap().renderSync();
            } catch (e2) {
            }
          }
        }.bind(this);
        this.img_.src = img;
        break;
      }
    }
  } else {
    this.img_ = this.defaultCompass_(this.element.clientWidth, this.getStroke().getColor());
  }
};
ol_control_Compass.prototype.compactCompass_ = function(s2, color2) {
  var canvas = document.createElement("canvas");
  var ctx = canvas.getContext("2d");
  s2 = canvas.width = canvas.height = s2 || 150;
  var r2 = s2 / 2;
  ctx.translate(r2, r2);
  ctx.fillStyle = color2 || "#963";
  ctx.lineWidth = 5;
  ctx.lineJoin = ctx.lineCap = "round";
  ctx.font = "bold " + r2 * 0.4 + "px sans-serif";
  ctx.textBaseline = "bottom";
  ctx.textAlign = "center";
  ctx.strokeStyle = "#fff";
  ctx.globalAlpha = 0.75;
  ctx.strokeText("N", 0, -r2 / 2);
  ctx.globalAlpha = 1;
  ctx.fillText("N", 0, -r2 / 2);
  ctx.beginPath();
  ctx.moveTo(0, r2 / 4);
  ctx.lineTo(r2 / 3, r2 / 2);
  ctx.lineTo(0, -r2 / 2);
  ctx.lineTo(-r2 / 3, r2 / 2);
  ctx.lineTo(0, r2 / 4);
  ctx.lineWidth = 12;
  ctx.fillStyle = "#fff";
  ctx.globalAlpha = 0.75;
  ctx.fill();
  ctx.stroke();
  ctx.globalAlpha = 1;
  ctx.fillStyle = ctx.strokeStyle = color2 || "#963";
  ctx.lineWidth = 5;
  ctx.beginPath();
  ctx.moveTo(0, r2 / 4);
  ctx.lineTo(0, -r2 / 2);
  ctx.lineTo(r2 / 3, r2 / 2);
  ctx.lineTo(0, r2 / 4);
  ctx.fill();
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(0, r2 / 4);
  ctx.lineTo(0, -r2 / 2);
  ctx.lineTo(-r2 / 3, r2 / 2);
  ctx.lineTo(0, r2 / 4);
  ctx.stroke();
  return canvas;
};
ol_control_Compass.prototype.defaultCompass_ = function(s2, color2) {
  var canvas = document.createElement("canvas");
  var ctx = canvas.getContext("2d");
  s2 = canvas.width = canvas.height = s2 || 150;
  var r2 = s2 / 2;
  var r22 = 0.22 * r2;
  function draw(r3, r23) {
    ctx.fillStyle = color2 || "#963";
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(r3, 0);
    ctx.lineTo(r23, r23);
    ctx.moveTo(0, 0);
    ctx.lineTo(-r3, 0);
    ctx.lineTo(-r23, -r23);
    ctx.moveTo(0, 0);
    ctx.lineTo(0, r3);
    ctx.lineTo(-r23, r23);
    ctx.moveTo(0, 0);
    ctx.lineTo(0, -r3);
    ctx.lineTo(r23, -r23);
    ctx.moveTo(0, 0);
    ctx.fill();
    ctx.stroke();
  }
  function draw2(r3, r23) {
    ctx.globalCompositeOperation = "destination-out";
    ctx.fillStyle = "#fff";
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(r3, 0);
    ctx.lineTo(r23, -r23);
    ctx.moveTo(0, 0);
    ctx.lineTo(-r3, 0);
    ctx.lineTo(-r23, r23);
    ctx.moveTo(0, 0);
    ctx.lineTo(0, r3);
    ctx.lineTo(r23, r23);
    ctx.moveTo(0, 0);
    ctx.lineTo(0, -r3);
    ctx.lineTo(-r23, -r23);
    ctx.moveTo(0, 0);
    ctx.fill();
    ctx.globalCompositeOperation = "source-over";
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(r3, 0);
    ctx.lineTo(r23, -r23);
    ctx.moveTo(0, 0);
    ctx.lineTo(-r3, 0);
    ctx.lineTo(-r23, r23);
    ctx.moveTo(0, 0);
    ctx.lineTo(0, r3);
    ctx.lineTo(r23, r23);
    ctx.moveTo(0, 0);
    ctx.lineTo(0, -r3);
    ctx.lineTo(-r23, -r23);
    ctx.moveTo(0, 0);
    ctx.stroke();
  }
  ctx.translate(r2, r2);
  ctx.strokeStyle = color2 || "#963";
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.arc(0, 0, s2 * 0.41, 0, 2 * Math.PI);
  ctx.arc(0, 0, s2 * 0.44, 0, 2 * Math.PI);
  ctx.stroke();
  ctx.rotate(Math.PI / 4);
  draw(r2 * 0.9, r22 * 0.8);
  draw2(r2 * 0.9, r22 * 0.8);
  ctx.rotate(-Math.PI / 4);
  draw(r2, r22);
  draw2(r2, r22);
  return canvas;
};
ol_control_Compass.prototype.getVisible = function() {
  return ol_ext_element.getStyle(this.element, "display") === "block";
};
ol_control_Compass.prototype.setVisible = function(b2) {
  if (b2)
    this.element.classList.add("ol-visible");
  else
    this.element.classList.remove("ol-visible");
  if (this.getMap())
    this.getMap().render();
};
ol_control_Compass.prototype._draw = function(e2) {
  var ctx = this.getContext(e2);
  if (!ctx || !this.getVisible())
    return;
  var canvas = ctx.canvas;
  var i2, da = [];
  for (i2 = 0; i2 < 8; i2++)
    da[i2] = [Math.cos(Math.PI * i2 / 8), Math.sin(Math.PI * i2 / 8)];
  var ratio = e2.frameState.pixelRatio;
  ctx.save();
  ctx.scale(ratio, ratio);
  var w2 = this.element.clientWidth;
  var h2 = this.element.clientHeight;
  var pos = { left: this.element.offsetLeft, top: this.element.offsetTop };
  var compass = this.img_;
  var rot = e2.frameState.viewState.rotation;
  ctx.beginPath();
  ctx.translate(pos.left + w2 / 2, pos.top + h2 / 2);
  if (this.get("rotateVithView"))
    ctx.rotate(rot);
  if (this.getStroke().getWidth()) {
    ctx.beginPath();
    ctx.strokeStyle = this.getStroke().getColor();
    ctx.lineWidth = this.getStroke().getWidth();
    var m2 = Math.max(canvas.width, canvas.height);
    for (i2 = 0; i2 < 8; i2++) {
      ctx.moveTo(-da[i2][0] * m2, -da[i2][1] * m2);
      ctx.lineTo(da[i2][0] * m2, da[i2][1] * m2);
    }
    ctx.stroke();
  }
  if (compass.width) {
    ctx.drawImage(compass, -w2 / 2, -h2 / 2, w2, h2);
  }
  ctx.closePath();
  ctx.restore();
};
var ol_control_PrintDialog = function(options) {
  if (!options)
    options = {};
  this._lang = options.lang || "en";
  var element = ol_ext_element.create("DIV", {
    className: (options.className || "ol-print") + " ol-unselectable ol-control"
  });
  ol_ext_element.create("BUTTON", {
    type: "button",
    title: options.title || "Print",
    click: function() {
      this.print();
    }.bind(this),
    parent: element
  });
  Control$1.call(this, {
    element
  });
  if (options.openWindow) {
    this.on("print", function(e2) {
      if (e2.canvas) {
        window.open().document.write('<img src="' + e2.canvas.toDataURL() + '"/>');
      }
    });
  }
  options.target = ol_ext_element.create("DIV");
  var printCtrl = this._printCtrl = new ol_control_Print(options);
  printCtrl.on(["print", "error", "printing"], function(e2) {
    content2.setAttribute("data-status", e2.type);
    if (!e2.clipboard) {
      this.dispatchEvent(e2);
    }
  }.bind(this));
  this._compass = new ol_control_Compass({
    src: options.northImage || "compact",
    visible: false,
    className: "olext-print-compass",
    style: new Stroke$1({ color: "#333", width: 0 })
  });
  var printDialog = this._printDialog = new ol_control_Dialog({
    target: document.body,
    closeBox: true,
    className: "ol-ext-print-dialog"
  });
  var content2 = printDialog.getContentElement();
  this._input = {};
  var param = ol_ext_element.create("DIV", {
    className: "ol-print-param",
    parent: content2
  });
  this._pages = [ol_ext_element.create("DIV", {
    className: "ol-page"
  })];
  var printMap = ol_ext_element.create("DIV", {
    className: "ol-map",
    parent: this._pages[0]
  });
  ol_ext_element.create("DIV", {
    html: this._pages[0],
    className: "ol-print-map",
    parent: content2
  });
  ol_ext_element.create("H2", {
    html: this.i18n("title"),
    parent: param
  });
  var ul = ol_ext_element.create("UL", { parent: param });
  var li = ol_ext_element.create("LI", {
    className: "ol-orientation",
    parent: ul
  });
  this._input.orientation = { list: li };
  var label = ol_ext_element.create("LABEL", {
    className: "portrait",
    parent: li
  });
  this._input.orientation.portrait = ol_ext_element.create("INPUT", {
    type: "radio",
    name: "ol-print-orientation",
    value: "portrait",
    checked: true,
    on: { change: function(e2) {
      this.setOrientation(e2.target.value);
    }.bind(this) },
    parent: label
  });
  ol_ext_element.create("SPAN", {
    html: this.i18n("portrait"),
    parent: label
  });
  label = ol_ext_element.create("LABEL", {
    className: "landscape",
    parent: li
  });
  this._input.orientation.landscape = ol_ext_element.create("INPUT", {
    type: "radio",
    name: "ol-print-orientation",
    value: "landscape",
    on: { change: function(e2) {
      this.setOrientation(e2.target.value);
    }.bind(this) },
    parent: label
  });
  ol_ext_element.create("SPAN", {
    html: this.i18n("landscape"),
    parent: label
  });
  var s2;
  li = ol_ext_element.create("LI", {
    html: ol_ext_element.create("LABEL", {
      html: this.i18n("size")
    }),
    className: "ol-size",
    parent: ul
  });
  var size = this._input.size = ol_ext_element.create("SELECT", {
    on: { change: function() {
      this.setSize(size.value || originalSize);
    }.bind(this) },
    parent: li
  });
  for (s2 in this.paperSize) {
    ol_ext_element.create("OPTION", {
      html: s2 + (this.paperSize[s2] ? " - " + this.paperSize[s2][0] + "x" + this.paperSize[s2][1] + " mm" : this.i18n("custom")),
      value: s2,
      parent: size
    });
  }
  li = ol_ext_element.create("LI", {
    html: ol_ext_element.create("LABEL", {
      html: this.i18n("margin")
    }),
    className: "ol-margin",
    parent: ul
  });
  var margin = this._input.margin = ol_ext_element.create("SELECT", {
    on: { change: function() {
      this.setMargin(margin.value);
    }.bind(this) },
    parent: li
  });
  for (s2 in this.marginSize) {
    ol_ext_element.create("OPTION", {
      html: this.i18n(s2) + " - " + this.marginSize[s2] + " mm",
      value: this.marginSize[s2],
      parent: margin
    });
  }
  li = ol_ext_element.create("LI", {
    html: ol_ext_element.create("LABEL", {
      html: this.i18n("scale")
    }),
    className: "ol-scale",
    parent: ul
  });
  var scale2 = this._input.scale = ol_ext_element.create("SELECT", {
    on: { change: function() {
      this.setScale(parseInt(scale2.value));
    }.bind(this) },
    parent: li
  });
  Object.keys(this.scales).forEach(function(s3) {
    ol_ext_element.create("OPTION", {
      html: this.scales[s3],
      value: s3,
      parent: scale2
    });
  }.bind(this));
  li = ol_ext_element.create("LI", {
    className: "ol-legend",
    parent: ul
  });
  var legend = ol_ext_element.createSwitch({
    html: this.i18n("legend"),
    checked: false,
    on: { change: function() {
      extraCtrl.legend.control.setCanvas(legend.checked);
    }.bind(this) },
    parent: li
  });
  li = ol_ext_element.create("LI", {
    className: "ol-print-north",
    parent: ul
  });
  var north = this._input.north = ol_ext_element.createSwitch({
    html: this.i18n("north"),
    checked: "checked",
    on: { change: function() {
      if (north.checked)
        this._compass.element.classList.add("ol-print-compass");
      else
        this._compass.element.classList.remove("ol-print-compass");
      this.getMap().render();
    }.bind(this) },
    parent: li
  });
  li = ol_ext_element.create("LI", {
    className: "ol-print-title",
    parent: ul
  });
  var title = ol_ext_element.createSwitch({
    html: this.i18n("mapTitle"),
    checked: false,
    on: { change: function(e2) {
      extraCtrl.title.control.setVisible(e2.target.checked);
    }.bind(this) },
    parent: li
  });
  var titleText = ol_ext_element.create("INPUT", {
    type: "text",
    placeholder: this.i18n("mapTitle"),
    on: {
      keydown: function(e2) {
        if (e2.keyCode === 13)
          e2.preventDefault();
      },
      keyup: function() {
        extraCtrl.title.control.setTitle(titleText.value);
      },
      change: function() {
        extraCtrl.title.control.setTitle(titleText.value);
      }.bind(this)
    },
    parent: li
  });
  var userElt = ol_ext_element.create("DIV", {
    className: "ol-user-param",
    parent: param
  });
  li = ol_ext_element.create("LI", {
    className: "ol-saveas",
    parent: ul
  });
  var copied = ol_ext_element.create("DIV", {
    html: this.i18n("copied"),
    className: "ol-clipboard-copy",
    parent: li
  });
  var save = ol_ext_element.create("SELECT", {
    on: { change: function() {
      if (this.formats[save.value].clipboard) {
        printCtrl.copyMap(this.formats[save.value], function(isok) {
          if (isok) {
            copied.classList.add("visible");
            setTimeout(function() {
              copied.classList.remove("visible");
            }, 1e3);
          }
        });
      } else {
        var format2 = typeof this.getSize() === "string" ? this.getSize() : null;
        var opt = Object.assign({
          format: format2,
          size: format2 ? this.paperSize[format2] : null,
          orient: this.getOrientation(),
          margin: this.getMargin()
        }, this.formats[save.value]);
        printCtrl.print(opt);
      }
      save.value = "";
    }.bind(this) },
    parent: li
  });
  ol_ext_element.create("OPTION", {
    html: this.i18n("saveas"),
    style: { display: "none" },
    value: "",
    parent: save
  });
  this.formats.forEach(function(format2, i2) {
    if (format2.pdf) {
      if (options.pdf === false)
        return;
    } else if (format2.clipboard) {
      if (options.copy === false)
        return;
    } else if (options.save === false) {
      return;
    }
    ol_ext_element.create("OPTION", {
      html: this.i18n(format2.title),
      value: i2,
      parent: save
    });
  }.bind(this));
  li = ol_ext_element.create("LI", {
    className: "ol-savelegend",
    parent: ul
  });
  var copylegend = ol_ext_element.create("DIV", {
    html: this.i18n("copied"),
    className: "ol-clipboard-copy",
    parent: li
  });
  var saveLegend = ol_ext_element.create("SELECT", {
    on: { change: function() {
      var clegend = extraCtrl.legend.control.getLegend().getCanvas();
      var canvas = document.createElement("CANVAS");
      canvas.width = clegend.width;
      canvas.height = clegend.height;
      var ctx = canvas.getContext("2d");
      ctx.fillStyle = "#fff";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(clegend, 0, 0);
      if (this.formats[saveLegend.value].clipboard) {
        canvas.toBlob(function(blob) {
          try {
            navigator.clipboard.write([
              new window.ClipboardItem(Object.defineProperty({}, blob.type, {
                value: blob,
                enumerable: true
              }))
            ]);
            copylegend.classList.add("visible");
            setTimeout(function() {
              copylegend.classList.remove("visible");
            }, 1e3);
          } catch (err2) {
          }
        }, "image/png");
      } else {
        var image2;
        try {
          image2 = canvas.toDataURL(this.formats[saveLegend.value].imageType, this.formats[saveLegend.value].quality);
          var format2 = typeof this.getSize() === "string" ? this.getSize() : "A4";
          var w2 = canvas.width / 96 * 25.4;
          var h2 = canvas.height / 96 * 25.4;
          var size2 = this.paperSize[format2];
          if (this.getOrientation() === "landscape")
            size2 = [size2[1], size2[0]];
          var position2 = [
            (size2[0] - w2) / 2,
            (size2[1] - h2) / 2
          ];
          this.dispatchEvent({
            type: "print",
            print: {
              legend: true,
              format: format2,
              orientation: this.getOrientation(),
              unit: "mm",
              size: this.paperSize[format2],
              position: position2,
              imageWidth: w2,
              imageHeight: h2
            },
            image: image2,
            imageType: this.formats[saveLegend.value].imageType,
            pdf: this.formats[saveLegend.value].pdf,
            quality: this.formats[saveLegend.value].quality,
            canvas
          });
        } catch (err2) {
        }
      }
      saveLegend.value = "";
    }.bind(this) },
    parent: li
  });
  ol_ext_element.create("OPTION", {
    html: this.i18n("saveLegend"),
    style: { display: "none" },
    value: "",
    parent: saveLegend
  });
  this.formats.forEach(function(format2, i2) {
    ol_ext_element.create("OPTION", {
      html: this.i18n(format2.title),
      value: i2,
      parent: saveLegend
    });
  }.bind(this));
  var prButtons = ol_ext_element.create("DIV", {
    className: "ol-ext-buttons",
    parent: param
  });
  ol_ext_element.create("BUTTON", {
    html: this.i18n("printBt"),
    type: "submit",
    click: function(e2) {
      e2.preventDefault();
      window.print();
    },
    parent: prButtons
  });
  ol_ext_element.create("BUTTON", {
    html: this.i18n("cancel"),
    type: "button",
    click: function() {
      printDialog.hide();
    },
    parent: prButtons
  });
  ol_ext_element.create("DIV", {
    html: this.i18n("errorMsg"),
    className: "ol-error",
    parent: param
  });
  var originalTarget;
  var originalSize;
  var scalelistener;
  var extraCtrl = {};
  printDialog.on("show", function() {
    this.dispatchEvent({ type: "show", userElement: userElt, dialog: this._printDialog, page: this.getPage() });
    var map = this.getMap();
    if (!map)
      return;
    document.body.classList.add("ol-print-document");
    originalTarget = map.getTargetElement();
    originalSize = map.getSize();
    if (typeof this.getSize() === "string")
      this.setSize(this.getSize());
    else
      this.setSize(originalSize);
    map.setTarget(printMap);
    if (scalelistener)
      unByKey(scalelistener);
    scalelistener = map.on("moveend", function() {
      this.setScale(ol_sphere_getMapScale(map));
    }.bind(this));
    this.setScale(ol_sphere_getMapScale(map));
    extraCtrl = {};
    this.getMap().getControls().forEach(function(c2) {
      if (c2 instanceof ol_control_Legend) {
        extraCtrl.legend = { control: c2 };
      }
      if (c2 instanceof ol_control_CanvasTitle) {
        extraCtrl.title = { control: c2 };
      }
      if (c2 instanceof ol_control_Compass) {
        if (extraCtrl.compass) {
          c2.element.classList.remove("ol-print-compass");
        } else {
          if (this._input.north.checked)
            c2.element.classList.add("ol-print-compass");
          else
            c2.element.classList.remove("ol-print-compass");
          this._compass = c2;
          extraCtrl.compass = { control: c2 };
        }
      }
    }.bind(this));
    if (extraCtrl.title) {
      title.checked = extraCtrl.title.isVisible = extraCtrl.title.control.getVisible();
      titleText.value = extraCtrl.title.control.getTitle();
      title.parentNode.parentNode.classList.remove("hidden");
    } else {
      title.parentNode.parentNode.classList.add("hidden");
    }
    if (extraCtrl.legend) {
      extraCtrl.legend.ison = extraCtrl.legend.control.onCanvas();
      extraCtrl.legend.collapsed = extraCtrl.legend.control.isCollapsed();
      extraCtrl.legend.control.collapse(false);
      saveLegend.parentNode.classList.remove("hidden");
      legend.parentNode.parentNode.classList.remove("hidden");
      legend.checked = !extraCtrl.legend.collapsed;
      extraCtrl.legend.control.setCanvas(!extraCtrl.legend.collapsed);
    } else {
      saveLegend.parentNode.classList.add("hidden");
      legend.parentNode.parentNode.classList.add("hidden");
    }
  }.bind(this));
  printDialog.on("hide", function() {
    document.body.classList.remove("ol-print-document");
    if (!originalTarget)
      return;
    this.getMap().setTarget(originalTarget);
    originalTarget = null;
    if (scalelistener)
      unByKey(scalelistener);
    if (extraCtrl.title) {
      extraCtrl.title.control.setVisible(extraCtrl.title.isVisible);
    }
    if (extraCtrl.legend) {
      extraCtrl.legend.control.setCanvas(extraCtrl.legend.ison);
      extraCtrl.legend.control.collapse(extraCtrl.legend.collapsed);
    }
    this.dispatchEvent({ type: "hide" });
  }.bind(this));
  window.addEventListener("resize", function() {
    this.setSize();
  }.bind(this));
  if (options.saveAs) {
    this.on("print", function(e2) {
      if (!e2.pdf) {
        e2.canvas.toBlob(function(blob) {
          var name = (e2.print.legend ? "legend." : "map.") + e2.imageType.replace("image/", "");
          options.saveAs(blob, name);
        }, e2.imageType, e2.quality);
      }
    });
  }
  if (options.jsPDF) {
    this.on("print", function(e2) {
      if (e2.pdf) {
        var pdf = new options.jsPDF({
          orientation: e2.print.orientation,
          unit: e2.print.unit,
          format: e2.print.size
        });
        pdf.addImage(e2.image, "JPEG", e2.print.position[0], e2.print.position[0], e2.print.imageWidth, e2.print.imageHeight);
        pdf.save(e2.print.legend ? "legend.pdf" : "map.pdf");
      }
    });
  }
};
ol_ext_inherits(ol_control_PrintDialog, Control$1);
ol_control_PrintDialog.prototype.isOpen = function() {
  return this._printDialog.isOpen();
};
ol_control_PrintDialog.addLang = function(lang, labels) {
  ol_control_PrintDialog.prototype._labels[lang] = labels;
};
ol_control_PrintDialog.prototype.i18n = function(what) {
  var rep = this._labels.en[what] || "bad param";
  if (this._labels[this._lang] && this._labels[this._lang][what]) {
    rep = this._labels[this._lang][what];
  }
  return rep;
};
ol_control_PrintDialog.prototype._labels = {
  en: {
    title: "Print",
    orientation: "Orientation",
    portrait: "Portrait",
    landscape: "Landscape",
    size: "Page size",
    custom: "screen size",
    margin: "Margin",
    scale: "Scale",
    legend: "Legend",
    north: "North arrow",
    mapTitle: "Map title",
    saveas: "Save as...",
    saveLegend: "Save legend...",
    copied: "\u2714 Copied to clipboard",
    errorMsg: "Can't save map canvas...",
    printBt: "Print...",
    clipboardFormat: "copy to clipboard...",
    jpegFormat: "save as jpeg",
    pngFormat: "save as png",
    pdfFormat: "save as pdf",
    none: "none",
    small: "small",
    large: "large",
    cancel: "cancel"
  },
  fr: {
    title: "Imprimer",
    orientation: "Orientation",
    portrait: "Portrait",
    landscape: "Paysage",
    size: "Taille du papier",
    custom: "taille \xE9cran",
    margin: "Marges",
    scale: "Echelle",
    legend: "L\xE9gende",
    north: "Fl\xE8che du nord",
    mapTitle: "Titre de la carte",
    saveas: "Enregistrer sous...",
    saveLegend: "Enregistrer la l\xE9gende...",
    copied: "\u2714 Carte copi\xE9e",
    errorMsg: "Impossible d'enregistrer la carte",
    printBt: "Imprimer",
    clipboardFormat: "copier dans le presse-papier...",
    jpegFormat: "enregistrer un jpeg",
    pngFormat: "enregistrer un png",
    pdfFormat: "enregistrer un pdf",
    none: "aucune",
    small: "petites",
    large: "larges",
    cancel: "annuler"
  },
  de: {
    title: "Drucken",
    orientation: "Ausrichtung",
    portrait: "Hochformat",
    landscape: "Querformat",
    size: "Papierformat",
    custom: "Bildschirmgr\xF6\xDFe",
    margin: "Rand",
    scale: "Ma\xDFstab",
    legend: "Legende",
    north: "Nordpfeil",
    mapTitle: "Kartentitel",
    saveas: "Speichern als...",
    saveLegend: "Legende speichern...",
    copied: "\u2714 In die Zwischenablage kopiert",
    errorMsg: "Kann Karte nicht speichern...",
    printBt: "Drucken...",
    clipboardFormat: "in die Zwischenablage kopieren...",
    jpegFormat: "speichern als jpeg",
    pngFormat: "speichern als png",
    pdfFormat: "speichern als pdf",
    none: "kein",
    small: "klein",
    large: "gro\xDF",
    cancel: "abbrechen"
  },
  zh: {
    title: "\u6253\u5370",
    orientation: "\u65B9\u5411",
    portrait: "\u7EB5\u5411",
    landscape: "\u6A2A\u5411",
    size: "\u9875\u9762\u5927\u5C0F",
    custom: "\u5C4F\u5E55\u5927\u5C0F",
    margin: "\u5916\u8FB9\u8DDD",
    scale: "\u5C3A\u5EA6",
    legend: "\u56FE\u4F8B",
    north: "\u6307\u5317\u9488",
    mapTitle: "\u5730\u56FE\u540D\u5B57",
    saveas: "\u4FDD\u5B58\u4E3A...",
    saveLegend: "\u4FDD\u5B58\u56FE\u4F8B\u4E3A...",
    copied: "\u2714 \u5DF2\u590D\u5236\u5230\u526A\u8D34\u677F",
    errorMsg: "\u65E0\u6CD5\u4FDD\u5B58\u5730\u56FE...",
    printBt: "\u6253\u5370...",
    cancel: "\u53D6\u6D88"
  }
};
ol_control_PrintDialog.prototype.paperSize = {
  "": null,
  "A0": [841, 1189],
  "A1": [594, 841],
  "A2": [420, 594],
  "A3": [297, 420],
  "A4": [210, 297],
  "US Letter": [215.9, 279.4],
  "A5": [148, 210],
  "B4": [257, 364],
  "B5": [182, 257]
};
ol_control_PrintDialog.prototype.marginSize = {
  none: 0,
  small: 5,
  large: 10
};
ol_control_PrintDialog.prototype.formats = [
  {
    title: "clipboardFormat",
    imageType: "image/png",
    clipboard: true
  },
  {
    title: "jpegFormat",
    imageType: "image/jpeg",
    quality: 0.8
  },
  {
    title: "pngFormat",
    imageType: "image/png",
    quality: 0.8
  },
  {
    title: "pdfFormat",
    imageType: "image/jpeg",
    pdf: true
  }
];
ol_control_PrintDialog.prototype.scales = {
  " 5000": "1/5.000",
  " 10000": "1/10.000",
  " 25000": "1/25.000",
  " 50000": "1/50.000",
  " 100000": "1/100.000",
  " 250000": "1/250.000",
  " 1000000": "1/1.000.000"
};
ol_control_PrintDialog.prototype.getOrientation = function() {
  return this._orientation || "portrait";
};
ol_control_PrintDialog.prototype.setOrientation = function(ori) {
  this._orientation = ori === "landscape" ? "landscape" : "portrait";
  this._input.orientation[this._orientation].checked = true;
  this.setSize();
};
ol_control_PrintDialog.prototype.getMargin = function() {
  return this._margin || 0;
};
ol_control_PrintDialog.prototype.setMargin = function(margin) {
  this._margin = margin;
  this._input.margin.value = margin;
  this.setSize();
};
ol_control_PrintDialog.prototype.getSize = function() {
  return this._size;
};
ol_control_PrintDialog.prototype.setSize = function(size) {
  this._printDialog.getContentElement().setAttribute("data-status", "");
  if (size)
    this._size = size;
  else
    size = this._size;
  if (!size)
    return;
  if (typeof size === "string") {
    for (var k2 in this.paperSize) {
      if (k2 && new RegExp(k2, "i").test(size)) {
        size = k2;
      }
    }
    if (!this.paperSize[size])
      size = this._size = "A4";
    this._input.size.value = size;
    size = [
      Math.trunc(this.paperSize[size][0] * 96 / 25.4),
      Math.trunc(this.paperSize[size][1] * 96 / 25.4)
    ];
    if (this.getOrientation() === "landscape") {
      size = [size[1], size[0]];
    }
    this.getPage().classList.remove("margin");
  } else {
    this._input.size.value = "";
    this.getPage().classList.add("margin");
  }
  var printElement = this.getPage();
  var s2 = printElement.parentNode.getBoundingClientRect();
  var scx = (s2.width - 40) / size[0];
  var scy = (s2.height - 40) / size[1];
  var sc = Math.min(scx, scy, 1);
  printElement.style.width = size[0] + "px";
  printElement.style.height = size[1] + "px";
  printElement.style["-webkit-transform"] = printElement.style.transform = "translate(-50%,-50%) scale(" + sc + ")";
  var px = Math.round(5 / sc);
  printElement.style["-webkit-box-shadow"] = printElement.style["box-shadow"] = px + "px " + px + "px " + px + "px rgba(0,0,0,.6)";
  printElement.style["padding"] = this.getMargin() * 96 / 25.4 + "px";
  if (this.getMap()) {
    this.getMap().updateSize();
  }
  this.dispatchEvent({ type: "dialog:refresh" });
};
ol_control_PrintDialog.prototype.getContentElement = function() {
  return this._printDialog.getContentElement();
};
ol_control_PrintDialog.prototype.getUserElement = function() {
  return this._printDialog.getContentElement().querySelector(".ol-user-param");
};
ol_control_PrintDialog.prototype.getPage = function() {
  return this._pages[0];
};
ol_control_PrintDialog.prototype.setMap = function(map) {
  if (this.getMap()) {
    this.getMap().removeControl(this._compass);
    this.getMap().removeControl(this._printCtrl);
    this.getMap().removeControl(this._printDialog);
  }
  Control$1.prototype.setMap.call(this, map);
  if (this.getMap()) {
    this.getMap().addControl(this._compass);
    this.getMap().addControl(this._printCtrl);
    this.getMap().addControl(this._printDialog);
  }
};
ol_control_PrintDialog.prototype.setScale = function(value) {
  ol_sphere_setMapScale(this.getMap(), value);
  this._input.scale.value = " " + Math.round(value / 100) * 100;
};
ol_control_PrintDialog.prototype.getScale = function() {
  return ol_sphere_getMapScale(this.getMap());
};
ol_control_PrintDialog.prototype.print = function(options) {
  options = options || {};
  if (options.size)
    this.setSize(options.size);
  if (options.scale)
    this.setScale(options.scale);
  if (options.orientation)
    this.setOrientation(options.orientation);
  if (options.margin)
    this.setMargin(options.margin);
  this._printDialog.show();
};
ol_control_PrintDialog.prototype.getrintControl = function() {
  return this._printCtrl;
};
var FileSaver_min = { exports: {} };
(function(module, exports2) {
  (function(a2, b2) {
    b2();
  })(commonjsGlobal, function() {
    function b2(a3, b3) {
      return typeof b3 == "undefined" ? b3 = { autoBom: false } : typeof b3 != "object" && (console.warn("Deprecated: Expected third argument to be a object"), b3 = { autoBom: !b3 }), b3.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a3.type) ? new Blob(["\uFEFF", a3], { type: a3.type }) : a3;
    }
    function c2(a3, b3, c3) {
      var d3 = new XMLHttpRequest();
      d3.open("GET", a3), d3.responseType = "blob", d3.onload = function() {
        g2(d3.response, b3, c3);
      }, d3.onerror = function() {
        console.error("could not download file");
      }, d3.send();
    }
    function d2(a3) {
      var b3 = new XMLHttpRequest();
      b3.open("HEAD", a3, false);
      try {
        b3.send();
      } catch (a4) {
      }
      return 200 <= b3.status && 299 >= b3.status;
    }
    function e2(a3) {
      try {
        a3.dispatchEvent(new MouseEvent("click"));
      } catch (c3) {
        var b3 = document.createEvent("MouseEvents");
        b3.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), a3.dispatchEvent(b3);
      }
    }
    var f2 = typeof window == "object" && window.window === window ? window : typeof self == "object" && self.self === self ? self : typeof commonjsGlobal == "object" && commonjsGlobal.global === commonjsGlobal ? commonjsGlobal : void 0, a2 = f2.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g2 = f2.saveAs || (typeof window != "object" || window !== f2 ? function() {
    } : "download" in HTMLAnchorElement.prototype && !a2 ? function(b3, g3, h2) {
      var i2 = f2.URL || f2.webkitURL, j2 = document.createElement("a");
      g3 = g3 || b3.name || "download", j2.download = g3, j2.rel = "noopener", typeof b3 == "string" ? (j2.href = b3, j2.origin === location.origin ? e2(j2) : d2(j2.href) ? c2(b3, g3, h2) : e2(j2, j2.target = "_blank")) : (j2.href = i2.createObjectURL(b3), setTimeout(function() {
        i2.revokeObjectURL(j2.href);
      }, 4e4), setTimeout(function() {
        e2(j2);
      }, 0));
    } : "msSaveOrOpenBlob" in navigator ? function(f3, g3, h2) {
      if (g3 = g3 || f3.name || "download", typeof f3 != "string")
        navigator.msSaveOrOpenBlob(b2(f3, h2), g3);
      else if (d2(f3))
        c2(f3, g3, h2);
      else {
        var i2 = document.createElement("a");
        i2.href = f3, i2.target = "_blank", setTimeout(function() {
          e2(i2);
        });
      }
    } : function(b3, d3, e3, g3) {
      if (g3 = g3 || open("", "_blank"), g3 && (g3.document.title = g3.document.body.innerText = "downloading..."), typeof b3 == "string")
        return c2(b3, d3, e3);
      var h2 = b3.type === "application/octet-stream", i2 = /constructor/i.test(f2.HTMLElement) || f2.safari, j2 = /CriOS\/[\d]+/.test(navigator.userAgent);
      if ((j2 || h2 && i2 || a2) && typeof FileReader != "undefined") {
        var k2 = new FileReader();
        k2.onloadend = function() {
          var a3 = k2.result;
          a3 = j2 ? a3 : a3.replace(/^data:[^;]*;/, "data:attachment/file;"), g3 ? g3.location.href = a3 : location = a3, g3 = null;
        }, k2.readAsDataURL(b3);
      } else {
        var l2 = f2.URL || f2.webkitURL, m2 = l2.createObjectURL(b3);
        g3 ? g3.location = m2 : location.href = m2, g3 = null, setTimeout(function() {
          l2.revokeObjectURL(m2);
        }, 4e4);
      }
    });
    f2.saveAs = g2.saveAs = g2, module.exports = g2;
  });
})(FileSaver_min);
function _typeof$2(obj) {
  "@babel/helpers - typeof";
  return _typeof$2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$2(obj);
}
var u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;
var fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]);
var fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = function(eb, start2) {
  var b2 = new u16(31);
  for (var i2 = 0; i2 < 31; ++i2) {
    b2[i2] = start2 += 1 << eb[i2 - 1];
  }
  var r2 = new u32(b2[30]);
  for (var i2 = 1; i2 < 30; ++i2) {
    for (var j2 = b2[i2]; j2 < b2[i2 + 1]; ++j2) {
      r2[j2] = j2 - b2[i2] << 5 | i2;
    }
  }
  return [b2, r2];
};
var _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0), fd = _b[0], revfd = _b[1];
var rev = new u16(32768);
for (var i$6 = 0; i$6 < 32768; ++i$6) {
  var x$1 = (i$6 & 43690) >>> 1 | (i$6 & 21845) << 1;
  x$1 = (x$1 & 52428) >>> 2 | (x$1 & 13107) << 2;
  x$1 = (x$1 & 61680) >>> 4 | (x$1 & 3855) << 4;
  rev[i$6] = ((x$1 & 65280) >>> 8 | (x$1 & 255) << 8) >>> 1;
}
var hMap = function(cd, mb, r2) {
  var s2 = cd.length;
  var i2 = 0;
  var l2 = new u16(mb);
  for (; i2 < s2; ++i2)
    ++l2[cd[i2] - 1];
  var le2 = new u16(mb);
  for (i2 = 0; i2 < mb; ++i2) {
    le2[i2] = le2[i2 - 1] + l2[i2 - 1] << 1;
  }
  var co;
  if (r2) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i2 = 0; i2 < s2; ++i2) {
      if (cd[i2]) {
        var sv = i2 << 4 | cd[i2];
        var r_1 = mb - cd[i2];
        var v2 = le2[cd[i2] - 1]++ << r_1;
        for (var m2 = v2 | (1 << r_1) - 1; v2 <= m2; ++v2) {
          co[rev[v2] >>> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s2);
    for (i2 = 0; i2 < s2; ++i2)
      co[i2] = rev[le2[cd[i2] - 1]++] >>> 15 - cd[i2];
  }
  return co;
};
var flt = new u8(288);
for (var i$6 = 0; i$6 < 144; ++i$6)
  flt[i$6] = 8;
for (var i$6 = 144; i$6 < 256; ++i$6)
  flt[i$6] = 9;
for (var i$6 = 256; i$6 < 280; ++i$6)
  flt[i$6] = 7;
for (var i$6 = 280; i$6 < 288; ++i$6)
  flt[i$6] = 8;
var fdt = new u8(32);
for (var i$6 = 0; i$6 < 32; ++i$6)
  fdt[i$6] = 5;
var flm = /* @__PURE__ */ hMap(flt, 9, 0), flrm = /* @__PURE__ */ hMap(flt, 9, 1);
var fdm = /* @__PURE__ */ hMap(fdt, 5, 0), fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
var max$3 = function(a2) {
  var m2 = a2[0];
  for (var i2 = 1; i2 < a2.length; ++i2) {
    if (a2[i2] > m2)
      m2 = a2[i2];
  }
  return m2;
};
var bits = function(d2, p5, m2) {
  var o2 = p5 / 8 >> 0;
  return (d2[o2] | d2[o2 + 1] << 8) >>> (p5 & 7) & m2;
};
var bits16 = function(d2, p5) {
  var o2 = p5 / 8 >> 0;
  return (d2[o2] | d2[o2 + 1] << 8 | d2[o2 + 2] << 16) >>> (p5 & 7);
};
var shft = function(p5) {
  return (p5 / 8 >> 0) + (p5 & 7 && 1);
};
var slc = function(v2, s2, e2) {
  if (s2 == null || s2 < 0)
    s2 = 0;
  if (e2 == null || e2 > v2.length)
    e2 = v2.length;
  var n2 = new (v2 instanceof u16 ? u16 : v2 instanceof u32 ? u32 : u8)(e2 - s2);
  n2.set(v2.subarray(s2, e2));
  return n2;
};
var inflt = function(dat, buf, st2) {
  var sl = dat.length;
  var noBuf = !buf || st2;
  var noSt = !st2 || st2.i;
  if (!st2)
    st2 = {};
  if (!buf)
    buf = new u8(sl * 3);
  var cbuf = function(l3) {
    var bl = buf.length;
    if (l3 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l3));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st2.f || 0, pos = st2.p || 0, bt2 = st2.b || 0, lm = st2.l, dm = st2.d, lbt = st2.m, dbt = st2.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      st2.f = final = bits(dat, pos, 1);
      var type = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type) {
        var s2 = shft(pos) + 4, l2 = dat[s2 - 4] | dat[s2 - 3] << 8, t3 = s2 + l2;
        if (t3 > sl) {
          if (noSt)
            throw "unexpected EOF";
          break;
        }
        if (noBuf)
          cbuf(bt2 + l2);
        buf.set(dat.subarray(s2, t3), bt2);
        st2.b = bt2 += l2, st2.p = pos = t3 * 8;
        continue;
      } else if (type == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i2 = 0; i2 < hcLen; ++i2) {
          clt[clim[i2]] = bits(dat, pos + i2 * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max$3(clt), clbmsk = (1 << clb) - 1;
        if (!noSt && pos + tl * (clb + 7) > tbts)
          break;
        var clm = hMap(clt, clb, 1);
        for (var i2 = 0; i2 < tl; ) {
          var r2 = clm[bits(dat, pos, clbmsk)];
          pos += r2 & 15;
          var s2 = r2 >>> 4;
          if (s2 < 16) {
            ldt[i2++] = s2;
          } else {
            var c2 = 0, n2 = 0;
            if (s2 == 16)
              n2 = 3 + bits(dat, pos, 3), pos += 2, c2 = ldt[i2 - 1];
            else if (s2 == 17)
              n2 = 3 + bits(dat, pos, 7), pos += 3;
            else if (s2 == 18)
              n2 = 11 + bits(dat, pos, 127), pos += 7;
            while (n2--)
              ldt[i2++] = c2;
          }
        }
        var lt2 = ldt.subarray(0, hLit), dt2 = ldt.subarray(hLit);
        lbt = max$3(lt2);
        dbt = max$3(dt2);
        lm = hMap(lt2, lbt, 1);
        dm = hMap(dt2, dbt, 1);
      } else
        throw "invalid block type";
      if (pos > tbts)
        throw "unexpected EOF";
    }
    if (noBuf)
      cbuf(bt2 + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var mxa = lbt + dbt + 18;
    while (noSt || pos + mxa < tbts) {
      var c2 = lm[bits16(dat, pos) & lms], sym = c2 >>> 4;
      pos += c2 & 15;
      if (pos > tbts)
        throw "unexpected EOF";
      if (!c2)
        throw "invalid length/literal";
      if (sym < 256)
        buf[bt2++] = sym;
      else if (sym == 256) {
        lm = null;
        break;
      } else {
        var add2 = sym - 254;
        if (sym > 264) {
          var i2 = sym - 257, b2 = fleb[i2];
          add2 = bits(dat, pos, (1 << b2) - 1) + fl[i2];
          pos += b2;
        }
        var d2 = dm[bits16(dat, pos) & dms], dsym = d2 >>> 4;
        if (!d2)
          throw "invalid distance";
        pos += d2 & 15;
        var dt2 = fd[dsym];
        if (dsym > 3) {
          var b2 = fdeb[dsym];
          dt2 += bits16(dat, pos) & (1 << b2) - 1, pos += b2;
        }
        if (pos > tbts)
          throw "unexpected EOF";
        if (noBuf)
          cbuf(bt2 + 131072);
        var end = bt2 + add2;
        for (; bt2 < end; bt2 += 4) {
          buf[bt2] = buf[bt2 - dt2];
          buf[bt2 + 1] = buf[bt2 + 1 - dt2];
          buf[bt2 + 2] = buf[bt2 + 2 - dt2];
          buf[bt2 + 3] = buf[bt2 + 3 - dt2];
        }
        bt2 = end;
      }
    }
    st2.l = lm, st2.p = pos, st2.b = bt2;
    if (lm)
      final = 1, st2.m = lbt, st2.d = dm, st2.n = dbt;
  } while (!final);
  return bt2 == buf.length ? buf : slc(buf, 0, bt2);
};
var wbits = function(d2, p5, v2) {
  v2 <<= p5 & 7;
  var o2 = p5 / 8 >> 0;
  d2[o2] |= v2;
  d2[o2 + 1] |= v2 >>> 8;
};
var wbits16 = function(d2, p5, v2) {
  v2 <<= p5 & 7;
  var o2 = p5 / 8 >> 0;
  d2[o2] |= v2;
  d2[o2 + 1] |= v2 >>> 8;
  d2[o2 + 2] |= v2 >>> 16;
};
var hTree = function(d2, mb) {
  var t3 = [];
  for (var i2 = 0; i2 < d2.length; ++i2) {
    if (d2[i2])
      t3.push({ s: i2, f: d2[i2] });
  }
  var s2 = t3.length;
  var t22 = t3.slice();
  if (!s2)
    return [new u8(0), 0];
  if (s2 == 1) {
    var v2 = new u8(t3[0].s + 1);
    v2[t3[0].s] = 1;
    return [v2, 1];
  }
  t3.sort(function(a2, b2) {
    return a2.f - b2.f;
  });
  t3.push({ s: -1, f: 25001 });
  var l2 = t3[0], r2 = t3[1], i0 = 0, i1 = 1, i22 = 2;
  t3[0] = { s: -1, f: l2.f + r2.f, l: l2, r: r2 };
  while (i1 != s2 - 1) {
    l2 = t3[t3[i0].f < t3[i22].f ? i0++ : i22++];
    r2 = t3[i0 != i1 && t3[i0].f < t3[i22].f ? i0++ : i22++];
    t3[i1++] = { s: -1, f: l2.f + r2.f, l: l2, r: r2 };
  }
  var maxSym = t22[0].s;
  for (var i2 = 1; i2 < s2; ++i2) {
    if (t22[i2].s > maxSym)
      maxSym = t22[i2].s;
  }
  var tr = new u16(maxSym + 1);
  var mbt = ln(t3[i1 - 1], tr, 0);
  if (mbt > mb) {
    var i2 = 0, dt2 = 0;
    var lft = mbt - mb, cst = 1 << lft;
    t22.sort(function(a2, b2) {
      return tr[b2.s] - tr[a2.s] || a2.f - b2.f;
    });
    for (; i2 < s2; ++i2) {
      var i2_1 = t22[i2].s;
      if (tr[i2_1] > mb) {
        dt2 += cst - (1 << mbt - tr[i2_1]);
        tr[i2_1] = mb;
      } else
        break;
    }
    dt2 >>>= lft;
    while (dt2 > 0) {
      var i2_2 = t22[i2].s;
      if (tr[i2_2] < mb)
        dt2 -= 1 << mb - tr[i2_2]++ - 1;
      else
        ++i2;
    }
    for (; i2 >= 0 && dt2; --i2) {
      var i2_3 = t22[i2].s;
      if (tr[i2_3] == mb) {
        --tr[i2_3];
        ++dt2;
      }
    }
    mbt = mb;
  }
  return [new u8(tr), mbt];
};
var ln = function(n2, l2, d2) {
  return n2.s == -1 ? Math.max(ln(n2.l, l2, d2 + 1), ln(n2.r, l2, d2 + 1)) : l2[n2.s] = d2;
};
var lc = function(c2) {
  var s2 = c2.length;
  while (s2 && !c2[--s2])
    ;
  var cl = new u16(++s2);
  var cli = 0, cln = c2[0], cls = 1;
  var w2 = function(v2) {
    cl[cli++] = v2;
  };
  for (var i2 = 1; i2 <= s2; ++i2) {
    if (c2[i2] == cln && i2 != s2)
      ++cls;
    else {
      if (!cln && cls > 2) {
        for (; cls > 138; cls -= 138)
          w2(32754);
        if (cls > 2) {
          w2(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
          cls = 0;
        }
      } else if (cls > 3) {
        w2(cln), --cls;
        for (; cls > 6; cls -= 6)
          w2(8304);
        if (cls > 2)
          w2(cls - 3 << 5 | 8208), cls = 0;
      }
      while (cls--)
        w2(cln);
      cls = 1;
      cln = c2[i2];
    }
  }
  return [cl.subarray(0, cli), s2];
};
var clen = function(cf, cl) {
  var l2 = 0;
  for (var i2 = 0; i2 < cl.length; ++i2)
    l2 += cf[i2] * cl[i2];
  return l2;
};
var wfblk = function(out, pos, dat) {
  var s2 = dat.length;
  var o2 = shft(pos + 2);
  out[o2] = s2 & 255;
  out[o2 + 1] = s2 >>> 8;
  out[o2 + 2] = out[o2] ^ 255;
  out[o2 + 3] = out[o2 + 1] ^ 255;
  for (var i2 = 0; i2 < s2; ++i2)
    out[o2 + i2 + 4] = dat[i2];
  return (o2 + 4 + s2) * 8;
};
var wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p5) {
  wbits(out, p5++, final);
  ++lf[256];
  var _a2 = hTree(lf, 15), dlt = _a2[0], mlb = _a2[1];
  var _b2 = hTree(df, 15), ddt = _b2[0], mdb = _b2[1];
  var _c = lc(dlt), lclt = _c[0], nlc = _c[1];
  var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];
  var lcfreq = new u16(19);
  for (var i2 = 0; i2 < lclt.length; ++i2)
    lcfreq[lclt[i2] & 31]++;
  for (var i2 = 0; i2 < lcdt.length; ++i2)
    lcfreq[lcdt[i2] & 31]++;
  var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];
  var nlcc = 19;
  for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
    ;
  var flen = bl + 5 << 3;
  var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
  var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);
  if (flen <= ftlen && flen <= dtlen)
    return wfblk(out, p5, dat.subarray(bs, bs + bl));
  var lm, ll, dm, dl;
  wbits(out, p5, 1 + (dtlen < ftlen)), p5 += 2;
  if (dtlen < ftlen) {
    lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
    var llm = hMap(lct, mlcb, 0);
    wbits(out, p5, nlc - 257);
    wbits(out, p5 + 5, ndc - 1);
    wbits(out, p5 + 10, nlcc - 4);
    p5 += 14;
    for (var i2 = 0; i2 < nlcc; ++i2)
      wbits(out, p5 + 3 * i2, lct[clim[i2]]);
    p5 += 3 * nlcc;
    var lcts = [lclt, lcdt];
    for (var it2 = 0; it2 < 2; ++it2) {
      var clct = lcts[it2];
      for (var i2 = 0; i2 < clct.length; ++i2) {
        var len = clct[i2] & 31;
        wbits(out, p5, llm[len]), p5 += lct[len];
        if (len > 15)
          wbits(out, p5, clct[i2] >>> 5 & 127), p5 += clct[i2] >>> 12;
      }
    }
  } else {
    lm = flm, ll = flt, dm = fdm, dl = fdt;
  }
  for (var i2 = 0; i2 < li; ++i2) {
    if (syms[i2] > 255) {
      var len = syms[i2] >>> 18 & 31;
      wbits16(out, p5, lm[len + 257]), p5 += ll[len + 257];
      if (len > 7)
        wbits(out, p5, syms[i2] >>> 23 & 31), p5 += fleb[len];
      var dst = syms[i2] & 31;
      wbits16(out, p5, dm[dst]), p5 += dl[dst];
      if (dst > 3)
        wbits16(out, p5, syms[i2] >>> 5 & 8191), p5 += fdeb[dst];
    } else {
      wbits16(out, p5, lm[syms[i2]]), p5 += ll[syms[i2]];
    }
  }
  wbits16(out, p5, lm[256]);
  return p5 + ll[256];
};
var deo = /* @__PURE__ */ new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
var et$1 = /* @__PURE__ */ new u8(0);
var dflt = function(dat, lvl, plvl, pre, post2, lst) {
  var s2 = dat.length;
  var o2 = new u8(pre + s2 + 5 * (1 + Math.floor(s2 / 7e3)) + post2);
  var w2 = o2.subarray(pre, o2.length - post2);
  var pos = 0;
  if (!lvl || s2 < 8) {
    for (var i2 = 0; i2 <= s2; i2 += 65535) {
      var e2 = i2 + 65535;
      if (e2 < s2) {
        pos = wfblk(w2, pos, dat.subarray(i2, e2));
      } else {
        w2[i2] = lst;
        pos = wfblk(w2, pos, dat.subarray(i2, s2));
      }
    }
  } else {
    var opt = deo[lvl - 1];
    var n2 = opt >>> 13, c2 = opt & 8191;
    var msk_1 = (1 << plvl) - 1;
    var prev = new u16(32768), head2 = new u16(msk_1 + 1);
    var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
    var hsh = function(i3) {
      return (dat[i3] ^ dat[i3 + 1] << bs1_1 ^ dat[i3 + 2] << bs2_1) & msk_1;
    };
    var syms = new u32(25e3);
    var lf = new u16(288), df = new u16(32);
    var lc_1 = 0, eb = 0, i2 = 0, li = 0, wi = 0, bs = 0;
    for (; i2 < s2; ++i2) {
      var hv = hsh(i2);
      var imod = i2 & 32767;
      var pimod = head2[hv];
      prev[imod] = pimod;
      head2[hv] = imod;
      if (wi <= i2) {
        var rem = s2 - i2;
        if ((lc_1 > 7e3 || li > 24576) && rem > 423) {
          pos = wblk(dat, w2, 0, syms, lf, df, eb, li, bs, i2 - bs, pos);
          li = lc_1 = eb = 0, bs = i2;
          for (var j2 = 0; j2 < 286; ++j2)
            lf[j2] = 0;
          for (var j2 = 0; j2 < 30; ++j2)
            df[j2] = 0;
        }
        var l2 = 2, d2 = 0, ch_1 = c2, dif = imod - pimod & 32767;
        if (rem > 2 && hv == hsh(i2 - dif)) {
          var maxn = Math.min(n2, rem) - 1;
          var maxd = Math.min(32767, i2);
          var ml = Math.min(258, rem);
          while (dif <= maxd && --ch_1 && imod != pimod) {
            if (dat[i2 + l2] == dat[i2 + l2 - dif]) {
              var nl = 0;
              for (; nl < ml && dat[i2 + nl] == dat[i2 + nl - dif]; ++nl)
                ;
              if (nl > l2) {
                l2 = nl, d2 = dif;
                if (nl > maxn)
                  break;
                var mmd = Math.min(dif, nl - 2);
                var md = 0;
                for (var j2 = 0; j2 < mmd; ++j2) {
                  var ti = i2 - dif + j2 + 32768 & 32767;
                  var pti = prev[ti];
                  var cd = ti - pti + 32768 & 32767;
                  if (cd > md)
                    md = cd, pimod = ti;
                }
              }
            }
            imod = pimod, pimod = prev[imod];
            dif += imod - pimod + 32768 & 32767;
          }
        }
        if (d2) {
          syms[li++] = 268435456 | revfl[l2] << 18 | revfd[d2];
          var lin = revfl[l2] & 31, din = revfd[d2] & 31;
          eb += fleb[lin] + fdeb[din];
          ++lf[257 + lin];
          ++df[din];
          wi = i2 + l2;
          ++lc_1;
        } else {
          syms[li++] = dat[i2];
          ++lf[dat[i2]];
        }
      }
    }
    pos = wblk(dat, w2, lst, syms, lf, df, eb, li, bs, i2 - bs, pos);
    if (!lst)
      pos = wfblk(w2, pos, et$1);
  }
  return slc(o2, 0, pre + shft(pos) + post2);
};
var adler = function() {
  var a2 = 1, b2 = 0;
  return {
    p: function(d2) {
      var n2 = a2, m2 = b2;
      var l2 = d2.length;
      for (var i2 = 0; i2 != l2; ) {
        var e2 = Math.min(i2 + 5552, l2);
        for (; i2 < e2; ++i2)
          n2 += d2[i2], m2 += n2;
        n2 %= 65521, m2 %= 65521;
      }
      a2 = n2, b2 = m2;
    },
    d: function() {
      return (a2 >>> 8 << 16 | (b2 & 255) << 8 | b2 >>> 8) + ((a2 & 255) << 23) * 2;
    }
  };
};
var dopt = function(dat, opt, pre, post2, st2) {
  return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 12 + opt.mem, pre, post2, !st2);
};
var wbytes = function(d2, b2, v2) {
  for (; v2; ++b2)
    d2[b2] = v2, v2 >>>= 8;
};
var zlh = function(c2, o2) {
  var lv = o2.level, fl2 = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
  c2[0] = 120, c2[1] = fl2 << 6 | (fl2 ? 32 - 2 * fl2 : 1);
};
var zlv = function(d2) {
  if ((d2[0] & 15) != 8 || d2[0] >>> 4 > 7 || (d2[0] << 8 | d2[1]) % 31)
    throw "invalid zlib data";
  if (d2[1] & 32)
    throw "invalid zlib data: preset dictionaries not supported";
};
function zlibSync(data2, opts) {
  if (opts === void 0) {
    opts = {};
  }
  var a2 = adler();
  a2.p(data2);
  var d2 = dopt(data2, opts, 2, 4);
  return zlh(d2, opts), wbytes(d2, d2.length - 4, a2.d()), d2;
}
function unzlibSync(data2, out) {
  return inflt((zlv(data2), data2.subarray(2, -4)), out);
}
/** @license
 *
 * jsPDF - PDF Document creation from JavaScript
 * Version 2.5.0 Built on 2021-12-21T09:44:51.866Z
 *                      CommitID 00000000
 *
 * Copyright (c) 2010-2021 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF
 *               2015-2021 yWorks GmbH, http://www.yworks.com
 *               2015-2021 Lukas Holländer <lukas.hollaender@yworks.com>, https://github.com/HackbrettXXX
 *               2016-2018 Aras Abbasi <aras.abbasi@gmail.com>
 *               2010 Aaron Spike, https://github.com/acspike
 *               2012 Willow Systems Corporation, https://github.com/willowsystems
 *               2012 Pablo Hess, https://github.com/pablohess
 *               2012 Florian Jenett, https://github.com/fjenett
 *               2013 Warren Weckesser, https://github.com/warrenweckesser
 *               2013 Youssef Beddad, https://github.com/lifof
 *               2013 Lee Driscoll, https://github.com/lsdriscoll
 *               2013 Stefan Slonevskiy, https://github.com/stefslon
 *               2013 Jeremy Morel, https://github.com/jmorel
 *               2013 Christoph Hartmann, https://github.com/chris-rock
 *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
 *               2014 James Makes, https://github.com/dollaruw
 *               2014 Diego Casorran, https://github.com/diegocr
 *               2014 Steven Spungin, https://github.com/Flamenco
 *               2014 Kenneth Glassey, https://github.com/Gavvers
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Contributor(s):
 *    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
 *    kim3er, mfo, alnorth, Flamenco
 */
var n$1 = function() {
  return typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this;
}();
function i$5() {
  n$1.console && typeof n$1.console.log == "function" && n$1.console.log.apply(n$1.console, arguments);
}
var a$2 = { log: i$5, warn: function(t3) {
  n$1.console && (typeof n$1.console.warn == "function" ? n$1.console.warn.apply(n$1.console, arguments) : i$5.call(null, arguments));
}, error: function(t3) {
  n$1.console && (typeof n$1.console.error == "function" ? n$1.console.error.apply(n$1.console, arguments) : i$5(t3));
} };
function o$1(t3, e2, r2) {
  var n2 = new XMLHttpRequest();
  n2.open("GET", t3), n2.responseType = "blob", n2.onload = function() {
    l$1(n2.response, e2, r2);
  }, n2.onerror = function() {
    a$2.error("could not download file");
  }, n2.send();
}
function s$1(t3) {
  var e2 = new XMLHttpRequest();
  e2.open("HEAD", t3, false);
  try {
    e2.send();
  } catch (t4) {
  }
  return e2.status >= 200 && e2.status <= 299;
}
function c$2(t3) {
  try {
    t3.dispatchEvent(new MouseEvent("click"));
  } catch (r2) {
    var e2 = document.createEvent("MouseEvents");
    e2.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), t3.dispatchEvent(e2);
  }
}
var u$2, h$1, l$1 = n$1.saveAs || ((typeof window == "undefined" ? "undefined" : _typeof$2(window)) !== "object" || window !== n$1 ? function() {
} : typeof HTMLAnchorElement != "undefined" && "download" in HTMLAnchorElement.prototype ? function(t3, e2, r2) {
  var i2 = n$1.URL || n$1.webkitURL, a2 = document.createElement("a");
  e2 = e2 || t3.name || "download", a2.download = e2, a2.rel = "noopener", typeof t3 == "string" ? (a2.href = t3, a2.origin !== location.origin ? s$1(a2.href) ? o$1(t3, e2, r2) : c$2(a2, a2.target = "_blank") : c$2(a2)) : (a2.href = i2.createObjectURL(t3), setTimeout(function() {
    i2.revokeObjectURL(a2.href);
  }, 4e4), setTimeout(function() {
    c$2(a2);
  }, 0));
} : "msSaveOrOpenBlob" in navigator ? function(e2, r2, n2) {
  if (r2 = r2 || e2.name || "download", typeof e2 == "string")
    if (s$1(e2))
      o$1(e2, r2, n2);
    else {
      var i2 = document.createElement("a");
      i2.href = e2, i2.target = "_blank", setTimeout(function() {
        c$2(i2);
      });
    }
  else
    navigator.msSaveOrOpenBlob(function(e3, r3) {
      return r3 === void 0 ? r3 = { autoBom: false } : _typeof$2(r3) !== "object" && (a$2.warn("Deprecated: Expected third argument to be a object"), r3 = { autoBom: !r3 }), r3.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e3.type) ? new Blob([String.fromCharCode(65279), e3], { type: e3.type }) : e3;
    }(e2, n2), r2);
} : function(e2, r2, i2, a2) {
  if ((a2 = a2 || open("", "_blank")) && (a2.document.title = a2.document.body.innerText = "downloading..."), typeof e2 == "string")
    return o$1(e2, r2, i2);
  var s2 = e2.type === "application/octet-stream", c2 = /constructor/i.test(n$1.HTMLElement) || n$1.safari, u2 = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((u2 || s2 && c2) && (typeof FileReader == "undefined" ? "undefined" : _typeof$2(FileReader)) === "object") {
    var h2 = new FileReader();
    h2.onloadend = function() {
      var t3 = h2.result;
      t3 = u2 ? t3 : t3.replace(/^data:[^;]*;/, "data:attachment/file;"), a2 ? a2.location.href = t3 : location = t3, a2 = null;
    }, h2.readAsDataURL(e2);
  } else {
    var l2 = n$1.URL || n$1.webkitURL, f2 = l2.createObjectURL(e2);
    a2 ? a2.location = f2 : location.href = f2, a2 = null, setTimeout(function() {
      l2.revokeObjectURL(f2);
    }, 4e4);
  }
});
/**
 * A class to parse color values
 * @author Stoyan Stefanov <sstoo@gmail.com>
 * {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}
 * @license Use it if you like it
 */
function f$2(t3) {
  var e2;
  t3 = t3 || "", this.ok = false, t3.charAt(0) == "#" && (t3 = t3.substr(1, 6));
  t3 = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dodgerblue: "1e90ff", feldspar: "d19275", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgrey: "d3d3d3", lightgreen: "90ee90", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslateblue: "8470ff", lightslategray: "778899", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "00ff00", limegreen: "32cd32", linen: "faf0e6", magenta: "ff00ff", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370d8", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "d87093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", red: "ff0000", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", violetred: "d02090", wheat: "f5deb3", white: "ffffff", whitesmoke: "f5f5f5", yellow: "ffff00", yellowgreen: "9acd32" }[t3 = (t3 = t3.replace(/ /g, "")).toLowerCase()] || t3;
  for (var r2 = [{ re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/, example: ["rgb(123, 234, 45)", "rgb(255,234,245)"], process: function(t4) {
    return [parseInt(t4[1]), parseInt(t4[2]), parseInt(t4[3])];
  } }, { re: /^(\w{2})(\w{2})(\w{2})$/, example: ["#00ff00", "336699"], process: function(t4) {
    return [parseInt(t4[1], 16), parseInt(t4[2], 16), parseInt(t4[3], 16)];
  } }, { re: /^(\w{1})(\w{1})(\w{1})$/, example: ["#fb0", "f0f"], process: function(t4) {
    return [parseInt(t4[1] + t4[1], 16), parseInt(t4[2] + t4[2], 16), parseInt(t4[3] + t4[3], 16)];
  } }], n2 = 0; n2 < r2.length; n2++) {
    var i2 = r2[n2].re, a2 = r2[n2].process, o2 = i2.exec(t3);
    o2 && (e2 = a2(o2), this.r = e2[0], this.g = e2[1], this.b = e2[2], this.ok = true);
  }
  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.toRGB = function() {
    return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
  }, this.toHex = function() {
    var t4 = this.r.toString(16), e3 = this.g.toString(16), r3 = this.b.toString(16);
    return t4.length == 1 && (t4 = "0" + t4), e3.length == 1 && (e3 = "0" + e3), r3.length == 1 && (r3 = "0" + r3), "#" + t4 + e3 + r3;
  };
}
/**
 * @license
 * Joseph Myers does not specify a particular license for his work.
 *
 * Author: Joseph Myers
 * Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js
 *
 * Modified by: Owen Leong
 */
function d(t3, e2) {
  var r2 = t3[0], n2 = t3[1], i2 = t3[2], a2 = t3[3];
  r2 = g(r2, n2, i2, a2, e2[0], 7, -680876936), a2 = g(a2, r2, n2, i2, e2[1], 12, -389564586), i2 = g(i2, a2, r2, n2, e2[2], 17, 606105819), n2 = g(n2, i2, a2, r2, e2[3], 22, -1044525330), r2 = g(r2, n2, i2, a2, e2[4], 7, -176418897), a2 = g(a2, r2, n2, i2, e2[5], 12, 1200080426), i2 = g(i2, a2, r2, n2, e2[6], 17, -1473231341), n2 = g(n2, i2, a2, r2, e2[7], 22, -45705983), r2 = g(r2, n2, i2, a2, e2[8], 7, 1770035416), a2 = g(a2, r2, n2, i2, e2[9], 12, -1958414417), i2 = g(i2, a2, r2, n2, e2[10], 17, -42063), n2 = g(n2, i2, a2, r2, e2[11], 22, -1990404162), r2 = g(r2, n2, i2, a2, e2[12], 7, 1804603682), a2 = g(a2, r2, n2, i2, e2[13], 12, -40341101), i2 = g(i2, a2, r2, n2, e2[14], 17, -1502002290), r2 = m$2(r2, n2 = g(n2, i2, a2, r2, e2[15], 22, 1236535329), i2, a2, e2[1], 5, -165796510), a2 = m$2(a2, r2, n2, i2, e2[6], 9, -1069501632), i2 = m$2(i2, a2, r2, n2, e2[11], 14, 643717713), n2 = m$2(n2, i2, a2, r2, e2[0], 20, -373897302), r2 = m$2(r2, n2, i2, a2, e2[5], 5, -701558691), a2 = m$2(a2, r2, n2, i2, e2[10], 9, 38016083), i2 = m$2(i2, a2, r2, n2, e2[15], 14, -660478335), n2 = m$2(n2, i2, a2, r2, e2[4], 20, -405537848), r2 = m$2(r2, n2, i2, a2, e2[9], 5, 568446438), a2 = m$2(a2, r2, n2, i2, e2[14], 9, -1019803690), i2 = m$2(i2, a2, r2, n2, e2[3], 14, -187363961), n2 = m$2(n2, i2, a2, r2, e2[8], 20, 1163531501), r2 = m$2(r2, n2, i2, a2, e2[13], 5, -1444681467), a2 = m$2(a2, r2, n2, i2, e2[2], 9, -51403784), i2 = m$2(i2, a2, r2, n2, e2[7], 14, 1735328473), r2 = v$1(r2, n2 = m$2(n2, i2, a2, r2, e2[12], 20, -1926607734), i2, a2, e2[5], 4, -378558), a2 = v$1(a2, r2, n2, i2, e2[8], 11, -2022574463), i2 = v$1(i2, a2, r2, n2, e2[11], 16, 1839030562), n2 = v$1(n2, i2, a2, r2, e2[14], 23, -35309556), r2 = v$1(r2, n2, i2, a2, e2[1], 4, -1530992060), a2 = v$1(a2, r2, n2, i2, e2[4], 11, 1272893353), i2 = v$1(i2, a2, r2, n2, e2[7], 16, -155497632), n2 = v$1(n2, i2, a2, r2, e2[10], 23, -1094730640), r2 = v$1(r2, n2, i2, a2, e2[13], 4, 681279174), a2 = v$1(a2, r2, n2, i2, e2[0], 11, -358537222), i2 = v$1(i2, a2, r2, n2, e2[3], 16, -722521979), n2 = v$1(n2, i2, a2, r2, e2[6], 23, 76029189), r2 = v$1(r2, n2, i2, a2, e2[9], 4, -640364487), a2 = v$1(a2, r2, n2, i2, e2[12], 11, -421815835), i2 = v$1(i2, a2, r2, n2, e2[15], 16, 530742520), r2 = b(r2, n2 = v$1(n2, i2, a2, r2, e2[2], 23, -995338651), i2, a2, e2[0], 6, -198630844), a2 = b(a2, r2, n2, i2, e2[7], 10, 1126891415), i2 = b(i2, a2, r2, n2, e2[14], 15, -1416354905), n2 = b(n2, i2, a2, r2, e2[5], 21, -57434055), r2 = b(r2, n2, i2, a2, e2[12], 6, 1700485571), a2 = b(a2, r2, n2, i2, e2[3], 10, -1894986606), i2 = b(i2, a2, r2, n2, e2[10], 15, -1051523), n2 = b(n2, i2, a2, r2, e2[1], 21, -2054922799), r2 = b(r2, n2, i2, a2, e2[8], 6, 1873313359), a2 = b(a2, r2, n2, i2, e2[15], 10, -30611744), i2 = b(i2, a2, r2, n2, e2[6], 15, -1560198380), n2 = b(n2, i2, a2, r2, e2[13], 21, 1309151649), r2 = b(r2, n2, i2, a2, e2[4], 6, -145523070), a2 = b(a2, r2, n2, i2, e2[11], 10, -1120210379), i2 = b(i2, a2, r2, n2, e2[2], 15, 718787259), n2 = b(n2, i2, a2, r2, e2[9], 21, -343485551), t3[0] = _$1(r2, t3[0]), t3[1] = _$1(n2, t3[1]), t3[2] = _$1(i2, t3[2]), t3[3] = _$1(a2, t3[3]);
}
function p$1(t3, e2, r2, n2, i2, a2) {
  return e2 = _$1(_$1(e2, t3), _$1(n2, a2)), _$1(e2 << i2 | e2 >>> 32 - i2, r2);
}
function g(t3, e2, r2, n2, i2, a2, o2) {
  return p$1(e2 & r2 | ~e2 & n2, t3, e2, i2, a2, o2);
}
function m$2(t3, e2, r2, n2, i2, a2, o2) {
  return p$1(e2 & n2 | r2 & ~n2, t3, e2, i2, a2, o2);
}
function v$1(t3, e2, r2, n2, i2, a2, o2) {
  return p$1(e2 ^ r2 ^ n2, t3, e2, i2, a2, o2);
}
function b(t3, e2, r2, n2, i2, a2, o2) {
  return p$1(r2 ^ (e2 | ~n2), t3, e2, i2, a2, o2);
}
function y$1(t3) {
  var e2, r2 = t3.length, n2 = [1732584193, -271733879, -1732584194, 271733878];
  for (e2 = 64; e2 <= t3.length; e2 += 64)
    d(n2, w(t3.substring(e2 - 64, e2)));
  t3 = t3.substring(e2 - 64);
  var i2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (e2 = 0; e2 < t3.length; e2++)
    i2[e2 >> 2] |= t3.charCodeAt(e2) << (e2 % 4 << 3);
  if (i2[e2 >> 2] |= 128 << (e2 % 4 << 3), e2 > 55)
    for (d(n2, i2), e2 = 0; e2 < 16; e2++)
      i2[e2] = 0;
  return i2[14] = 8 * r2, d(n2, i2), n2;
}
function w(t3) {
  var e2, r2 = [];
  for (e2 = 0; e2 < 64; e2 += 4)
    r2[e2 >> 2] = t3.charCodeAt(e2) + (t3.charCodeAt(e2 + 1) << 8) + (t3.charCodeAt(e2 + 2) << 16) + (t3.charCodeAt(e2 + 3) << 24);
  return r2;
}
u$2 = n$1.atob.bind(n$1), h$1 = n$1.btoa.bind(n$1);
var N$1 = "0123456789abcdef".split("");
function L$1(t3) {
  for (var e2 = "", r2 = 0; r2 < 4; r2++)
    e2 += N$1[t3 >> 8 * r2 + 4 & 15] + N$1[t3 >> 8 * r2 & 15];
  return e2;
}
function A$1(t3) {
  return String.fromCharCode((255 & t3) >> 0, (65280 & t3) >> 8, (16711680 & t3) >> 16, (4278190080 & t3) >> 24);
}
function x(t3) {
  return y$1(t3).map(A$1).join("");
}
var S = function(t3) {
  for (var e2 = 0; e2 < t3.length; e2++)
    t3[e2] = L$1(t3[e2]);
  return t3.join("");
}(y$1("hello")) != "5d41402abc4b2a76b9719d911017c592";
function _$1(t3, e2) {
  if (S) {
    var r2 = (65535 & t3) + (65535 & e2);
    return (t3 >> 16) + (e2 >> 16) + (r2 >> 16) << 16 | 65535 & r2;
  }
  return t3 + e2 & 4294967295;
}
/**
 * @license
 * FPDF is released under a permissive license: there is no usage restriction.
 * You may embed it freely in your application (commercial or not), with or
 * without modifications.
 *
 * Reference: http://www.fpdf.org/en/script/script37.php
 */
function P(t3, e2) {
  var r2, n2, i2, a2;
  if (t3 !== r2) {
    for (var o2 = (i2 = t3, a2 = 1 + (256 / t3.length >> 0), new Array(a2 + 1).join(i2)), s2 = [], c2 = 0; c2 < 256; c2++)
      s2[c2] = c2;
    var u2 = 0;
    for (c2 = 0; c2 < 256; c2++) {
      var h2 = s2[c2];
      u2 = (u2 + h2 + o2.charCodeAt(c2)) % 256, s2[c2] = s2[u2], s2[u2] = h2;
    }
    r2 = t3, n2 = s2;
  } else
    s2 = n2;
  var l2 = e2.length, f2 = 0, d2 = 0, p5 = "";
  for (c2 = 0; c2 < l2; c2++)
    d2 = (d2 + (h2 = s2[f2 = (f2 + 1) % 256])) % 256, s2[f2] = s2[d2], s2[d2] = h2, o2 = s2[(s2[f2] + s2[d2]) % 256], p5 += String.fromCharCode(e2.charCodeAt(c2) ^ o2);
  return p5;
}
/**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 * Author: Owen Leong (@owenl131)
 * Date: 15 Oct 2020
 * References:
 * https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
 * https://github.com/foliojs/pdfkit/blob/master/lib/security.js
 * http://www.fpdf.org/en/script/script37.php
 */
var k = { print: 4, modify: 8, copy: 16, "annot-forms": 32 };
function I(t3, e2, r2, n2) {
  this.v = 1, this.r = 2;
  var i2 = 192;
  t3.forEach(function(t4) {
    if (k.perm !== void 0)
      throw new Error("Invalid permission: " + t4);
    i2 += k[t4];
  }), this.padding = "(\xBFN^Nu\x8AAd\0NV\xFF\xFA\b..\0\xB6\xD0h>\x80/\f\xA9\xFEdSiz";
  var a2 = (e2 + this.padding).substr(0, 32), o2 = (r2 + this.padding).substr(0, 32);
  this.O = this.processOwnerPassword(a2, o2), this.P = -(1 + (255 ^ i2)), this.encryptionKey = x(a2 + this.O + this.lsbFirstWord(this.P) + this.hexToBytes(n2)).substr(0, 5), this.U = P(this.encryptionKey, this.padding);
}
function F$1(t3) {
  if (/[^\u0000-\u00ff]/.test(t3))
    throw new Error("Invalid PDF Name Object: " + t3 + ", Only accept ASCII characters.");
  for (var e2 = "", r2 = t3.length, n2 = 0; n2 < r2; n2++) {
    var i2 = t3.charCodeAt(n2);
    if (i2 < 33 || i2 === 35 || i2 === 37 || i2 === 40 || i2 === 41 || i2 === 47 || i2 === 60 || i2 === 62 || i2 === 91 || i2 === 93 || i2 === 123 || i2 === 125 || i2 > 126)
      e2 += "#" + ("0" + i2.toString(16)).slice(-2);
    else
      e2 += t3[n2];
  }
  return e2;
}
function C(e2) {
  if (_typeof$2(e2) !== "object")
    throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");
  var r2 = {};
  this.subscribe = function(t3, e3, n2) {
    if (n2 = n2 || false, typeof t3 != "string" || typeof e3 != "function" || typeof n2 != "boolean")
      throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");
    r2.hasOwnProperty(t3) || (r2[t3] = {});
    var i2 = Math.random().toString(35);
    return r2[t3][i2] = [e3, !!n2], i2;
  }, this.unsubscribe = function(t3) {
    for (var e3 in r2)
      if (r2[e3][t3])
        return delete r2[e3][t3], Object.keys(r2[e3]).length === 0 && delete r2[e3], true;
    return false;
  }, this.publish = function(t3) {
    if (r2.hasOwnProperty(t3)) {
      var i2 = Array.prototype.slice.call(arguments, 1), o2 = [];
      for (var s2 in r2[t3]) {
        var c2 = r2[t3][s2];
        try {
          c2[0].apply(e2, i2);
        } catch (t4) {
          n$1.console && a$2.error("jsPDF PubSub Error", t4.message, t4);
        }
        c2[1] && o2.push(s2);
      }
      o2.length && o2.forEach(this.unsubscribe);
    }
  }, this.getTopics = function() {
    return r2;
  };
}
function j(t3) {
  if (!(this instanceof j))
    return new j(t3);
  var e2 = "opacity,stroke-opacity".split(",");
  for (var r2 in t3)
    t3.hasOwnProperty(r2) && e2.indexOf(r2) >= 0 && (this[r2] = t3[r2]);
  this.id = "", this.objectNumber = -1;
}
function O$1(t3, e2) {
  this.gState = t3, this.matrix = e2, this.id = "", this.objectNumber = -1;
}
function B(t3, e2, r2, n2, i2) {
  if (!(this instanceof B))
    return new B(t3, e2, r2, n2, i2);
  this.type = t3 === "axial" ? 2 : 3, this.coords = e2, this.colors = r2, O$1.call(this, n2, i2);
}
function M$1(t3, e2, r2, n2, i2) {
  if (!(this instanceof M$1))
    return new M$1(t3, e2, r2, n2, i2);
  this.boundingBox = t3, this.xStep = e2, this.yStep = r2, this.stream = "", this.cloneIndex = 0, O$1.call(this, n2, i2);
}
function E$1(e2) {
  var r2, i2 = typeof arguments[0] == "string" ? arguments[0] : "p", o2 = arguments[1], s2 = arguments[2], c2 = arguments[3], u2 = [], d2 = 1, p5 = 16, g2 = "S", m2 = null;
  _typeof$2(e2 = e2 || {}) === "object" && (i2 = e2.orientation, o2 = e2.unit || o2, s2 = e2.format || s2, c2 = e2.compress || e2.compressPdf || c2, (m2 = e2.encryption || null) !== null && (m2.userPassword = m2.userPassword || "", m2.ownerPassword = m2.ownerPassword || "", m2.userPermissions = m2.userPermissions || []), d2 = typeof e2.userUnit == "number" ? Math.abs(e2.userUnit) : 1, e2.precision !== void 0 && (r2 = e2.precision), e2.floatPrecision !== void 0 && (p5 = e2.floatPrecision), g2 = e2.defaultPathOperation || "S"), u2 = e2.filters || (c2 === true ? ["FlateEncode"] : u2), o2 = o2 || "mm", i2 = ("" + (i2 || "P")).toLowerCase();
  var v2 = e2.putOnlyUsedFonts || false, b2 = {}, y2 = { internal: {}, __private__: {} };
  y2.__private__.PubSub = C;
  var w2 = "1.3", N2 = y2.__private__.getPdfVersion = function() {
    return w2;
  };
  y2.__private__.setPdfVersion = function(t3) {
    w2 = t3;
  };
  var L2 = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
  y2.__private__.getPageFormats = function() {
    return L2;
  };
  var A2 = y2.__private__.getPageFormat = function(t3) {
    return L2[t3];
  };
  s2 = s2 || "a4";
  var x2 = { COMPAT: "compat", ADVANCED: "advanced" }, S2 = x2.COMPAT;
  function _2() {
    this.saveGraphicsState(), lt2(new Vt2(_t2, 0, 0, -_t2, 0, Rr() * _t2).toString() + " cm"), this.setFontSize(this.getFontSize() / _t2), g2 = "n", S2 = x2.ADVANCED;
  }
  function P2() {
    this.restoreGraphicsState(), g2 = "S", S2 = x2.COMPAT;
  }
  var k2 = y2.__private__.combineFontStyleAndFontWeight = function(t3, e3) {
    if (t3 == "bold" && e3 == "normal" || t3 == "bold" && e3 == 400 || t3 == "normal" && e3 == "italic" || t3 == "bold" && e3 == "italic")
      throw new Error("Invalid Combination of fontweight and fontstyle");
    return e3 && (t3 = e3 == 400 || e3 === "normal" ? t3 === "italic" ? "italic" : "normal" : e3 != 700 && e3 !== "bold" || t3 !== "normal" ? (e3 == 700 ? "bold" : e3) + "" + t3 : "bold"), t3;
  };
  y2.advancedAPI = function(t3) {
    var e3 = S2 === x2.COMPAT;
    return e3 && _2.call(this), typeof t3 != "function" || (t3(this), e3 && P2.call(this)), this;
  }, y2.compatAPI = function(t3) {
    var e3 = S2 === x2.ADVANCED;
    return e3 && P2.call(this), typeof t3 != "function" || (t3(this), e3 && _2.call(this)), this;
  }, y2.isAdvancedAPI = function() {
    return S2 === x2.ADVANCED;
  };
  var O2, q2 = function(t3) {
    if (S2 !== x2.ADVANCED)
      throw new Error(t3 + " is only available in 'advanced' API mode. You need to call advancedAPI() first.");
  }, D2 = y2.roundToPrecision = y2.__private__.roundToPrecision = function(t3, e3) {
    var n2 = r2 || e3;
    if (isNaN(t3) || isNaN(n2))
      throw new Error("Invalid argument passed to jsPDF.roundToPrecision");
    return t3.toFixed(n2).replace(/0+$/, "");
  };
  O2 = y2.hpf = y2.__private__.hpf = typeof p5 == "number" ? function(t3) {
    if (isNaN(t3))
      throw new Error("Invalid argument passed to jsPDF.hpf");
    return D2(t3, p5);
  } : p5 === "smart" ? function(t3) {
    if (isNaN(t3))
      throw new Error("Invalid argument passed to jsPDF.hpf");
    return D2(t3, t3 > -1 && t3 < 1 ? 16 : 5);
  } : function(t3) {
    if (isNaN(t3))
      throw new Error("Invalid argument passed to jsPDF.hpf");
    return D2(t3, 16);
  };
  var R2 = y2.f2 = y2.__private__.f2 = function(t3) {
    if (isNaN(t3))
      throw new Error("Invalid argument passed to jsPDF.f2");
    return D2(t3, 2);
  }, T2 = y2.__private__.f3 = function(t3) {
    if (isNaN(t3))
      throw new Error("Invalid argument passed to jsPDF.f3");
    return D2(t3, 3);
  }, z2 = y2.scale = y2.__private__.scale = function(t3) {
    if (isNaN(t3))
      throw new Error("Invalid argument passed to jsPDF.scale");
    return S2 === x2.COMPAT ? t3 * _t2 : S2 === x2.ADVANCED ? t3 : void 0;
  }, U2 = function(t3) {
    return S2 === x2.COMPAT ? Rr() - t3 : S2 === x2.ADVANCED ? t3 : void 0;
  }, H4 = function(t3) {
    return z2(U2(t3));
  };
  y2.__private__.setPrecision = y2.setPrecision = function(t3) {
    typeof parseInt(t3, 10) == "number" && (r2 = parseInt(t3, 10));
  };
  var W2, V2 = "00000000000000000000000000000000", G2 = y2.__private__.getFileId = function() {
    return V2;
  }, Y2 = y2.__private__.setFileId = function(t3) {
    return V2 = t3 !== void 0 && /^[a-fA-F0-9]{32}$/.test(t3) ? t3.toUpperCase() : V2.split("").map(function() {
      return "ABCDEF0123456789".charAt(Math.floor(16 * Math.random()));
    }).join(""), m2 !== null && (Ye = new I(m2.userPermissions, m2.userPassword, m2.ownerPassword, V2)), V2;
  };
  y2.setFileId = function(t3) {
    return Y2(t3), this;
  }, y2.getFileId = function() {
    return G2();
  };
  var J2 = y2.__private__.convertDateToPDFDate = function(t3) {
    var e3 = t3.getTimezoneOffset(), r3 = e3 < 0 ? "+" : "-", n2 = Math.floor(Math.abs(e3 / 60)), i3 = Math.abs(e3 % 60), a2 = [r3, Q2(n2), "'", Q2(i3), "'"].join("");
    return ["D:", t3.getFullYear(), Q2(t3.getMonth() + 1), Q2(t3.getDate()), Q2(t3.getHours()), Q2(t3.getMinutes()), Q2(t3.getSeconds()), a2].join("");
  }, X2 = y2.__private__.convertPDFDateToDate = function(t3) {
    var e3 = parseInt(t3.substr(2, 4), 10), r3 = parseInt(t3.substr(6, 2), 10) - 1, n2 = parseInt(t3.substr(8, 2), 10), i3 = parseInt(t3.substr(10, 2), 10), a2 = parseInt(t3.substr(12, 2), 10), o3 = parseInt(t3.substr(14, 2), 10);
    return new Date(e3, r3, n2, i3, a2, o3, 0);
  }, K2 = y2.__private__.setCreationDate = function(t3) {
    var e3;
    if (t3 === void 0 && (t3 = new Date()), t3 instanceof Date)
      e3 = J2(t3);
    else {
      if (!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(t3))
        throw new Error("Invalid argument passed to jsPDF.setCreationDate");
      e3 = t3;
    }
    return W2 = e3;
  }, Z2 = y2.__private__.getCreationDate = function(t3) {
    var e3 = W2;
    return t3 === "jsDate" && (e3 = X2(W2)), e3;
  };
  y2.setCreationDate = function(t3) {
    return K2(t3), this;
  }, y2.getCreationDate = function(t3) {
    return Z2(t3);
  };
  var $2, Q2 = y2.__private__.padd2 = function(t3) {
    return ("0" + parseInt(t3)).slice(-2);
  }, tt2 = y2.__private__.padd2Hex = function(t3) {
    return ("00" + (t3 = t3.toString())).substr(t3.length);
  }, et2 = 0, rt2 = [], nt2 = [], it2 = 0, at2 = [], ot2 = [], st2 = false, ct2 = nt2, ut2 = function() {
    et2 = 0, it2 = 0, nt2 = [], rt2 = [], at2 = [], Qt2 = Kt2(), te2 = Kt2();
  };
  y2.__private__.setCustomOutputDestination = function(t3) {
    st2 = true, ct2 = t3;
  };
  var ht2 = function(t3) {
    st2 || (ct2 = t3);
  };
  y2.__private__.resetCustomOutputDestination = function() {
    st2 = false, ct2 = nt2;
  };
  var lt2 = y2.__private__.out = function(t3) {
    return t3 = t3.toString(), it2 += t3.length + 1, ct2.push(t3), ct2;
  }, ft2 = y2.__private__.write = function(t3) {
    return lt2(arguments.length === 1 ? t3.toString() : Array.prototype.join.call(arguments, " "));
  }, dt2 = y2.__private__.getArrayBuffer = function(t3) {
    for (var e3 = t3.length, r3 = new ArrayBuffer(e3), n2 = new Uint8Array(r3); e3--; )
      n2[e3] = t3.charCodeAt(e3);
    return r3;
  }, pt2 = [["Helvetica", "helvetica", "normal", "WinAnsiEncoding"], ["Helvetica-Bold", "helvetica", "bold", "WinAnsiEncoding"], ["Helvetica-Oblique", "helvetica", "italic", "WinAnsiEncoding"], ["Helvetica-BoldOblique", "helvetica", "bolditalic", "WinAnsiEncoding"], ["Courier", "courier", "normal", "WinAnsiEncoding"], ["Courier-Bold", "courier", "bold", "WinAnsiEncoding"], ["Courier-Oblique", "courier", "italic", "WinAnsiEncoding"], ["Courier-BoldOblique", "courier", "bolditalic", "WinAnsiEncoding"], ["Times-Roman", "times", "normal", "WinAnsiEncoding"], ["Times-Bold", "times", "bold", "WinAnsiEncoding"], ["Times-Italic", "times", "italic", "WinAnsiEncoding"], ["Times-BoldItalic", "times", "bolditalic", "WinAnsiEncoding"], ["ZapfDingbats", "zapfdingbats", "normal", null], ["Symbol", "symbol", "normal", null]];
  y2.__private__.getStandardFonts = function() {
    return pt2;
  };
  var gt2 = e2.fontSize || 16;
  y2.__private__.setFontSize = y2.setFontSize = function(t3) {
    return gt2 = S2 === x2.ADVANCED ? t3 / _t2 : t3, this;
  };
  var mt2, vt2 = y2.__private__.getFontSize = y2.getFontSize = function() {
    return S2 === x2.COMPAT ? gt2 : gt2 * _t2;
  }, bt2 = e2.R2L || false;
  y2.__private__.setR2L = y2.setR2L = function(t3) {
    return bt2 = t3, this;
  }, y2.__private__.getR2L = y2.getR2L = function() {
    return bt2;
  };
  var yt2, wt2 = y2.__private__.setZoomMode = function(t3) {
    var e3 = [void 0, null, "fullwidth", "fullheight", "fullpage", "original"];
    if (/^\d*\.?\d*%$/.test(t3))
      mt2 = t3;
    else if (isNaN(t3)) {
      if (e3.indexOf(t3) === -1)
        throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "' + t3 + '" is not recognized.');
      mt2 = t3;
    } else
      mt2 = parseInt(t3, 10);
  };
  y2.__private__.getZoomMode = function() {
    return mt2;
  };
  var Nt2, Lt2 = y2.__private__.setPageMode = function(t3) {
    if ([void 0, null, "UseNone", "UseOutlines", "UseThumbs", "FullScreen"].indexOf(t3) == -1)
      throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + t3 + '" is not recognized.');
    yt2 = t3;
  };
  y2.__private__.getPageMode = function() {
    return yt2;
  };
  var At2 = y2.__private__.setLayoutMode = function(t3) {
    if ([void 0, null, "continuous", "single", "twoleft", "tworight", "two"].indexOf(t3) == -1)
      throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "' + t3 + '" is not recognized.');
    Nt2 = t3;
  };
  y2.__private__.getLayoutMode = function() {
    return Nt2;
  }, y2.__private__.setDisplayMode = y2.setDisplayMode = function(t3, e3, r3) {
    return wt2(t3), At2(e3), Lt2(r3), this;
  };
  var xt2 = { title: "", subject: "", author: "", keywords: "", creator: "" };
  y2.__private__.getDocumentProperty = function(t3) {
    if (Object.keys(xt2).indexOf(t3) === -1)
      throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");
    return xt2[t3];
  }, y2.__private__.getDocumentProperties = function() {
    return xt2;
  }, y2.__private__.setDocumentProperties = y2.setProperties = y2.setDocumentProperties = function(t3) {
    for (var e3 in xt2)
      xt2.hasOwnProperty(e3) && t3[e3] && (xt2[e3] = t3[e3]);
    return this;
  }, y2.__private__.setDocumentProperty = function(t3, e3) {
    if (Object.keys(xt2).indexOf(t3) === -1)
      throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");
    return xt2[t3] = e3;
  };
  var St, _t2, Pt2, kt2, It2, Ft2 = {}, Ct2 = {}, jt2 = [], Ot2 = {}, Bt2 = {}, Mt2 = {}, Et2 = {}, qt2 = null, Dt2 = 0, Rt2 = [], Tt2 = new C(y2), zt2 = e2.hotfixes || [], Ut2 = {}, Ht2 = {}, Wt2 = [], Vt2 = function t3(e3, r3, n2, i3, a2, o3) {
    if (!(this instanceof t3))
      return new t3(e3, r3, n2, i3, a2, o3);
    isNaN(e3) && (e3 = 1), isNaN(r3) && (r3 = 0), isNaN(n2) && (n2 = 0), isNaN(i3) && (i3 = 1), isNaN(a2) && (a2 = 0), isNaN(o3) && (o3 = 0), this._matrix = [e3, r3, n2, i3, a2, o3];
  };
  Object.defineProperty(Vt2.prototype, "sx", { get: function() {
    return this._matrix[0];
  }, set: function(t3) {
    this._matrix[0] = t3;
  } }), Object.defineProperty(Vt2.prototype, "shy", { get: function() {
    return this._matrix[1];
  }, set: function(t3) {
    this._matrix[1] = t3;
  } }), Object.defineProperty(Vt2.prototype, "shx", { get: function() {
    return this._matrix[2];
  }, set: function(t3) {
    this._matrix[2] = t3;
  } }), Object.defineProperty(Vt2.prototype, "sy", { get: function() {
    return this._matrix[3];
  }, set: function(t3) {
    this._matrix[3] = t3;
  } }), Object.defineProperty(Vt2.prototype, "tx", { get: function() {
    return this._matrix[4];
  }, set: function(t3) {
    this._matrix[4] = t3;
  } }), Object.defineProperty(Vt2.prototype, "ty", { get: function() {
    return this._matrix[5];
  }, set: function(t3) {
    this._matrix[5] = t3;
  } }), Object.defineProperty(Vt2.prototype, "a", { get: function() {
    return this._matrix[0];
  }, set: function(t3) {
    this._matrix[0] = t3;
  } }), Object.defineProperty(Vt2.prototype, "b", { get: function() {
    return this._matrix[1];
  }, set: function(t3) {
    this._matrix[1] = t3;
  } }), Object.defineProperty(Vt2.prototype, "c", { get: function() {
    return this._matrix[2];
  }, set: function(t3) {
    this._matrix[2] = t3;
  } }), Object.defineProperty(Vt2.prototype, "d", { get: function() {
    return this._matrix[3];
  }, set: function(t3) {
    this._matrix[3] = t3;
  } }), Object.defineProperty(Vt2.prototype, "e", { get: function() {
    return this._matrix[4];
  }, set: function(t3) {
    this._matrix[4] = t3;
  } }), Object.defineProperty(Vt2.prototype, "f", { get: function() {
    return this._matrix[5];
  }, set: function(t3) {
    this._matrix[5] = t3;
  } }), Object.defineProperty(Vt2.prototype, "rotation", { get: function() {
    return Math.atan2(this.shx, this.sx);
  } }), Object.defineProperty(Vt2.prototype, "scaleX", { get: function() {
    return this.decompose().scale.sx;
  } }), Object.defineProperty(Vt2.prototype, "scaleY", { get: function() {
    return this.decompose().scale.sy;
  } }), Object.defineProperty(Vt2.prototype, "isIdentity", { get: function() {
    return this.sx === 1 && (this.shy === 0 && (this.shx === 0 && (this.sy === 1 && (this.tx === 0 && this.ty === 0))));
  } }), Vt2.prototype.join = function(t3) {
    return [this.sx, this.shy, this.shx, this.sy, this.tx, this.ty].map(O2).join(t3);
  }, Vt2.prototype.multiply = function(t3) {
    var e3 = t3.sx * this.sx + t3.shy * this.shx, r3 = t3.sx * this.shy + t3.shy * this.sy, n2 = t3.shx * this.sx + t3.sy * this.shx, i3 = t3.shx * this.shy + t3.sy * this.sy, a2 = t3.tx * this.sx + t3.ty * this.shx + this.tx, o3 = t3.tx * this.shy + t3.ty * this.sy + this.ty;
    return new Vt2(e3, r3, n2, i3, a2, o3);
  }, Vt2.prototype.decompose = function() {
    var t3 = this.sx, e3 = this.shy, r3 = this.shx, n2 = this.sy, i3 = this.tx, a2 = this.ty, o3 = Math.sqrt(t3 * t3 + e3 * e3), s3 = (t3 /= o3) * r3 + (e3 /= o3) * n2;
    r3 -= t3 * s3, n2 -= e3 * s3;
    var c3 = Math.sqrt(r3 * r3 + n2 * n2);
    return s3 /= c3, t3 * (n2 /= c3) < e3 * (r3 /= c3) && (t3 = -t3, e3 = -e3, s3 = -s3, o3 = -o3), { scale: new Vt2(o3, 0, 0, c3, 0, 0), translate: new Vt2(1, 0, 0, 1, i3, a2), rotate: new Vt2(t3, e3, -e3, t3, 0, 0), skew: new Vt2(1, 0, s3, 1, 0, 0) };
  }, Vt2.prototype.toString = function(t3) {
    return this.join(" ");
  }, Vt2.prototype.inversed = function() {
    var t3 = this.sx, e3 = this.shy, r3 = this.shx, n2 = this.sy, i3 = this.tx, a2 = this.ty, o3 = 1 / (t3 * n2 - e3 * r3), s3 = n2 * o3, c3 = -e3 * o3, u3 = -r3 * o3, h2 = t3 * o3;
    return new Vt2(s3, c3, u3, h2, -s3 * i3 - u3 * a2, -c3 * i3 - h2 * a2);
  }, Vt2.prototype.applyToPoint = function(t3) {
    var e3 = t3.x * this.sx + t3.y * this.shx + this.tx, r3 = t3.x * this.shy + t3.y * this.sy + this.ty;
    return new Cr(e3, r3);
  }, Vt2.prototype.applyToRectangle = function(t3) {
    var e3 = this.applyToPoint(t3), r3 = this.applyToPoint(new Cr(t3.x + t3.w, t3.y + t3.h));
    return new jr(e3.x, e3.y, r3.x - e3.x, r3.y - e3.y);
  }, Vt2.prototype.clone = function() {
    var t3 = this.sx, e3 = this.shy, r3 = this.shx, n2 = this.sy, i3 = this.tx, a2 = this.ty;
    return new Vt2(t3, e3, r3, n2, i3, a2);
  }, y2.Matrix = Vt2;
  var Gt2 = y2.matrixMult = function(t3, e3) {
    return e3.multiply(t3);
  }, Yt2 = new Vt2(1, 0, 0, 1, 0, 0);
  y2.unitMatrix = y2.identityMatrix = Yt2;
  var Jt2 = function(t3, e3) {
    if (!Bt2[t3]) {
      var r3 = (e3 instanceof B ? "Sh" : "P") + (Object.keys(Ot2).length + 1).toString(10);
      e3.id = r3, Bt2[t3] = r3, Ot2[r3] = e3, Tt2.publish("addPattern", e3);
    }
  };
  y2.ShadingPattern = B, y2.TilingPattern = M$1, y2.addShadingPattern = function(t3, e3) {
    return q2("addShadingPattern()"), Jt2(t3, e3), this;
  }, y2.beginTilingPattern = function(t3) {
    q2("beginTilingPattern()"), Br(t3.boundingBox[0], t3.boundingBox[1], t3.boundingBox[2] - t3.boundingBox[0], t3.boundingBox[3] - t3.boundingBox[1], t3.matrix);
  }, y2.endTilingPattern = function(t3, e3) {
    q2("endTilingPattern()"), e3.stream = ot2[$2].join("\n"), Jt2(t3, e3), Tt2.publish("endTilingPattern", e3), Wt2.pop().restore();
  };
  var Xt2 = y2.__private__.newObject = function() {
    var t3 = Kt2();
    return Zt2(t3, true), t3;
  }, Kt2 = y2.__private__.newObjectDeferred = function() {
    return et2++, rt2[et2] = function() {
      return it2;
    }, et2;
  }, Zt2 = function(t3, e3) {
    return e3 = typeof e3 == "boolean" && e3, rt2[t3] = it2, e3 && lt2(t3 + " 0 obj"), t3;
  }, $t2 = y2.__private__.newAdditionalObject = function() {
    var t3 = { objId: Kt2(), content: "" };
    return at2.push(t3), t3;
  }, Qt2 = Kt2(), te2 = Kt2(), ee2 = y2.__private__.decodeColorString = function(t3) {
    var e3 = t3.split(" ");
    if (e3.length !== 2 || e3[1] !== "g" && e3[1] !== "G") {
      if (e3.length === 5 && (e3[4] === "k" || e3[4] === "K")) {
        e3 = [(1 - e3[0]) * (1 - e3[3]), (1 - e3[1]) * (1 - e3[3]), (1 - e3[2]) * (1 - e3[3]), "r"];
      }
    } else {
      var r3 = parseFloat(e3[0]);
      e3 = [r3, r3, r3, "r"];
    }
    for (var n2 = "#", i3 = 0; i3 < 3; i3++)
      n2 += ("0" + Math.floor(255 * parseFloat(e3[i3])).toString(16)).slice(-2);
    return n2;
  }, re2 = y2.__private__.encodeColorString = function(e3) {
    var r3;
    typeof e3 == "string" && (e3 = { ch1: e3 });
    var n2 = e3.ch1, i3 = e3.ch2, a2 = e3.ch3, o3 = e3.ch4, s3 = e3.pdfColorType === "draw" ? ["G", "RG", "K"] : ["g", "rg", "k"];
    if (typeof n2 == "string" && n2.charAt(0) !== "#") {
      var c3 = new f$2(n2);
      if (c3.ok)
        n2 = c3.toHex();
      else if (!/^\d*\.?\d*$/.test(n2))
        throw new Error('Invalid color "' + n2 + '" passed to jsPDF.encodeColorString.');
    }
    if (typeof n2 == "string" && /^#[0-9A-Fa-f]{3}$/.test(n2) && (n2 = "#" + n2[1] + n2[1] + n2[2] + n2[2] + n2[3] + n2[3]), typeof n2 == "string" && /^#[0-9A-Fa-f]{6}$/.test(n2)) {
      var u3 = parseInt(n2.substr(1), 16);
      n2 = u3 >> 16 & 255, i3 = u3 >> 8 & 255, a2 = 255 & u3;
    }
    if (i3 === void 0 || o3 === void 0 && n2 === i3 && i3 === a2)
      if (typeof n2 == "string")
        r3 = n2 + " " + s3[0];
      else
        switch (e3.precision) {
          case 2:
            r3 = R2(n2 / 255) + " " + s3[0];
            break;
          case 3:
          default:
            r3 = T2(n2 / 255) + " " + s3[0];
        }
    else if (o3 === void 0 || _typeof$2(o3) === "object") {
      if (o3 && !isNaN(o3.a) && o3.a === 0)
        return r3 = ["1.", "1.", "1.", s3[1]].join(" ");
      if (typeof n2 == "string")
        r3 = [n2, i3, a2, s3[1]].join(" ");
      else
        switch (e3.precision) {
          case 2:
            r3 = [R2(n2 / 255), R2(i3 / 255), R2(a2 / 255), s3[1]].join(" ");
            break;
          default:
          case 3:
            r3 = [T2(n2 / 255), T2(i3 / 255), T2(a2 / 255), s3[1]].join(" ");
        }
    } else if (typeof n2 == "string")
      r3 = [n2, i3, a2, o3, s3[2]].join(" ");
    else
      switch (e3.precision) {
        case 2:
          r3 = [R2(n2), R2(i3), R2(a2), R2(o3), s3[2]].join(" ");
          break;
        case 3:
        default:
          r3 = [T2(n2), T2(i3), T2(a2), T2(o3), s3[2]].join(" ");
      }
    return r3;
  }, ne2 = y2.__private__.getFilters = function() {
    return u2;
  }, ie2 = y2.__private__.putStream = function(t3) {
    var e3 = (t3 = t3 || {}).data || "", r3 = t3.filters || ne2(), n2 = t3.alreadyAppliedFilters || [], i3 = t3.addLength1 || false, a2 = e3.length, o3 = t3.objectId, s3 = function(t4) {
      return t4;
    };
    if (m2 !== null && o3 === void 0)
      throw new Error("ObjectId must be passed to putStream for file encryption");
    m2 !== null && (s3 = Ye.encryptor(o3, 0));
    var c3 = {};
    r3 === true && (r3 = ["FlateEncode"]);
    var u3 = t3.additionalKeyValues || [], h2 = (c3 = E$1.API.processDataByFilters !== void 0 ? E$1.API.processDataByFilters(e3, r3) : { data: e3, reverseChain: [] }).reverseChain + (Array.isArray(n2) ? n2.join(" ") : n2.toString());
    if (c3.data.length !== 0 && (u3.push({ key: "Length", value: c3.data.length }), i3 === true && u3.push({ key: "Length1", value: a2 })), h2.length != 0)
      if (h2.split("/").length - 1 == 1)
        u3.push({ key: "Filter", value: h2 });
      else {
        u3.push({ key: "Filter", value: "[" + h2 + "]" });
        for (var l2 = 0; l2 < u3.length; l2 += 1)
          if (u3[l2].key === "DecodeParms") {
            for (var f2 = [], d3 = 0; d3 < c3.reverseChain.split("/").length - 1; d3 += 1)
              f2.push("null");
            f2.push(u3[l2].value), u3[l2].value = "[" + f2.join(" ") + "]";
          }
      }
    lt2("<<");
    for (var p6 = 0; p6 < u3.length; p6++)
      lt2("/" + u3[p6].key + " " + u3[p6].value);
    lt2(">>"), c3.data.length !== 0 && (lt2("stream"), lt2(s3(c3.data)), lt2("endstream"));
  }, ae2 = y2.__private__.putPage = function(t3) {
    var e3 = t3.number, r3 = t3.data, n2 = t3.objId, i3 = t3.contentsObjId;
    Zt2(n2, true), lt2("<</Type /Page"), lt2("/Parent " + t3.rootDictionaryObjId + " 0 R"), lt2("/Resources " + t3.resourceDictionaryObjId + " 0 R"), lt2("/MediaBox [" + parseFloat(O2(t3.mediaBox.bottomLeftX)) + " " + parseFloat(O2(t3.mediaBox.bottomLeftY)) + " " + O2(t3.mediaBox.topRightX) + " " + O2(t3.mediaBox.topRightY) + "]"), t3.cropBox !== null && lt2("/CropBox [" + O2(t3.cropBox.bottomLeftX) + " " + O2(t3.cropBox.bottomLeftY) + " " + O2(t3.cropBox.topRightX) + " " + O2(t3.cropBox.topRightY) + "]"), t3.bleedBox !== null && lt2("/BleedBox [" + O2(t3.bleedBox.bottomLeftX) + " " + O2(t3.bleedBox.bottomLeftY) + " " + O2(t3.bleedBox.topRightX) + " " + O2(t3.bleedBox.topRightY) + "]"), t3.trimBox !== null && lt2("/TrimBox [" + O2(t3.trimBox.bottomLeftX) + " " + O2(t3.trimBox.bottomLeftY) + " " + O2(t3.trimBox.topRightX) + " " + O2(t3.trimBox.topRightY) + "]"), t3.artBox !== null && lt2("/ArtBox [" + O2(t3.artBox.bottomLeftX) + " " + O2(t3.artBox.bottomLeftY) + " " + O2(t3.artBox.topRightX) + " " + O2(t3.artBox.topRightY) + "]"), typeof t3.userUnit == "number" && t3.userUnit !== 1 && lt2("/UserUnit " + t3.userUnit), Tt2.publish("putPage", { objId: n2, pageContext: Rt2[e3], pageNumber: e3, page: r3 }), lt2("/Contents " + i3 + " 0 R"), lt2(">>"), lt2("endobj");
    var a2 = r3.join("\n");
    return S2 === x2.ADVANCED && (a2 += "\nQ"), Zt2(i3, true), ie2({ data: a2, filters: ne2(), objectId: i3 }), lt2("endobj"), n2;
  }, oe2 = y2.__private__.putPages = function() {
    var t3, e3, r3 = [];
    for (t3 = 1; t3 <= Dt2; t3++)
      Rt2[t3].objId = Kt2(), Rt2[t3].contentsObjId = Kt2();
    for (t3 = 1; t3 <= Dt2; t3++)
      r3.push(ae2({ number: t3, data: ot2[t3], objId: Rt2[t3].objId, contentsObjId: Rt2[t3].contentsObjId, mediaBox: Rt2[t3].mediaBox, cropBox: Rt2[t3].cropBox, bleedBox: Rt2[t3].bleedBox, trimBox: Rt2[t3].trimBox, artBox: Rt2[t3].artBox, userUnit: Rt2[t3].userUnit, rootDictionaryObjId: Qt2, resourceDictionaryObjId: te2 }));
    Zt2(Qt2, true), lt2("<</Type /Pages");
    var n2 = "/Kids [";
    for (e3 = 0; e3 < Dt2; e3++)
      n2 += r3[e3] + " 0 R ";
    lt2(n2 + "]"), lt2("/Count " + Dt2), lt2(">>"), lt2("endobj"), Tt2.publish("postPutPages");
  }, se2 = function(t3) {
    Tt2.publish("putFont", { font: t3, out: lt2, newObject: Xt2, putStream: ie2 }), t3.isAlreadyPutted !== true && (t3.objectNumber = Xt2(), lt2("<<"), lt2("/Type /Font"), lt2("/BaseFont /" + F$1(t3.postScriptName)), lt2("/Subtype /Type1"), typeof t3.encoding == "string" && lt2("/Encoding /" + t3.encoding), lt2("/FirstChar 32"), lt2("/LastChar 255"), lt2(">>"), lt2("endobj"));
  }, ce2 = function() {
    for (var t3 in Ft2)
      Ft2.hasOwnProperty(t3) && (v2 === false || v2 === true && b2.hasOwnProperty(t3)) && se2(Ft2[t3]);
  }, ue2 = function(t3) {
    t3.objectNumber = Xt2();
    var e3 = [];
    e3.push({ key: "Type", value: "/XObject" }), e3.push({ key: "Subtype", value: "/Form" }), e3.push({ key: "BBox", value: "[" + [O2(t3.x), O2(t3.y), O2(t3.x + t3.width), O2(t3.y + t3.height)].join(" ") + "]" }), e3.push({ key: "Matrix", value: "[" + t3.matrix.toString() + "]" });
    var r3 = t3.pages[1].join("\n");
    ie2({ data: r3, additionalKeyValues: e3, objectId: t3.objectNumber }), lt2("endobj");
  }, he2 = function() {
    for (var t3 in Ut2)
      Ut2.hasOwnProperty(t3) && ue2(Ut2[t3]);
  }, le2 = function(t3, e3) {
    var r3, n2 = [], i3 = 1 / (e3 - 1);
    for (r3 = 0; r3 < 1; r3 += i3)
      n2.push(r3);
    if (n2.push(1), t3[0].offset != 0) {
      var a2 = { offset: 0, color: t3[0].color };
      t3.unshift(a2);
    }
    if (t3[t3.length - 1].offset != 1) {
      var o3 = { offset: 1, color: t3[t3.length - 1].color };
      t3.push(o3);
    }
    for (var s3 = "", c3 = 0, u3 = 0; u3 < n2.length; u3++) {
      for (r3 = n2[u3]; r3 > t3[c3 + 1].offset; )
        c3++;
      var h2 = t3[c3].offset, l2 = (r3 - h2) / (t3[c3 + 1].offset - h2), f2 = t3[c3].color, d3 = t3[c3 + 1].color;
      s3 += tt2(Math.round((1 - l2) * f2[0] + l2 * d3[0]).toString(16)) + tt2(Math.round((1 - l2) * f2[1] + l2 * d3[1]).toString(16)) + tt2(Math.round((1 - l2) * f2[2] + l2 * d3[2]).toString(16));
    }
    return s3.trim();
  }, fe2 = function(t3, e3) {
    e3 || (e3 = 21);
    var r3 = Xt2(), n2 = le2(t3.colors, e3), i3 = [];
    i3.push({ key: "FunctionType", value: "0" }), i3.push({ key: "Domain", value: "[0.0 1.0]" }), i3.push({ key: "Size", value: "[" + e3 + "]" }), i3.push({ key: "BitsPerSample", value: "8" }), i3.push({ key: "Range", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), i3.push({ key: "Decode", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), ie2({ data: n2, additionalKeyValues: i3, alreadyAppliedFilters: ["/ASCIIHexDecode"], objectId: r3 }), lt2("endobj"), t3.objectNumber = Xt2(), lt2("<< /ShadingType " + t3.type), lt2("/ColorSpace /DeviceRGB");
    var a2 = "/Coords [" + O2(parseFloat(t3.coords[0])) + " " + O2(parseFloat(t3.coords[1])) + " ";
    t3.type === 2 ? a2 += O2(parseFloat(t3.coords[2])) + " " + O2(parseFloat(t3.coords[3])) : a2 += O2(parseFloat(t3.coords[2])) + " " + O2(parseFloat(t3.coords[3])) + " " + O2(parseFloat(t3.coords[4])) + " " + O2(parseFloat(t3.coords[5])), lt2(a2 += "]"), t3.matrix && lt2("/Matrix [" + t3.matrix.toString() + "]"), lt2("/Function " + r3 + " 0 R"), lt2("/Extend [true true]"), lt2(">>"), lt2("endobj");
  }, de2 = function(t3, e3) {
    var r3 = Kt2(), n2 = Xt2();
    e3.push({ resourcesOid: r3, objectOid: n2 }), t3.objectNumber = n2;
    var i3 = [];
    i3.push({ key: "Type", value: "/Pattern" }), i3.push({ key: "PatternType", value: "1" }), i3.push({ key: "PaintType", value: "1" }), i3.push({ key: "TilingType", value: "1" }), i3.push({ key: "BBox", value: "[" + t3.boundingBox.map(O2).join(" ") + "]" }), i3.push({ key: "XStep", value: O2(t3.xStep) }), i3.push({ key: "YStep", value: O2(t3.yStep) }), i3.push({ key: "Resources", value: r3 + " 0 R" }), t3.matrix && i3.push({ key: "Matrix", value: "[" + t3.matrix.toString() + "]" }), ie2({ data: t3.stream, additionalKeyValues: i3, objectId: t3.objectNumber }), lt2("endobj");
  }, pe2 = function(t3) {
    var e3;
    for (e3 in Ot2)
      Ot2.hasOwnProperty(e3) && (Ot2[e3] instanceof B ? fe2(Ot2[e3]) : Ot2[e3] instanceof M$1 && de2(Ot2[e3], t3));
  }, ge2 = function(t3) {
    for (var e3 in t3.objectNumber = Xt2(), lt2("<<"), t3)
      switch (e3) {
        case "opacity":
          lt2("/ca " + R2(t3[e3]));
          break;
        case "stroke-opacity":
          lt2("/CA " + R2(t3[e3]));
      }
    lt2(">>"), lt2("endobj");
  }, me2 = function() {
    var t3;
    for (t3 in Mt2)
      Mt2.hasOwnProperty(t3) && ge2(Mt2[t3]);
  }, ve2 = function() {
    for (var t3 in lt2("/XObject <<"), Ut2)
      Ut2.hasOwnProperty(t3) && Ut2[t3].objectNumber >= 0 && lt2("/" + t3 + " " + Ut2[t3].objectNumber + " 0 R");
    Tt2.publish("putXobjectDict"), lt2(">>");
  }, be2 = function() {
    Ye.oid = Xt2(), lt2("<<"), lt2("/Filter /Standard"), lt2("/V " + Ye.v), lt2("/R " + Ye.r), lt2("/U <" + Ye.toHexString(Ye.U) + ">"), lt2("/O <" + Ye.toHexString(Ye.O) + ">"), lt2("/P " + Ye.P), lt2(">>"), lt2("endobj");
  }, ye2 = function() {
    for (var t3 in lt2("/Font <<"), Ft2)
      Ft2.hasOwnProperty(t3) && (v2 === false || v2 === true && b2.hasOwnProperty(t3)) && lt2("/" + t3 + " " + Ft2[t3].objectNumber + " 0 R");
    lt2(">>");
  }, we2 = function() {
    if (Object.keys(Ot2).length > 0) {
      for (var t3 in lt2("/Shading <<"), Ot2)
        Ot2.hasOwnProperty(t3) && Ot2[t3] instanceof B && Ot2[t3].objectNumber >= 0 && lt2("/" + t3 + " " + Ot2[t3].objectNumber + " 0 R");
      Tt2.publish("putShadingPatternDict"), lt2(">>");
    }
  }, Ne2 = function(t3) {
    if (Object.keys(Ot2).length > 0) {
      for (var e3 in lt2("/Pattern <<"), Ot2)
        Ot2.hasOwnProperty(e3) && Ot2[e3] instanceof y2.TilingPattern && Ot2[e3].objectNumber >= 0 && Ot2[e3].objectNumber < t3 && lt2("/" + e3 + " " + Ot2[e3].objectNumber + " 0 R");
      Tt2.publish("putTilingPatternDict"), lt2(">>");
    }
  }, Le2 = function() {
    if (Object.keys(Mt2).length > 0) {
      var t3;
      for (t3 in lt2("/ExtGState <<"), Mt2)
        Mt2.hasOwnProperty(t3) && Mt2[t3].objectNumber >= 0 && lt2("/" + t3 + " " + Mt2[t3].objectNumber + " 0 R");
      Tt2.publish("putGStateDict"), lt2(">>");
    }
  }, Ae = function(t3) {
    Zt2(t3.resourcesOid, true), lt2("<<"), lt2("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"), ye2(), we2(), Ne2(t3.objectOid), Le2(), ve2(), lt2(">>"), lt2("endobj");
  }, xe = function() {
    var t3 = [];
    ce2(), me2(), he2(), pe2(t3), Tt2.publish("putResources"), t3.forEach(Ae), Ae({ resourcesOid: te2, objectOid: Number.MAX_SAFE_INTEGER }), Tt2.publish("postPutResources");
  }, Se = function() {
    Tt2.publish("putAdditionalObjects");
    for (var t3 = 0; t3 < at2.length; t3++) {
      var e3 = at2[t3];
      Zt2(e3.objId, true), lt2(e3.content), lt2("endobj");
    }
    Tt2.publish("postPutAdditionalObjects");
  }, _e = function(t3) {
    Ct2[t3.fontName] = Ct2[t3.fontName] || {}, Ct2[t3.fontName][t3.fontStyle] = t3.id;
  }, Pe = function(t3, e3, r3, n2, i3) {
    var a2 = { id: "F" + (Object.keys(Ft2).length + 1).toString(10), postScriptName: t3, fontName: e3, fontStyle: r3, encoding: n2, isStandardFont: i3 || false, metadata: {} };
    return Tt2.publish("addFont", { font: a2, instance: this }), Ft2[a2.id] = a2, _e(a2), a2.id;
  }, ke = function(t3) {
    for (var e3 = 0, r3 = pt2.length; e3 < r3; e3++) {
      var n2 = Pe.call(this, t3[e3][0], t3[e3][1], t3[e3][2], pt2[e3][3], true);
      v2 === false && (b2[n2] = true);
      var i3 = t3[e3][0].split("-");
      _e({ id: n2, fontName: i3[0], fontStyle: i3[1] || "" });
    }
    Tt2.publish("addFonts", { fonts: Ft2, dictionary: Ct2 });
  }, Ie = function(t3) {
    return t3.foo = function() {
      try {
        return t3.apply(this, arguments);
      } catch (t4) {
        var e3 = t4.stack || "";
        ~e3.indexOf(" at ") && (e3 = e3.split(" at ")[1]);
        var r3 = "Error in function " + e3.split("\n")[0].split("<")[0] + ": " + t4.message;
        if (!n$1.console)
          throw new Error(r3);
        n$1.console.error(r3, t4), n$1.alert && alert(r3);
      }
    }, t3.foo.bar = t3, t3.foo;
  }, Fe = function(t3, e3) {
    var r3, n2, i3, a2, o3, s3, c3, u3, h2;
    if (i3 = (e3 = e3 || {}).sourceEncoding || "Unicode", o3 = e3.outputEncoding, (e3.autoencode || o3) && Ft2[St].metadata && Ft2[St].metadata[i3] && Ft2[St].metadata[i3].encoding && (a2 = Ft2[St].metadata[i3].encoding, !o3 && Ft2[St].encoding && (o3 = Ft2[St].encoding), !o3 && a2.codePages && (o3 = a2.codePages[0]), typeof o3 == "string" && (o3 = a2[o3]), o3)) {
      for (c3 = false, s3 = [], r3 = 0, n2 = t3.length; r3 < n2; r3++)
        (u3 = o3[t3.charCodeAt(r3)]) ? s3.push(String.fromCharCode(u3)) : s3.push(t3[r3]), s3[r3].charCodeAt(0) >> 8 && (c3 = true);
      t3 = s3.join("");
    }
    for (r3 = t3.length; c3 === void 0 && r3 !== 0; )
      t3.charCodeAt(r3 - 1) >> 8 && (c3 = true), r3--;
    if (!c3)
      return t3;
    for (s3 = e3.noBOM ? [] : [254, 255], r3 = 0, n2 = t3.length; r3 < n2; r3++) {
      if ((h2 = (u3 = t3.charCodeAt(r3)) >> 8) >> 8)
        throw new Error("Character at position " + r3 + " of string '" + t3 + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
      s3.push(h2), s3.push(u3 - (h2 << 8));
    }
    return String.fromCharCode.apply(void 0, s3);
  }, Ce = y2.__private__.pdfEscape = y2.pdfEscape = function(t3, e3) {
    return Fe(t3, e3).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
  }, je = y2.__private__.beginPage = function(t3) {
    ot2[++Dt2] = [], Rt2[Dt2] = { objId: 0, contentsObjId: 0, userUnit: Number(d2), artBox: null, bleedBox: null, cropBox: null, trimBox: null, mediaBox: { bottomLeftX: 0, bottomLeftY: 0, topRightX: Number(t3[0]), topRightY: Number(t3[1]) } }, Me(Dt2), ht2(ot2[$2]);
  }, Oe = function(t3, e3) {
    var r3, n2, o3;
    switch (i2 = e3 || i2, typeof t3 == "string" && (r3 = A2(t3.toLowerCase()), Array.isArray(r3) && (n2 = r3[0], o3 = r3[1])), Array.isArray(t3) && (n2 = t3[0] * _t2, o3 = t3[1] * _t2), isNaN(n2) && (n2 = s2[0], o3 = s2[1]), (n2 > 14400 || o3 > 14400) && (a$2.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"), n2 = Math.min(14400, n2), o3 = Math.min(14400, o3)), s2 = [n2, o3], i2.substr(0, 1)) {
      case "l":
        o3 > n2 && (s2 = [o3, n2]);
        break;
      case "p":
        n2 > o3 && (s2 = [o3, n2]);
    }
    je(s2), pr(fr), lt2(Lr), kr !== 0 && lt2(kr + " J"), Ir !== 0 && lt2(Ir + " j"), Tt2.publish("addPage", { pageNumber: Dt2 });
  }, Be = function(t3) {
    t3 > 0 && t3 <= Dt2 && (ot2.splice(t3, 1), Rt2.splice(t3, 1), Dt2--, $2 > Dt2 && ($2 = Dt2), this.setPage($2));
  }, Me = function(t3) {
    t3 > 0 && t3 <= Dt2 && ($2 = t3);
  }, Ee = y2.__private__.getNumberOfPages = y2.getNumberOfPages = function() {
    return ot2.length - 1;
  }, qe = function(t3, e3, r3) {
    var n2, i3 = void 0;
    return r3 = r3 || {}, t3 = t3 !== void 0 ? t3 : Ft2[St].fontName, e3 = e3 !== void 0 ? e3 : Ft2[St].fontStyle, n2 = t3.toLowerCase(), Ct2[n2] !== void 0 && Ct2[n2][e3] !== void 0 ? i3 = Ct2[n2][e3] : Ct2[t3] !== void 0 && Ct2[t3][e3] !== void 0 ? i3 = Ct2[t3][e3] : r3.disableWarning === false && a$2.warn("Unable to look up font label for font '" + t3 + "', '" + e3 + "'. Refer to getFontList() for available fonts."), i3 || r3.noFallback || (i3 = Ct2.times[e3]) == null && (i3 = Ct2.times.normal), i3;
  }, De = y2.__private__.putInfo = function() {
    var t3 = Xt2(), e3 = function(t4) {
      return t4;
    };
    for (var r3 in m2 !== null && (e3 = Ye.encryptor(t3, 0)), lt2("<<"), lt2("/Producer (" + Ce(e3("jsPDF " + E$1.version)) + ")"), xt2)
      xt2.hasOwnProperty(r3) && xt2[r3] && lt2("/" + r3.substr(0, 1).toUpperCase() + r3.substr(1) + " (" + Ce(e3(xt2[r3])) + ")");
    lt2("/CreationDate (" + Ce(e3(W2)) + ")"), lt2(">>"), lt2("endobj");
  }, Re = y2.__private__.putCatalog = function(t3) {
    var e3 = (t3 = t3 || {}).rootDictionaryObjId || Qt2;
    switch (Xt2(), lt2("<<"), lt2("/Type /Catalog"), lt2("/Pages " + e3 + " 0 R"), mt2 || (mt2 = "fullwidth"), mt2) {
      case "fullwidth":
        lt2("/OpenAction [3 0 R /FitH null]");
        break;
      case "fullheight":
        lt2("/OpenAction [3 0 R /FitV null]");
        break;
      case "fullpage":
        lt2("/OpenAction [3 0 R /Fit]");
        break;
      case "original":
        lt2("/OpenAction [3 0 R /XYZ null null 1]");
        break;
      default:
        var r3 = "" + mt2;
        r3.substr(r3.length - 1) === "%" && (mt2 = parseInt(mt2) / 100), typeof mt2 == "number" && lt2("/OpenAction [3 0 R /XYZ null null " + R2(mt2) + "]");
    }
    switch (Nt2 || (Nt2 = "continuous"), Nt2) {
      case "continuous":
        lt2("/PageLayout /OneColumn");
        break;
      case "single":
        lt2("/PageLayout /SinglePage");
        break;
      case "two":
      case "twoleft":
        lt2("/PageLayout /TwoColumnLeft");
        break;
      case "tworight":
        lt2("/PageLayout /TwoColumnRight");
    }
    yt2 && lt2("/PageMode /" + yt2), Tt2.publish("putCatalog"), lt2(">>"), lt2("endobj");
  }, Te = y2.__private__.putTrailer = function() {
    lt2("trailer"), lt2("<<"), lt2("/Size " + (et2 + 1)), lt2("/Root " + et2 + " 0 R"), lt2("/Info " + (et2 - 1) + " 0 R"), m2 !== null && lt2("/Encrypt " + Ye.oid + " 0 R"), lt2("/ID [ <" + V2 + "> <" + V2 + "> ]"), lt2(">>");
  }, ze = y2.__private__.putHeader = function() {
    lt2("%PDF-" + w2), lt2("%\xBA\xDF\xAC\xE0");
  }, Ue = y2.__private__.putXRef = function() {
    var t3 = "0000000000";
    lt2("xref"), lt2("0 " + (et2 + 1)), lt2("0000000000 65535 f ");
    for (var e3 = 1; e3 <= et2; e3++) {
      typeof rt2[e3] == "function" ? lt2((t3 + rt2[e3]()).slice(-10) + " 00000 n ") : rt2[e3] !== void 0 ? lt2((t3 + rt2[e3]).slice(-10) + " 00000 n ") : lt2("0000000000 00000 n ");
    }
  }, He = y2.__private__.buildDocument = function() {
    ut2(), ht2(nt2), Tt2.publish("buildDocument"), ze(), oe2(), Se(), xe(), m2 !== null && be2(), De(), Re();
    var t3 = it2;
    return Ue(), Te(), lt2("startxref"), lt2("" + t3), lt2("%%EOF"), ht2(ot2[$2]), nt2.join("\n");
  }, We = y2.__private__.getBlob = function(t3) {
    return new Blob([dt2(t3)], { type: "application/pdf" });
  }, Ve = y2.output = y2.__private__.output = Ie(function(t3, e3) {
    switch (typeof (e3 = e3 || {}) == "string" ? e3 = { filename: e3 } : e3.filename = e3.filename || "generated.pdf", t3) {
      case void 0:
        return He();
      case "save":
        y2.save(e3.filename);
        break;
      case "arraybuffer":
        return dt2(He());
      case "blob":
        return We(He());
      case "bloburi":
      case "bloburl":
        if (n$1.URL !== void 0 && typeof n$1.URL.createObjectURL == "function")
          return n$1.URL && n$1.URL.createObjectURL(We(He())) || void 0;
        a$2.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");
        break;
      case "datauristring":
      case "dataurlstring":
        var r3 = "", i3 = He();
        try {
          r3 = h$1(i3);
        } catch (t4) {
          r3 = h$1(unescape(encodeURIComponent(i3)));
        }
        return "data:application/pdf;filename=" + e3.filename + ";base64," + r3;
      case "pdfobjectnewwindow":
        if (Object.prototype.toString.call(n$1) === "[object Window]") {
          var o3 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="' + (e3.pdfObjectUrl || "https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js") + '"><\/script><script >PDFObject.embed("' + this.output("dataurlstring") + '", ' + JSON.stringify(e3) + ");<\/script></body></html>", s3 = n$1.open();
          return s3 !== null && s3.document.write(o3), s3;
        }
        throw new Error("The option pdfobjectnewwindow just works in a browser-environment.");
      case "pdfjsnewwindow":
        if (Object.prototype.toString.call(n$1) === "[object Window]") {
          var c3 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="' + (e3.pdfJsUrl || "examples/PDF.js/web/viewer.html") + "?file=&downloadName=" + e3.filename + '" width="500px" height="400px" /></body></html>', u3 = n$1.open();
          if (u3 !== null) {
            u3.document.write(c3);
            var l2 = this;
            u3.document.documentElement.querySelector("#pdfViewer").onload = function() {
              u3.document.title = e3.filename, u3.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(l2.output("bloburl"));
            };
          }
          return u3;
        }
        throw new Error("The option pdfjsnewwindow just works in a browser-environment.");
      case "dataurlnewwindow":
        if (Object.prototype.toString.call(n$1) !== "[object Window]")
          throw new Error("The option dataurlnewwindow just works in a browser-environment.");
        var f2 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="' + this.output("datauristring", e3) + '"></iframe></body></html>', d3 = n$1.open();
        if (d3 !== null && (d3.document.write(f2), d3.document.title = e3.filename), d3 || typeof safari == "undefined")
          return d3;
        break;
      case "datauri":
      case "dataurl":
        return n$1.document.location.href = this.output("datauristring", e3);
      default:
        return null;
    }
  }), Ge = function(t3) {
    return Array.isArray(zt2) === true && zt2.indexOf(t3) > -1;
  };
  switch (o2) {
    case "pt":
      _t2 = 1;
      break;
    case "mm":
      _t2 = 72 / 25.4;
      break;
    case "cm":
      _t2 = 72 / 2.54;
      break;
    case "in":
      _t2 = 72;
      break;
    case "px":
      _t2 = Ge("px_scaling") == 1 ? 0.75 : 96 / 72;
      break;
    case "pc":
    case "em":
      _t2 = 12;
      break;
    case "ex":
      _t2 = 6;
      break;
    default:
      if (typeof o2 != "number")
        throw new Error("Invalid unit: " + o2);
      _t2 = o2;
  }
  var Ye = null;
  K2(), Y2();
  var Je = function(t3) {
    return m2 !== null ? Ye.encryptor(t3, 0) : function(t4) {
      return t4;
    };
  }, Xe = y2.__private__.getPageInfo = y2.getPageInfo = function(t3) {
    if (isNaN(t3) || t3 % 1 != 0)
      throw new Error("Invalid argument passed to jsPDF.getPageInfo");
    return { objId: Rt2[t3].objId, pageNumber: t3, pageContext: Rt2[t3] };
  }, Ke = y2.__private__.getPageInfoByObjId = function(t3) {
    if (isNaN(t3) || t3 % 1 != 0)
      throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");
    for (var e3 in Rt2)
      if (Rt2[e3].objId === t3)
        break;
    return Xe(e3);
  }, Ze = y2.__private__.getCurrentPageInfo = y2.getCurrentPageInfo = function() {
    return { objId: Rt2[$2].objId, pageNumber: $2, pageContext: Rt2[$2] };
  };
  y2.addPage = function() {
    return Oe.apply(this, arguments), this;
  }, y2.setPage = function() {
    return Me.apply(this, arguments), ht2.call(this, ot2[$2]), this;
  }, y2.insertPage = function(t3) {
    return this.addPage(), this.movePage($2, t3), this;
  }, y2.movePage = function(t3, e3) {
    var r3, n2;
    if (t3 > e3) {
      r3 = ot2[t3], n2 = Rt2[t3];
      for (var i3 = t3; i3 > e3; i3--)
        ot2[i3] = ot2[i3 - 1], Rt2[i3] = Rt2[i3 - 1];
      ot2[e3] = r3, Rt2[e3] = n2, this.setPage(e3);
    } else if (t3 < e3) {
      r3 = ot2[t3], n2 = Rt2[t3];
      for (var a2 = t3; a2 < e3; a2++)
        ot2[a2] = ot2[a2 + 1], Rt2[a2] = Rt2[a2 + 1];
      ot2[e3] = r3, Rt2[e3] = n2, this.setPage(e3);
    }
    return this;
  }, y2.deletePage = function() {
    return Be.apply(this, arguments), this;
  }, y2.__private__.text = y2.text = function(e3, r3, n2, i3, a2) {
    var o3, s3, c3, u3, h2, l2, f2, d3, p6, g3 = (i3 = i3 || {}).scope || this;
    if (typeof e3 == "number" && typeof r3 == "number" && (typeof n2 == "string" || Array.isArray(n2))) {
      var m3 = n2;
      n2 = r3, r3 = e3, e3 = m3;
    }
    if (arguments[3] instanceof Vt2 == false ? (c3 = arguments[4], u3 = arguments[5], _typeof$2(f2 = arguments[3]) === "object" && f2 !== null || (typeof c3 == "string" && (u3 = c3, c3 = null), typeof f2 == "string" && (u3 = f2, f2 = null), typeof f2 == "number" && (c3 = f2, f2 = null), i3 = { flags: f2, angle: c3, align: u3 })) : (q2("The transform parameter of text() with a Matrix value"), p6 = a2), isNaN(r3) || isNaN(n2) || e3 == null)
      throw new Error("Invalid arguments passed to jsPDF.text");
    if (e3.length === 0)
      return g3;
    var v3 = "", y3 = false, w3 = typeof i3.lineHeightFactor == "number" ? i3.lineHeightFactor : lr, N3 = g3.internal.scaleFactor;
    function L3(t3) {
      return t3 = t3.split("	").join(Array(i3.TabLen || 9).join(" ")), Ce(t3, f2);
    }
    function A3(t3) {
      for (var e4, r4 = t3.concat(), n3 = [], i4 = r4.length; i4--; )
        typeof (e4 = r4.shift()) == "string" ? n3.push(e4) : Array.isArray(t3) && (e4.length === 1 || e4[1] === void 0 && e4[2] === void 0) ? n3.push(e4[0]) : n3.push([e4[0], e4[1], e4[2]]);
      return n3;
    }
    function _3(t3, e4) {
      var r4;
      if (typeof t3 == "string")
        r4 = e4(t3)[0];
      else if (Array.isArray(t3)) {
        for (var n3, i4, a3 = t3.concat(), o4 = [], s4 = a3.length; s4--; )
          typeof (n3 = a3.shift()) == "string" ? o4.push(e4(n3)[0]) : Array.isArray(n3) && typeof n3[0] == "string" && (i4 = e4(n3[0], n3[1], n3[2]), o4.push([i4[0], i4[1], i4[2]]));
        r4 = o4;
      }
      return r4;
    }
    var P3 = false, k3 = true;
    if (typeof e3 == "string")
      P3 = true;
    else if (Array.isArray(e3)) {
      var I2 = e3.concat();
      s3 = [];
      for (var F2, C2 = I2.length; C2--; )
        (typeof (F2 = I2.shift()) != "string" || Array.isArray(F2) && typeof F2[0] != "string") && (k3 = false);
      P3 = k3;
    }
    if (P3 === false)
      throw new Error('Type of text must be string or Array. "' + e3 + '" is not recognized.');
    typeof e3 == "string" && (e3 = e3.match(/[\r?\n]/) ? e3.split(/\r\n|\r|\n/g) : [e3]);
    var j2 = gt2 / g3.internal.scaleFactor, B3 = j2 * (w3 - 1);
    switch (i3.baseline) {
      case "bottom":
        n2 -= B3;
        break;
      case "top":
        n2 += j2 - B3;
        break;
      case "hanging":
        n2 += j2 - 2 * B3;
        break;
      case "middle":
        n2 += j2 / 2 - B3;
    }
    if ((l2 = i3.maxWidth || 0) > 0 && (typeof e3 == "string" ? e3 = g3.splitTextToSize(e3, l2) : Object.prototype.toString.call(e3) === "[object Array]" && (e3 = e3.reduce(function(t3, e4) {
      return t3.concat(g3.splitTextToSize(e4, l2));
    }, []))), o3 = { text: e3, x: r3, y: n2, options: i3, mutex: { pdfEscape: Ce, activeFontKey: St, fonts: Ft2, activeFontSize: gt2 } }, Tt2.publish("preProcessText", o3), e3 = o3.text, c3 = (i3 = o3.options).angle, p6 instanceof Vt2 == false && c3 && typeof c3 == "number") {
      c3 *= Math.PI / 180, i3.rotationDirection === 0 && (c3 = -c3), S2 === x2.ADVANCED && (c3 = -c3);
      var M2 = Math.cos(c3), E2 = Math.sin(c3);
      p6 = new Vt2(M2, E2, -E2, M2, 0, 0);
    } else
      c3 && c3 instanceof Vt2 && (p6 = c3);
    S2 !== x2.ADVANCED || p6 || (p6 = Yt2), (h2 = i3.charSpace || _r) !== void 0 && (v3 += O2(z2(h2)) + " Tc\n", this.setCharSpace(this.getCharSpace() || 0)), (d3 = i3.horizontalScale) !== void 0 && (v3 += O2(100 * d3) + " Tz\n");
    i3.lang;
    var D3 = -1, R3 = i3.renderingMode !== void 0 ? i3.renderingMode : i3.stroke, T3 = g3.internal.getCurrentPageInfo().pageContext;
    switch (R3) {
      case 0:
      case false:
      case "fill":
        D3 = 0;
        break;
      case 1:
      case true:
      case "stroke":
        D3 = 1;
        break;
      case 2:
      case "fillThenStroke":
        D3 = 2;
        break;
      case 3:
      case "invisible":
        D3 = 3;
        break;
      case 4:
      case "fillAndAddForClipping":
        D3 = 4;
        break;
      case 5:
      case "strokeAndAddPathForClipping":
        D3 = 5;
        break;
      case 6:
      case "fillThenStrokeAndAddToPathForClipping":
        D3 = 6;
        break;
      case 7:
      case "addToPathForClipping":
        D3 = 7;
    }
    var U3 = T3.usedRenderingMode !== void 0 ? T3.usedRenderingMode : -1;
    D3 !== -1 ? v3 += D3 + " Tr\n" : U3 !== -1 && (v3 += "0 Tr\n"), D3 !== -1 && (T3.usedRenderingMode = D3), u3 = i3.align || "left";
    var H5, W3 = gt2 * w3, V3 = g3.internal.pageSize.getWidth(), G3 = Ft2[St];
    h2 = i3.charSpace || _r, l2 = i3.maxWidth || 0, f2 = Object.assign({ autoencode: true, noBOM: true }, i3.flags);
    var Y3 = [];
    if (Object.prototype.toString.call(e3) === "[object Array]") {
      var J3;
      s3 = A3(e3), u3 !== "left" && (H5 = s3.map(function(t3) {
        return g3.getStringUnitWidth(t3, { font: G3, charSpace: h2, fontSize: gt2, doKerning: false }) * gt2 / N3;
      }));
      var X3, K3 = 0;
      if (u3 === "right") {
        r3 -= H5[0], e3 = [], C2 = s3.length;
        for (var Z3 = 0; Z3 < C2; Z3++)
          Z3 === 0 ? (X3 = br(r3), J3 = yr(n2)) : (X3 = z2(K3 - H5[Z3]), J3 = -W3), e3.push([s3[Z3], X3, J3]), K3 = H5[Z3];
      } else if (u3 === "center") {
        r3 -= H5[0] / 2, e3 = [], C2 = s3.length;
        for (var $3 = 0; $3 < C2; $3++)
          $3 === 0 ? (X3 = br(r3), J3 = yr(n2)) : (X3 = z2((K3 - H5[$3]) / 2), J3 = -W3), e3.push([s3[$3], X3, J3]), K3 = H5[$3];
      } else if (u3 === "left") {
        e3 = [], C2 = s3.length;
        for (var Q3 = 0; Q3 < C2; Q3++)
          e3.push(s3[Q3]);
      } else {
        if (u3 !== "justify")
          throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');
        e3 = [], C2 = s3.length, l2 = l2 !== 0 ? l2 : V3;
        for (var tt3 = 0; tt3 < C2; tt3++)
          J3 = tt3 === 0 ? yr(n2) : -W3, X3 = tt3 === 0 ? br(r3) : 0, tt3 < C2 - 1 ? Y3.push(O2(z2((l2 - H5[tt3]) / (s3[tt3].split(" ").length - 1)))) : Y3.push(0), e3.push([s3[tt3], X3, J3]);
      }
    }
    var et3 = typeof i3.R2L == "boolean" ? i3.R2L : bt2;
    et3 === true && (e3 = _3(e3, function(t3, e4, r4) {
      return [t3.split("").reverse().join(""), e4, r4];
    })), o3 = { text: e3, x: r3, y: n2, options: i3, mutex: { pdfEscape: Ce, activeFontKey: St, fonts: Ft2, activeFontSize: gt2 } }, Tt2.publish("postProcessText", o3), e3 = o3.text, y3 = o3.mutex.isHex || false;
    var rt3 = Ft2[St].encoding;
    rt3 !== "WinAnsiEncoding" && rt3 !== "StandardEncoding" || (e3 = _3(e3, function(t3, e4, r4) {
      return [L3(t3), e4, r4];
    })), s3 = A3(e3), e3 = [];
    for (var nt3, it3, at3, ot3 = 0, st3 = 1, ct3 = Array.isArray(s3[0]) ? st3 : ot3, ut3 = "", ht3 = function(t3, e4, r4) {
      var n3 = "";
      return r4 instanceof Vt2 ? (r4 = typeof i3.angle == "number" ? Gt2(r4, new Vt2(1, 0, 0, 1, t3, e4)) : Gt2(new Vt2(1, 0, 0, 1, t3, e4), r4), S2 === x2.ADVANCED && (r4 = Gt2(new Vt2(1, 0, 0, -1, 0, 0), r4)), n3 = r4.join(" ") + " Tm\n") : n3 = O2(t3) + " " + O2(e4) + " Td\n", n3;
    }, ft3 = 0; ft3 < s3.length; ft3++) {
      switch (ut3 = "", ct3) {
        case st3:
          at3 = (y3 ? "<" : "(") + s3[ft3][0] + (y3 ? ">" : ")"), nt3 = parseFloat(s3[ft3][1]), it3 = parseFloat(s3[ft3][2]);
          break;
        case ot3:
          at3 = (y3 ? "<" : "(") + s3[ft3] + (y3 ? ">" : ")"), nt3 = br(r3), it3 = yr(n2);
      }
      Y3 !== void 0 && Y3[ft3] !== void 0 && (ut3 = Y3[ft3] + " Tw\n"), ft3 === 0 ? e3.push(ut3 + ht3(nt3, it3, p6) + at3) : ct3 === ot3 ? e3.push(ut3 + at3) : ct3 === st3 && e3.push(ut3 + ht3(nt3, it3, p6) + at3);
    }
    e3 = ct3 === ot3 ? e3.join(" Tj\nT* ") : e3.join(" Tj\n"), e3 += " Tj\n";
    var dt3 = "BT\n/";
    return dt3 += St + " " + gt2 + " Tf\n", dt3 += O2(gt2 * w3) + " TL\n", dt3 += xr + "\n", dt3 += v3, dt3 += e3, lt2(dt3 += "ET"), b2[St] = true, g3;
  };
  var $e = y2.__private__.clip = y2.clip = function(t3) {
    return lt2(t3 === "evenodd" ? "W*" : "W"), this;
  };
  y2.clipEvenOdd = function() {
    return $e("evenodd");
  }, y2.__private__.discardPath = y2.discardPath = function() {
    return lt2("n"), this;
  };
  var Qe = y2.__private__.isValidStyle = function(t3) {
    var e3 = false;
    return [void 0, null, "S", "D", "F", "DF", "FD", "f", "f*", "B", "B*", "n"].indexOf(t3) !== -1 && (e3 = true), e3;
  };
  y2.__private__.setDefaultPathOperation = y2.setDefaultPathOperation = function(t3) {
    return Qe(t3) && (g2 = t3), this;
  };
  var tr = y2.__private__.getStyle = y2.getStyle = function(t3) {
    var e3 = g2;
    switch (t3) {
      case "D":
      case "S":
        e3 = "S";
        break;
      case "F":
        e3 = "f";
        break;
      case "FD":
      case "DF":
        e3 = "B";
        break;
      case "f":
      case "f*":
      case "B":
      case "B*":
        e3 = t3;
    }
    return e3;
  }, er = y2.close = function() {
    return lt2("h"), this;
  };
  y2.stroke = function() {
    return lt2("S"), this;
  }, y2.fill = function(t3) {
    return rr("f", t3), this;
  }, y2.fillEvenOdd = function(t3) {
    return rr("f*", t3), this;
  }, y2.fillStroke = function(t3) {
    return rr("B", t3), this;
  }, y2.fillStrokeEvenOdd = function(t3) {
    return rr("B*", t3), this;
  };
  var rr = function(e3, r3) {
    _typeof$2(r3) === "object" ? ar(r3, e3) : lt2(e3);
  }, nr = function(t3) {
    t3 === null || S2 === x2.ADVANCED && t3 === void 0 || (t3 = tr(t3), lt2(t3));
  };
  function ir(t3, e3, r3, n2, i3) {
    var a2 = new M$1(e3 || this.boundingBox, r3 || this.xStep, n2 || this.yStep, this.gState, i3 || this.matrix);
    a2.stream = this.stream;
    var o3 = t3 + "$$" + this.cloneIndex++ + "$$";
    return Jt2(o3, a2), a2;
  }
  var ar = function(t3, e3) {
    var r3 = Bt2[t3.key], n2 = Ot2[r3];
    if (n2 instanceof B)
      lt2("q"), lt2(or(e3)), n2.gState && y2.setGState(n2.gState), lt2(t3.matrix.toString() + " cm"), lt2("/" + r3 + " sh"), lt2("Q");
    else if (n2 instanceof M$1) {
      var i3 = new Vt2(1, 0, 0, -1, 0, Rr());
      t3.matrix && (i3 = i3.multiply(t3.matrix || Yt2), r3 = ir.call(n2, t3.key, t3.boundingBox, t3.xStep, t3.yStep, i3).id), lt2("q"), lt2("/Pattern cs"), lt2("/" + r3 + " scn"), n2.gState && y2.setGState(n2.gState), lt2(e3), lt2("Q");
    }
  }, or = function(t3) {
    switch (t3) {
      case "f":
      case "F":
        return "W n";
      case "f*":
        return "W* n";
      case "B":
        return "W S";
      case "B*":
        return "W* S";
      case "S":
        return "W S";
      case "n":
        return "W n";
    }
  }, sr = y2.moveTo = function(t3, e3) {
    return lt2(O2(z2(t3)) + " " + O2(H4(e3)) + " m"), this;
  }, cr = y2.lineTo = function(t3, e3) {
    return lt2(O2(z2(t3)) + " " + O2(H4(e3)) + " l"), this;
  }, ur = y2.curveTo = function(t3, e3, r3, n2, i3, a2) {
    return lt2([O2(z2(t3)), O2(H4(e3)), O2(z2(r3)), O2(H4(n2)), O2(z2(i3)), O2(H4(a2)), "c"].join(" ")), this;
  };
  y2.__private__.line = y2.line = function(t3, e3, r3, n2, i3) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n2) || !Qe(i3))
      throw new Error("Invalid arguments passed to jsPDF.line");
    return S2 === x2.COMPAT ? this.lines([[r3 - t3, n2 - e3]], t3, e3, [1, 1], i3 || "S") : this.lines([[r3 - t3, n2 - e3]], t3, e3, [1, 1]).stroke();
  }, y2.__private__.lines = y2.lines = function(t3, e3, r3, n2, i3, a2) {
    var o3, s3, c3, u3, h2, l2, f2, d3, p6, g3, m3, v3;
    if (typeof t3 == "number" && (v3 = r3, r3 = e3, e3 = t3, t3 = v3), n2 = n2 || [1, 1], a2 = a2 || false, isNaN(e3) || isNaN(r3) || !Array.isArray(t3) || !Array.isArray(n2) || !Qe(i3) || typeof a2 != "boolean")
      throw new Error("Invalid arguments passed to jsPDF.lines");
    for (sr(e3, r3), o3 = n2[0], s3 = n2[1], u3 = t3.length, g3 = e3, m3 = r3, c3 = 0; c3 < u3; c3++)
      (h2 = t3[c3]).length === 2 ? (g3 = h2[0] * o3 + g3, m3 = h2[1] * s3 + m3, cr(g3, m3)) : (l2 = h2[0] * o3 + g3, f2 = h2[1] * s3 + m3, d3 = h2[2] * o3 + g3, p6 = h2[3] * s3 + m3, g3 = h2[4] * o3 + g3, m3 = h2[5] * s3 + m3, ur(l2, f2, d3, p6, g3, m3));
    return a2 && er(), nr(i3), this;
  }, y2.path = function(t3) {
    for (var e3 = 0; e3 < t3.length; e3++) {
      var r3 = t3[e3], n2 = r3.c;
      switch (r3.op) {
        case "m":
          sr(n2[0], n2[1]);
          break;
        case "l":
          cr(n2[0], n2[1]);
          break;
        case "c":
          ur.apply(this, n2);
          break;
        case "h":
          er();
      }
    }
    return this;
  }, y2.__private__.rect = y2.rect = function(t3, e3, r3, n2, i3) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n2) || !Qe(i3))
      throw new Error("Invalid arguments passed to jsPDF.rect");
    return S2 === x2.COMPAT && (n2 = -n2), lt2([O2(z2(t3)), O2(H4(e3)), O2(z2(r3)), O2(z2(n2)), "re"].join(" ")), nr(i3), this;
  }, y2.__private__.triangle = y2.triangle = function(t3, e3, r3, n2, i3, a2, o3) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n2) || isNaN(i3) || isNaN(a2) || !Qe(o3))
      throw new Error("Invalid arguments passed to jsPDF.triangle");
    return this.lines([[r3 - t3, n2 - e3], [i3 - r3, a2 - n2], [t3 - i3, e3 - a2]], t3, e3, [1, 1], o3, true), this;
  }, y2.__private__.roundedRect = y2.roundedRect = function(t3, e3, r3, n2, i3, a2, o3) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n2) || isNaN(i3) || isNaN(a2) || !Qe(o3))
      throw new Error("Invalid arguments passed to jsPDF.roundedRect");
    var s3 = 4 / 3 * (Math.SQRT2 - 1);
    return i3 = Math.min(i3, 0.5 * r3), a2 = Math.min(a2, 0.5 * n2), this.lines([[r3 - 2 * i3, 0], [i3 * s3, 0, i3, a2 - a2 * s3, i3, a2], [0, n2 - 2 * a2], [0, a2 * s3, -i3 * s3, a2, -i3, a2], [2 * i3 - r3, 0], [-i3 * s3, 0, -i3, -a2 * s3, -i3, -a2], [0, 2 * a2 - n2], [0, -a2 * s3, i3 * s3, -a2, i3, -a2]], t3 + i3, e3, [1, 1], o3, true), this;
  }, y2.__private__.ellipse = y2.ellipse = function(t3, e3, r3, n2, i3) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n2) || !Qe(i3))
      throw new Error("Invalid arguments passed to jsPDF.ellipse");
    var a2 = 4 / 3 * (Math.SQRT2 - 1) * r3, o3 = 4 / 3 * (Math.SQRT2 - 1) * n2;
    return sr(t3 + r3, e3), ur(t3 + r3, e3 - o3, t3 + a2, e3 - n2, t3, e3 - n2), ur(t3 - a2, e3 - n2, t3 - r3, e3 - o3, t3 - r3, e3), ur(t3 - r3, e3 + o3, t3 - a2, e3 + n2, t3, e3 + n2), ur(t3 + a2, e3 + n2, t3 + r3, e3 + o3, t3 + r3, e3), nr(i3), this;
  }, y2.__private__.circle = y2.circle = function(t3, e3, r3, n2) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || !Qe(n2))
      throw new Error("Invalid arguments passed to jsPDF.circle");
    return this.ellipse(t3, e3, r3, r3, n2);
  }, y2.setFont = function(t3, e3, r3) {
    return r3 && (e3 = k2(e3, r3)), St = qe(t3, e3, { disableWarning: false }), this;
  };
  var hr = y2.__private__.getFont = y2.getFont = function() {
    return Ft2[qe.apply(y2, arguments)];
  };
  y2.__private__.getFontList = y2.getFontList = function() {
    var t3, e3, r3 = {};
    for (t3 in Ct2)
      if (Ct2.hasOwnProperty(t3))
        for (e3 in r3[t3] = [], Ct2[t3])
          Ct2[t3].hasOwnProperty(e3) && r3[t3].push(e3);
    return r3;
  }, y2.addFont = function(t3, e3, r3, n2, i3) {
    var a2 = ["StandardEncoding", "MacRomanEncoding", "Identity-H", "WinAnsiEncoding"];
    return arguments[3] && a2.indexOf(arguments[3]) !== -1 ? i3 = arguments[3] : arguments[3] && a2.indexOf(arguments[3]) == -1 && (r3 = k2(r3, n2)), i3 = i3 || "Identity-H", Pe.call(this, t3, e3, r3, i3);
  };
  var lr, fr = e2.lineWidth || 0.200025, dr = y2.__private__.getLineWidth = y2.getLineWidth = function() {
    return fr;
  }, pr = y2.__private__.setLineWidth = y2.setLineWidth = function(t3) {
    return fr = t3, lt2(O2(z2(t3)) + " w"), this;
  };
  y2.__private__.setLineDash = E$1.API.setLineDash = E$1.API.setLineDashPattern = function(t3, e3) {
    if (t3 = t3 || [], e3 = e3 || 0, isNaN(e3) || !Array.isArray(t3))
      throw new Error("Invalid arguments passed to jsPDF.setLineDash");
    return t3 = t3.map(function(t4) {
      return O2(z2(t4));
    }).join(" "), e3 = O2(z2(e3)), lt2("[" + t3 + "] " + e3 + " d"), this;
  };
  var gr = y2.__private__.getLineHeight = y2.getLineHeight = function() {
    return gt2 * lr;
  };
  y2.__private__.getLineHeight = y2.getLineHeight = function() {
    return gt2 * lr;
  };
  var mr = y2.__private__.setLineHeightFactor = y2.setLineHeightFactor = function(t3) {
    return typeof (t3 = t3 || 1.15) == "number" && (lr = t3), this;
  }, vr = y2.__private__.getLineHeightFactor = y2.getLineHeightFactor = function() {
    return lr;
  };
  mr(e2.lineHeight);
  var br = y2.__private__.getHorizontalCoordinate = function(t3) {
    return z2(t3);
  }, yr = y2.__private__.getVerticalCoordinate = function(t3) {
    return S2 === x2.ADVANCED ? t3 : Rt2[$2].mediaBox.topRightY - Rt2[$2].mediaBox.bottomLeftY - z2(t3);
  }, wr = y2.__private__.getHorizontalCoordinateString = y2.getHorizontalCoordinateString = function(t3) {
    return O2(br(t3));
  }, Nr = y2.__private__.getVerticalCoordinateString = y2.getVerticalCoordinateString = function(t3) {
    return O2(yr(t3));
  }, Lr = e2.strokeColor || "0 G";
  y2.__private__.getStrokeColor = y2.getDrawColor = function() {
    return ee2(Lr);
  }, y2.__private__.setStrokeColor = y2.setDrawColor = function(t3, e3, r3, n2) {
    return Lr = re2({ ch1: t3, ch2: e3, ch3: r3, ch4: n2, pdfColorType: "draw", precision: 2 }), lt2(Lr), this;
  };
  var Ar = e2.fillColor || "0 g";
  y2.__private__.getFillColor = y2.getFillColor = function() {
    return ee2(Ar);
  }, y2.__private__.setFillColor = y2.setFillColor = function(t3, e3, r3, n2) {
    return Ar = re2({ ch1: t3, ch2: e3, ch3: r3, ch4: n2, pdfColorType: "fill", precision: 2 }), lt2(Ar), this;
  };
  var xr = e2.textColor || "0 g", Sr = y2.__private__.getTextColor = y2.getTextColor = function() {
    return ee2(xr);
  };
  y2.__private__.setTextColor = y2.setTextColor = function(t3, e3, r3, n2) {
    return xr = re2({ ch1: t3, ch2: e3, ch3: r3, ch4: n2, pdfColorType: "text", precision: 3 }), this;
  };
  var _r = e2.charSpace, Pr = y2.__private__.getCharSpace = y2.getCharSpace = function() {
    return parseFloat(_r || 0);
  };
  y2.__private__.setCharSpace = y2.setCharSpace = function(t3) {
    if (isNaN(t3))
      throw new Error("Invalid argument passed to jsPDF.setCharSpace");
    return _r = t3, this;
  };
  var kr = 0;
  y2.CapJoinStyles = { 0: 0, butt: 0, but: 0, miter: 0, 1: 1, round: 1, rounded: 1, circle: 1, 2: 2, projecting: 2, project: 2, square: 2, bevel: 2 }, y2.__private__.setLineCap = y2.setLineCap = function(t3) {
    var e3 = y2.CapJoinStyles[t3];
    if (e3 === void 0)
      throw new Error("Line cap style of '" + t3 + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return kr = e3, lt2(e3 + " J"), this;
  };
  var Ir = 0;
  y2.__private__.setLineJoin = y2.setLineJoin = function(t3) {
    var e3 = y2.CapJoinStyles[t3];
    if (e3 === void 0)
      throw new Error("Line join style of '" + t3 + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return Ir = e3, lt2(e3 + " j"), this;
  }, y2.__private__.setLineMiterLimit = y2.__private__.setMiterLimit = y2.setLineMiterLimit = y2.setMiterLimit = function(t3) {
    if (t3 = t3 || 0, isNaN(t3))
      throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit");
    return lt2(O2(z2(t3)) + " M"), this;
  }, y2.GState = j, y2.setGState = function(t3) {
    (t3 = typeof t3 == "string" ? Mt2[Et2[t3]] : Fr(null, t3)).equals(qt2) || (lt2("/" + t3.id + " gs"), qt2 = t3);
  };
  var Fr = function(t3, e3) {
    if (!t3 || !Et2[t3]) {
      var r3 = false;
      for (var n2 in Mt2)
        if (Mt2.hasOwnProperty(n2) && Mt2[n2].equals(e3)) {
          r3 = true;
          break;
        }
      if (r3)
        e3 = Mt2[n2];
      else {
        var i3 = "GS" + (Object.keys(Mt2).length + 1).toString(10);
        Mt2[i3] = e3, e3.id = i3;
      }
      return t3 && (Et2[t3] = e3.id), Tt2.publish("addGState", e3), e3;
    }
  };
  y2.addGState = function(t3, e3) {
    return Fr(t3, e3), this;
  }, y2.saveGraphicsState = function() {
    return lt2("q"), jt2.push({ key: St, size: gt2, color: xr }), this;
  }, y2.restoreGraphicsState = function() {
    lt2("Q");
    var t3 = jt2.pop();
    return St = t3.key, gt2 = t3.size, xr = t3.color, qt2 = null, this;
  }, y2.setCurrentTransformationMatrix = function(t3) {
    return lt2(t3.toString() + " cm"), this;
  }, y2.comment = function(t3) {
    return lt2("#" + t3), this;
  };
  var Cr = function(t3, e3) {
    var r3 = t3 || 0;
    Object.defineProperty(this, "x", { enumerable: true, get: function() {
      return r3;
    }, set: function(t4) {
      isNaN(t4) || (r3 = parseFloat(t4));
    } });
    var n2 = e3 || 0;
    Object.defineProperty(this, "y", { enumerable: true, get: function() {
      return n2;
    }, set: function(t4) {
      isNaN(t4) || (n2 = parseFloat(t4));
    } });
    var i3 = "pt";
    return Object.defineProperty(this, "type", { enumerable: true, get: function() {
      return i3;
    }, set: function(t4) {
      i3 = t4.toString();
    } }), this;
  }, jr = function(t3, e3, r3, n2) {
    Cr.call(this, t3, e3), this.type = "rect";
    var i3 = r3 || 0;
    Object.defineProperty(this, "w", { enumerable: true, get: function() {
      return i3;
    }, set: function(t4) {
      isNaN(t4) || (i3 = parseFloat(t4));
    } });
    var a2 = n2 || 0;
    return Object.defineProperty(this, "h", { enumerable: true, get: function() {
      return a2;
    }, set: function(t4) {
      isNaN(t4) || (a2 = parseFloat(t4));
    } }), this;
  }, Or = function() {
    this.page = Dt2, this.currentPage = $2, this.pages = ot2.slice(0), this.pagesContext = Rt2.slice(0), this.x = Pt2, this.y = kt2, this.matrix = It2, this.width = qr($2), this.height = Rr($2), this.outputDestination = ct2, this.id = "", this.objectNumber = -1;
  };
  Or.prototype.restore = function() {
    Dt2 = this.page, $2 = this.currentPage, Rt2 = this.pagesContext, ot2 = this.pages, Pt2 = this.x, kt2 = this.y, It2 = this.matrix, Dr($2, this.width), Tr($2, this.height), ct2 = this.outputDestination;
  };
  var Br = function(t3, e3, r3, n2, i3) {
    Wt2.push(new Or()), Dt2 = $2 = 0, ot2 = [], Pt2 = t3, kt2 = e3, It2 = i3, je([r3, n2]);
  }, Mr = function(t3) {
    if (Ht2[t3])
      Wt2.pop().restore();
    else {
      var e3 = new Or(), r3 = "Xo" + (Object.keys(Ut2).length + 1).toString(10);
      e3.id = r3, Ht2[t3] = r3, Ut2[r3] = e3, Tt2.publish("addFormObject", e3), Wt2.pop().restore();
    }
  };
  for (var Er in y2.beginFormObject = function(t3, e3, r3, n2, i3) {
    return Br(t3, e3, r3, n2, i3), this;
  }, y2.endFormObject = function(t3) {
    return Mr(t3), this;
  }, y2.doFormObject = function(t3, e3) {
    var r3 = Ut2[Ht2[t3]];
    return lt2("q"), lt2(e3.toString() + " cm"), lt2("/" + r3.id + " Do"), lt2("Q"), this;
  }, y2.getFormObject = function(t3) {
    var e3 = Ut2[Ht2[t3]];
    return { x: e3.x, y: e3.y, width: e3.width, height: e3.height, matrix: e3.matrix };
  }, y2.save = function(t3, e3) {
    return t3 = t3 || "generated.pdf", (e3 = e3 || {}).returnPromise = e3.returnPromise || false, e3.returnPromise === false ? (l$1(We(He()), t3), typeof l$1.unload == "function" && n$1.setTimeout && setTimeout(l$1.unload, 911), this) : new Promise(function(e4, r3) {
      try {
        var i3 = l$1(We(He()), t3);
        typeof l$1.unload == "function" && n$1.setTimeout && setTimeout(l$1.unload, 911), e4(i3);
      } catch (t4) {
        r3(t4.message);
      }
    });
  }, E$1.API)
    E$1.API.hasOwnProperty(Er) && (Er === "events" && E$1.API.events.length ? function(t3, e3) {
      var r3, n2, i3;
      for (i3 = e3.length - 1; i3 !== -1; i3--)
        r3 = e3[i3][0], n2 = e3[i3][1], t3.subscribe.apply(t3, [r3].concat(typeof n2 == "function" ? [n2] : n2));
    }(Tt2, E$1.API.events) : y2[Er] = E$1.API[Er]);
  var qr = y2.getPageWidth = function(t3) {
    return (Rt2[t3 = t3 || $2].mediaBox.topRightX - Rt2[t3].mediaBox.bottomLeftX) / _t2;
  }, Dr = y2.setPageWidth = function(t3, e3) {
    Rt2[t3].mediaBox.topRightX = e3 * _t2 + Rt2[t3].mediaBox.bottomLeftX;
  }, Rr = y2.getPageHeight = function(t3) {
    return (Rt2[t3 = t3 || $2].mediaBox.topRightY - Rt2[t3].mediaBox.bottomLeftY) / _t2;
  }, Tr = y2.setPageHeight = function(t3, e3) {
    Rt2[t3].mediaBox.topRightY = e3 * _t2 + Rt2[t3].mediaBox.bottomLeftY;
  };
  return y2.internal = { pdfEscape: Ce, getStyle: tr, getFont: hr, getFontSize: vt2, getCharSpace: Pr, getTextColor: Sr, getLineHeight: gr, getLineHeightFactor: vr, getLineWidth: dr, write: ft2, getHorizontalCoordinate: br, getVerticalCoordinate: yr, getCoordinateString: wr, getVerticalCoordinateString: Nr, collections: {}, newObject: Xt2, newAdditionalObject: $t2, newObjectDeferred: Kt2, newObjectDeferredBegin: Zt2, getFilters: ne2, putStream: ie2, events: Tt2, scaleFactor: _t2, pageSize: { getWidth: function() {
    return qr($2);
  }, setWidth: function(t3) {
    Dr($2, t3);
  }, getHeight: function() {
    return Rr($2);
  }, setHeight: function(t3) {
    Tr($2, t3);
  } }, encryptionOptions: m2, encryption: Ye, getEncryptor: Je, output: Ve, getNumberOfPages: Ee, pages: ot2, out: lt2, f2: R2, f3: T2, getPageInfo: Xe, getPageInfoByObjId: Ke, getCurrentPageInfo: Ze, getPDFVersion: N2, Point: Cr, Rectangle: jr, Matrix: Vt2, hasHotfix: Ge }, Object.defineProperty(y2.internal.pageSize, "width", { get: function() {
    return qr($2);
  }, set: function(t3) {
    Dr($2, t3);
  }, enumerable: true, configurable: true }), Object.defineProperty(y2.internal.pageSize, "height", { get: function() {
    return Rr($2);
  }, set: function(t3) {
    Tr($2, t3);
  }, enumerable: true, configurable: true }), ke.call(y2, pt2), St = "F1", Oe(s2, i2), Tt2.publish("initialized"), y2;
}
I.prototype.lsbFirstWord = function(t3) {
  return String.fromCharCode(t3 >> 0 & 255, t3 >> 8 & 255, t3 >> 16 & 255, t3 >> 24 & 255);
}, I.prototype.toHexString = function(t3) {
  return t3.split("").map(function(t4) {
    return ("0" + (255 & t4.charCodeAt(0)).toString(16)).slice(-2);
  }).join("");
}, I.prototype.hexToBytes = function(t3) {
  for (var e2 = [], r2 = 0; r2 < t3.length; r2 += 2)
    e2.push(String.fromCharCode(parseInt(t3.substr(r2, 2), 16)));
  return e2.join("");
}, I.prototype.processOwnerPassword = function(t3, e2) {
  return P(x(e2).substr(0, 5), t3);
}, I.prototype.encryptor = function(t3, e2) {
  var r2 = x(this.encryptionKey + String.fromCharCode(255 & t3, t3 >> 8 & 255, t3 >> 16 & 255, 255 & e2, e2 >> 8 & 255)).substr(0, 10);
  return function(t4) {
    return P(r2, t4);
  };
}, j.prototype.equals = function(e2) {
  var r2, n2 = "id,objectNumber,equals";
  if (!e2 || _typeof$2(e2) !== _typeof$2(this))
    return false;
  var i2 = 0;
  for (r2 in this)
    if (!(n2.indexOf(r2) >= 0)) {
      if (this.hasOwnProperty(r2) && !e2.hasOwnProperty(r2))
        return false;
      if (this[r2] !== e2[r2])
        return false;
      i2++;
    }
  for (r2 in e2)
    e2.hasOwnProperty(r2) && n2.indexOf(r2) < 0 && i2--;
  return i2 === 0;
}, E$1.API = { events: [] }, E$1.version = "2.5.0";
var q = E$1.API, D = 1, R = function(t3) {
  return t3.replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
}, T$2 = function(t3) {
  return t3.replace(/\\\\/g, "\\").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}, z$1 = function(t3) {
  return t3.toFixed(2);
}, U$1 = function(t3) {
  return t3.toFixed(5);
};
q.__acroform__ = {};
var H = function(t3, e2) {
  t3.prototype = Object.create(e2.prototype), t3.prototype.constructor = t3;
}, W = function(t3) {
  return t3 * D;
}, V$1 = function(t3) {
  var e2 = new ut(), r2 = At.internal.getHeight(t3) || 0, n2 = At.internal.getWidth(t3) || 0;
  return e2.BBox = [0, 0, Number(z$1(n2)), Number(z$1(r2))], e2;
}, G = q.__acroform__.setBit = function(t3, e2) {
  if (t3 = t3 || 0, e2 = e2 || 0, isNaN(t3) || isNaN(e2))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");
  return t3 |= 1 << e2;
}, Y = q.__acroform__.clearBit = function(t3, e2) {
  if (t3 = t3 || 0, e2 = e2 || 0, isNaN(t3) || isNaN(e2))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");
  return t3 &= ~(1 << e2);
}, J = q.__acroform__.getBit = function(t3, e2) {
  if (isNaN(t3) || isNaN(e2))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");
  return (t3 & 1 << e2) == 0 ? 0 : 1;
}, X = q.__acroform__.getBitForPdf = function(t3, e2) {
  if (isNaN(t3) || isNaN(e2))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");
  return J(t3, e2 - 1);
}, K = q.__acroform__.setBitForPdf = function(t3, e2) {
  if (isNaN(t3) || isNaN(e2))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");
  return G(t3, e2 - 1);
}, Z$2 = q.__acroform__.clearBitForPdf = function(t3, e2) {
  if (isNaN(t3) || isNaN(e2))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");
  return Y(t3, e2 - 1);
}, $$a = q.__acroform__.calculateCoordinates = function(t3, e2) {
  var r2 = e2.internal.getHorizontalCoordinate, n2 = e2.internal.getVerticalCoordinate, i2 = t3[0], a2 = t3[1], o2 = t3[2], s2 = t3[3], c2 = {};
  return c2.lowerLeft_X = r2(i2) || 0, c2.lowerLeft_Y = n2(a2 + s2) || 0, c2.upperRight_X = r2(i2 + o2) || 0, c2.upperRight_Y = n2(a2) || 0, [Number(z$1(c2.lowerLeft_X)), Number(z$1(c2.lowerLeft_Y)), Number(z$1(c2.upperRight_X)), Number(z$1(c2.upperRight_Y))];
}, Q = function(t3) {
  if (t3.appearanceStreamContent)
    return t3.appearanceStreamContent;
  if (t3.V || t3.DV) {
    var e2 = [], r2 = t3._V || t3.DV, n2 = tt(t3, r2), i2 = t3.scope.internal.getFont(t3.fontName, t3.fontStyle).id;
    e2.push("/Tx BMC"), e2.push("q"), e2.push("BT"), e2.push(t3.scope.__private__.encodeColorString(t3.color)), e2.push("/" + i2 + " " + z$1(n2.fontSize) + " Tf"), e2.push("1 0 0 1 0 0 Tm"), e2.push(n2.text), e2.push("ET"), e2.push("Q"), e2.push("EMC");
    var a2 = V$1(t3);
    return a2.scope = t3.scope, a2.stream = e2.join("\n"), a2;
  }
}, tt = function(t3, e2) {
  var r2 = t3.fontSize === 0 ? t3.maxFontSize : t3.fontSize, n2 = { text: "", fontSize: "" }, i2 = (e2 = (e2 = e2.substr(0, 1) == "(" ? e2.substr(1) : e2).substr(e2.length - 1) == ")" ? e2.substr(0, e2.length - 1) : e2).split(" ");
  i2 = t3.multiline ? i2.map(function(t4) {
    return t4.split("\n");
  }) : i2.map(function(t4) {
    return [t4];
  });
  var a2 = r2, o2 = At.internal.getHeight(t3) || 0;
  o2 = o2 < 0 ? -o2 : o2;
  var s2 = At.internal.getWidth(t3) || 0;
  s2 = s2 < 0 ? -s2 : s2;
  var c2 = function(e3, r3, n3) {
    if (e3 + 1 < i2.length) {
      var a3 = r3 + " " + i2[e3 + 1][0];
      return et(a3, t3, n3).width <= s2 - 4;
    }
    return false;
  };
  a2++;
  t:
    for (; a2 > 0; ) {
      e2 = "", a2--;
      var u2, h2, l2 = et("3", t3, a2).height, f2 = t3.multiline ? o2 - a2 : (o2 - l2) / 2, d2 = f2 += 2, p5 = 0, g2 = 0, m2 = 0;
      if (a2 <= 0) {
        e2 = "(...) Tj\n", e2 += "% Width of Text: " + et(e2, t3, a2 = 12).width + ", FieldWidth:" + s2 + "\n";
        break;
      }
      for (var v2 = "", b2 = 0, y2 = 0; y2 < i2.length; y2++)
        if (i2.hasOwnProperty(y2)) {
          var w2 = false;
          if (i2[y2].length !== 1 && m2 !== i2[y2].length - 1) {
            if ((l2 + 2) * (b2 + 2) + 2 > o2)
              continue t;
            v2 += i2[y2][m2], w2 = true, g2 = y2, y2--;
          } else {
            v2 = (v2 += i2[y2][m2] + " ").substr(v2.length - 1) == " " ? v2.substr(0, v2.length - 1) : v2;
            var N2 = parseInt(y2), L2 = c2(N2, v2, a2), A2 = y2 >= i2.length - 1;
            if (L2 && !A2) {
              v2 += " ", m2 = 0;
              continue;
            }
            if (L2 || A2) {
              if (A2)
                g2 = N2;
              else if (t3.multiline && (l2 + 2) * (b2 + 2) + 2 > o2)
                continue t;
            } else {
              if (!t3.multiline)
                continue t;
              if ((l2 + 2) * (b2 + 2) + 2 > o2)
                continue t;
              g2 = N2;
            }
          }
          for (var x2 = "", S2 = p5; S2 <= g2; S2++) {
            var _2 = i2[S2];
            if (t3.multiline) {
              if (S2 === g2) {
                x2 += _2[m2] + " ", m2 = (m2 + 1) % _2.length;
                continue;
              }
              if (S2 === p5) {
                x2 += _2[_2.length - 1] + " ";
                continue;
              }
            }
            x2 += _2[0] + " ";
          }
          switch (x2 = x2.substr(x2.length - 1) == " " ? x2.substr(0, x2.length - 1) : x2, h2 = et(x2, t3, a2).width, t3.textAlign) {
            case "right":
              u2 = s2 - h2 - 2;
              break;
            case "center":
              u2 = (s2 - h2) / 2;
              break;
            case "left":
            default:
              u2 = 2;
          }
          e2 += z$1(u2) + " " + z$1(d2) + " Td\n", e2 += "(" + R(x2) + ") Tj\n", e2 += -z$1(u2) + " 0 Td\n", d2 = -(a2 + 2), h2 = 0, p5 = w2 ? g2 : g2 + 1, b2++, v2 = "";
        }
      break;
    }
  return n2.text = e2, n2.fontSize = a2, n2;
}, et = function(t3, e2, r2) {
  var n2 = e2.scope.internal.getFont(e2.fontName, e2.fontStyle), i2 = e2.scope.getStringUnitWidth(t3, { font: n2, fontSize: parseFloat(r2), charSpace: 0 }) * parseFloat(r2);
  return { height: e2.scope.getStringUnitWidth("3", { font: n2, fontSize: parseFloat(r2), charSpace: 0 }) * parseFloat(r2) * 1.5, width: i2 };
}, rt = { fields: [], xForms: [], acroFormDictionaryRoot: null, printedOut: false, internal: null, isInitialized: false }, nt = function(t3, e2) {
  var r2 = { type: "reference", object: t3 };
  e2.internal.getPageInfo(t3.page).pageContext.annotations.find(function(t4) {
    return t4.type === r2.type && t4.object === r2.object;
  }) === void 0 && e2.internal.getPageInfo(t3.page).pageContext.annotations.push(r2);
}, it = function(e2, r2) {
  for (var n2 in e2)
    if (e2.hasOwnProperty(n2)) {
      var i2 = n2, a2 = e2[n2];
      r2.internal.newObjectDeferredBegin(a2.objId, true), _typeof$2(a2) === "object" && typeof a2.putStream == "function" && a2.putStream(), delete e2[i2];
    }
}, at = function(e2, r2) {
  if (r2.scope = e2, e2.internal !== void 0 && (e2.internal.acroformPlugin === void 0 || e2.internal.acroformPlugin.isInitialized === false)) {
    if (lt.FieldNum = 0, e2.internal.acroformPlugin = JSON.parse(JSON.stringify(rt)), e2.internal.acroformPlugin.acroFormDictionaryRoot)
      throw new Error("Exception while creating AcroformDictionary");
    D = e2.internal.scaleFactor, e2.internal.acroformPlugin.acroFormDictionaryRoot = new ht(), e2.internal.acroformPlugin.acroFormDictionaryRoot.scope = e2, e2.internal.acroformPlugin.acroFormDictionaryRoot._eventID = e2.internal.events.subscribe("postPutResources", function() {
      !function(t3) {
        t3.internal.events.unsubscribe(t3.internal.acroformPlugin.acroFormDictionaryRoot._eventID), delete t3.internal.acroformPlugin.acroFormDictionaryRoot._eventID, t3.internal.acroformPlugin.printedOut = true;
      }(e2);
    }), e2.internal.events.subscribe("buildDocument", function() {
      !function(t3) {
        t3.internal.acroformPlugin.acroFormDictionaryRoot.objId = void 0;
        var e3 = t3.internal.acroformPlugin.acroFormDictionaryRoot.Fields;
        for (var r3 in e3)
          if (e3.hasOwnProperty(r3)) {
            var n2 = e3[r3];
            n2.objId = void 0, n2.hasAnnotation && nt(n2, t3);
          }
      }(e2);
    }), e2.internal.events.subscribe("putCatalog", function() {
      !function(t3) {
        if (t3.internal.acroformPlugin.acroFormDictionaryRoot === void 0)
          throw new Error("putCatalogCallback: Root missing.");
        t3.internal.write("/AcroForm " + t3.internal.acroformPlugin.acroFormDictionaryRoot.objId + " 0 R");
      }(e2);
    }), e2.internal.events.subscribe("postPutPages", function(r3) {
      !function(e3, r4) {
        var n2 = !e3;
        for (var i2 in e3 || (r4.internal.newObjectDeferredBegin(r4.internal.acroformPlugin.acroFormDictionaryRoot.objId, true), r4.internal.acroformPlugin.acroFormDictionaryRoot.putStream()), e3 = e3 || r4.internal.acroformPlugin.acroFormDictionaryRoot.Kids)
          if (e3.hasOwnProperty(i2)) {
            var a2 = e3[i2], o2 = [], s2 = a2.Rect;
            if (a2.Rect && (a2.Rect = $$a(a2.Rect, r4)), r4.internal.newObjectDeferredBegin(a2.objId, true), a2.DA = At.createDefaultAppearanceStream(a2), _typeof$2(a2) === "object" && typeof a2.getKeyValueListForStream == "function" && (o2 = a2.getKeyValueListForStream()), a2.Rect = s2, a2.hasAppearanceStream && !a2.appearanceStreamContent) {
              var c2 = Q(a2);
              o2.push({ key: "AP", value: "<</N " + c2 + ">>" }), r4.internal.acroformPlugin.xForms.push(c2);
            }
            if (a2.appearanceStreamContent) {
              var u2 = "";
              for (var h2 in a2.appearanceStreamContent)
                if (a2.appearanceStreamContent.hasOwnProperty(h2)) {
                  var l2 = a2.appearanceStreamContent[h2];
                  if (u2 += "/" + h2 + " ", u2 += "<<", Object.keys(l2).length >= 1 || Array.isArray(l2)) {
                    for (var i2 in l2)
                      if (l2.hasOwnProperty(i2)) {
                        var f2 = l2[i2];
                        typeof f2 == "function" && (f2 = f2.call(r4, a2)), u2 += "/" + i2 + " " + f2 + " ", r4.internal.acroformPlugin.xForms.indexOf(f2) >= 0 || r4.internal.acroformPlugin.xForms.push(f2);
                      }
                  } else
                    typeof (f2 = l2) == "function" && (f2 = f2.call(r4, a2)), u2 += "/" + i2 + " " + f2, r4.internal.acroformPlugin.xForms.indexOf(f2) >= 0 || r4.internal.acroformPlugin.xForms.push(f2);
                  u2 += ">>";
                }
              o2.push({ key: "AP", value: "<<\n" + u2 + ">>" });
            }
            r4.internal.putStream({ additionalKeyValues: o2, objectId: a2.objId }), r4.internal.out("endobj");
          }
        n2 && it(r4.internal.acroformPlugin.xForms, r4);
      }(r3, e2);
    }), e2.internal.acroformPlugin.isInitialized = true;
  }
}, ot = q.__acroform__.arrayToPdfArray = function(e2, r2, n2) {
  var i2 = function(t3) {
    return t3;
  };
  if (Array.isArray(e2)) {
    for (var a2 = "[", o2 = 0; o2 < e2.length; o2++)
      switch (o2 !== 0 && (a2 += " "), _typeof$2(e2[o2])) {
        case "boolean":
        case "number":
        case "object":
          a2 += e2[o2].toString();
          break;
        case "string":
          e2[o2].substr(0, 1) !== "/" ? (r2 !== void 0 && n2 && (i2 = n2.internal.getEncryptor(r2)), a2 += "(" + R(i2(e2[o2].toString())) + ")") : a2 += e2[o2].toString();
      }
    return a2 += "]";
  }
  throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray");
};
var st = function(t3, e2, r2) {
  var n2 = function(t4) {
    return t4;
  };
  return e2 !== void 0 && r2 && (n2 = r2.internal.getEncryptor(e2)), (t3 = t3 || "").toString(), t3 = "(" + R(n2(t3)) + ")";
}, ct = function() {
  this._objId = void 0, this._scope = void 0, Object.defineProperty(this, "objId", { get: function() {
    if (this._objId === void 0) {
      if (this.scope === void 0)
        return;
      this._objId = this.scope.internal.newObjectDeferred();
    }
    return this._objId;
  }, set: function(t3) {
    this._objId = t3;
  } }), Object.defineProperty(this, "scope", { value: this._scope, writable: true });
};
ct.prototype.toString = function() {
  return this.objId + " 0 R";
}, ct.prototype.putStream = function() {
  var t3 = this.getKeyValueListForStream();
  this.scope.internal.putStream({ data: this.stream, additionalKeyValues: t3, objectId: this.objId }), this.scope.internal.out("endobj");
}, ct.prototype.getKeyValueListForStream = function() {
  var t3 = [], e2 = Object.getOwnPropertyNames(this).filter(function(t4) {
    return t4 != "content" && t4 != "appearanceStreamContent" && t4 != "scope" && t4 != "objId" && t4.substring(0, 1) != "_";
  });
  for (var r2 in e2)
    if (Object.getOwnPropertyDescriptor(this, e2[r2]).configurable === false) {
      var n2 = e2[r2], i2 = this[n2];
      i2 && (Array.isArray(i2) ? t3.push({ key: n2, value: ot(i2, this.objId, this.scope) }) : i2 instanceof ct ? (i2.scope = this.scope, t3.push({ key: n2, value: i2.objId + " 0 R" })) : typeof i2 != "function" && t3.push({ key: n2, value: i2 }));
    }
  return t3;
};
var ut = function() {
  ct.call(this), Object.defineProperty(this, "Type", { value: "/XObject", configurable: false, writable: true }), Object.defineProperty(this, "Subtype", { value: "/Form", configurable: false, writable: true }), Object.defineProperty(this, "FormType", { value: 1, configurable: false, writable: true });
  var t3, e2 = [];
  Object.defineProperty(this, "BBox", { configurable: false, get: function() {
    return e2;
  }, set: function(t4) {
    e2 = t4;
  } }), Object.defineProperty(this, "Resources", { value: "2 0 R", configurable: false, writable: true }), Object.defineProperty(this, "stream", { enumerable: false, configurable: true, set: function(e3) {
    t3 = e3.trim();
  }, get: function() {
    return t3 || null;
  } });
};
H(ut, ct);
var ht = function() {
  ct.call(this);
  var t3, e2 = [];
  Object.defineProperty(this, "Kids", { enumerable: false, configurable: true, get: function() {
    return e2.length > 0 ? e2 : void 0;
  } }), Object.defineProperty(this, "Fields", { enumerable: false, configurable: false, get: function() {
    return e2;
  } }), Object.defineProperty(this, "DA", { enumerable: false, configurable: false, get: function() {
    if (t3) {
      var e3 = function(t4) {
        return t4;
      };
      return this.scope && (e3 = this.scope.internal.getEncryptor(this.objId)), "(" + R(e3(t3)) + ")";
    }
  }, set: function(e3) {
    t3 = e3;
  } });
};
H(ht, ct);
var lt = function t() {
  ct.call(this);
  var e2 = 4;
  Object.defineProperty(this, "F", { enumerable: false, configurable: false, get: function() {
    return e2;
  }, set: function(t3) {
    if (isNaN(t3))
      throw new Error('Invalid value "' + t3 + '" for attribute F supplied.');
    e2 = t3;
  } }), Object.defineProperty(this, "showWhenPrinted", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(e2, 3));
  }, set: function(t3) {
    Boolean(t3) === true ? this.F = K(e2, 3) : this.F = Z$2(e2, 3);
  } });
  var r2 = 0;
  Object.defineProperty(this, "Ff", { enumerable: false, configurable: false, get: function() {
    return r2;
  }, set: function(t3) {
    if (isNaN(t3))
      throw new Error('Invalid value "' + t3 + '" for attribute Ff supplied.');
    r2 = t3;
  } });
  var n2 = [];
  Object.defineProperty(this, "Rect", { enumerable: false, configurable: false, get: function() {
    if (n2.length !== 0)
      return n2;
  }, set: function(t3) {
    n2 = t3 !== void 0 ? t3 : [];
  } }), Object.defineProperty(this, "x", { enumerable: true, configurable: true, get: function() {
    return !n2 || isNaN(n2[0]) ? 0 : n2[0];
  }, set: function(t3) {
    n2[0] = t3;
  } }), Object.defineProperty(this, "y", { enumerable: true, configurable: true, get: function() {
    return !n2 || isNaN(n2[1]) ? 0 : n2[1];
  }, set: function(t3) {
    n2[1] = t3;
  } }), Object.defineProperty(this, "width", { enumerable: true, configurable: true, get: function() {
    return !n2 || isNaN(n2[2]) ? 0 : n2[2];
  }, set: function(t3) {
    n2[2] = t3;
  } }), Object.defineProperty(this, "height", { enumerable: true, configurable: true, get: function() {
    return !n2 || isNaN(n2[3]) ? 0 : n2[3];
  }, set: function(t3) {
    n2[3] = t3;
  } });
  var i2 = "";
  Object.defineProperty(this, "FT", { enumerable: true, configurable: false, get: function() {
    return i2;
  }, set: function(t3) {
    switch (t3) {
      case "/Btn":
      case "/Tx":
      case "/Ch":
      case "/Sig":
        i2 = t3;
        break;
      default:
        throw new Error('Invalid value "' + t3 + '" for attribute FT supplied.');
    }
  } });
  var a2 = null;
  Object.defineProperty(this, "T", { enumerable: true, configurable: false, get: function() {
    if (!a2 || a2.length < 1) {
      if (this instanceof yt)
        return;
      a2 = "FieldObject" + t.FieldNum++;
    }
    var e3 = function(t3) {
      return t3;
    };
    return this.scope && (e3 = this.scope.internal.getEncryptor(this.objId)), "(" + R(e3(a2)) + ")";
  }, set: function(t3) {
    a2 = t3.toString();
  } }), Object.defineProperty(this, "fieldName", { configurable: true, enumerable: true, get: function() {
    return a2;
  }, set: function(t3) {
    a2 = t3;
  } });
  var o2 = "helvetica";
  Object.defineProperty(this, "fontName", { enumerable: true, configurable: true, get: function() {
    return o2;
  }, set: function(t3) {
    o2 = t3;
  } });
  var s2 = "normal";
  Object.defineProperty(this, "fontStyle", { enumerable: true, configurable: true, get: function() {
    return s2;
  }, set: function(t3) {
    s2 = t3;
  } });
  var c2 = 0;
  Object.defineProperty(this, "fontSize", { enumerable: true, configurable: true, get: function() {
    return c2;
  }, set: function(t3) {
    c2 = t3;
  } });
  var u2 = void 0;
  Object.defineProperty(this, "maxFontSize", { enumerable: true, configurable: true, get: function() {
    return u2 === void 0 ? 50 / D : u2;
  }, set: function(t3) {
    u2 = t3;
  } });
  var h2 = "black";
  Object.defineProperty(this, "color", { enumerable: true, configurable: true, get: function() {
    return h2;
  }, set: function(t3) {
    h2 = t3;
  } });
  var l2 = "/F1 0 Tf 0 g";
  Object.defineProperty(this, "DA", { enumerable: true, configurable: false, get: function() {
    if (!(!l2 || this instanceof yt || this instanceof Nt))
      return st(l2, this.objId, this.scope);
  }, set: function(t3) {
    t3 = t3.toString(), l2 = t3;
  } });
  var f2 = null;
  Object.defineProperty(this, "DV", { enumerable: false, configurable: false, get: function() {
    if (f2)
      return this instanceof mt == false ? st(f2, this.objId, this.scope) : f2;
  }, set: function(t3) {
    t3 = t3.toString(), f2 = this instanceof mt == false ? t3.substr(0, 1) === "(" ? T$2(t3.substr(1, t3.length - 2)) : T$2(t3) : t3;
  } }), Object.defineProperty(this, "defaultValue", { enumerable: true, configurable: true, get: function() {
    return this instanceof mt == true ? T$2(f2.substr(1, f2.length - 1)) : f2;
  }, set: function(t3) {
    t3 = t3.toString(), f2 = this instanceof mt == true ? "/" + t3 : t3;
  } });
  var d2 = null;
  Object.defineProperty(this, "_V", { enumerable: false, configurable: false, get: function() {
    if (d2)
      return d2;
  }, set: function(t3) {
    this.V = t3;
  } }), Object.defineProperty(this, "V", { enumerable: false, configurable: false, get: function() {
    if (d2)
      return this instanceof mt == false ? st(d2, this.objId, this.scope) : d2;
  }, set: function(t3) {
    t3 = t3.toString(), d2 = this instanceof mt == false ? t3.substr(0, 1) === "(" ? T$2(t3.substr(1, t3.length - 2)) : T$2(t3) : t3;
  } }), Object.defineProperty(this, "value", { enumerable: true, configurable: true, get: function() {
    return this instanceof mt == true ? T$2(d2.substr(1, d2.length - 1)) : d2;
  }, set: function(t3) {
    t3 = t3.toString(), d2 = this instanceof mt == true ? "/" + t3 : t3;
  } }), Object.defineProperty(this, "hasAnnotation", { enumerable: true, configurable: true, get: function() {
    return this.Rect;
  } }), Object.defineProperty(this, "Type", { enumerable: true, configurable: false, get: function() {
    return this.hasAnnotation ? "/Annot" : null;
  } }), Object.defineProperty(this, "Subtype", { enumerable: true, configurable: false, get: function() {
    return this.hasAnnotation ? "/Widget" : null;
  } });
  var p5, g2 = false;
  Object.defineProperty(this, "hasAppearanceStream", { enumerable: true, configurable: true, get: function() {
    return g2;
  }, set: function(t3) {
    t3 = Boolean(t3), g2 = t3;
  } }), Object.defineProperty(this, "page", { enumerable: true, configurable: true, get: function() {
    if (p5)
      return p5;
  }, set: function(t3) {
    p5 = t3;
  } }), Object.defineProperty(this, "readOnly", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 1));
  }, set: function(t3) {
    Boolean(t3) === true ? this.Ff = K(this.Ff, 1) : this.Ff = Z$2(this.Ff, 1);
  } }), Object.defineProperty(this, "required", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 2));
  }, set: function(t3) {
    Boolean(t3) === true ? this.Ff = K(this.Ff, 2) : this.Ff = Z$2(this.Ff, 2);
  } }), Object.defineProperty(this, "noExport", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 3));
  }, set: function(t3) {
    Boolean(t3) === true ? this.Ff = K(this.Ff, 3) : this.Ff = Z$2(this.Ff, 3);
  } });
  var m2 = null;
  Object.defineProperty(this, "Q", { enumerable: true, configurable: false, get: function() {
    if (m2 !== null)
      return m2;
  }, set: function(t3) {
    if ([0, 1, 2].indexOf(t3) === -1)
      throw new Error('Invalid value "' + t3 + '" for attribute Q supplied.');
    m2 = t3;
  } }), Object.defineProperty(this, "textAlign", { get: function() {
    var t3;
    switch (m2) {
      case 0:
      default:
        t3 = "left";
        break;
      case 1:
        t3 = "center";
        break;
      case 2:
        t3 = "right";
    }
    return t3;
  }, configurable: true, enumerable: true, set: function(t3) {
    switch (t3) {
      case "right":
      case 2:
        m2 = 2;
        break;
      case "center":
      case 1:
        m2 = 1;
        break;
      case "left":
      case 0:
      default:
        m2 = 0;
    }
  } });
};
H(lt, ct);
var ft = function() {
  lt.call(this), this.FT = "/Ch", this.V = "()", this.fontName = "zapfdingbats";
  var t3 = 0;
  Object.defineProperty(this, "TI", { enumerable: true, configurable: false, get: function() {
    return t3;
  }, set: function(e3) {
    t3 = e3;
  } }), Object.defineProperty(this, "topIndex", { enumerable: true, configurable: true, get: function() {
    return t3;
  }, set: function(e3) {
    t3 = e3;
  } });
  var e2 = [];
  Object.defineProperty(this, "Opt", { enumerable: true, configurable: false, get: function() {
    return ot(e2, this.objId, this.scope);
  }, set: function(t4) {
    var r2, n2;
    n2 = [], typeof (r2 = t4) == "string" && (n2 = function(t5, e3, r3) {
      r3 || (r3 = 1);
      for (var n3, i2 = []; n3 = e3.exec(t5); )
        i2.push(n3[r3]);
      return i2;
    }(r2, /\((.*?)\)/g)), e2 = n2;
  } }), this.getOptions = function() {
    return e2;
  }, this.setOptions = function(t4) {
    e2 = t4, this.sort && e2.sort();
  }, this.addOption = function(t4) {
    t4 = (t4 = t4 || "").toString(), e2.push(t4), this.sort && e2.sort();
  }, this.removeOption = function(t4, r2) {
    for (r2 = r2 || false, t4 = (t4 = t4 || "").toString(); e2.indexOf(t4) !== -1 && (e2.splice(e2.indexOf(t4), 1), r2 !== false); )
      ;
  }, Object.defineProperty(this, "combo", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 18));
  }, set: function(t4) {
    Boolean(t4) === true ? this.Ff = K(this.Ff, 18) : this.Ff = Z$2(this.Ff, 18);
  } }), Object.defineProperty(this, "edit", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 19));
  }, set: function(t4) {
    this.combo === true && (Boolean(t4) === true ? this.Ff = K(this.Ff, 19) : this.Ff = Z$2(this.Ff, 19));
  } }), Object.defineProperty(this, "sort", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 20));
  }, set: function(t4) {
    Boolean(t4) === true ? (this.Ff = K(this.Ff, 20), e2.sort()) : this.Ff = Z$2(this.Ff, 20);
  } }), Object.defineProperty(this, "multiSelect", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 22));
  }, set: function(t4) {
    Boolean(t4) === true ? this.Ff = K(this.Ff, 22) : this.Ff = Z$2(this.Ff, 22);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 23));
  }, set: function(t4) {
    Boolean(t4) === true ? this.Ff = K(this.Ff, 23) : this.Ff = Z$2(this.Ff, 23);
  } }), Object.defineProperty(this, "commitOnSelChange", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 27));
  }, set: function(t4) {
    Boolean(t4) === true ? this.Ff = K(this.Ff, 27) : this.Ff = Z$2(this.Ff, 27);
  } }), this.hasAppearanceStream = false;
};
H(ft, lt);
var dt = function() {
  ft.call(this), this.fontName = "helvetica", this.combo = false;
};
H(dt, ft);
var pt = function() {
  dt.call(this), this.combo = true;
};
H(pt, dt);
var gt = function() {
  pt.call(this), this.edit = true;
};
H(gt, pt);
var mt = function() {
  lt.call(this), this.FT = "/Btn", Object.defineProperty(this, "noToggleToOff", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 15));
  }, set: function(t3) {
    Boolean(t3) === true ? this.Ff = K(this.Ff, 15) : this.Ff = Z$2(this.Ff, 15);
  } }), Object.defineProperty(this, "radio", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 16));
  }, set: function(t3) {
    Boolean(t3) === true ? this.Ff = K(this.Ff, 16) : this.Ff = Z$2(this.Ff, 16);
  } }), Object.defineProperty(this, "pushButton", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 17));
  }, set: function(t3) {
    Boolean(t3) === true ? this.Ff = K(this.Ff, 17) : this.Ff = Z$2(this.Ff, 17);
  } }), Object.defineProperty(this, "radioIsUnison", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 26));
  }, set: function(t3) {
    Boolean(t3) === true ? this.Ff = K(this.Ff, 26) : this.Ff = Z$2(this.Ff, 26);
  } });
  var e2, r2 = {};
  Object.defineProperty(this, "MK", { enumerable: false, configurable: false, get: function() {
    var t3 = function(t4) {
      return t4;
    };
    if (this.scope && (t3 = this.scope.internal.getEncryptor(this.objId)), Object.keys(r2).length !== 0) {
      var e3, n2 = [];
      for (e3 in n2.push("<<"), r2)
        n2.push("/" + e3 + " (" + R(t3(r2[e3])) + ")");
      return n2.push(">>"), n2.join("\n");
    }
  }, set: function(e3) {
    _typeof$2(e3) === "object" && (r2 = e3);
  } }), Object.defineProperty(this, "caption", { enumerable: true, configurable: true, get: function() {
    return r2.CA || "";
  }, set: function(t3) {
    typeof t3 == "string" && (r2.CA = t3);
  } }), Object.defineProperty(this, "AS", { enumerable: false, configurable: false, get: function() {
    return e2;
  }, set: function(t3) {
    e2 = t3;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: true, configurable: true, get: function() {
    return e2.substr(1, e2.length - 1);
  }, set: function(t3) {
    e2 = "/" + t3;
  } });
};
H(mt, lt);
var vt = function() {
  mt.call(this), this.pushButton = true;
};
H(vt, mt);
var bt = function() {
  mt.call(this), this.radio = true, this.pushButton = false;
  var t3 = [];
  Object.defineProperty(this, "Kids", { enumerable: true, configurable: false, get: function() {
    return t3;
  }, set: function(e2) {
    t3 = e2 !== void 0 ? e2 : [];
  } });
};
H(bt, mt);
var yt = function() {
  var e2, r2;
  lt.call(this), Object.defineProperty(this, "Parent", { enumerable: false, configurable: false, get: function() {
    return e2;
  }, set: function(t3) {
    e2 = t3;
  } }), Object.defineProperty(this, "optionName", { enumerable: false, configurable: true, get: function() {
    return r2;
  }, set: function(t3) {
    r2 = t3;
  } });
  var n2, i2 = {};
  Object.defineProperty(this, "MK", { enumerable: false, configurable: false, get: function() {
    var t3 = function(t4) {
      return t4;
    };
    this.scope && (t3 = this.scope.internal.getEncryptor(this.objId));
    var e3, r3 = [];
    for (e3 in r3.push("<<"), i2)
      r3.push("/" + e3 + " (" + R(t3(i2[e3])) + ")");
    return r3.push(">>"), r3.join("\n");
  }, set: function(e3) {
    _typeof$2(e3) === "object" && (i2 = e3);
  } }), Object.defineProperty(this, "caption", { enumerable: true, configurable: true, get: function() {
    return i2.CA || "";
  }, set: function(t3) {
    typeof t3 == "string" && (i2.CA = t3);
  } }), Object.defineProperty(this, "AS", { enumerable: false, configurable: false, get: function() {
    return n2;
  }, set: function(t3) {
    n2 = t3;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: true, configurable: true, get: function() {
    return n2.substr(1, n2.length - 1);
  }, set: function(t3) {
    n2 = "/" + t3;
  } }), this.caption = "l", this.appearanceState = "Off", this._AppearanceType = At.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(this.optionName);
};
H(yt, lt), bt.prototype.setAppearance = function(t3) {
  if (!("createAppearanceStream" in t3) || !("getCA" in t3))
    throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");
  for (var e2 in this.Kids)
    if (this.Kids.hasOwnProperty(e2)) {
      var r2 = this.Kids[e2];
      r2.appearanceStreamContent = t3.createAppearanceStream(r2.optionName), r2.caption = t3.getCA();
    }
}, bt.prototype.createOption = function(t3) {
  var e2 = new yt();
  return e2.Parent = this, e2.optionName = t3, this.Kids.push(e2), xt.call(this.scope, e2), e2;
};
var wt = function() {
  mt.call(this), this.fontName = "zapfdingbats", this.caption = "3", this.appearanceState = "On", this.value = "On", this.textAlign = "center", this.appearanceStreamContent = At.CheckBox.createAppearanceStream();
};
H(wt, mt);
var Nt = function() {
  lt.call(this), this.FT = "/Tx", Object.defineProperty(this, "multiline", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 13));
  }, set: function(t4) {
    Boolean(t4) === true ? this.Ff = K(this.Ff, 13) : this.Ff = Z$2(this.Ff, 13);
  } }), Object.defineProperty(this, "fileSelect", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 21));
  }, set: function(t4) {
    Boolean(t4) === true ? this.Ff = K(this.Ff, 21) : this.Ff = Z$2(this.Ff, 21);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 23));
  }, set: function(t4) {
    Boolean(t4) === true ? this.Ff = K(this.Ff, 23) : this.Ff = Z$2(this.Ff, 23);
  } }), Object.defineProperty(this, "doNotScroll", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 24));
  }, set: function(t4) {
    Boolean(t4) === true ? this.Ff = K(this.Ff, 24) : this.Ff = Z$2(this.Ff, 24);
  } }), Object.defineProperty(this, "comb", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 25));
  }, set: function(t4) {
    Boolean(t4) === true ? this.Ff = K(this.Ff, 25) : this.Ff = Z$2(this.Ff, 25);
  } }), Object.defineProperty(this, "richText", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 26));
  }, set: function(t4) {
    Boolean(t4) === true ? this.Ff = K(this.Ff, 26) : this.Ff = Z$2(this.Ff, 26);
  } });
  var t3 = null;
  Object.defineProperty(this, "MaxLen", { enumerable: true, configurable: false, get: function() {
    return t3;
  }, set: function(e2) {
    t3 = e2;
  } }), Object.defineProperty(this, "maxLength", { enumerable: true, configurable: true, get: function() {
    return t3;
  }, set: function(e2) {
    Number.isInteger(e2) && (t3 = e2);
  } }), Object.defineProperty(this, "hasAppearanceStream", { enumerable: true, configurable: true, get: function() {
    return this.V || this.DV;
  } });
};
H(Nt, lt);
var Lt = function() {
  Nt.call(this), Object.defineProperty(this, "password", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 14));
  }, set: function(t3) {
    Boolean(t3) === true ? this.Ff = K(this.Ff, 14) : this.Ff = Z$2(this.Ff, 14);
  } }), this.password = true;
};
H(Lt, Nt);
var At = { CheckBox: { createAppearanceStream: function() {
  return { N: { On: At.CheckBox.YesNormal }, D: { On: At.CheckBox.YesPushDown, Off: At.CheckBox.OffPushDown } };
}, YesPushDown: function(t3) {
  var e2 = V$1(t3);
  e2.scope = t3.scope;
  var r2 = [], n2 = t3.scope.internal.getFont(t3.fontName, t3.fontStyle).id, i2 = t3.scope.__private__.encodeColorString(t3.color), a2 = tt(t3, t3.caption);
  return r2.push("0.749023 g"), r2.push("0 0 " + z$1(At.internal.getWidth(t3)) + " " + z$1(At.internal.getHeight(t3)) + " re"), r2.push("f"), r2.push("BMC"), r2.push("q"), r2.push("0 0 1 rg"), r2.push("/" + n2 + " " + z$1(a2.fontSize) + " Tf " + i2), r2.push("BT"), r2.push(a2.text), r2.push("ET"), r2.push("Q"), r2.push("EMC"), e2.stream = r2.join("\n"), e2;
}, YesNormal: function(t3) {
  var e2 = V$1(t3);
  e2.scope = t3.scope;
  var r2 = t3.scope.internal.getFont(t3.fontName, t3.fontStyle).id, n2 = t3.scope.__private__.encodeColorString(t3.color), i2 = [], a2 = At.internal.getHeight(t3), o2 = At.internal.getWidth(t3), s2 = tt(t3, t3.caption);
  return i2.push("1 g"), i2.push("0 0 " + z$1(o2) + " " + z$1(a2) + " re"), i2.push("f"), i2.push("q"), i2.push("0 0 1 rg"), i2.push("0 0 " + z$1(o2 - 1) + " " + z$1(a2 - 1) + " re"), i2.push("W"), i2.push("n"), i2.push("0 g"), i2.push("BT"), i2.push("/" + r2 + " " + z$1(s2.fontSize) + " Tf " + n2), i2.push(s2.text), i2.push("ET"), i2.push("Q"), e2.stream = i2.join("\n"), e2;
}, OffPushDown: function(t3) {
  var e2 = V$1(t3);
  e2.scope = t3.scope;
  var r2 = [];
  return r2.push("0.749023 g"), r2.push("0 0 " + z$1(At.internal.getWidth(t3)) + " " + z$1(At.internal.getHeight(t3)) + " re"), r2.push("f"), e2.stream = r2.join("\n"), e2;
} }, RadioButton: { Circle: { createAppearanceStream: function(t3) {
  var e2 = { D: { Off: At.RadioButton.Circle.OffPushDown }, N: {} };
  return e2.N[t3] = At.RadioButton.Circle.YesNormal, e2.D[t3] = At.RadioButton.Circle.YesPushDown, e2;
}, getCA: function() {
  return "l";
}, YesNormal: function(t3) {
  var e2 = V$1(t3);
  e2.scope = t3.scope;
  var r2 = [], n2 = At.internal.getWidth(t3) <= At.internal.getHeight(t3) ? At.internal.getWidth(t3) / 4 : At.internal.getHeight(t3) / 4;
  n2 = Number((0.9 * n2).toFixed(5));
  var i2 = At.internal.Bezier_C, a2 = Number((n2 * i2).toFixed(5));
  return r2.push("q"), r2.push("1 0 0 1 " + U$1(At.internal.getWidth(t3) / 2) + " " + U$1(At.internal.getHeight(t3) / 2) + " cm"), r2.push(n2 + " 0 m"), r2.push(n2 + " " + a2 + " " + a2 + " " + n2 + " 0 " + n2 + " c"), r2.push("-" + a2 + " " + n2 + " -" + n2 + " " + a2 + " -" + n2 + " 0 c"), r2.push("-" + n2 + " -" + a2 + " -" + a2 + " -" + n2 + " 0 -" + n2 + " c"), r2.push(a2 + " -" + n2 + " " + n2 + " -" + a2 + " " + n2 + " 0 c"), r2.push("f"), r2.push("Q"), e2.stream = r2.join("\n"), e2;
}, YesPushDown: function(t3) {
  var e2 = V$1(t3);
  e2.scope = t3.scope;
  var r2 = [], n2 = At.internal.getWidth(t3) <= At.internal.getHeight(t3) ? At.internal.getWidth(t3) / 4 : At.internal.getHeight(t3) / 4;
  n2 = Number((0.9 * n2).toFixed(5));
  var i2 = Number((2 * n2).toFixed(5)), a2 = Number((i2 * At.internal.Bezier_C).toFixed(5)), o2 = Number((n2 * At.internal.Bezier_C).toFixed(5));
  return r2.push("0.749023 g"), r2.push("q"), r2.push("1 0 0 1 " + U$1(At.internal.getWidth(t3) / 2) + " " + U$1(At.internal.getHeight(t3) / 2) + " cm"), r2.push(i2 + " 0 m"), r2.push(i2 + " " + a2 + " " + a2 + " " + i2 + " 0 " + i2 + " c"), r2.push("-" + a2 + " " + i2 + " -" + i2 + " " + a2 + " -" + i2 + " 0 c"), r2.push("-" + i2 + " -" + a2 + " -" + a2 + " -" + i2 + " 0 -" + i2 + " c"), r2.push(a2 + " -" + i2 + " " + i2 + " -" + a2 + " " + i2 + " 0 c"), r2.push("f"), r2.push("Q"), r2.push("0 g"), r2.push("q"), r2.push("1 0 0 1 " + U$1(At.internal.getWidth(t3) / 2) + " " + U$1(At.internal.getHeight(t3) / 2) + " cm"), r2.push(n2 + " 0 m"), r2.push(n2 + " " + o2 + " " + o2 + " " + n2 + " 0 " + n2 + " c"), r2.push("-" + o2 + " " + n2 + " -" + n2 + " " + o2 + " -" + n2 + " 0 c"), r2.push("-" + n2 + " -" + o2 + " -" + o2 + " -" + n2 + " 0 -" + n2 + " c"), r2.push(o2 + " -" + n2 + " " + n2 + " -" + o2 + " " + n2 + " 0 c"), r2.push("f"), r2.push("Q"), e2.stream = r2.join("\n"), e2;
}, OffPushDown: function(t3) {
  var e2 = V$1(t3);
  e2.scope = t3.scope;
  var r2 = [], n2 = At.internal.getWidth(t3) <= At.internal.getHeight(t3) ? At.internal.getWidth(t3) / 4 : At.internal.getHeight(t3) / 4;
  n2 = Number((0.9 * n2).toFixed(5));
  var i2 = Number((2 * n2).toFixed(5)), a2 = Number((i2 * At.internal.Bezier_C).toFixed(5));
  return r2.push("0.749023 g"), r2.push("q"), r2.push("1 0 0 1 " + U$1(At.internal.getWidth(t3) / 2) + " " + U$1(At.internal.getHeight(t3) / 2) + " cm"), r2.push(i2 + " 0 m"), r2.push(i2 + " " + a2 + " " + a2 + " " + i2 + " 0 " + i2 + " c"), r2.push("-" + a2 + " " + i2 + " -" + i2 + " " + a2 + " -" + i2 + " 0 c"), r2.push("-" + i2 + " -" + a2 + " -" + a2 + " -" + i2 + " 0 -" + i2 + " c"), r2.push(a2 + " -" + i2 + " " + i2 + " -" + a2 + " " + i2 + " 0 c"), r2.push("f"), r2.push("Q"), e2.stream = r2.join("\n"), e2;
} }, Cross: { createAppearanceStream: function(t3) {
  var e2 = { D: { Off: At.RadioButton.Cross.OffPushDown }, N: {} };
  return e2.N[t3] = At.RadioButton.Cross.YesNormal, e2.D[t3] = At.RadioButton.Cross.YesPushDown, e2;
}, getCA: function() {
  return "8";
}, YesNormal: function(t3) {
  var e2 = V$1(t3);
  e2.scope = t3.scope;
  var r2 = [], n2 = At.internal.calculateCross(t3);
  return r2.push("q"), r2.push("1 1 " + z$1(At.internal.getWidth(t3) - 2) + " " + z$1(At.internal.getHeight(t3) - 2) + " re"), r2.push("W"), r2.push("n"), r2.push(z$1(n2.x1.x) + " " + z$1(n2.x1.y) + " m"), r2.push(z$1(n2.x2.x) + " " + z$1(n2.x2.y) + " l"), r2.push(z$1(n2.x4.x) + " " + z$1(n2.x4.y) + " m"), r2.push(z$1(n2.x3.x) + " " + z$1(n2.x3.y) + " l"), r2.push("s"), r2.push("Q"), e2.stream = r2.join("\n"), e2;
}, YesPushDown: function(t3) {
  var e2 = V$1(t3);
  e2.scope = t3.scope;
  var r2 = At.internal.calculateCross(t3), n2 = [];
  return n2.push("0.749023 g"), n2.push("0 0 " + z$1(At.internal.getWidth(t3)) + " " + z$1(At.internal.getHeight(t3)) + " re"), n2.push("f"), n2.push("q"), n2.push("1 1 " + z$1(At.internal.getWidth(t3) - 2) + " " + z$1(At.internal.getHeight(t3) - 2) + " re"), n2.push("W"), n2.push("n"), n2.push(z$1(r2.x1.x) + " " + z$1(r2.x1.y) + " m"), n2.push(z$1(r2.x2.x) + " " + z$1(r2.x2.y) + " l"), n2.push(z$1(r2.x4.x) + " " + z$1(r2.x4.y) + " m"), n2.push(z$1(r2.x3.x) + " " + z$1(r2.x3.y) + " l"), n2.push("s"), n2.push("Q"), e2.stream = n2.join("\n"), e2;
}, OffPushDown: function(t3) {
  var e2 = V$1(t3);
  e2.scope = t3.scope;
  var r2 = [];
  return r2.push("0.749023 g"), r2.push("0 0 " + z$1(At.internal.getWidth(t3)) + " " + z$1(At.internal.getHeight(t3)) + " re"), r2.push("f"), e2.stream = r2.join("\n"), e2;
} } }, createDefaultAppearanceStream: function(t3) {
  var e2 = t3.scope.internal.getFont(t3.fontName, t3.fontStyle).id, r2 = t3.scope.__private__.encodeColorString(t3.color);
  return "/" + e2 + " " + t3.fontSize + " Tf " + r2;
} };
At.internal = { Bezier_C: 0.551915024494, calculateCross: function(t3) {
  var e2 = At.internal.getWidth(t3), r2 = At.internal.getHeight(t3), n2 = Math.min(e2, r2);
  return { x1: { x: (e2 - n2) / 2, y: (r2 - n2) / 2 + n2 }, x2: { x: (e2 - n2) / 2 + n2, y: (r2 - n2) / 2 }, x3: { x: (e2 - n2) / 2, y: (r2 - n2) / 2 }, x4: { x: (e2 - n2) / 2 + n2, y: (r2 - n2) / 2 + n2 } };
} }, At.internal.getWidth = function(e2) {
  var r2 = 0;
  return _typeof$2(e2) === "object" && (r2 = W(e2.Rect[2])), r2;
}, At.internal.getHeight = function(e2) {
  var r2 = 0;
  return _typeof$2(e2) === "object" && (r2 = W(e2.Rect[3])), r2;
};
var xt = q.addField = function(t3) {
  if (at(this, t3), !(t3 instanceof lt))
    throw new Error("Invalid argument passed to jsPDF.addField.");
  var e2;
  return (e2 = t3).scope.internal.acroformPlugin.printedOut && (e2.scope.internal.acroformPlugin.printedOut = false, e2.scope.internal.acroformPlugin.acroFormDictionaryRoot = null), e2.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(e2), t3.page = t3.scope.internal.getCurrentPageInfo().pageNumber, this;
};
q.AcroFormChoiceField = ft, q.AcroFormListBox = dt, q.AcroFormComboBox = pt, q.AcroFormEditBox = gt, q.AcroFormButton = mt, q.AcroFormPushButton = vt, q.AcroFormRadioButton = bt, q.AcroFormCheckBox = wt, q.AcroFormTextField = Nt, q.AcroFormPasswordField = Lt, q.AcroFormAppearance = At, q.AcroForm = { ChoiceField: ft, ListBox: dt, ComboBox: pt, EditBox: gt, Button: mt, PushButton: vt, RadioButton: bt, CheckBox: wt, TextField: Nt, PasswordField: Lt, Appearance: At }, E$1.AcroForm = { ChoiceField: ft, ListBox: dt, ComboBox: pt, EditBox: gt, Button: mt, PushButton: vt, RadioButton: bt, CheckBox: wt, TextField: Nt, PasswordField: Lt, Appearance: At };
E$1.AcroForm;
function _t(t3) {
  return t3.reduce(function(t4, e2, r2) {
    return t4[e2] = r2, t4;
  }, {});
}
!function(e2) {
  e2.__addimage__ = {};
  var r2 = "UNKNOWN", n2 = { PNG: [[137, 80, 78, 71]], TIFF: [[77, 77, 0, 42], [73, 73, 42, 0]], JPEG: [[255, 216, 255, 224, void 0, void 0, 74, 70, 73, 70, 0], [255, 216, 255, 225, void 0, void 0, 69, 120, 105, 102, 0, 0], [255, 216, 255, 219], [255, 216, 255, 238]], JPEG2000: [[0, 0, 0, 12, 106, 80, 32, 32]], GIF87a: [[71, 73, 70, 56, 55, 97]], GIF89a: [[71, 73, 70, 56, 57, 97]], WEBP: [[82, 73, 70, 70, void 0, void 0, void 0, void 0, 87, 69, 66, 80]], BMP: [[66, 77], [66, 65], [67, 73], [67, 80], [73, 67], [80, 84]] }, i2 = e2.__addimage__.getImageFileTypeByImageData = function(t3, e3) {
    var i3, a3, o3, s3, c3, u2 = r2;
    if ((e3 = e3 || r2) === "RGBA" || t3.data !== void 0 && t3.data instanceof Uint8ClampedArray && "height" in t3 && "width" in t3)
      return "RGBA";
    if (x2(t3))
      for (c3 in n2)
        for (o3 = n2[c3], i3 = 0; i3 < o3.length; i3 += 1) {
          for (s3 = true, a3 = 0; a3 < o3[i3].length; a3 += 1)
            if (o3[i3][a3] !== void 0 && o3[i3][a3] !== t3[a3]) {
              s3 = false;
              break;
            }
          if (s3 === true) {
            u2 = c3;
            break;
          }
        }
    else
      for (c3 in n2)
        for (o3 = n2[c3], i3 = 0; i3 < o3.length; i3 += 1) {
          for (s3 = true, a3 = 0; a3 < o3[i3].length; a3 += 1)
            if (o3[i3][a3] !== void 0 && o3[i3][a3] !== t3.charCodeAt(a3)) {
              s3 = false;
              break;
            }
          if (s3 === true) {
            u2 = c3;
            break;
          }
        }
    return u2 === r2 && e3 !== r2 && (u2 = e3), u2;
  }, a2 = function t3(e3) {
    for (var r3 = this.internal.write, n3 = this.internal.putStream, i3 = (0, this.internal.getFilters)(); i3.indexOf("FlateEncode") !== -1; )
      i3.splice(i3.indexOf("FlateEncode"), 1);
    e3.objectId = this.internal.newObject();
    var a3 = [];
    if (a3.push({ key: "Type", value: "/XObject" }), a3.push({ key: "Subtype", value: "/Image" }), a3.push({ key: "Width", value: e3.width }), a3.push({ key: "Height", value: e3.height }), e3.colorSpace === b2.INDEXED ? a3.push({ key: "ColorSpace", value: "[/Indexed /DeviceRGB " + (e3.palette.length / 3 - 1) + " " + ("sMask" in e3 && e3.sMask !== void 0 ? e3.objectId + 2 : e3.objectId + 1) + " 0 R]" }) : (a3.push({ key: "ColorSpace", value: "/" + e3.colorSpace }), e3.colorSpace === b2.DEVICE_CMYK && a3.push({ key: "Decode", value: "[1 0 1 0 1 0 1 0]" })), a3.push({ key: "BitsPerComponent", value: e3.bitsPerComponent }), "decodeParameters" in e3 && e3.decodeParameters !== void 0 && a3.push({ key: "DecodeParms", value: "<<" + e3.decodeParameters + ">>" }), "transparency" in e3 && Array.isArray(e3.transparency)) {
      for (var o3 = "", s3 = 0, c3 = e3.transparency.length; s3 < c3; s3++)
        o3 += e3.transparency[s3] + " " + e3.transparency[s3] + " ";
      a3.push({ key: "Mask", value: "[" + o3 + "]" });
    }
    e3.sMask !== void 0 && a3.push({ key: "SMask", value: e3.objectId + 1 + " 0 R" });
    var u2 = e3.filter !== void 0 ? ["/" + e3.filter] : void 0;
    if (n3({ data: e3.data, additionalKeyValues: a3, alreadyAppliedFilters: u2, objectId: e3.objectId }), r3("endobj"), "sMask" in e3 && e3.sMask !== void 0) {
      var h3 = "/Predictor " + e3.predictor + " /Colors 1 /BitsPerComponent " + e3.bitsPerComponent + " /Columns " + e3.width, l3 = { width: e3.width, height: e3.height, colorSpace: "DeviceGray", bitsPerComponent: e3.bitsPerComponent, decodeParameters: h3, data: e3.sMask };
      "filter" in e3 && (l3.filter = e3.filter), t3.call(this, l3);
    }
    if (e3.colorSpace === b2.INDEXED) {
      var f3 = this.internal.newObject();
      n3({ data: _2(new Uint8Array(e3.palette)), objectId: f3 }), r3("endobj");
    }
  }, o2 = function() {
    var t3 = this.internal.collections.addImage_images;
    for (var e3 in t3)
      a2.call(this, t3[e3]);
  }, s2 = function() {
    var t3, e3 = this.internal.collections.addImage_images, r3 = this.internal.write;
    for (var n3 in e3)
      r3("/I" + (t3 = e3[n3]).index, t3.objectId, "0", "R");
  }, c2 = function() {
    this.internal.collections.addImage_images || (this.internal.collections.addImage_images = {}, this.internal.events.subscribe("putResources", o2), this.internal.events.subscribe("putXobjectDict", s2));
  }, h2 = function() {
    var t3 = this.internal.collections.addImage_images;
    return c2.call(this), t3;
  }, l2 = function() {
    return Object.keys(this.internal.collections.addImage_images).length;
  }, f2 = function(t3) {
    return typeof e2["process" + t3.toUpperCase()] == "function";
  }, d2 = function(e3) {
    return _typeof$2(e3) === "object" && e3.nodeType === 1;
  }, p5 = function(t3, r3) {
    if (t3.nodeName === "IMG" && t3.hasAttribute("src")) {
      var n3 = "" + t3.getAttribute("src");
      if (n3.indexOf("data:image/") === 0)
        return u$2(unescape(n3).split("base64,").pop());
      var i3 = e2.loadFile(n3, true);
      if (i3 !== void 0)
        return i3;
    }
    if (t3.nodeName === "CANVAS") {
      if (t3.width === 0 || t3.height === 0)
        throw new Error("Given canvas must have data. Canvas width: " + t3.width + ", height: " + t3.height);
      var a3;
      switch (r3) {
        case "PNG":
          a3 = "image/png";
          break;
        case "WEBP":
          a3 = "image/webp";
          break;
        case "JPEG":
        case "JPG":
        default:
          a3 = "image/jpeg";
      }
      return u$2(t3.toDataURL(a3, 1).split("base64,").pop());
    }
  }, g2 = function(t3) {
    var e3 = this.internal.collections.addImage_images;
    if (e3) {
      for (var r3 in e3)
        if (t3 === e3[r3].alias)
          return e3[r3];
    }
  }, m2 = function(t3, e3, r3) {
    return t3 || e3 || (t3 = -96, e3 = -96), t3 < 0 && (t3 = -1 * r3.width * 72 / t3 / this.internal.scaleFactor), e3 < 0 && (e3 = -1 * r3.height * 72 / e3 / this.internal.scaleFactor), t3 === 0 && (t3 = e3 * r3.width / r3.height), e3 === 0 && (e3 = t3 * r3.height / r3.width), [t3, e3];
  }, v2 = function(t3, e3, r3, n3, i3, a3) {
    var o3 = m2.call(this, r3, n3, i3), s3 = this.internal.getCoordinateString, c3 = this.internal.getVerticalCoordinateString, u2 = h2.call(this);
    if (r3 = o3[0], n3 = o3[1], u2[i3.index] = i3, a3) {
      a3 *= Math.PI / 180;
      var l3 = Math.cos(a3), f3 = Math.sin(a3), d3 = function(t4) {
        return t4.toFixed(4);
      }, p6 = [d3(l3), d3(f3), d3(-1 * f3), d3(l3), 0, 0, "cm"];
    }
    this.internal.write("q"), a3 ? (this.internal.write([1, "0", "0", 1, s3(t3), c3(e3 + n3), "cm"].join(" ")), this.internal.write(p6.join(" ")), this.internal.write([s3(r3), "0", "0", s3(n3), "0", "0", "cm"].join(" "))) : this.internal.write([s3(r3), "0", "0", s3(n3), s3(t3), c3(e3 + n3), "cm"].join(" ")), this.isAdvancedAPI() && this.internal.write([1, 0, 0, -1, 0, 0, "cm"].join(" ")), this.internal.write("/I" + i3.index + " Do"), this.internal.write("Q");
  }, b2 = e2.color_spaces = { DEVICE_RGB: "DeviceRGB", DEVICE_GRAY: "DeviceGray", DEVICE_CMYK: "DeviceCMYK", CAL_GREY: "CalGray", CAL_RGB: "CalRGB", LAB: "Lab", ICC_BASED: "ICCBased", INDEXED: "Indexed", PATTERN: "Pattern", SEPARATION: "Separation", DEVICE_N: "DeviceN" };
  e2.decode = { DCT_DECODE: "DCTDecode", FLATE_DECODE: "FlateDecode", LZW_DECODE: "LZWDecode", JPX_DECODE: "JPXDecode", JBIG2_DECODE: "JBIG2Decode", ASCII85_DECODE: "ASCII85Decode", ASCII_HEX_DECODE: "ASCIIHexDecode", RUN_LENGTH_DECODE: "RunLengthDecode", CCITT_FAX_DECODE: "CCITTFaxDecode" };
  var y2 = e2.image_compression = { NONE: "NONE", FAST: "FAST", MEDIUM: "MEDIUM", SLOW: "SLOW" }, w2 = e2.__addimage__.sHashCode = function(t3) {
    var e3, r3, n3 = 0;
    if (typeof t3 == "string")
      for (r3 = t3.length, e3 = 0; e3 < r3; e3++)
        n3 = (n3 << 5) - n3 + t3.charCodeAt(e3), n3 |= 0;
    else if (x2(t3))
      for (r3 = t3.byteLength / 2, e3 = 0; e3 < r3; e3++)
        n3 = (n3 << 5) - n3 + t3[e3], n3 |= 0;
    return n3;
  }, N2 = e2.__addimage__.validateStringAsBase64 = function(t3) {
    (t3 = t3 || "").toString().trim();
    var e3 = true;
    return t3.length === 0 && (e3 = false), t3.length % 4 != 0 && (e3 = false), /^[A-Za-z0-9+/]+$/.test(t3.substr(0, t3.length - 2)) === false && (e3 = false), /^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(t3.substr(-2)) === false && (e3 = false), e3;
  }, L2 = e2.__addimage__.extractImageFromDataUrl = function(t3) {
    var e3 = (t3 = t3 || "").split("base64,"), r3 = null;
    if (e3.length === 2) {
      var n3 = /^data:(\w*\/\w*);*(charset=(?!charset=)[\w=-]*)*;*$/.exec(e3[0]);
      Array.isArray(n3) && (r3 = { mimeType: n3[1], charset: n3[2], data: e3[1] });
    }
    return r3;
  }, A2 = e2.__addimage__.supportsArrayBuffer = function() {
    return typeof ArrayBuffer != "undefined" && typeof Uint8Array != "undefined";
  };
  e2.__addimage__.isArrayBuffer = function(t3) {
    return A2() && t3 instanceof ArrayBuffer;
  };
  var x2 = e2.__addimage__.isArrayBufferView = function(t3) {
    return A2() && typeof Uint32Array != "undefined" && (t3 instanceof Int8Array || t3 instanceof Uint8Array || typeof Uint8ClampedArray != "undefined" && t3 instanceof Uint8ClampedArray || t3 instanceof Int16Array || t3 instanceof Uint16Array || t3 instanceof Int32Array || t3 instanceof Uint32Array || t3 instanceof Float32Array || t3 instanceof Float64Array);
  }, S2 = e2.__addimage__.binaryStringToUint8Array = function(t3) {
    for (var e3 = t3.length, r3 = new Uint8Array(e3), n3 = 0; n3 < e3; n3++)
      r3[n3] = t3.charCodeAt(n3);
    return r3;
  }, _2 = e2.__addimage__.arrayBufferToBinaryString = function(t3) {
    for (var e3 = "", r3 = x2(t3) ? t3 : new Uint8Array(t3), n3 = 0; n3 < r3.length; n3 += 8192)
      e3 += String.fromCharCode.apply(null, r3.subarray(n3, n3 + 8192));
    return e3;
  };
  e2.addImage = function() {
    var e3, n3, i3, a3, o3, s3, u2, h3, l3;
    if (typeof arguments[1] == "number" ? (n3 = r2, i3 = arguments[1], a3 = arguments[2], o3 = arguments[3], s3 = arguments[4], u2 = arguments[5], h3 = arguments[6], l3 = arguments[7]) : (n3 = arguments[1], i3 = arguments[2], a3 = arguments[3], o3 = arguments[4], s3 = arguments[5], u2 = arguments[6], h3 = arguments[7], l3 = arguments[8]), _typeof$2(e3 = arguments[0]) === "object" && !d2(e3) && "imageData" in e3) {
      var f3 = e3;
      e3 = f3.imageData, n3 = f3.format || n3 || r2, i3 = f3.x || i3 || 0, a3 = f3.y || a3 || 0, o3 = f3.w || f3.width || o3, s3 = f3.h || f3.height || s3, u2 = f3.alias || u2, h3 = f3.compression || h3, l3 = f3.rotation || f3.angle || l3;
    }
    var p6 = this.internal.getFilters();
    if (h3 === void 0 && p6.indexOf("FlateEncode") !== -1 && (h3 = "SLOW"), isNaN(i3) || isNaN(a3))
      throw new Error("Invalid coordinates passed to jsPDF.addImage");
    c2.call(this);
    var g3 = P2.call(this, e3, n3, u2, h3);
    return v2.call(this, i3, a3, o3, s3, g3, l3), this;
  };
  var P2 = function(t3, n3, a3, o3) {
    var s3, c3, u2;
    if (typeof t3 == "string" && i2(t3) === r2) {
      t3 = unescape(t3);
      var h3 = k2(t3, false);
      (h3 !== "" || (h3 = e2.loadFile(t3, true)) !== void 0) && (t3 = h3);
    }
    if (d2(t3) && (t3 = p5(t3, n3)), n3 = i2(t3, n3), !f2(n3))
      throw new Error("addImage does not support files of type '" + n3 + "', please ensure that a plugin for '" + n3 + "' support is added.");
    if (((u2 = a3) == null || u2.length === 0) && (a3 = function(t4) {
      return typeof t4 == "string" || x2(t4) ? w2(t4) : x2(t4.data) ? w2(t4.data) : null;
    }(t3)), (s3 = g2.call(this, a3)) || (A2() && (t3 instanceof Uint8Array || n3 === "RGBA" || (c3 = t3, t3 = S2(t3))), s3 = this["process" + n3.toUpperCase()](t3, l2.call(this), a3, function(t4) {
      return t4 && typeof t4 == "string" && (t4 = t4.toUpperCase()), t4 in e2.image_compression ? t4 : y2.NONE;
    }(o3), c3)), !s3)
      throw new Error("An unknown error occurred whilst processing the image.");
    return s3;
  }, k2 = e2.__addimage__.convertBase64ToBinaryString = function(t3, e3) {
    var r3;
    e3 = typeof e3 != "boolean" || e3;
    var n3, i3 = "";
    if (typeof t3 == "string") {
      n3 = (r3 = L2(t3)) !== null ? r3.data : t3;
      try {
        i3 = u$2(n3);
      } catch (t4) {
        if (e3)
          throw N2(n3) ? new Error("atob-Error in jsPDF.convertBase64ToBinaryString " + t4.message) : new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ");
      }
    }
    return i3;
  };
  e2.getImageProperties = function(t3) {
    var n3, a3, o3 = "";
    if (d2(t3) && (t3 = p5(t3)), typeof t3 == "string" && i2(t3) === r2 && ((o3 = k2(t3, false)) === "" && (o3 = e2.loadFile(t3) || ""), t3 = o3), a3 = i2(t3), !f2(a3))
      throw new Error("addImage does not support files of type '" + a3 + "', please ensure that a plugin for '" + a3 + "' support is added.");
    if (!A2() || t3 instanceof Uint8Array || (t3 = S2(t3)), !(n3 = this["process" + a3.toUpperCase()](t3)))
      throw new Error("An unknown error occurred whilst processing the image");
    return n3.fileType = a3, n3;
  };
}(E$1.API), function(t3) {
  var e2 = function(t4) {
    if (t4 !== void 0 && t4 != "")
      return true;
  };
  E$1.API.events.push(["addPage", function(t4) {
    this.internal.getPageInfo(t4.pageNumber).pageContext.annotations = [];
  }]), t3.events.push(["putPage", function(t4) {
    for (var r2, n2, i2, a2 = this.internal.getCoordinateString, o2 = this.internal.getVerticalCoordinateString, s2 = this.internal.getPageInfoByObjId(t4.objId), c2 = t4.pageContext.annotations, u2 = false, h2 = 0; h2 < c2.length && !u2; h2++)
      switch ((r2 = c2[h2]).type) {
        case "link":
          (e2(r2.options.url) || e2(r2.options.pageNumber)) && (u2 = true);
          break;
        case "reference":
        case "text":
        case "freetext":
          u2 = true;
      }
    if (u2 != 0) {
      this.internal.write("/Annots [");
      for (var l2 = 0; l2 < c2.length; l2++) {
        r2 = c2[l2];
        var f2 = this.internal.pdfEscape, d2 = this.internal.getEncryptor(t4.objId);
        switch (r2.type) {
          case "reference":
            this.internal.write(" " + r2.object.objId + " 0 R ");
            break;
          case "text":
            var p5 = this.internal.newAdditionalObject(), g2 = this.internal.newAdditionalObject(), m2 = this.internal.getEncryptor(p5.objId), v2 = r2.title || "Note";
            i2 = "<</Type /Annot /Subtype /Text " + (n2 = "/Rect [" + a2(r2.bounds.x) + " " + o2(r2.bounds.y + r2.bounds.h) + " " + a2(r2.bounds.x + r2.bounds.w) + " " + o2(r2.bounds.y) + "] ") + "/Contents (" + f2(m2(r2.contents)) + ")", i2 += " /Popup " + g2.objId + " 0 R", i2 += " /P " + s2.objId + " 0 R", i2 += " /T (" + f2(m2(v2)) + ") >>", p5.content = i2;
            var b2 = p5.objId + " 0 R";
            i2 = "<</Type /Annot /Subtype /Popup " + (n2 = "/Rect [" + a2(r2.bounds.x + 30) + " " + o2(r2.bounds.y + r2.bounds.h) + " " + a2(r2.bounds.x + r2.bounds.w + 30) + " " + o2(r2.bounds.y) + "] ") + " /Parent " + b2, r2.open && (i2 += " /Open true"), i2 += " >>", g2.content = i2, this.internal.write(p5.objId, "0 R", g2.objId, "0 R");
            break;
          case "freetext":
            n2 = "/Rect [" + a2(r2.bounds.x) + " " + o2(r2.bounds.y) + " " + a2(r2.bounds.x + r2.bounds.w) + " " + o2(r2.bounds.y + r2.bounds.h) + "] ";
            var y2 = r2.color || "#000000";
            i2 = "<</Type /Annot /Subtype /FreeText " + n2 + "/Contents (" + f2(d2(r2.contents)) + ")", i2 += " /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#" + y2 + ")", i2 += " /Border [0 0 0]", i2 += " >>", this.internal.write(i2);
            break;
          case "link":
            if (r2.options.name) {
              var w2 = this.annotations._nameMap[r2.options.name];
              r2.options.pageNumber = w2.page, r2.options.top = w2.y;
            } else
              r2.options.top || (r2.options.top = 0);
            if (n2 = "/Rect [" + r2.finalBounds.x + " " + r2.finalBounds.y + " " + r2.finalBounds.w + " " + r2.finalBounds.h + "] ", i2 = "", r2.options.url)
              i2 = "<</Type /Annot /Subtype /Link " + n2 + "/Border [0 0 0] /A <</S /URI /URI (" + f2(d2(r2.options.url)) + ") >>";
            else if (r2.options.pageNumber) {
              switch (i2 = "<</Type /Annot /Subtype /Link " + n2 + "/Border [0 0 0] /Dest [" + this.internal.getPageInfo(r2.options.pageNumber).objId + " 0 R", r2.options.magFactor = r2.options.magFactor || "XYZ", r2.options.magFactor) {
                case "Fit":
                  i2 += " /Fit]";
                  break;
                case "FitH":
                  i2 += " /FitH " + r2.options.top + "]";
                  break;
                case "FitV":
                  r2.options.left = r2.options.left || 0, i2 += " /FitV " + r2.options.left + "]";
                  break;
                case "XYZ":
                default:
                  var N2 = o2(r2.options.top);
                  r2.options.left = r2.options.left || 0, r2.options.zoom === void 0 && (r2.options.zoom = 0), i2 += " /XYZ " + r2.options.left + " " + N2 + " " + r2.options.zoom + "]";
              }
            }
            i2 != "" && (i2 += " >>", this.internal.write(i2));
        }
      }
      this.internal.write("]");
    }
  }]), t3.createAnnotation = function(t4) {
    var e3 = this.internal.getCurrentPageInfo();
    switch (t4.type) {
      case "link":
        this.link(t4.bounds.x, t4.bounds.y, t4.bounds.w, t4.bounds.h, t4);
        break;
      case "text":
      case "freetext":
        e3.pageContext.annotations.push(t4);
    }
  }, t3.link = function(t4, e3, r2, n2, i2) {
    var a2 = this.internal.getCurrentPageInfo(), o2 = this.internal.getCoordinateString, s2 = this.internal.getVerticalCoordinateString;
    a2.pageContext.annotations.push({ finalBounds: { x: o2(t4), y: s2(e3), w: o2(t4 + r2), h: s2(e3 + n2) }, options: i2, type: "link" });
  }, t3.textWithLink = function(t4, e3, r2, n2) {
    var i2, a2, o2 = this.getTextWidth(t4), s2 = this.internal.getLineHeight() / this.internal.scaleFactor;
    if (n2.maxWidth !== void 0) {
      a2 = n2.maxWidth;
      var c2 = this.splitTextToSize(t4, a2).length;
      i2 = Math.ceil(s2 * c2);
    } else
      a2 = o2, i2 = s2;
    return this.text(t4, e3, r2, n2), r2 += 0.2 * s2, n2.align === "center" && (e3 -= o2 / 2), n2.align === "right" && (e3 -= o2), this.link(e3, r2 - s2, a2, i2, n2), o2;
  }, t3.getTextWidth = function(t4) {
    var e3 = this.internal.getFontSize();
    return this.getStringUnitWidth(t4) * e3 / this.internal.scaleFactor;
  };
}(E$1.API), function(t3) {
  var e2 = { 1569: [65152], 1570: [65153, 65154], 1571: [65155, 65156], 1572: [65157, 65158], 1573: [65159, 65160], 1574: [65161, 65162, 65163, 65164], 1575: [65165, 65166], 1576: [65167, 65168, 65169, 65170], 1577: [65171, 65172], 1578: [65173, 65174, 65175, 65176], 1579: [65177, 65178, 65179, 65180], 1580: [65181, 65182, 65183, 65184], 1581: [65185, 65186, 65187, 65188], 1582: [65189, 65190, 65191, 65192], 1583: [65193, 65194], 1584: [65195, 65196], 1585: [65197, 65198], 1586: [65199, 65200], 1587: [65201, 65202, 65203, 65204], 1588: [65205, 65206, 65207, 65208], 1589: [65209, 65210, 65211, 65212], 1590: [65213, 65214, 65215, 65216], 1591: [65217, 65218, 65219, 65220], 1592: [65221, 65222, 65223, 65224], 1593: [65225, 65226, 65227, 65228], 1594: [65229, 65230, 65231, 65232], 1601: [65233, 65234, 65235, 65236], 1602: [65237, 65238, 65239, 65240], 1603: [65241, 65242, 65243, 65244], 1604: [65245, 65246, 65247, 65248], 1605: [65249, 65250, 65251, 65252], 1606: [65253, 65254, 65255, 65256], 1607: [65257, 65258, 65259, 65260], 1608: [65261, 65262], 1609: [65263, 65264, 64488, 64489], 1610: [65265, 65266, 65267, 65268], 1649: [64336, 64337], 1655: [64477], 1657: [64358, 64359, 64360, 64361], 1658: [64350, 64351, 64352, 64353], 1659: [64338, 64339, 64340, 64341], 1662: [64342, 64343, 64344, 64345], 1663: [64354, 64355, 64356, 64357], 1664: [64346, 64347, 64348, 64349], 1667: [64374, 64375, 64376, 64377], 1668: [64370, 64371, 64372, 64373], 1670: [64378, 64379, 64380, 64381], 1671: [64382, 64383, 64384, 64385], 1672: [64392, 64393], 1676: [64388, 64389], 1677: [64386, 64387], 1678: [64390, 64391], 1681: [64396, 64397], 1688: [64394, 64395], 1700: [64362, 64363, 64364, 64365], 1702: [64366, 64367, 64368, 64369], 1705: [64398, 64399, 64400, 64401], 1709: [64467, 64468, 64469, 64470], 1711: [64402, 64403, 64404, 64405], 1713: [64410, 64411, 64412, 64413], 1715: [64406, 64407, 64408, 64409], 1722: [64414, 64415], 1723: [64416, 64417, 64418, 64419], 1726: [64426, 64427, 64428, 64429], 1728: [64420, 64421], 1729: [64422, 64423, 64424, 64425], 1733: [64480, 64481], 1734: [64473, 64474], 1735: [64471, 64472], 1736: [64475, 64476], 1737: [64482, 64483], 1739: [64478, 64479], 1740: [64508, 64509, 64510, 64511], 1744: [64484, 64485, 64486, 64487], 1746: [64430, 64431], 1747: [64432, 64433] }, r2 = { 65247: { 65154: 65269, 65156: 65271, 65160: 65273, 65166: 65275 }, 65248: { 65154: 65270, 65156: 65272, 65160: 65274, 65166: 65276 }, 65165: { 65247: { 65248: { 65258: 65010 } } }, 1617: { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 } }, n2 = { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 }, i2 = [1570, 1571, 1573, 1575];
  t3.__arabicParser__ = {};
  var a2 = t3.__arabicParser__.isInArabicSubstitutionA = function(t4) {
    return e2[t4.charCodeAt(0)] !== void 0;
  }, o2 = t3.__arabicParser__.isArabicLetter = function(t4) {
    return typeof t4 == "string" && /^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(t4);
  }, s2 = t3.__arabicParser__.isArabicEndLetter = function(t4) {
    return o2(t4) && a2(t4) && e2[t4.charCodeAt(0)].length <= 2;
  }, c2 = t3.__arabicParser__.isArabicAlfLetter = function(t4) {
    return o2(t4) && i2.indexOf(t4.charCodeAt(0)) >= 0;
  };
  t3.__arabicParser__.arabicLetterHasIsolatedForm = function(t4) {
    return o2(t4) && a2(t4) && e2[t4.charCodeAt(0)].length >= 1;
  };
  var u2 = t3.__arabicParser__.arabicLetterHasFinalForm = function(t4) {
    return o2(t4) && a2(t4) && e2[t4.charCodeAt(0)].length >= 2;
  };
  t3.__arabicParser__.arabicLetterHasInitialForm = function(t4) {
    return o2(t4) && a2(t4) && e2[t4.charCodeAt(0)].length >= 3;
  };
  var h2 = t3.__arabicParser__.arabicLetterHasMedialForm = function(t4) {
    return o2(t4) && a2(t4) && e2[t4.charCodeAt(0)].length == 4;
  }, l2 = t3.__arabicParser__.resolveLigatures = function(t4) {
    var e3 = 0, n3 = r2, i3 = "", a3 = 0;
    for (e3 = 0; e3 < t4.length; e3 += 1)
      n3[t4.charCodeAt(e3)] !== void 0 ? (a3++, typeof (n3 = n3[t4.charCodeAt(e3)]) == "number" && (i3 += String.fromCharCode(n3), n3 = r2, a3 = 0), e3 === t4.length - 1 && (n3 = r2, i3 += t4.charAt(e3 - (a3 - 1)), e3 -= a3 - 1, a3 = 0)) : (n3 = r2, i3 += t4.charAt(e3 - a3), e3 -= a3, a3 = 0);
    return i3;
  };
  t3.__arabicParser__.isArabicDiacritic = function(t4) {
    return t4 !== void 0 && n2[t4.charCodeAt(0)] !== void 0;
  };
  var f2 = t3.__arabicParser__.getCorrectForm = function(t4, e3, r3) {
    return o2(t4) ? a2(t4) === false ? -1 : !u2(t4) || !o2(e3) && !o2(r3) || !o2(r3) && s2(e3) || s2(t4) && !o2(e3) || s2(t4) && c2(e3) || s2(t4) && s2(e3) ? 0 : h2(t4) && o2(e3) && !s2(e3) && o2(r3) && u2(r3) ? 3 : s2(t4) || !o2(r3) ? 1 : 2 : -1;
  }, d2 = function(t4) {
    var r3 = 0, n3 = 0, i3 = 0, a3 = "", s3 = "", c3 = "", u3 = (t4 = t4 || "").split("\\s+"), h3 = [];
    for (r3 = 0; r3 < u3.length; r3 += 1) {
      for (h3.push(""), n3 = 0; n3 < u3[r3].length; n3 += 1)
        a3 = u3[r3][n3], s3 = u3[r3][n3 - 1], c3 = u3[r3][n3 + 1], o2(a3) ? (i3 = f2(a3, s3, c3), h3[r3] += i3 !== -1 ? String.fromCharCode(e2[a3.charCodeAt(0)][i3]) : a3) : h3[r3] += a3;
      h3[r3] = l2(h3[r3]);
    }
    return h3.join(" ");
  }, p5 = t3.__arabicParser__.processArabic = t3.processArabic = function() {
    var t4, e3 = typeof arguments[0] == "string" ? arguments[0] : arguments[0].text, r3 = [];
    if (Array.isArray(e3)) {
      var n3 = 0;
      for (r3 = [], n3 = 0; n3 < e3.length; n3 += 1)
        Array.isArray(e3[n3]) ? r3.push([d2(e3[n3][0]), e3[n3][1], e3[n3][2]]) : r3.push([d2(e3[n3])]);
      t4 = r3;
    } else
      t4 = d2(e3);
    return typeof arguments[0] == "string" ? t4 : (arguments[0].text = t4, arguments[0]);
  };
  t3.events.push(["preProcessText", p5]);
}(E$1.API), E$1.API.autoPrint = function(t3) {
  var e2;
  switch ((t3 = t3 || {}).variant = t3.variant || "non-conform", t3.variant) {
    case "javascript":
      this.addJS("print({});");
      break;
    case "non-conform":
    default:
      this.internal.events.subscribe("postPutResources", function() {
        e2 = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /Named"), this.internal.out("/Type /Action"), this.internal.out("/N /Print"), this.internal.out(">>"), this.internal.out("endobj");
      }), this.internal.events.subscribe("putCatalog", function() {
        this.internal.out("/OpenAction " + e2 + " 0 R");
      });
  }
  return this;
}, function(t3) {
  var e2 = function() {
    var t4 = void 0;
    Object.defineProperty(this, "pdf", { get: function() {
      return t4;
    }, set: function(e4) {
      t4 = e4;
    } });
    var e3 = 150;
    Object.defineProperty(this, "width", { get: function() {
      return e3;
    }, set: function(t5) {
      e3 = isNaN(t5) || Number.isInteger(t5) === false || t5 < 0 ? 150 : t5, this.getContext("2d").pageWrapXEnabled && (this.getContext("2d").pageWrapX = e3 + 1);
    } });
    var r2 = 300;
    Object.defineProperty(this, "height", { get: function() {
      return r2;
    }, set: function(t5) {
      r2 = isNaN(t5) || Number.isInteger(t5) === false || t5 < 0 ? 300 : t5, this.getContext("2d").pageWrapYEnabled && (this.getContext("2d").pageWrapY = r2 + 1);
    } });
    var n2 = [];
    Object.defineProperty(this, "childNodes", { get: function() {
      return n2;
    }, set: function(t5) {
      n2 = t5;
    } });
    var i2 = {};
    Object.defineProperty(this, "style", { get: function() {
      return i2;
    }, set: function(t5) {
      i2 = t5;
    } }), Object.defineProperty(this, "parentNode", {});
  };
  e2.prototype.getContext = function(t4, e3) {
    var r2;
    if ((t4 = t4 || "2d") !== "2d")
      return null;
    for (r2 in e3)
      this.pdf.context2d.hasOwnProperty(r2) && (this.pdf.context2d[r2] = e3[r2]);
    return this.pdf.context2d._canvas = this, this.pdf.context2d;
  }, e2.prototype.toDataURL = function() {
    throw new Error("toDataURL is not implemented.");
  }, t3.events.push(["initialized", function() {
    this.canvas = new e2(), this.canvas.pdf = this;
  }]);
}(E$1.API), function(e2) {
  var r2 = { left: 0, top: 0, bottom: 0, right: 0 }, n2 = false, i2 = function() {
    this.internal.__cell__ === void 0 && (this.internal.__cell__ = {}, this.internal.__cell__.padding = 3, this.internal.__cell__.headerFunction = void 0, this.internal.__cell__.margins = Object.assign({}, r2), this.internal.__cell__.margins.width = this.getPageWidth(), a2.call(this));
  }, a2 = function() {
    this.internal.__cell__.lastCell = new o2(), this.internal.__cell__.pages = 1;
  }, o2 = function() {
    var t3 = arguments[0];
    Object.defineProperty(this, "x", { enumerable: true, get: function() {
      return t3;
    }, set: function(e4) {
      t3 = e4;
    } });
    var e3 = arguments[1];
    Object.defineProperty(this, "y", { enumerable: true, get: function() {
      return e3;
    }, set: function(t4) {
      e3 = t4;
    } });
    var r3 = arguments[2];
    Object.defineProperty(this, "width", { enumerable: true, get: function() {
      return r3;
    }, set: function(t4) {
      r3 = t4;
    } });
    var n3 = arguments[3];
    Object.defineProperty(this, "height", { enumerable: true, get: function() {
      return n3;
    }, set: function(t4) {
      n3 = t4;
    } });
    var i3 = arguments[4];
    Object.defineProperty(this, "text", { enumerable: true, get: function() {
      return i3;
    }, set: function(t4) {
      i3 = t4;
    } });
    var a3 = arguments[5];
    Object.defineProperty(this, "lineNumber", { enumerable: true, get: function() {
      return a3;
    }, set: function(t4) {
      a3 = t4;
    } });
    var o3 = arguments[6];
    return Object.defineProperty(this, "align", { enumerable: true, get: function() {
      return o3;
    }, set: function(t4) {
      o3 = t4;
    } }), this;
  };
  o2.prototype.clone = function() {
    return new o2(this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align);
  }, o2.prototype.toArray = function() {
    return [this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align];
  }, e2.setHeaderFunction = function(t3) {
    return i2.call(this), this.internal.__cell__.headerFunction = typeof t3 == "function" ? t3 : void 0, this;
  }, e2.getTextDimensions = function(t3, e3) {
    i2.call(this);
    var r3 = (e3 = e3 || {}).fontSize || this.getFontSize(), n3 = e3.font || this.getFont(), a3 = e3.scaleFactor || this.internal.scaleFactor, o3 = 0, s3 = 0, c3 = 0, u2 = this;
    if (!Array.isArray(t3) && typeof t3 != "string") {
      if (typeof t3 != "number")
        throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.");
      t3 = String(t3);
    }
    var h2 = e3.maxWidth;
    h2 > 0 ? typeof t3 == "string" ? t3 = this.splitTextToSize(t3, h2) : Object.prototype.toString.call(t3) === "[object Array]" && (t3 = t3.reduce(function(t4, e4) {
      return t4.concat(u2.splitTextToSize(e4, h2));
    }, [])) : t3 = Array.isArray(t3) ? t3 : [t3];
    for (var l2 = 0; l2 < t3.length; l2++)
      o3 < (c3 = this.getStringUnitWidth(t3[l2], { font: n3 }) * r3) && (o3 = c3);
    return o3 !== 0 && (s3 = t3.length), { w: o3 /= a3, h: Math.max((s3 * r3 * this.getLineHeightFactor() - r3 * (this.getLineHeightFactor() - 1)) / a3, 0) };
  }, e2.cellAddPage = function() {
    i2.call(this), this.addPage();
    var t3 = this.internal.__cell__.margins || r2;
    return this.internal.__cell__.lastCell = new o2(t3.left, t3.top, void 0, void 0), this.internal.__cell__.pages += 1, this;
  };
  var s2 = e2.cell = function() {
    var t3;
    t3 = arguments[0] instanceof o2 ? arguments[0] : new o2(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]), i2.call(this);
    var e3 = this.internal.__cell__.lastCell, a3 = this.internal.__cell__.padding, s3 = this.internal.__cell__.margins || r2, c3 = this.internal.__cell__.tableHeaderRow, u2 = this.internal.__cell__.printHeaders;
    return e3.lineNumber !== void 0 && (e3.lineNumber === t3.lineNumber ? (t3.x = (e3.x || 0) + (e3.width || 0), t3.y = e3.y || 0) : e3.y + e3.height + t3.height + s3.bottom > this.getPageHeight() ? (this.cellAddPage(), t3.y = s3.top, u2 && c3 && (this.printHeaderRow(t3.lineNumber, true), t3.y += c3[0].height)) : t3.y = e3.y + e3.height || t3.y), t3.text[0] !== void 0 && (this.rect(t3.x, t3.y, t3.width, t3.height, n2 === true ? "FD" : void 0), t3.align === "right" ? this.text(t3.text, t3.x + t3.width - a3, t3.y + a3, { align: "right", baseline: "top" }) : t3.align === "center" ? this.text(t3.text, t3.x + t3.width / 2, t3.y + a3, { align: "center", baseline: "top", maxWidth: t3.width - a3 - a3 }) : this.text(t3.text, t3.x + a3, t3.y + a3, { align: "left", baseline: "top", maxWidth: t3.width - a3 - a3 })), this.internal.__cell__.lastCell = t3, this;
  };
  e2.table = function(e3, n3, u2, h2, l2) {
    if (i2.call(this), !u2)
      throw new Error("No data for PDF table.");
    var f2, d2, p5, g2, m2 = [], v2 = [], b2 = [], y2 = {}, w2 = {}, N2 = [], L2 = [], A2 = (l2 = l2 || {}).autoSize || false, x2 = l2.printHeaders !== false, S2 = l2.css && l2.css["font-size"] !== void 0 ? 16 * l2.css["font-size"] : l2.fontSize || 12, _2 = l2.margins || Object.assign({ width: this.getPageWidth() }, r2), P2 = typeof l2.padding == "number" ? l2.padding : 3, k2 = l2.headerBackgroundColor || "#c8c8c8", I2 = l2.headerTextColor || "#000";
    if (a2.call(this), this.internal.__cell__.printHeaders = x2, this.internal.__cell__.margins = _2, this.internal.__cell__.table_font_size = S2, this.internal.__cell__.padding = P2, this.internal.__cell__.headerBackgroundColor = k2, this.internal.__cell__.headerTextColor = I2, this.setFontSize(S2), h2 == null)
      v2 = m2 = Object.keys(u2[0]), b2 = m2.map(function() {
        return "left";
      });
    else if (Array.isArray(h2) && _typeof$2(h2[0]) === "object")
      for (m2 = h2.map(function(t3) {
        return t3.name;
      }), v2 = h2.map(function(t3) {
        return t3.prompt || t3.name || "";
      }), b2 = h2.map(function(t3) {
        return t3.align || "left";
      }), f2 = 0; f2 < h2.length; f2 += 1)
        w2[h2[f2].name] = h2[f2].width * (19.049976 / 25.4);
    else
      Array.isArray(h2) && typeof h2[0] == "string" && (v2 = m2 = h2, b2 = m2.map(function() {
        return "left";
      }));
    if (A2 || Array.isArray(h2) && typeof h2[0] == "string")
      for (f2 = 0; f2 < m2.length; f2 += 1) {
        for (y2[g2 = m2[f2]] = u2.map(function(t3) {
          return t3[g2];
        }), this.setFont(void 0, "bold"), N2.push(this.getTextDimensions(v2[f2], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w), d2 = y2[g2], this.setFont(void 0, "normal"), p5 = 0; p5 < d2.length; p5 += 1)
          N2.push(this.getTextDimensions(d2[p5], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w);
        w2[g2] = Math.max.apply(null, N2) + P2 + P2, N2 = [];
      }
    if (x2) {
      var F2 = {};
      for (f2 = 0; f2 < m2.length; f2 += 1)
        F2[m2[f2]] = {}, F2[m2[f2]].text = v2[f2], F2[m2[f2]].align = b2[f2];
      var C2 = c2.call(this, F2, w2);
      L2 = m2.map(function(t3) {
        return new o2(e3, n3, w2[t3], C2, F2[t3].text, void 0, F2[t3].align);
      }), this.setTableHeaderRow(L2), this.printHeaderRow(1, false);
    }
    var j2 = h2.reduce(function(t3, e4) {
      return t3[e4.name] = e4.align, t3;
    }, {});
    for (f2 = 0; f2 < u2.length; f2 += 1) {
      "rowStart" in l2 && l2.rowStart instanceof Function && l2.rowStart({ row: f2, data: u2[f2] }, this);
      var O2 = c2.call(this, u2[f2], w2);
      for (p5 = 0; p5 < m2.length; p5 += 1) {
        var B3 = u2[f2][m2[p5]];
        "cellStart" in l2 && l2.cellStart instanceof Function && l2.cellStart({ row: f2, col: p5, data: B3 }, this), s2.call(this, new o2(e3, n3, w2[m2[p5]], O2, B3, f2 + 2, j2[m2[p5]]));
      }
    }
    return this.internal.__cell__.table_x = e3, this.internal.__cell__.table_y = n3, this;
  };
  var c2 = function(t3, e3) {
    var r3 = this.internal.__cell__.padding, n3 = this.internal.__cell__.table_font_size, i3 = this.internal.scaleFactor;
    return Object.keys(t3).map(function(n4) {
      var i4 = t3[n4];
      return this.splitTextToSize(i4.hasOwnProperty("text") ? i4.text : i4, e3[n4] - r3 - r3);
    }, this).map(function(t4) {
      return this.getLineHeightFactor() * t4.length * n3 / i3 + r3 + r3;
    }, this).reduce(function(t4, e4) {
      return Math.max(t4, e4);
    }, 0);
  };
  e2.setTableHeaderRow = function(t3) {
    i2.call(this), this.internal.__cell__.tableHeaderRow = t3;
  }, e2.printHeaderRow = function(t3, e3) {
    if (i2.call(this), !this.internal.__cell__.tableHeaderRow)
      throw new Error("Property tableHeaderRow does not exist.");
    var r3;
    if (n2 = true, typeof this.internal.__cell__.headerFunction == "function") {
      var a3 = this.internal.__cell__.headerFunction(this, this.internal.__cell__.pages);
      this.internal.__cell__.lastCell = new o2(a3[0], a3[1], a3[2], a3[3], void 0, -1);
    }
    this.setFont(void 0, "bold");
    for (var c3 = [], u2 = 0; u2 < this.internal.__cell__.tableHeaderRow.length; u2 += 1) {
      r3 = this.internal.__cell__.tableHeaderRow[u2].clone(), e3 && (r3.y = this.internal.__cell__.margins.top || 0, c3.push(r3)), r3.lineNumber = t3;
      var h2 = this.getTextColor();
      this.setTextColor(this.internal.__cell__.headerTextColor), this.setFillColor(this.internal.__cell__.headerBackgroundColor), s2.call(this, r3), this.setTextColor(h2);
    }
    c3.length > 0 && this.setTableHeaderRow(c3), this.setFont(void 0, "normal"), n2 = false;
  };
}(E$1.API);
var Pt = { italic: ["italic", "oblique", "normal"], oblique: ["oblique", "italic", "normal"], normal: ["normal", "oblique", "italic"] }, kt = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"], It = _t(kt), Ft = [100, 200, 300, 400, 500, 600, 700, 800, 900], Ct = _t(Ft);
function jt(t3) {
  var e2 = t3.family.replace(/"|'/g, "").toLowerCase(), r2 = function(t4) {
    return Pt[t4 = t4 || "normal"] ? t4 : "normal";
  }(t3.style), n2 = function(t4) {
    if (!t4)
      return 400;
    if (typeof t4 == "number")
      return t4 >= 100 && t4 <= 900 && t4 % 100 == 0 ? t4 : 400;
    if (/^\d00$/.test(t4))
      return parseInt(t4);
    switch (t4) {
      case "bold":
        return 700;
      case "normal":
      default:
        return 400;
    }
  }(t3.weight), i2 = function(t4) {
    return typeof It[t4 = t4 || "normal"] == "number" ? t4 : "normal";
  }(t3.stretch);
  return { family: e2, style: r2, weight: n2, stretch: i2, src: t3.src || [], ref: t3.ref || { name: e2, style: [i2, r2, n2].join(" ") } };
}
function Ot(t3, e2, r2, n2) {
  var i2;
  for (i2 = r2; i2 >= 0 && i2 < e2.length; i2 += n2)
    if (t3[e2[i2]])
      return t3[e2[i2]];
  for (i2 = r2; i2 >= 0 && i2 < e2.length; i2 -= n2)
    if (t3[e2[i2]])
      return t3[e2[i2]];
}
var Bt = { "sans-serif": "helvetica", fixed: "courier", monospace: "courier", terminal: "courier", cursive: "times", fantasy: "times", serif: "times" }, Mt = { caption: "times", icon: "times", menu: "times", "message-box": "times", "small-caption": "times", "status-bar": "times" };
function Et(t3) {
  return [t3.stretch, t3.style, t3.weight, t3.family].join(" ");
}
function qt(t3, e2, r2) {
  for (var n2 = (r2 = r2 || {}).defaultFontFamily || "times", i2 = Object.assign({}, Bt, r2.genericFontFamilies || {}), a2 = null, o2 = null, s2 = 0; s2 < e2.length; ++s2)
    if (i2[(a2 = jt(e2[s2])).family] && (a2.family = i2[a2.family]), t3.hasOwnProperty(a2.family)) {
      o2 = t3[a2.family];
      break;
    }
  if (!(o2 = o2 || t3[n2]))
    throw new Error("Could not find a font-family for the rule '" + Et(a2) + "' and default family '" + n2 + "'.");
  if (o2 = function(t4, e3) {
    if (e3[t4])
      return e3[t4];
    var r3 = It[t4], n3 = r3 <= It.normal ? -1 : 1, i3 = Ot(e3, kt, r3, n3);
    if (!i3)
      throw new Error("Could not find a matching font-stretch value for " + t4);
    return i3;
  }(a2.stretch, o2), o2 = function(t4, e3) {
    if (e3[t4])
      return e3[t4];
    for (var r3 = Pt[t4], n3 = 0; n3 < r3.length; ++n3)
      if (e3[r3[n3]])
        return e3[r3[n3]];
    throw new Error("Could not find a matching font-style for " + t4);
  }(a2.style, o2), !(o2 = function(t4, e3) {
    if (e3[t4])
      return e3[t4];
    if (t4 === 400 && e3[500])
      return e3[500];
    if (t4 === 500 && e3[400])
      return e3[400];
    var r3 = Ct[t4], n3 = Ot(e3, Ft, r3, t4 < 400 ? -1 : 1);
    if (!n3)
      throw new Error("Could not find a matching font-weight for value " + t4);
    return n3;
  }(a2.weight, o2)))
    throw new Error("Failed to resolve a font for the rule '" + Et(a2) + "'.");
  return o2;
}
function Dt(t3) {
  return t3.trimLeft();
}
function Rt(t3, e2) {
  for (var r2 = 0; r2 < t3.length; ) {
    if (t3.charAt(r2) === e2)
      return [t3.substring(0, r2), t3.substring(r2 + 1)];
    r2 += 1;
  }
  return null;
}
function Tt(t3) {
  var e2 = t3.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);
  return e2 === null ? null : [e2[0], t3.substring(e2[0].length)];
}
var zt, Ut, Ht, Wt = ["times"];
!function(e2) {
  var r2, n2, i2, o2, s2, c2, u2, h2, l2, d2 = function(t3) {
    return t3 = t3 || {}, this.isStrokeTransparent = t3.isStrokeTransparent || false, this.strokeOpacity = t3.strokeOpacity || 1, this.strokeStyle = t3.strokeStyle || "#000000", this.fillStyle = t3.fillStyle || "#000000", this.isFillTransparent = t3.isFillTransparent || false, this.fillOpacity = t3.fillOpacity || 1, this.font = t3.font || "10px sans-serif", this.textBaseline = t3.textBaseline || "alphabetic", this.textAlign = t3.textAlign || "left", this.lineWidth = t3.lineWidth || 1, this.lineJoin = t3.lineJoin || "miter", this.lineCap = t3.lineCap || "butt", this.path = t3.path || [], this.transform = t3.transform !== void 0 ? t3.transform.clone() : new h2(), this.globalCompositeOperation = t3.globalCompositeOperation || "normal", this.globalAlpha = t3.globalAlpha || 1, this.clip_path = t3.clip_path || [], this.currentPoint = t3.currentPoint || new c2(), this.miterLimit = t3.miterLimit || 10, this.lastPoint = t3.lastPoint || new c2(), this.lineDashOffset = t3.lineDashOffset || 0, this.lineDash = t3.lineDash || [], this.margin = t3.margin || [0, 0, 0, 0], this.prevPageLastElemOffset = t3.prevPageLastElemOffset || 0, this.ignoreClearRect = typeof t3.ignoreClearRect != "boolean" || t3.ignoreClearRect, this;
  };
  e2.events.push(["initialized", function() {
    this.context2d = new p5(this), r2 = this.internal.f2, n2 = this.internal.getCoordinateString, i2 = this.internal.getVerticalCoordinateString, o2 = this.internal.getHorizontalCoordinate, s2 = this.internal.getVerticalCoordinate, c2 = this.internal.Point, u2 = this.internal.Rectangle, h2 = this.internal.Matrix, l2 = new d2();
  }]);
  var p5 = function(t3) {
    Object.defineProperty(this, "canvas", { get: function() {
      return { parentNode: false, style: false };
    } });
    var e3 = t3;
    Object.defineProperty(this, "pdf", { get: function() {
      return e3;
    } });
    var r3 = false;
    Object.defineProperty(this, "pageWrapXEnabled", { get: function() {
      return r3;
    }, set: function(t4) {
      r3 = Boolean(t4);
    } });
    var n3 = false;
    Object.defineProperty(this, "pageWrapYEnabled", { get: function() {
      return n3;
    }, set: function(t4) {
      n3 = Boolean(t4);
    } });
    var i3 = 0;
    Object.defineProperty(this, "posX", { get: function() {
      return i3;
    }, set: function(t4) {
      isNaN(t4) || (i3 = t4);
    } });
    var a2 = 0;
    Object.defineProperty(this, "posY", { get: function() {
      return a2;
    }, set: function(t4) {
      isNaN(t4) || (a2 = t4);
    } }), Object.defineProperty(this, "margin", { get: function() {
      return l2.margin;
    }, set: function(t4) {
      var e4;
      typeof t4 == "number" ? e4 = [t4, t4, t4, t4] : ((e4 = new Array(4))[0] = t4[0], e4[1] = t4.length >= 2 ? t4[1] : e4[0], e4[2] = t4.length >= 3 ? t4[2] : e4[0], e4[3] = t4.length >= 4 ? t4[3] : e4[1]), l2.margin = e4;
    } });
    var o3 = false;
    Object.defineProperty(this, "autoPaging", { get: function() {
      return o3;
    }, set: function(t4) {
      o3 = t4;
    } });
    var s3 = 0;
    Object.defineProperty(this, "lastBreak", { get: function() {
      return s3;
    }, set: function(t4) {
      s3 = t4;
    } });
    var c3 = [];
    Object.defineProperty(this, "pageBreaks", { get: function() {
      return c3;
    }, set: function(t4) {
      c3 = t4;
    } }), Object.defineProperty(this, "ctx", { get: function() {
      return l2;
    }, set: function(t4) {
      t4 instanceof d2 && (l2 = t4);
    } }), Object.defineProperty(this, "path", { get: function() {
      return l2.path;
    }, set: function(t4) {
      l2.path = t4;
    } });
    var u3 = [];
    Object.defineProperty(this, "ctxStack", { get: function() {
      return u3;
    }, set: function(t4) {
      u3 = t4;
    } }), Object.defineProperty(this, "fillStyle", { get: function() {
      return this.ctx.fillStyle;
    }, set: function(t4) {
      var e4;
      e4 = g2(t4), this.ctx.fillStyle = e4.style, this.ctx.isFillTransparent = e4.a === 0, this.ctx.fillOpacity = e4.a, this.pdf.setFillColor(e4.r, e4.g, e4.b, { a: e4.a }), this.pdf.setTextColor(e4.r, e4.g, e4.b, { a: e4.a });
    } }), Object.defineProperty(this, "strokeStyle", { get: function() {
      return this.ctx.strokeStyle;
    }, set: function(t4) {
      var e4 = g2(t4);
      this.ctx.strokeStyle = e4.style, this.ctx.isStrokeTransparent = e4.a === 0, this.ctx.strokeOpacity = e4.a, e4.a === 0 ? this.pdf.setDrawColor(255, 255, 255) : (e4.a, this.pdf.setDrawColor(e4.r, e4.g, e4.b));
    } }), Object.defineProperty(this, "lineCap", { get: function() {
      return this.ctx.lineCap;
    }, set: function(t4) {
      ["butt", "round", "square"].indexOf(t4) !== -1 && (this.ctx.lineCap = t4, this.pdf.setLineCap(t4));
    } }), Object.defineProperty(this, "lineWidth", { get: function() {
      return this.ctx.lineWidth;
    }, set: function(t4) {
      isNaN(t4) || (this.ctx.lineWidth = t4, this.pdf.setLineWidth(t4));
    } }), Object.defineProperty(this, "lineJoin", { get: function() {
      return this.ctx.lineJoin;
    }, set: function(t4) {
      ["bevel", "round", "miter"].indexOf(t4) !== -1 && (this.ctx.lineJoin = t4, this.pdf.setLineJoin(t4));
    } }), Object.defineProperty(this, "miterLimit", { get: function() {
      return this.ctx.miterLimit;
    }, set: function(t4) {
      isNaN(t4) || (this.ctx.miterLimit = t4, this.pdf.setMiterLimit(t4));
    } }), Object.defineProperty(this, "textBaseline", { get: function() {
      return this.ctx.textBaseline;
    }, set: function(t4) {
      this.ctx.textBaseline = t4;
    } }), Object.defineProperty(this, "textAlign", { get: function() {
      return this.ctx.textAlign;
    }, set: function(t4) {
      ["right", "end", "center", "left", "start"].indexOf(t4) !== -1 && (this.ctx.textAlign = t4);
    } });
    var h3 = null;
    function f2(t4, e4) {
      if (h3 === null) {
        var r4 = function(t5) {
          var e5 = [];
          return Object.keys(t5).forEach(function(r5) {
            t5[r5].forEach(function(t6) {
              var n4 = null;
              switch (t6) {
                case "bold":
                  n4 = { family: r5, weight: "bold" };
                  break;
                case "italic":
                  n4 = { family: r5, style: "italic" };
                  break;
                case "bolditalic":
                  n4 = { family: r5, weight: "bold", style: "italic" };
                  break;
                case "":
                case "normal":
                  n4 = { family: r5 };
              }
              n4 !== null && (n4.ref = { name: r5, style: t6 }, e5.push(n4));
            });
          }), e5;
        }(t4.getFontList());
        h3 = function(t5) {
          for (var e5 = {}, r5 = 0; r5 < t5.length; ++r5) {
            var n4 = jt(t5[r5]), i4 = n4.family, a3 = n4.stretch, o4 = n4.style, s4 = n4.weight;
            e5[i4] = e5[i4] || {}, e5[i4][a3] = e5[i4][a3] || {}, e5[i4][a3][o4] = e5[i4][a3][o4] || {}, e5[i4][a3][o4][s4] = n4;
          }
          return e5;
        }(r4.concat(e4));
      }
      return h3;
    }
    var p6 = null;
    Object.defineProperty(this, "fontFaces", { get: function() {
      return p6;
    }, set: function(t4) {
      h3 = null, p6 = t4;
    } }), Object.defineProperty(this, "font", { get: function() {
      return this.ctx.font;
    }, set: function(t4) {
      var e4;
      if (this.ctx.font = t4, (e4 = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z]+?)\s*$/i.exec(t4)) !== null) {
        var r4 = e4[1], n4 = (e4[2], e4[3]), i4 = e4[4], a3 = (e4[5], e4[6]), o4 = /^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(i4)[2];
        i4 = o4 === "px" ? Math.floor(parseFloat(i4) * this.pdf.internal.scaleFactor) : o4 === "em" ? Math.floor(parseFloat(i4) * this.pdf.getFontSize()) : Math.floor(parseFloat(i4) * this.pdf.internal.scaleFactor), this.pdf.setFontSize(i4);
        var s4 = function(t5) {
          var e5, r5, n5 = [], i5 = t5.trim();
          if (i5 === "")
            return Wt;
          if (i5 in Mt)
            return [Mt[i5]];
          for (; i5 !== ""; ) {
            switch (r5 = null, e5 = (i5 = Dt(i5)).charAt(0)) {
              case '"':
              case "'":
                r5 = Rt(i5.substring(1), e5);
                break;
              default:
                r5 = Tt(i5);
            }
            if (r5 === null)
              return Wt;
            if (n5.push(r5[0]), (i5 = Dt(r5[1])) !== "" && i5.charAt(0) !== ",")
              return Wt;
            i5 = i5.replace(/^,/, "");
          }
          return n5;
        }(a3);
        if (this.fontFaces) {
          var c4 = qt(f2(this.pdf, this.fontFaces), s4.map(function(t5) {
            return { family: t5, stretch: "normal", weight: n4, style: r4 };
          }));
          this.pdf.setFont(c4.ref.name, c4.ref.style);
        } else {
          var u4 = "";
          (n4 === "bold" || parseInt(n4, 10) >= 700 || r4 === "bold") && (u4 = "bold"), r4 === "italic" && (u4 += "italic"), u4.length === 0 && (u4 = "normal");
          for (var h4 = "", l3 = { arial: "Helvetica", Arial: "Helvetica", verdana: "Helvetica", Verdana: "Helvetica", helvetica: "Helvetica", Helvetica: "Helvetica", "sans-serif": "Helvetica", fixed: "Courier", monospace: "Courier", terminal: "Courier", cursive: "Times", fantasy: "Times", serif: "Times" }, d3 = 0; d3 < s4.length; d3++) {
            if (this.pdf.internal.getFont(s4[d3], u4, { noFallback: true, disableWarning: true }) !== void 0) {
              h4 = s4[d3];
              break;
            }
            if (u4 === "bolditalic" && this.pdf.internal.getFont(s4[d3], "bold", { noFallback: true, disableWarning: true }) !== void 0)
              h4 = s4[d3], u4 = "bold";
            else if (this.pdf.internal.getFont(s4[d3], "normal", { noFallback: true, disableWarning: true }) !== void 0) {
              h4 = s4[d3], u4 = "normal";
              break;
            }
          }
          if (h4 === "") {
            for (var p7 = 0; p7 < s4.length; p7++)
              if (l3[s4[p7]]) {
                h4 = l3[s4[p7]];
                break;
              }
          }
          h4 = h4 === "" ? "Times" : h4, this.pdf.setFont(h4, u4);
        }
      }
    } }), Object.defineProperty(this, "globalCompositeOperation", { get: function() {
      return this.ctx.globalCompositeOperation;
    }, set: function(t4) {
      this.ctx.globalCompositeOperation = t4;
    } }), Object.defineProperty(this, "globalAlpha", { get: function() {
      return this.ctx.globalAlpha;
    }, set: function(t4) {
      this.ctx.globalAlpha = t4;
    } }), Object.defineProperty(this, "lineDashOffset", { get: function() {
      return this.ctx.lineDashOffset;
    }, set: function(t4) {
      this.ctx.lineDashOffset = t4, T2.call(this);
    } }), Object.defineProperty(this, "lineDash", { get: function() {
      return this.ctx.lineDash;
    }, set: function(t4) {
      this.ctx.lineDash = t4, T2.call(this);
    } }), Object.defineProperty(this, "ignoreClearRect", { get: function() {
      return this.ctx.ignoreClearRect;
    }, set: function(t4) {
      this.ctx.ignoreClearRect = Boolean(t4);
    } });
  };
  p5.prototype.setLineDash = function(t3) {
    this.lineDash = t3;
  }, p5.prototype.getLineDash = function() {
    return this.lineDash.length % 2 ? this.lineDash.concat(this.lineDash) : this.lineDash.slice();
  }, p5.prototype.fill = function() {
    A2.call(this, "fill", false);
  }, p5.prototype.stroke = function() {
    A2.call(this, "stroke", false);
  }, p5.prototype.beginPath = function() {
    this.path = [{ type: "begin" }];
  }, p5.prototype.moveTo = function(t3, e3) {
    if (isNaN(t3) || isNaN(e3))
      throw a$2.error("jsPDF.context2d.moveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.moveTo");
    var r3 = this.ctx.transform.applyToPoint(new c2(t3, e3));
    this.path.push({ type: "mt", x: r3.x, y: r3.y }), this.ctx.lastPoint = new c2(t3, e3);
  }, p5.prototype.closePath = function() {
    var e3 = new c2(0, 0), r3 = 0;
    for (r3 = this.path.length - 1; r3 !== -1; r3--)
      if (this.path[r3].type === "begin" && _typeof$2(this.path[r3 + 1]) === "object" && typeof this.path[r3 + 1].x == "number") {
        e3 = new c2(this.path[r3 + 1].x, this.path[r3 + 1].y);
        break;
      }
    this.path.push({ type: "close" }), this.ctx.lastPoint = new c2(e3.x, e3.y);
  }, p5.prototype.lineTo = function(t3, e3) {
    if (isNaN(t3) || isNaN(e3))
      throw a$2.error("jsPDF.context2d.lineTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.lineTo");
    var r3 = this.ctx.transform.applyToPoint(new c2(t3, e3));
    this.path.push({ type: "lt", x: r3.x, y: r3.y }), this.ctx.lastPoint = new c2(r3.x, r3.y);
  }, p5.prototype.clip = function() {
    this.ctx.clip_path = JSON.parse(JSON.stringify(this.path)), A2.call(this, null, true);
  }, p5.prototype.quadraticCurveTo = function(t3, e3, r3, n3) {
    if (isNaN(r3) || isNaN(n3) || isNaN(t3) || isNaN(e3))
      throw a$2.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");
    var i3 = this.ctx.transform.applyToPoint(new c2(r3, n3)), o3 = this.ctx.transform.applyToPoint(new c2(t3, e3));
    this.path.push({ type: "qct", x1: o3.x, y1: o3.y, x: i3.x, y: i3.y }), this.ctx.lastPoint = new c2(i3.x, i3.y);
  }, p5.prototype.bezierCurveTo = function(t3, e3, r3, n3, i3, o3) {
    if (isNaN(i3) || isNaN(o3) || isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n3))
      throw a$2.error("jsPDF.context2d.bezierCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");
    var s3 = this.ctx.transform.applyToPoint(new c2(i3, o3)), u3 = this.ctx.transform.applyToPoint(new c2(t3, e3)), h3 = this.ctx.transform.applyToPoint(new c2(r3, n3));
    this.path.push({ type: "bct", x1: u3.x, y1: u3.y, x2: h3.x, y2: h3.y, x: s3.x, y: s3.y }), this.ctx.lastPoint = new c2(s3.x, s3.y);
  }, p5.prototype.arc = function(t3, e3, r3, n3, i3, o3) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n3) || isNaN(i3))
      throw a$2.error("jsPDF.context2d.arc: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.arc");
    if (o3 = Boolean(o3), !this.ctx.transform.isIdentity) {
      var s3 = this.ctx.transform.applyToPoint(new c2(t3, e3));
      t3 = s3.x, e3 = s3.y;
      var u3 = this.ctx.transform.applyToPoint(new c2(0, r3)), h3 = this.ctx.transform.applyToPoint(new c2(0, 0));
      r3 = Math.sqrt(Math.pow(u3.x - h3.x, 2) + Math.pow(u3.y - h3.y, 2));
    }
    Math.abs(i3 - n3) >= 2 * Math.PI && (n3 = 0, i3 = 2 * Math.PI), this.path.push({ type: "arc", x: t3, y: e3, radius: r3, startAngle: n3, endAngle: i3, counterclockwise: o3 });
  }, p5.prototype.arcTo = function(t3, e3, r3, n3, i3) {
    throw new Error("arcTo not implemented.");
  }, p5.prototype.rect = function(t3, e3, r3, n3) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n3))
      throw a$2.error("jsPDF.context2d.rect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rect");
    this.moveTo(t3, e3), this.lineTo(t3 + r3, e3), this.lineTo(t3 + r3, e3 + n3), this.lineTo(t3, e3 + n3), this.lineTo(t3, e3), this.lineTo(t3 + r3, e3), this.lineTo(t3, e3);
  }, p5.prototype.fillRect = function(t3, e3, r3, n3) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n3))
      throw a$2.error("jsPDF.context2d.fillRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillRect");
    if (!m2.call(this)) {
      var i3 = {};
      this.lineCap !== "butt" && (i3.lineCap = this.lineCap, this.lineCap = "butt"), this.lineJoin !== "miter" && (i3.lineJoin = this.lineJoin, this.lineJoin = "miter"), this.beginPath(), this.rect(t3, e3, r3, n3), this.fill(), i3.hasOwnProperty("lineCap") && (this.lineCap = i3.lineCap), i3.hasOwnProperty("lineJoin") && (this.lineJoin = i3.lineJoin);
    }
  }, p5.prototype.strokeRect = function(t3, e3, r3, n3) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n3))
      throw a$2.error("jsPDF.context2d.strokeRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");
    v2.call(this) || (this.beginPath(), this.rect(t3, e3, r3, n3), this.stroke());
  }, p5.prototype.clearRect = function(t3, e3, r3, n3) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n3))
      throw a$2.error("jsPDF.context2d.clearRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.clearRect");
    this.ignoreClearRect || (this.fillStyle = "#ffffff", this.fillRect(t3, e3, r3, n3));
  }, p5.prototype.save = function(t3) {
    t3 = typeof t3 != "boolean" || t3;
    for (var e3 = this.pdf.internal.getCurrentPageInfo().pageNumber, r3 = 0; r3 < this.pdf.internal.getNumberOfPages(); r3++)
      this.pdf.setPage(r3 + 1), this.pdf.internal.out("q");
    if (this.pdf.setPage(e3), t3) {
      this.ctx.fontSize = this.pdf.internal.getFontSize();
      var n3 = new d2(this.ctx);
      this.ctxStack.push(this.ctx), this.ctx = n3;
    }
  }, p5.prototype.restore = function(t3) {
    t3 = typeof t3 != "boolean" || t3;
    for (var e3 = this.pdf.internal.getCurrentPageInfo().pageNumber, r3 = 0; r3 < this.pdf.internal.getNumberOfPages(); r3++)
      this.pdf.setPage(r3 + 1), this.pdf.internal.out("Q");
    this.pdf.setPage(e3), t3 && this.ctxStack.length !== 0 && (this.ctx = this.ctxStack.pop(), this.fillStyle = this.ctx.fillStyle, this.strokeStyle = this.ctx.strokeStyle, this.font = this.ctx.font, this.lineCap = this.ctx.lineCap, this.lineWidth = this.ctx.lineWidth, this.lineJoin = this.ctx.lineJoin, this.lineDash = this.ctx.lineDash, this.lineDashOffset = this.ctx.lineDashOffset);
  }, p5.prototype.toDataURL = function() {
    throw new Error("toDataUrl not implemented.");
  };
  var g2 = function(t3) {
    var e3, r3, n3, i3;
    if (t3.isCanvasGradient === true && (t3 = t3.getColor()), !t3)
      return { r: 0, g: 0, b: 0, a: 0, style: t3 };
    if (/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(t3))
      e3 = 0, r3 = 0, n3 = 0, i3 = 0;
    else {
      var a2 = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(t3);
      if (a2 !== null)
        e3 = parseInt(a2[1]), r3 = parseInt(a2[2]), n3 = parseInt(a2[3]), i3 = 1;
      else if ((a2 = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/.exec(t3)) !== null)
        e3 = parseInt(a2[1]), r3 = parseInt(a2[2]), n3 = parseInt(a2[3]), i3 = parseFloat(a2[4]);
      else {
        if (i3 = 1, typeof t3 == "string" && t3.charAt(0) !== "#") {
          var o3 = new f$2(t3);
          t3 = o3.ok ? o3.toHex() : "#000000";
        }
        t3.length === 4 ? (e3 = t3.substring(1, 2), e3 += e3, r3 = t3.substring(2, 3), r3 += r3, n3 = t3.substring(3, 4), n3 += n3) : (e3 = t3.substring(1, 3), r3 = t3.substring(3, 5), n3 = t3.substring(5, 7)), e3 = parseInt(e3, 16), r3 = parseInt(r3, 16), n3 = parseInt(n3, 16);
      }
    }
    return { r: e3, g: r3, b: n3, a: i3, style: t3 };
  }, m2 = function() {
    return this.ctx.isFillTransparent || this.globalAlpha == 0;
  }, v2 = function() {
    return Boolean(this.ctx.isStrokeTransparent || this.globalAlpha == 0);
  };
  p5.prototype.fillText = function(t3, e3, r3, n3) {
    if (isNaN(e3) || isNaN(r3) || typeof t3 != "string")
      throw a$2.error("jsPDF.context2d.fillText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillText");
    if (n3 = isNaN(n3) ? void 0 : n3, !m2.call(this)) {
      var i3 = q2(this.ctx.transform.rotation), o3 = this.ctx.transform.scaleX;
      C2.call(this, { text: t3, x: e3, y: r3, scale: o3, angle: i3, align: this.textAlign, maxWidth: n3 });
    }
  }, p5.prototype.strokeText = function(t3, e3, r3, n3) {
    if (isNaN(e3) || isNaN(r3) || typeof t3 != "string")
      throw a$2.error("jsPDF.context2d.strokeText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeText");
    if (!v2.call(this)) {
      n3 = isNaN(n3) ? void 0 : n3;
      var i3 = q2(this.ctx.transform.rotation), o3 = this.ctx.transform.scaleX;
      C2.call(this, { text: t3, x: e3, y: r3, scale: o3, renderingMode: "stroke", angle: i3, align: this.textAlign, maxWidth: n3 });
    }
  }, p5.prototype.measureText = function(t3) {
    if (typeof t3 != "string")
      throw a$2.error("jsPDF.context2d.measureText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.measureText");
    var e3 = this.pdf, r3 = this.pdf.internal.scaleFactor, n3 = e3.internal.getFontSize(), i3 = e3.getStringUnitWidth(t3) * n3 / e3.internal.scaleFactor, o3 = function(t4) {
      var e4 = (t4 = t4 || {}).width || 0;
      return Object.defineProperty(this, "width", { get: function() {
        return e4;
      } }), this;
    };
    return new o3({ width: i3 *= Math.round(96 * r3 / 72 * 1e4) / 1e4 });
  }, p5.prototype.scale = function(t3, e3) {
    if (isNaN(t3) || isNaN(e3))
      throw a$2.error("jsPDF.context2d.scale: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.scale");
    var r3 = new h2(t3, 0, 0, e3, 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(r3);
  }, p5.prototype.rotate = function(t3) {
    if (isNaN(t3))
      throw a$2.error("jsPDF.context2d.rotate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rotate");
    var e3 = new h2(Math.cos(t3), Math.sin(t3), -Math.sin(t3), Math.cos(t3), 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(e3);
  }, p5.prototype.translate = function(t3, e3) {
    if (isNaN(t3) || isNaN(e3))
      throw a$2.error("jsPDF.context2d.translate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.translate");
    var r3 = new h2(1, 0, 0, 1, t3, e3);
    this.ctx.transform = this.ctx.transform.multiply(r3);
  }, p5.prototype.transform = function(t3, e3, r3, n3, i3, o3) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n3) || isNaN(i3) || isNaN(o3))
      throw a$2.error("jsPDF.context2d.transform: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.transform");
    var s3 = new h2(t3, e3, r3, n3, i3, o3);
    this.ctx.transform = this.ctx.transform.multiply(s3);
  }, p5.prototype.setTransform = function(t3, e3, r3, n3, i3, a2) {
    t3 = isNaN(t3) ? 1 : t3, e3 = isNaN(e3) ? 0 : e3, r3 = isNaN(r3) ? 0 : r3, n3 = isNaN(n3) ? 1 : n3, i3 = isNaN(i3) ? 0 : i3, a2 = isNaN(a2) ? 0 : a2, this.ctx.transform = new h2(t3, e3, r3, n3, i3, a2);
  };
  var b2 = function() {
    return this.margin[0] > 0 || this.margin[1] > 0 || this.margin[2] > 0 || this.margin[3] > 0;
  };
  p5.prototype.drawImage = function(t3, e3, r3, n3, i3, a2, o3, s3, c3) {
    var l3 = this.pdf.getImageProperties(t3), f2 = 1, d3 = 1, p6 = 1, g3 = 1;
    n3 !== void 0 && s3 !== void 0 && (p6 = s3 / n3, g3 = c3 / i3, f2 = l3.width / n3 * s3 / n3, d3 = l3.height / i3 * c3 / i3), a2 === void 0 && (a2 = e3, o3 = r3, e3 = 0, r3 = 0), n3 !== void 0 && s3 === void 0 && (s3 = n3, c3 = i3), n3 === void 0 && s3 === void 0 && (s3 = l3.width, c3 = l3.height);
    for (var m3, v3 = this.ctx.transform.decompose(), w3 = q2(v3.rotate.shx), A3 = new h2(), S3 = (A3 = (A3 = (A3 = A3.multiply(v3.translate)).multiply(v3.skew)).multiply(v3.scale)).applyToRectangle(new u2(a2 - e3 * p6, o3 - r3 * g3, n3 * f2, i3 * d3)), _3 = y2.call(this, S3), P3 = [], k3 = 0; k3 < _3.length; k3 += 1)
      P3.indexOf(_3[k3]) === -1 && P3.push(_3[k3]);
    if (L2(P3), this.autoPaging)
      for (var I3 = P3[0], F3 = P3[P3.length - 1], C3 = I3; C3 < F3 + 1; C3++) {
        this.pdf.setPage(C3);
        var j3 = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], O3 = C3 === 1 ? this.posY + this.margin[0] : this.margin[0], B4 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], M3 = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], E3 = C3 === 1 ? 0 : B4 + (C3 - 2) * M3;
        if (this.ctx.clip_path.length !== 0) {
          var D3 = this.path;
          m3 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N2(m3, this.posX + this.margin[3], -E3 + O3 + this.ctx.prevPageLastElemOffset), x2.call(this, "fill", true), this.path = D3;
        }
        var R3 = JSON.parse(JSON.stringify(S3));
        R3 = N2([R3], this.posX + this.margin[3], -E3 + O3 + this.ctx.prevPageLastElemOffset)[0];
        var T3 = (C3 > I3 || C3 < F3) && b2.call(this);
        T3 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], j3, M3, null).clip().discardPath()), this.pdf.addImage(t3, "JPEG", R3.x, R3.y, R3.w, R3.h, null, null, w3), T3 && this.pdf.restoreGraphicsState();
      }
    else
      this.pdf.addImage(t3, "JPEG", S3.x, S3.y, S3.w, S3.h, null, null, w3);
  };
  var y2 = function(t3, e3, r3) {
    var n3 = [];
    e3 = e3 || this.pdf.internal.pageSize.width, r3 = r3 || this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2];
    var i3 = this.posY + this.ctx.prevPageLastElemOffset;
    switch (t3.type) {
      default:
      case "mt":
      case "lt":
        n3.push(Math.floor((t3.y + i3) / r3) + 1);
        break;
      case "arc":
        n3.push(Math.floor((t3.y + i3 - t3.radius) / r3) + 1), n3.push(Math.floor((t3.y + i3 + t3.radius) / r3) + 1);
        break;
      case "qct":
        var a2 = D2(this.ctx.lastPoint.x, this.ctx.lastPoint.y, t3.x1, t3.y1, t3.x, t3.y);
        n3.push(Math.floor((a2.y + i3) / r3) + 1), n3.push(Math.floor((a2.y + a2.h + i3) / r3) + 1);
        break;
      case "bct":
        var o3 = R2(this.ctx.lastPoint.x, this.ctx.lastPoint.y, t3.x1, t3.y1, t3.x2, t3.y2, t3.x, t3.y);
        n3.push(Math.floor((o3.y + i3) / r3) + 1), n3.push(Math.floor((o3.y + o3.h + i3) / r3) + 1);
        break;
      case "rect":
        n3.push(Math.floor((t3.y + i3) / r3) + 1), n3.push(Math.floor((t3.y + t3.h + i3) / r3) + 1);
    }
    for (var s3 = 0; s3 < n3.length; s3 += 1)
      for (; this.pdf.internal.getNumberOfPages() < n3[s3]; )
        w2.call(this);
    return n3;
  }, w2 = function() {
    var t3 = this.fillStyle, e3 = this.strokeStyle, r3 = this.font, n3 = this.lineCap, i3 = this.lineWidth, a2 = this.lineJoin;
    this.pdf.addPage(), this.fillStyle = t3, this.strokeStyle = e3, this.font = r3, this.lineCap = n3, this.lineWidth = i3, this.lineJoin = a2;
  }, N2 = function(t3, e3, r3) {
    for (var n3 = 0; n3 < t3.length; n3++)
      switch (t3[n3].type) {
        case "bct":
          t3[n3].x2 += e3, t3[n3].y2 += r3;
        case "qct":
          t3[n3].x1 += e3, t3[n3].y1 += r3;
        case "mt":
        case "lt":
        case "arc":
        default:
          t3[n3].x += e3, t3[n3].y += r3;
      }
    return t3;
  }, L2 = function(t3) {
    return t3.sort(function(t4, e3) {
      return t4 - e3;
    });
  }, A2 = function(t3, e3) {
    for (var r3, n3, i3 = this.fillStyle, a2 = this.strokeStyle, o3 = this.lineCap, s3 = this.lineWidth, c3 = Math.abs(s3 * this.ctx.transform.scaleX), u3 = this.lineJoin, h3 = JSON.parse(JSON.stringify(this.path)), l3 = JSON.parse(JSON.stringify(this.path)), f2 = [], d3 = 0; d3 < l3.length; d3++)
      if (l3[d3].x !== void 0)
        for (var p6 = y2.call(this, l3[d3]), g3 = 0; g3 < p6.length; g3 += 1)
          f2.indexOf(p6[g3]) === -1 && f2.push(p6[g3]);
    for (var m3 = 0; m3 < f2.length; m3++)
      for (; this.pdf.internal.getNumberOfPages() < f2[m3]; )
        w2.call(this);
    if (L2(f2), this.autoPaging)
      for (var v3 = f2[0], A3 = f2[f2.length - 1], S3 = v3; S3 < A3 + 1; S3++) {
        this.pdf.setPage(S3), this.fillStyle = i3, this.strokeStyle = a2, this.lineCap = o3, this.lineWidth = c3, this.lineJoin = u3;
        var _3 = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], P3 = S3 === 1 ? this.posY + this.margin[0] : this.margin[0], k3 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], I3 = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], F3 = S3 === 1 ? 0 : k3 + (S3 - 2) * I3;
        if (this.ctx.clip_path.length !== 0) {
          var C3 = this.path;
          r3 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N2(r3, this.posX + this.margin[3], -F3 + P3 + this.ctx.prevPageLastElemOffset), x2.call(this, t3, true), this.path = C3;
        }
        if (n3 = JSON.parse(JSON.stringify(h3)), this.path = N2(n3, this.posX + this.margin[3], -F3 + P3 + this.ctx.prevPageLastElemOffset), e3 === false || S3 === 0) {
          var j3 = (S3 > v3 || S3 < A3) && b2.call(this);
          j3 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], _3, I3, null).clip().discardPath()), x2.call(this, t3, e3), j3 && this.pdf.restoreGraphicsState();
        }
        this.lineWidth = s3;
      }
    else
      this.lineWidth = c3, x2.call(this, t3, e3), this.lineWidth = s3;
    this.path = h3;
  }, x2 = function(t3, e3) {
    if ((t3 !== "stroke" || e3 || !v2.call(this)) && (t3 === "stroke" || e3 || !m2.call(this))) {
      for (var r3, n3, i3 = [], a2 = this.path, o3 = 0; o3 < a2.length; o3++) {
        var s3 = a2[o3];
        switch (s3.type) {
          case "begin":
            i3.push({ begin: true });
            break;
          case "close":
            i3.push({ close: true });
            break;
          case "mt":
            i3.push({ start: s3, deltas: [], abs: [] });
            break;
          case "lt":
            var c3 = i3.length;
            if (a2[o3 - 1] && !isNaN(a2[o3 - 1].x) && (r3 = [s3.x - a2[o3 - 1].x, s3.y - a2[o3 - 1].y], c3 > 0)) {
              for (; c3 >= 0; c3--)
                if (i3[c3 - 1].close !== true && i3[c3 - 1].begin !== true) {
                  i3[c3 - 1].deltas.push(r3), i3[c3 - 1].abs.push(s3);
                  break;
                }
            }
            break;
          case "bct":
            r3 = [s3.x1 - a2[o3 - 1].x, s3.y1 - a2[o3 - 1].y, s3.x2 - a2[o3 - 1].x, s3.y2 - a2[o3 - 1].y, s3.x - a2[o3 - 1].x, s3.y - a2[o3 - 1].y], i3[i3.length - 1].deltas.push(r3);
            break;
          case "qct":
            var u3 = a2[o3 - 1].x + 2 / 3 * (s3.x1 - a2[o3 - 1].x), h3 = a2[o3 - 1].y + 2 / 3 * (s3.y1 - a2[o3 - 1].y), l3 = s3.x + 2 / 3 * (s3.x1 - s3.x), f2 = s3.y + 2 / 3 * (s3.y1 - s3.y), d3 = s3.x, p6 = s3.y;
            r3 = [u3 - a2[o3 - 1].x, h3 - a2[o3 - 1].y, l3 - a2[o3 - 1].x, f2 - a2[o3 - 1].y, d3 - a2[o3 - 1].x, p6 - a2[o3 - 1].y], i3[i3.length - 1].deltas.push(r3);
            break;
          case "arc":
            i3.push({ deltas: [], abs: [], arc: true }), Array.isArray(i3[i3.length - 1].abs) && i3[i3.length - 1].abs.push(s3);
        }
      }
      n3 = e3 ? null : t3 === "stroke" ? "stroke" : "fill";
      for (var g3 = false, b3 = 0; b3 < i3.length; b3++)
        if (i3[b3].arc)
          for (var y3 = i3[b3].abs, w3 = 0; w3 < y3.length; w3++) {
            var N3 = y3[w3];
            N3.type === "arc" ? P2.call(this, N3.x, N3.y, N3.radius, N3.startAngle, N3.endAngle, N3.counterclockwise, void 0, e3, !g3) : j2.call(this, N3.x, N3.y), g3 = true;
          }
        else if (i3[b3].close === true)
          this.pdf.internal.out("h"), g3 = false;
        else if (i3[b3].begin !== true) {
          var L3 = i3[b3].start.x, A3 = i3[b3].start.y;
          O2.call(this, i3[b3].deltas, L3, A3), g3 = true;
        }
      n3 && k2.call(this, n3), e3 && I2.call(this);
    }
  }, S2 = function(t3) {
    var e3 = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor, r3 = e3 * (this.pdf.internal.getLineHeightFactor() - 1);
    switch (this.ctx.textBaseline) {
      case "bottom":
        return t3 - r3;
      case "top":
        return t3 + e3 - r3;
      case "hanging":
        return t3 + e3 - 2 * r3;
      case "middle":
        return t3 + e3 / 2 - r3;
      case "ideographic":
        return t3;
      case "alphabetic":
      default:
        return t3;
    }
  }, _2 = function(t3) {
    return t3 + this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor * (this.pdf.internal.getLineHeightFactor() - 1);
  };
  p5.prototype.createLinearGradient = function() {
    var t3 = function() {
    };
    return t3.colorStops = [], t3.addColorStop = function(t4, e3) {
      this.colorStops.push([t4, e3]);
    }, t3.getColor = function() {
      return this.colorStops.length === 0 ? "#000000" : this.colorStops[0][1];
    }, t3.isCanvasGradient = true, t3;
  }, p5.prototype.createPattern = function() {
    return this.createLinearGradient();
  }, p5.prototype.createRadialGradient = function() {
    return this.createLinearGradient();
  };
  var P2 = function(t3, e3, r3, n3, i3, a2, o3, s3, c3) {
    for (var u3 = M2.call(this, r3, n3, i3, a2), h3 = 0; h3 < u3.length; h3++) {
      var l3 = u3[h3];
      h3 === 0 && (c3 ? F2.call(this, l3.x1 + t3, l3.y1 + e3) : j2.call(this, l3.x1 + t3, l3.y1 + e3)), B3.call(this, t3, e3, l3.x2, l3.y2, l3.x3, l3.y3, l3.x4, l3.y4);
    }
    s3 ? I2.call(this) : k2.call(this, o3);
  }, k2 = function(t3) {
    switch (t3) {
      case "stroke":
        this.pdf.internal.out("S");
        break;
      case "fill":
        this.pdf.internal.out("f");
    }
  }, I2 = function() {
    this.pdf.clip(), this.pdf.discardPath();
  }, F2 = function(t3, e3) {
    this.pdf.internal.out(n2(t3) + " " + i2(e3) + " m");
  }, C2 = function(t3) {
    var e3;
    switch (t3.align) {
      case "right":
      case "end":
        e3 = "right";
        break;
      case "center":
        e3 = "center";
        break;
      case "left":
      case "start":
      default:
        e3 = "left";
    }
    var r3 = this.pdf.getTextDimensions(t3.text), n3 = S2.call(this, t3.y), i3 = _2.call(this, n3) - r3.h, a2 = this.ctx.transform.applyToPoint(new c2(t3.x, n3)), o3 = this.ctx.transform.decompose(), s3 = new h2();
    s3 = (s3 = (s3 = s3.multiply(o3.translate)).multiply(o3.skew)).multiply(o3.scale);
    for (var l3, f2, d3, p6 = this.ctx.transform.applyToRectangle(new u2(t3.x, n3, r3.w, r3.h)), g3 = s3.applyToRectangle(new u2(t3.x, i3, r3.w, r3.h)), m3 = y2.call(this, g3), v3 = [], w3 = 0; w3 < m3.length; w3 += 1)
      v3.indexOf(m3[w3]) === -1 && v3.push(m3[w3]);
    if (L2(v3), this.autoPaging)
      for (var A3 = v3[0], P3 = v3[v3.length - 1], k3 = A3; k3 < P3 + 1; k3++) {
        this.pdf.setPage(k3);
        var I3 = k3 === 1 ? this.posY + this.margin[0] : this.margin[0], F3 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], C3 = this.pdf.internal.pageSize.height - this.margin[2], j3 = C3 - this.margin[0], O3 = this.pdf.internal.pageSize.width - this.margin[1], B4 = O3 - this.margin[3], M3 = k3 === 1 ? 0 : F3 + (k3 - 2) * j3;
        if (this.ctx.clip_path.length !== 0) {
          var E3 = this.path;
          l3 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N2(l3, this.posX + this.margin[3], -1 * M3 + I3), x2.call(this, "fill", true), this.path = E3;
        }
        var q3 = N2([JSON.parse(JSON.stringify(g3))], this.posX + this.margin[3], -M3 + I3 + this.ctx.prevPageLastElemOffset)[0];
        t3.scale >= 0.01 && (f2 = this.pdf.internal.getFontSize(), this.pdf.setFontSize(f2 * t3.scale), d3 = this.lineWidth, this.lineWidth = d3 * t3.scale);
        var D3 = this.autoPaging !== "text";
        if (D3 || q3.y + q3.h <= C3) {
          if (D3 || q3.y >= I3 && q3.x <= O3) {
            var R3 = D3 ? t3.text : this.pdf.splitTextToSize(t3.text, t3.maxWidth || O3 - q3.x)[0], T3 = N2([JSON.parse(JSON.stringify(p6))], this.posX + this.margin[3], -M3 + I3 + this.ctx.prevPageLastElemOffset)[0], z2 = D3 && (k3 > A3 || k3 < P3) && b2.call(this);
            z2 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], B4, j3, null).clip().discardPath()), this.pdf.text(R3, T3.x, T3.y, { angle: t3.angle, align: e3, renderingMode: t3.renderingMode }), z2 && this.pdf.restoreGraphicsState();
          }
        } else
          q3.y < C3 && (this.ctx.prevPageLastElemOffset += C3 - q3.y);
        t3.scale >= 0.01 && (this.pdf.setFontSize(f2), this.lineWidth = d3);
      }
    else
      t3.scale >= 0.01 && (f2 = this.pdf.internal.getFontSize(), this.pdf.setFontSize(f2 * t3.scale), d3 = this.lineWidth, this.lineWidth = d3 * t3.scale), this.pdf.text(t3.text, a2.x + this.posX, a2.y + this.posY, { angle: t3.angle, align: e3, renderingMode: t3.renderingMode, maxWidth: t3.maxWidth }), t3.scale >= 0.01 && (this.pdf.setFontSize(f2), this.lineWidth = d3);
  }, j2 = function(t3, e3, r3, a2) {
    r3 = r3 || 0, a2 = a2 || 0, this.pdf.internal.out(n2(t3 + r3) + " " + i2(e3 + a2) + " l");
  }, O2 = function(t3, e3, r3) {
    return this.pdf.lines(t3, e3, r3, null, null);
  }, B3 = function(t3, e3, n3, i3, a2, c3, u3, h3) {
    this.pdf.internal.out([r2(o2(n3 + t3)), r2(s2(i3 + e3)), r2(o2(a2 + t3)), r2(s2(c3 + e3)), r2(o2(u3 + t3)), r2(s2(h3 + e3)), "c"].join(" "));
  }, M2 = function(t3, e3, r3, n3) {
    for (var i3 = 2 * Math.PI, a2 = Math.PI / 2; e3 > r3; )
      e3 -= i3;
    var o3 = Math.abs(r3 - e3);
    o3 < i3 && n3 && (o3 = i3 - o3);
    for (var s3 = [], c3 = n3 ? -1 : 1, u3 = e3; o3 > 1e-5; ) {
      var h3 = u3 + c3 * Math.min(o3, a2);
      s3.push(E2.call(this, t3, u3, h3)), o3 -= Math.abs(h3 - u3), u3 = h3;
    }
    return s3;
  }, E2 = function(t3, e3, r3) {
    var n3 = (r3 - e3) / 2, i3 = t3 * Math.cos(n3), a2 = t3 * Math.sin(n3), o3 = i3, s3 = -a2, c3 = o3 * o3 + s3 * s3, u3 = c3 + o3 * i3 + s3 * a2, h3 = 4 / 3 * (Math.sqrt(2 * c3 * u3) - u3) / (o3 * a2 - s3 * i3), l3 = o3 - h3 * s3, f2 = s3 + h3 * o3, d3 = l3, p6 = -f2, g3 = n3 + e3, m3 = Math.cos(g3), v3 = Math.sin(g3);
    return { x1: t3 * Math.cos(e3), y1: t3 * Math.sin(e3), x2: l3 * m3 - f2 * v3, y2: l3 * v3 + f2 * m3, x3: d3 * m3 - p6 * v3, y3: d3 * v3 + p6 * m3, x4: t3 * Math.cos(r3), y4: t3 * Math.sin(r3) };
  }, q2 = function(t3) {
    return 180 * t3 / Math.PI;
  }, D2 = function(t3, e3, r3, n3, i3, a2) {
    var o3 = t3 + 0.5 * (r3 - t3), s3 = e3 + 0.5 * (n3 - e3), c3 = i3 + 0.5 * (r3 - i3), h3 = a2 + 0.5 * (n3 - a2), l3 = Math.min(t3, i3, o3, c3), f2 = Math.max(t3, i3, o3, c3), d3 = Math.min(e3, a2, s3, h3), p6 = Math.max(e3, a2, s3, h3);
    return new u2(l3, d3, f2 - l3, p6 - d3);
  }, R2 = function(t3, e3, r3, n3, i3, a2, o3, s3) {
    var c3, h3, l3, f2, d3, p6, g3, m3, v3, b3, y3, w3, N3, L3, A3 = r3 - t3, x3 = n3 - e3, S3 = i3 - r3, _3 = a2 - n3, P3 = o3 - i3, k3 = s3 - a2;
    for (h3 = 0; h3 < 41; h3++)
      v3 = (g3 = (l3 = t3 + (c3 = h3 / 40) * A3) + c3 * ((d3 = r3 + c3 * S3) - l3)) + c3 * (d3 + c3 * (i3 + c3 * P3 - d3) - g3), b3 = (m3 = (f2 = e3 + c3 * x3) + c3 * ((p6 = n3 + c3 * _3) - f2)) + c3 * (p6 + c3 * (a2 + c3 * k3 - p6) - m3), h3 == 0 ? (y3 = v3, w3 = b3, N3 = v3, L3 = b3) : (y3 = Math.min(y3, v3), w3 = Math.min(w3, b3), N3 = Math.max(N3, v3), L3 = Math.max(L3, b3));
    return new u2(Math.round(y3), Math.round(w3), Math.round(N3 - y3), Math.round(L3 - w3));
  }, T2 = function() {
    if (this.prevLineDash || this.ctx.lineDash.length || this.ctx.lineDashOffset) {
      var t3, e3, r3 = (t3 = this.ctx.lineDash, e3 = this.ctx.lineDashOffset, JSON.stringify({ lineDash: t3, lineDashOffset: e3 }));
      this.prevLineDash !== r3 && (this.pdf.setLineDash(this.ctx.lineDash, this.ctx.lineDashOffset), this.prevLineDash = r3);
    }
  };
}(E$1.API), function(t3) {
  var r2 = function(t4) {
    var e2, r3, n3, i3, a3, o2, s2, c2, u2, h2;
    for (/[^\x00-\xFF]/.test(t4), r3 = [], n3 = 0, i3 = (t4 += e2 = "\0\0\0\0".slice(t4.length % 4 || 4)).length; i3 > n3; n3 += 4)
      (a3 = (t4.charCodeAt(n3) << 24) + (t4.charCodeAt(n3 + 1) << 16) + (t4.charCodeAt(n3 + 2) << 8) + t4.charCodeAt(n3 + 3)) !== 0 ? (o2 = (a3 = ((a3 = ((a3 = ((a3 = (a3 - (h2 = a3 % 85)) / 85) - (u2 = a3 % 85)) / 85) - (c2 = a3 % 85)) / 85) - (s2 = a3 % 85)) / 85) % 85, r3.push(o2 + 33, s2 + 33, c2 + 33, u2 + 33, h2 + 33)) : r3.push(122);
    return function(t5, e3) {
      for (var r4 = e3; r4 > 0; r4--)
        t5.pop();
    }(r3, e2.length), String.fromCharCode.apply(String, r3) + "~>";
  }, n2 = function(t4) {
    var e2, r3, n3, i3, a3, o2 = String, s2 = "length", c2 = 255, u2 = "charCodeAt", h2 = "slice", l2 = "replace";
    for (t4[h2](-2), t4 = t4[h2](0, -2)[l2](/\s/g, "")[l2]("z", "!!!!!"), n3 = [], i3 = 0, a3 = (t4 += e2 = "uuuuu"[h2](t4[s2] % 5 || 5))[s2]; a3 > i3; i3 += 5)
      r3 = 52200625 * (t4[u2](i3) - 33) + 614125 * (t4[u2](i3 + 1) - 33) + 7225 * (t4[u2](i3 + 2) - 33) + 85 * (t4[u2](i3 + 3) - 33) + (t4[u2](i3 + 4) - 33), n3.push(c2 & r3 >> 24, c2 & r3 >> 16, c2 & r3 >> 8, c2 & r3);
    return function(t5, e3) {
      for (var r4 = e3; r4 > 0; r4--)
        t5.pop();
    }(n3, e2[s2]), o2.fromCharCode.apply(o2, n3);
  }, i2 = function(t4) {
    var e2 = new RegExp(/^([0-9A-Fa-f]{2})+$/);
    if ((t4 = t4.replace(/\s/g, "")).indexOf(">") !== -1 && (t4 = t4.substr(0, t4.indexOf(">"))), t4.length % 2 && (t4 += "0"), e2.test(t4) === false)
      return "";
    for (var r3 = "", n3 = 0; n3 < t4.length; n3 += 2)
      r3 += String.fromCharCode("0x" + (t4[n3] + t4[n3 + 1]));
    return r3;
  }, a2 = function(t4) {
    for (var r3 = new Uint8Array(t4.length), n3 = t4.length; n3--; )
      r3[n3] = t4.charCodeAt(n3);
    return t4 = (r3 = zlibSync(r3)).reduce(function(t5, e2) {
      return t5 + String.fromCharCode(e2);
    }, "");
  };
  t3.processDataByFilters = function(t4, e2) {
    var o2 = 0, s2 = t4 || "", c2 = [];
    for (typeof (e2 = e2 || []) == "string" && (e2 = [e2]), o2 = 0; o2 < e2.length; o2 += 1)
      switch (e2[o2]) {
        case "ASCII85Decode":
        case "/ASCII85Decode":
          s2 = n2(s2), c2.push("/ASCII85Encode");
          break;
        case "ASCII85Encode":
        case "/ASCII85Encode":
          s2 = r2(s2), c2.push("/ASCII85Decode");
          break;
        case "ASCIIHexDecode":
        case "/ASCIIHexDecode":
          s2 = i2(s2), c2.push("/ASCIIHexEncode");
          break;
        case "ASCIIHexEncode":
        case "/ASCIIHexEncode":
          s2 = s2.split("").map(function(t5) {
            return ("0" + t5.charCodeAt().toString(16)).slice(-2);
          }).join("") + ">", c2.push("/ASCIIHexDecode");
          break;
        case "FlateEncode":
        case "/FlateEncode":
          s2 = a2(s2), c2.push("/FlateDecode");
          break;
        default:
          throw new Error('The filter: "' + e2[o2] + '" is not implemented');
      }
    return { data: s2, reverseChain: c2.reverse().join(" ") };
  };
}(E$1.API), function(t3) {
  t3.loadFile = function(t4, e2, r2) {
    return function(t5, e3, r3) {
      e3 = e3 !== false, r3 = typeof r3 == "function" ? r3 : function() {
      };
      var n2 = void 0;
      try {
        n2 = function(t6, e4, r4) {
          var n3 = new XMLHttpRequest(), i2 = 0, a2 = function(t7) {
            var e5 = t7.length, r5 = [], n4 = String.fromCharCode;
            for (i2 = 0; i2 < e5; i2 += 1)
              r5.push(n4(255 & t7.charCodeAt(i2)));
            return r5.join("");
          };
          if (n3.open("GET", t6, !e4), n3.overrideMimeType("text/plain; charset=x-user-defined"), e4 === false && (n3.onload = function() {
            n3.status === 200 ? r4(a2(this.responseText)) : r4(void 0);
          }), n3.send(null), e4 && n3.status === 200)
            return a2(n3.responseText);
        }(t5, e3, r3);
      } catch (t6) {
      }
      return n2;
    }(t4, e2, r2);
  }, t3.loadImageFile = t3.loadFile;
}(E$1.API), function(e2) {
  function r2() {
    return (n$1.html2canvas ? Promise.resolve(n$1.html2canvas) : Promise.resolve().then(function() {
      return html2canvas_esm;
    })).catch(function(t3) {
      return Promise.reject(new Error("Could not load html2canvas: " + t3));
    }).then(function(t3) {
      return t3.default ? t3.default : t3;
    });
  }
  function i2() {
    return (n$1.DOMPurify ? Promise.resolve(n$1.DOMPurify) : Promise.resolve().then(function() {
      return purify_es;
    })).catch(function(t3) {
      return Promise.reject(new Error("Could not load dompurify: " + t3));
    }).then(function(t3) {
      return t3.default ? t3.default : t3;
    });
  }
  var a2 = function(e3) {
    var r3 = _typeof$2(e3);
    return r3 === "undefined" ? "undefined" : r3 === "string" || e3 instanceof String ? "string" : r3 === "number" || e3 instanceof Number ? "number" : r3 === "function" || e3 instanceof Function ? "function" : e3 && e3.constructor === Array ? "array" : e3 && e3.nodeType === 1 ? "element" : r3 === "object" ? "object" : "unknown";
  }, o2 = function(t3, e3) {
    var r3 = document.createElement(t3);
    for (var n2 in e3.className && (r3.className = e3.className), e3.innerHTML && e3.dompurify && (r3.innerHTML = e3.dompurify.sanitize(e3.innerHTML)), e3.style)
      r3.style[n2] = e3.style[n2];
    return r3;
  }, s2 = function t3(e3) {
    var r3 = Object.assign(t3.convert(Promise.resolve()), JSON.parse(JSON.stringify(t3.template))), n2 = t3.convert(Promise.resolve(), r3);
    return n2 = (n2 = n2.setProgress(1, t3, 1, [t3])).set(e3);
  };
  (s2.prototype = Object.create(Promise.prototype)).constructor = s2, s2.convert = function(t3, e3) {
    return t3.__proto__ = e3 || s2.prototype, t3;
  }, s2.template = { prop: { src: null, container: null, overlay: null, canvas: null, img: null, pdf: null, pageSize: null, callback: function() {
  } }, progress: { val: 0, state: null, n: 0, stack: [] }, opt: { filename: "file.pdf", margin: [0, 0, 0, 0], enableLinks: true, x: 0, y: 0, html2canvas: {}, jsPDF: {}, backgroundColor: "transparent" } }, s2.prototype.from = function(t3, e3) {
    return this.then(function() {
      switch (e3 = e3 || function(t4) {
        switch (a2(t4)) {
          case "string":
            return "string";
          case "element":
            return t4.nodeName.toLowerCase() === "canvas" ? "canvas" : "element";
          default:
            return "unknown";
        }
      }(t3)) {
        case "string":
          return this.then(i2).then(function(e4) {
            return this.set({ src: o2("div", { innerHTML: t3, dompurify: e4 }) });
          });
        case "element":
          return this.set({ src: t3 });
        case "canvas":
          return this.set({ canvas: t3 });
        case "img":
          return this.set({ img: t3 });
        default:
          return this.error("Unknown source type.");
      }
    });
  }, s2.prototype.to = function(t3) {
    switch (t3) {
      case "container":
        return this.toContainer();
      case "canvas":
        return this.toCanvas();
      case "img":
        return this.toImg();
      case "pdf":
        return this.toPdf();
      default:
        return this.error("Invalid target.");
    }
  }, s2.prototype.toContainer = function() {
    return this.thenList([function() {
      return this.prop.src || this.error("Cannot duplicate - no source HTML.");
    }, function() {
      return this.prop.pageSize || this.setPageSize();
    }]).then(function() {
      var t3 = { position: "relative", display: "inline-block", width: (typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth) : this.opt.windowWidth) + "px", left: 0, right: 0, top: 0, margin: "auto", backgroundColor: this.opt.backgroundColor }, e3 = function t4(e4, r3) {
        for (var n2 = e4.nodeType === 3 ? document.createTextNode(e4.nodeValue) : e4.cloneNode(false), i3 = e4.firstChild; i3; i3 = i3.nextSibling)
          r3 !== true && i3.nodeType === 1 && i3.nodeName === "SCRIPT" || n2.appendChild(t4(i3, r3));
        return e4.nodeType === 1 && (e4.nodeName === "CANVAS" ? (n2.width = e4.width, n2.height = e4.height, n2.getContext("2d").drawImage(e4, 0, 0)) : e4.nodeName !== "TEXTAREA" && e4.nodeName !== "SELECT" || (n2.value = e4.value), n2.addEventListener("load", function() {
          n2.scrollTop = e4.scrollTop, n2.scrollLeft = e4.scrollLeft;
        }, true)), n2;
      }(this.prop.src, this.opt.html2canvas.javascriptEnabled);
      e3.tagName === "BODY" && (t3.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + "px"), this.prop.overlay = o2("div", { className: "html2pdf__overlay", style: { position: "fixed", overflow: "hidden", zIndex: 1e3, left: "-100000px", right: 0, bottom: 0, top: 0 } }), this.prop.container = o2("div", { className: "html2pdf__container", style: t3 }), this.prop.container.appendChild(e3), this.prop.container.firstChild.appendChild(o2("div", { style: { clear: "both", border: "0 none transparent", margin: 0, padding: 0, height: 0 } })), this.prop.container.style.float = "none", this.prop.overlay.appendChild(this.prop.container), document.body.appendChild(this.prop.overlay), this.prop.container.firstChild.style.position = "relative", this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + "px";
    });
  }, s2.prototype.toCanvas = function() {
    var t3 = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(t3).then(r2).then(function(t4) {
      var e3 = Object.assign({}, this.opt.html2canvas);
      return delete e3.onrendered, t4(this.prop.container, e3);
    }).then(function(t4) {
      (this.opt.html2canvas.onrendered || function() {
      })(t4), this.prop.canvas = t4, document.body.removeChild(this.prop.overlay);
    });
  }, s2.prototype.toContext2d = function() {
    var t3 = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(t3).then(r2).then(function(t4) {
      var e3 = this.opt.jsPDF, r3 = this.opt.fontFaces, n2 = typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? 1 : this.opt.width / this.opt.windowWidth, i3 = Object.assign({ async: true, allowTaint: true, scale: n2, scrollX: this.opt.scrollX || 0, scrollY: this.opt.scrollY || 0, backgroundColor: "#ffffff", imageTimeout: 15e3, logging: true, proxy: null, removeContainer: true, foreignObjectRendering: false, useCORS: false }, this.opt.html2canvas);
      if (delete i3.onrendered, e3.context2d.autoPaging = this.opt.autoPaging === void 0 || this.opt.autoPaging, e3.context2d.posX = this.opt.x, e3.context2d.posY = this.opt.y, e3.context2d.margin = this.opt.margin, e3.context2d.fontFaces = r3, r3)
        for (var a3 = 0; a3 < r3.length; ++a3) {
          var o3 = r3[a3], s3 = o3.src.find(function(t5) {
            return t5.format === "truetype";
          });
          s3 && e3.addFont(s3.url, o3.ref.name, o3.ref.style);
        }
      return i3.windowHeight = i3.windowHeight || 0, i3.windowHeight = i3.windowHeight == 0 ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : i3.windowHeight, e3.context2d.save(true), t4(this.prop.container, i3);
    }).then(function(t4) {
      this.opt.jsPDF.context2d.restore(true), (this.opt.html2canvas.onrendered || function() {
      })(t4), this.prop.canvas = t4, document.body.removeChild(this.prop.overlay);
    });
  }, s2.prototype.toImg = function() {
    return this.thenList([function() {
      return this.prop.canvas || this.toCanvas();
    }]).then(function() {
      var t3 = this.prop.canvas.toDataURL("image/" + this.opt.image.type, this.opt.image.quality);
      this.prop.img = document.createElement("img"), this.prop.img.src = t3;
    });
  }, s2.prototype.toPdf = function() {
    return this.thenList([function() {
      return this.toContext2d();
    }]).then(function() {
      this.prop.pdf = this.prop.pdf || this.opt.jsPDF;
    });
  }, s2.prototype.output = function(t3, e3, r3) {
    return (r3 = r3 || "pdf").toLowerCase() === "img" || r3.toLowerCase() === "image" ? this.outputImg(t3, e3) : this.outputPdf(t3, e3);
  }, s2.prototype.outputPdf = function(t3, e3) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      return this.prop.pdf.output(t3, e3);
    });
  }, s2.prototype.outputImg = function(t3) {
    return this.thenList([function() {
      return this.prop.img || this.toImg();
    }]).then(function() {
      switch (t3) {
        case void 0:
        case "img":
          return this.prop.img;
        case "datauristring":
        case "dataurlstring":
          return this.prop.img.src;
        case "datauri":
        case "dataurl":
          return document.location.href = this.prop.img.src;
        default:
          throw 'Image output type "' + t3 + '" is not supported.';
      }
    });
  }, s2.prototype.save = function(t3) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).set(t3 ? { filename: t3 } : null).then(function() {
      this.prop.pdf.save(this.opt.filename);
    });
  }, s2.prototype.doCallback = function() {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      this.prop.callback(this.prop.pdf);
    });
  }, s2.prototype.set = function(t3) {
    if (a2(t3) !== "object")
      return this;
    var e3 = Object.keys(t3 || {}).map(function(e4) {
      if (e4 in s2.template.prop)
        return function() {
          this.prop[e4] = t3[e4];
        };
      switch (e4) {
        case "margin":
          return this.setMargin.bind(this, t3.margin);
        case "jsPDF":
          return function() {
            return this.opt.jsPDF = t3.jsPDF, this.setPageSize();
          };
        case "pageSize":
          return this.setPageSize.bind(this, t3.pageSize);
        default:
          return function() {
            this.opt[e4] = t3[e4];
          };
      }
    }, this);
    return this.then(function() {
      return this.thenList(e3);
    });
  }, s2.prototype.get = function(t3, e3) {
    return this.then(function() {
      var r3 = t3 in s2.template.prop ? this.prop[t3] : this.opt[t3];
      return e3 ? e3(r3) : r3;
    });
  }, s2.prototype.setMargin = function(t3) {
    return this.then(function() {
      switch (a2(t3)) {
        case "number":
          t3 = [t3, t3, t3, t3];
        case "array":
          if (t3.length === 2 && (t3 = [t3[0], t3[1], t3[0], t3[1]]), t3.length === 4)
            break;
        default:
          return this.error("Invalid margin array.");
      }
      this.opt.margin = t3;
    }).then(this.setPageSize);
  }, s2.prototype.setPageSize = function(t3) {
    function e3(t4, e4) {
      return Math.floor(t4 * e4 / 72 * 96);
    }
    return this.then(function() {
      (t3 = t3 || E$1.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner") || (t3.inner = { width: t3.width - this.opt.margin[1] - this.opt.margin[3], height: t3.height - this.opt.margin[0] - this.opt.margin[2] }, t3.inner.px = { width: e3(t3.inner.width, t3.k), height: e3(t3.inner.height, t3.k) }, t3.inner.ratio = t3.inner.height / t3.inner.width), this.prop.pageSize = t3;
    });
  }, s2.prototype.setProgress = function(t3, e3, r3, n2) {
    return t3 != null && (this.progress.val = t3), e3 != null && (this.progress.state = e3), r3 != null && (this.progress.n = r3), n2 != null && (this.progress.stack = n2), this.progress.ratio = this.progress.val / this.progress.state, this;
  }, s2.prototype.updateProgress = function(t3, e3, r3, n2) {
    return this.setProgress(t3 ? this.progress.val + t3 : null, e3 || null, r3 ? this.progress.n + r3 : null, n2 ? this.progress.stack.concat(n2) : null);
  }, s2.prototype.then = function(t3, e3) {
    var r3 = this;
    return this.thenCore(t3, e3, function(t4, e4) {
      return r3.updateProgress(null, null, 1, [t4]), Promise.prototype.then.call(this, function(e5) {
        return r3.updateProgress(null, t4), e5;
      }).then(t4, e4).then(function(t5) {
        return r3.updateProgress(1), t5;
      });
    });
  }, s2.prototype.thenCore = function(t3, e3, r3) {
    r3 = r3 || Promise.prototype.then;
    t3 && (t3 = t3.bind(this)), e3 && (e3 = e3.bind(this));
    var n2 = Promise.toString().indexOf("[native code]") !== -1 && Promise.name === "Promise" ? this : s2.convert(Object.assign({}, this), Promise.prototype), i3 = r3.call(n2, t3, e3);
    return s2.convert(i3, this.__proto__);
  }, s2.prototype.thenExternal = function(t3, e3) {
    return Promise.prototype.then.call(this, t3, e3);
  }, s2.prototype.thenList = function(t3) {
    var e3 = this;
    return t3.forEach(function(t4) {
      e3 = e3.thenCore(t4);
    }), e3;
  }, s2.prototype.catch = function(t3) {
    t3 && (t3 = t3.bind(this));
    var e3 = Promise.prototype.catch.call(this, t3);
    return s2.convert(e3, this);
  }, s2.prototype.catchExternal = function(t3) {
    return Promise.prototype.catch.call(this, t3);
  }, s2.prototype.error = function(t3) {
    return this.then(function() {
      throw new Error(t3);
    });
  }, s2.prototype.using = s2.prototype.set, s2.prototype.saveAs = s2.prototype.save, s2.prototype.export = s2.prototype.output, s2.prototype.run = s2.prototype.then, E$1.getPageSize = function(e3, r3, n2) {
    if (_typeof$2(e3) === "object") {
      var i3 = e3;
      e3 = i3.orientation, r3 = i3.unit || r3, n2 = i3.format || n2;
    }
    r3 = r3 || "mm", n2 = n2 || "a4", e3 = ("" + (e3 || "P")).toLowerCase();
    var a3, o3 = ("" + n2).toLowerCase(), s3 = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
    switch (r3) {
      case "pt":
        a3 = 1;
        break;
      case "mm":
        a3 = 72 / 25.4;
        break;
      case "cm":
        a3 = 72 / 2.54;
        break;
      case "in":
        a3 = 72;
        break;
      case "px":
        a3 = 0.75;
        break;
      case "pc":
      case "em":
        a3 = 12;
        break;
      case "ex":
        a3 = 6;
        break;
      default:
        throw "Invalid unit: " + r3;
    }
    var c2, u2 = 0, h2 = 0;
    if (s3.hasOwnProperty(o3))
      u2 = s3[o3][1] / a3, h2 = s3[o3][0] / a3;
    else
      try {
        u2 = n2[1], h2 = n2[0];
      } catch (t3) {
        throw new Error("Invalid format: " + n2);
      }
    if (e3 === "p" || e3 === "portrait")
      e3 = "p", h2 > u2 && (c2 = h2, h2 = u2, u2 = c2);
    else {
      if (e3 !== "l" && e3 !== "landscape")
        throw "Invalid orientation: " + e3;
      e3 = "l", u2 > h2 && (c2 = h2, h2 = u2, u2 = c2);
    }
    return { width: h2, height: u2, unit: r3, k: a3, orientation: e3 };
  }, e2.html = function(t3, e3) {
    (e3 = e3 || {}).callback = e3.callback || function() {
    }, e3.html2canvas = e3.html2canvas || {}, e3.html2canvas.canvas = e3.html2canvas.canvas || this.canvas, e3.jsPDF = e3.jsPDF || this, e3.fontFaces = e3.fontFaces ? e3.fontFaces.map(jt) : null;
    var r3 = new s2(e3);
    return e3.worker ? r3 : r3.from(t3).doCallback();
  };
}(E$1.API), E$1.API.addJS = function(t3) {
  return Ht = t3, this.internal.events.subscribe("postPutResources", function() {
    zt = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/Names [(EmbeddedJS) " + (zt + 1) + " 0 R]"), this.internal.out(">>"), this.internal.out("endobj"), Ut = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /JavaScript"), this.internal.out("/JS (" + Ht + ")"), this.internal.out(">>"), this.internal.out("endobj");
  }), this.internal.events.subscribe("putCatalog", function() {
    zt !== void 0 && Ut !== void 0 && this.internal.out("/Names <</JavaScript " + zt + " 0 R>>");
  }), this;
}, function(t3) {
  var e2;
  t3.events.push(["postPutResources", function() {
    var t4 = this, r2 = /^(\d+) 0 obj$/;
    if (this.outline.root.children.length > 0)
      for (var n2 = t4.outline.render().split(/\r\n/), i2 = 0; i2 < n2.length; i2++) {
        var a2 = n2[i2], o2 = r2.exec(a2);
        if (o2 != null) {
          var s2 = o2[1];
          t4.internal.newObjectDeferredBegin(s2, false);
        }
        t4.internal.write(a2);
      }
    if (this.outline.createNamedDestinations) {
      var c2 = this.internal.pages.length, u2 = [];
      for (i2 = 0; i2 < c2; i2++) {
        var h2 = t4.internal.newObject();
        u2.push(h2);
        var l2 = t4.internal.getPageInfo(i2 + 1);
        t4.internal.write("<< /D[" + l2.objId + " 0 R /XYZ null null null]>> endobj");
      }
      var f2 = t4.internal.newObject();
      t4.internal.write("<< /Names [ ");
      for (i2 = 0; i2 < u2.length; i2++)
        t4.internal.write("(page_" + (i2 + 1) + ")" + u2[i2] + " 0 R");
      t4.internal.write(" ] >>", "endobj"), e2 = t4.internal.newObject(), t4.internal.write("<< /Dests " + f2 + " 0 R"), t4.internal.write(">>", "endobj");
    }
  }]), t3.events.push(["putCatalog", function() {
    this.outline.root.children.length > 0 && (this.internal.write("/Outlines", this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && this.internal.write("/Names " + e2 + " 0 R"));
  }]), t3.events.push(["initialized", function() {
    var t4 = this;
    t4.outline = { createNamedDestinations: false, root: { children: [] } }, t4.outline.add = function(t5, e3, r2) {
      var n2 = { title: e3, options: r2, children: [] };
      return t5 == null && (t5 = this.root), t5.children.push(n2), n2;
    }, t4.outline.render = function() {
      return this.ctx = {}, this.ctx.val = "", this.ctx.pdf = t4, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val;
    }, t4.outline.genIds_r = function(e3) {
      e3.id = t4.internal.newObjectDeferred();
      for (var r2 = 0; r2 < e3.children.length; r2++)
        this.genIds_r(e3.children[r2]);
    }, t4.outline.renderRoot = function(t5) {
      this.objStart(t5), this.line("/Type /Outlines"), t5.children.length > 0 && (this.line("/First " + this.makeRef(t5.children[0])), this.line("/Last " + this.makeRef(t5.children[t5.children.length - 1]))), this.line("/Count " + this.count_r({ count: 0 }, t5)), this.objEnd();
    }, t4.outline.renderItems = function(e3) {
      for (var r2 = this.ctx.pdf.internal.getVerticalCoordinateString, n2 = 0; n2 < e3.children.length; n2++) {
        var i2 = e3.children[n2];
        this.objStart(i2), this.line("/Title " + this.makeString(i2.title)), this.line("/Parent " + this.makeRef(e3)), n2 > 0 && this.line("/Prev " + this.makeRef(e3.children[n2 - 1])), n2 < e3.children.length - 1 && this.line("/Next " + this.makeRef(e3.children[n2 + 1])), i2.children.length > 0 && (this.line("/First " + this.makeRef(i2.children[0])), this.line("/Last " + this.makeRef(i2.children[i2.children.length - 1])));
        var a2 = this.count = this.count_r({ count: 0 }, i2);
        if (a2 > 0 && this.line("/Count " + a2), i2.options && i2.options.pageNumber) {
          var o2 = t4.internal.getPageInfo(i2.options.pageNumber);
          this.line("/Dest [" + o2.objId + " 0 R /XYZ 0 " + r2(0) + " 0]");
        }
        this.objEnd();
      }
      for (var s2 = 0; s2 < e3.children.length; s2++)
        this.renderItems(e3.children[s2]);
    }, t4.outline.line = function(t5) {
      this.ctx.val += t5 + "\r\n";
    }, t4.outline.makeRef = function(t5) {
      return t5.id + " 0 R";
    }, t4.outline.makeString = function(e3) {
      return "(" + t4.internal.pdfEscape(e3) + ")";
    }, t4.outline.objStart = function(t5) {
      this.ctx.val += "\r\n" + t5.id + " 0 obj\r\n<<\r\n";
    }, t4.outline.objEnd = function() {
      this.ctx.val += ">> \r\nendobj\r\n";
    }, t4.outline.count_r = function(t5, e3) {
      for (var r2 = 0; r2 < e3.children.length; r2++)
        t5.count++, this.count_r(t5, e3.children[r2]);
      return t5.count;
    };
  }]);
}(E$1.API), function(t3) {
  var e2 = [192, 193, 194, 195, 196, 197, 198, 199];
  t3.processJPEG = function(t4, r2, n2, i2, a2, o2) {
    var s2, c2 = this.decode.DCT_DECODE, u2 = null;
    if (typeof t4 == "string" || this.__addimage__.isArrayBuffer(t4) || this.__addimage__.isArrayBufferView(t4)) {
      switch (t4 = a2 || t4, t4 = this.__addimage__.isArrayBuffer(t4) ? new Uint8Array(t4) : t4, (s2 = function(t5) {
        for (var r3, n3 = 256 * t5.charCodeAt(4) + t5.charCodeAt(5), i3 = t5.length, a3 = { width: 0, height: 0, numcomponents: 1 }, o3 = 4; o3 < i3; o3 += 2) {
          if (o3 += n3, e2.indexOf(t5.charCodeAt(o3 + 1)) !== -1) {
            r3 = 256 * t5.charCodeAt(o3 + 5) + t5.charCodeAt(o3 + 6), a3 = { width: 256 * t5.charCodeAt(o3 + 7) + t5.charCodeAt(o3 + 8), height: r3, numcomponents: t5.charCodeAt(o3 + 9) };
            break;
          }
          n3 = 256 * t5.charCodeAt(o3 + 2) + t5.charCodeAt(o3 + 3);
        }
        return a3;
      }(t4 = this.__addimage__.isArrayBufferView(t4) ? this.__addimage__.arrayBufferToBinaryString(t4) : t4)).numcomponents) {
        case 1:
          o2 = this.color_spaces.DEVICE_GRAY;
          break;
        case 4:
          o2 = this.color_spaces.DEVICE_CMYK;
          break;
        case 3:
          o2 = this.color_spaces.DEVICE_RGB;
      }
      u2 = { data: t4, width: s2.width, height: s2.height, colorSpace: o2, bitsPerComponent: 8, filter: c2, index: r2, alias: n2 };
    }
    return u2;
  };
}(E$1.API);
var Vt, Gt, Yt, Jt, Xt, Kt = function() {
  var t3, e2, i2;
  function a2(t4) {
    var e3, r2, n2, i3, a3, o3, s2, c2, u2, h2, l2, f2, d2, p5;
    for (this.data = t4, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, o3 = null; ; ) {
      switch (e3 = this.readUInt32(), u2 = function() {
        var t5, e4;
        for (e4 = [], t5 = 0; t5 < 4; ++t5)
          e4.push(String.fromCharCode(this.data[this.pos++]));
        return e4;
      }.call(this).join("")) {
        case "IHDR":
          this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
          break;
        case "acTL":
          this.animation = { numFrames: this.readUInt32(), numPlays: this.readUInt32() || 1 / 0, frames: [] };
          break;
        case "PLTE":
          this.palette = this.read(e3);
          break;
        case "fcTL":
          o3 && this.animation.frames.push(o3), this.pos += 4, o3 = { width: this.readUInt32(), height: this.readUInt32(), xOffset: this.readUInt32(), yOffset: this.readUInt32() }, a3 = this.readUInt16(), i3 = this.readUInt16() || 100, o3.delay = 1e3 * a3 / i3, o3.disposeOp = this.data[this.pos++], o3.blendOp = this.data[this.pos++], o3.data = [];
          break;
        case "IDAT":
        case "fdAT":
          for (u2 === "fdAT" && (this.pos += 4, e3 -= 4), t4 = (o3 != null ? o3.data : void 0) || this.imgData, f2 = 0; 0 <= e3 ? f2 < e3 : f2 > e3; 0 <= e3 ? ++f2 : --f2)
            t4.push(this.data[this.pos++]);
          break;
        case "tRNS":
          switch (this.transparency = {}, this.colorType) {
            case 3:
              if (n2 = this.palette.length / 3, this.transparency.indexed = this.read(e3), this.transparency.indexed.length > n2)
                throw new Error("More transparent colors than palette size");
              if ((h2 = n2 - this.transparency.indexed.length) > 0)
                for (d2 = 0; 0 <= h2 ? d2 < h2 : d2 > h2; 0 <= h2 ? ++d2 : --d2)
                  this.transparency.indexed.push(255);
              break;
            case 0:
              this.transparency.grayscale = this.read(e3)[0];
              break;
            case 2:
              this.transparency.rgb = this.read(e3);
          }
          break;
        case "tEXt":
          s2 = (l2 = this.read(e3)).indexOf(0), c2 = String.fromCharCode.apply(String, l2.slice(0, s2)), this.text[c2] = String.fromCharCode.apply(String, l2.slice(s2 + 1));
          break;
        case "IEND":
          return o3 && this.animation.frames.push(o3), this.colors = function() {
            switch (this.colorType) {
              case 0:
              case 3:
              case 4:
                return 1;
              case 2:
              case 6:
                return 3;
            }
          }.call(this), this.hasAlphaChannel = (p5 = this.colorType) === 4 || p5 === 6, r2 = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * r2, this.colorSpace = function() {
            switch (this.colors) {
              case 1:
                return "DeviceGray";
              case 3:
                return "DeviceRGB";
            }
          }.call(this), void (this.imgData = new Uint8Array(this.imgData));
        default:
          this.pos += e3;
      }
      if (this.pos += 4, this.pos > this.data.length)
        throw new Error("Incomplete or corrupt PNG file");
    }
  }
  a2.prototype.read = function(t4) {
    var e3, r2;
    for (r2 = [], e3 = 0; 0 <= t4 ? e3 < t4 : e3 > t4; 0 <= t4 ? ++e3 : --e3)
      r2.push(this.data[this.pos++]);
    return r2;
  }, a2.prototype.readUInt32 = function() {
    return this.data[this.pos++] << 24 | this.data[this.pos++] << 16 | this.data[this.pos++] << 8 | this.data[this.pos++];
  }, a2.prototype.readUInt16 = function() {
    return this.data[this.pos++] << 8 | this.data[this.pos++];
  }, a2.prototype.decodePixels = function(t4) {
    var e3 = this.pixelBitlength / 8, n2 = new Uint8Array(this.width * this.height * e3), i3 = 0, a3 = this;
    if (t4 == null && (t4 = this.imgData), t4.length === 0)
      return new Uint8Array(0);
    function o3(r2, o4, s2, c2) {
      var u2, h2, l2, f2, d2, p5, g2, m2, v2, b2, y2, w2, N2, L2, A2, x2, S2, _2, P2, k2, I2, F2 = Math.ceil((a3.width - r2) / s2), C2 = Math.ceil((a3.height - o4) / c2), j2 = a3.width == F2 && a3.height == C2;
      for (L2 = e3 * F2, w2 = j2 ? n2 : new Uint8Array(L2 * C2), p5 = t4.length, N2 = 0, h2 = 0; N2 < C2 && i3 < p5; ) {
        switch (t4[i3++]) {
          case 0:
            for (f2 = S2 = 0; S2 < L2; f2 = S2 += 1)
              w2[h2++] = t4[i3++];
            break;
          case 1:
            for (f2 = _2 = 0; _2 < L2; f2 = _2 += 1)
              u2 = t4[i3++], d2 = f2 < e3 ? 0 : w2[h2 - e3], w2[h2++] = (u2 + d2) % 256;
            break;
          case 2:
            for (f2 = P2 = 0; P2 < L2; f2 = P2 += 1)
              u2 = t4[i3++], l2 = (f2 - f2 % e3) / e3, A2 = N2 && w2[(N2 - 1) * L2 + l2 * e3 + f2 % e3], w2[h2++] = (A2 + u2) % 256;
            break;
          case 3:
            for (f2 = k2 = 0; k2 < L2; f2 = k2 += 1)
              u2 = t4[i3++], l2 = (f2 - f2 % e3) / e3, d2 = f2 < e3 ? 0 : w2[h2 - e3], A2 = N2 && w2[(N2 - 1) * L2 + l2 * e3 + f2 % e3], w2[h2++] = (u2 + Math.floor((d2 + A2) / 2)) % 256;
            break;
          case 4:
            for (f2 = I2 = 0; I2 < L2; f2 = I2 += 1)
              u2 = t4[i3++], l2 = (f2 - f2 % e3) / e3, d2 = f2 < e3 ? 0 : w2[h2 - e3], N2 === 0 ? A2 = x2 = 0 : (A2 = w2[(N2 - 1) * L2 + l2 * e3 + f2 % e3], x2 = l2 && w2[(N2 - 1) * L2 + (l2 - 1) * e3 + f2 % e3]), g2 = d2 + A2 - x2, m2 = Math.abs(g2 - d2), b2 = Math.abs(g2 - A2), y2 = Math.abs(g2 - x2), v2 = m2 <= b2 && m2 <= y2 ? d2 : b2 <= y2 ? A2 : x2, w2[h2++] = (u2 + v2) % 256;
            break;
          default:
            throw new Error("Invalid filter algorithm: " + t4[i3 - 1]);
        }
        if (!j2) {
          var O2 = ((o4 + N2 * c2) * a3.width + r2) * e3, B3 = N2 * L2;
          for (f2 = 0; f2 < F2; f2 += 1) {
            for (var M2 = 0; M2 < e3; M2 += 1)
              n2[O2++] = w2[B3++];
            O2 += (s2 - 1) * e3;
          }
        }
        N2++;
      }
    }
    return t4 = unzlibSync(t4), a3.interlaceMethod == 1 ? (o3(0, 0, 8, 8), o3(4, 0, 8, 8), o3(0, 4, 4, 8), o3(2, 0, 4, 4), o3(0, 2, 2, 4), o3(1, 0, 2, 2), o3(0, 1, 1, 2)) : o3(0, 0, 1, 1), n2;
  }, a2.prototype.decodePalette = function() {
    var t4, e3, r2, n2, i3, a3, o3, s2, c2;
    for (r2 = this.palette, a3 = this.transparency.indexed || [], i3 = new Uint8Array((a3.length || 0) + r2.length), n2 = 0, t4 = 0, e3 = o3 = 0, s2 = r2.length; o3 < s2; e3 = o3 += 3)
      i3[n2++] = r2[e3], i3[n2++] = r2[e3 + 1], i3[n2++] = r2[e3 + 2], i3[n2++] = (c2 = a3[t4++]) != null ? c2 : 255;
    return i3;
  }, a2.prototype.copyToImageData = function(t4, e3) {
    var r2, n2, i3, a3, o3, s2, c2, u2, h2, l2, f2;
    if (n2 = this.colors, h2 = null, r2 = this.hasAlphaChannel, this.palette.length && (h2 = (f2 = this._decodedPalette) != null ? f2 : this._decodedPalette = this.decodePalette(), n2 = 4, r2 = true), u2 = (i3 = t4.data || t4).length, o3 = h2 || e3, a3 = s2 = 0, n2 === 1)
      for (; a3 < u2; )
        c2 = h2 ? 4 * e3[a3 / 4] : s2, l2 = o3[c2++], i3[a3++] = l2, i3[a3++] = l2, i3[a3++] = l2, i3[a3++] = r2 ? o3[c2++] : 255, s2 = c2;
    else
      for (; a3 < u2; )
        c2 = h2 ? 4 * e3[a3 / 4] : s2, i3[a3++] = o3[c2++], i3[a3++] = o3[c2++], i3[a3++] = o3[c2++], i3[a3++] = r2 ? o3[c2++] : 255, s2 = c2;
  }, a2.prototype.decode = function() {
    var t4;
    return t4 = new Uint8Array(this.width * this.height * 4), this.copyToImageData(t4, this.decodePixels()), t4;
  };
  var o2 = function() {
    if (Object.prototype.toString.call(n$1) === "[object Window]") {
      try {
        e2 = n$1.document.createElement("canvas"), i2 = e2.getContext("2d");
      } catch (t4) {
        return false;
      }
      return true;
    }
    return false;
  };
  return o2(), t3 = function(t4) {
    var r2;
    if (o2() === true)
      return i2.width = t4.width, i2.height = t4.height, i2.clearRect(0, 0, t4.width, t4.height), i2.putImageData(t4, 0, 0), (r2 = new Image()).src = e2.toDataURL(), r2;
    throw new Error("This method requires a Browser with Canvas-capability.");
  }, a2.prototype.decodeFrames = function(e3) {
    var r2, n2, i3, a3, o3, s2, c2, u2;
    if (this.animation) {
      for (u2 = [], n2 = o3 = 0, s2 = (c2 = this.animation.frames).length; o3 < s2; n2 = ++o3)
        r2 = c2[n2], i3 = e3.createImageData(r2.width, r2.height), a3 = this.decodePixels(new Uint8Array(r2.data)), this.copyToImageData(i3, a3), r2.imageData = i3, u2.push(r2.image = t3(i3));
      return u2;
    }
  }, a2.prototype.renderFrame = function(t4, e3) {
    var r2, n2, i3;
    return r2 = (n2 = this.animation.frames)[e3], i3 = n2[e3 - 1], e3 === 0 && t4.clearRect(0, 0, this.width, this.height), (i3 != null ? i3.disposeOp : void 0) === 1 ? t4.clearRect(i3.xOffset, i3.yOffset, i3.width, i3.height) : (i3 != null ? i3.disposeOp : void 0) === 2 && t4.putImageData(i3.imageData, i3.xOffset, i3.yOffset), r2.blendOp === 0 && t4.clearRect(r2.xOffset, r2.yOffset, r2.width, r2.height), t4.drawImage(r2.image, r2.xOffset, r2.yOffset);
  }, a2.prototype.animate = function(t4) {
    var e3, r2, n2, i3, a3, o3, s2 = this;
    return r2 = 0, o3 = this.animation, i3 = o3.numFrames, n2 = o3.frames, a3 = o3.numPlays, (e3 = function() {
      var o4, c2;
      if (o4 = r2++ % i3, c2 = n2[o4], s2.renderFrame(t4, o4), i3 > 1 && r2 / i3 < a3)
        return s2.animation._timeout = setTimeout(e3, c2.delay);
    })();
  }, a2.prototype.stopAnimation = function() {
    var t4;
    return clearTimeout((t4 = this.animation) != null ? t4._timeout : void 0);
  }, a2.prototype.render = function(t4) {
    var e3, r2;
    return t4._png && t4._png.stopAnimation(), t4._png = this, t4.width = this.width, t4.height = this.height, e3 = t4.getContext("2d"), this.animation ? (this.decodeFrames(e3), this.animate(e3)) : (r2 = e3.createImageData(this.width, this.height), this.copyToImageData(r2, this.decodePixels()), e3.putImageData(r2, 0, 0));
  }, a2;
}();
/**
 * @license
 *
 * Copyright (c) 2014 James Robb, https://github.com/jamesbrobb
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
/**
 * @license
 * (c) Dean McNamee <dean@gmail.com>, 2013.
 *
 * https://github.com/deanm/omggif
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
 * including animation and compression.  It does not rely on any specific
 * underlying system, so should run in the browser, Node, or Plask.
 */
function Zt(t3) {
  var e2 = 0;
  if (t3[e2++] !== 71 || t3[e2++] !== 73 || t3[e2++] !== 70 || t3[e2++] !== 56 || (t3[e2++] + 1 & 253) != 56 || t3[e2++] !== 97)
    throw new Error("Invalid GIF 87a/89a header.");
  var r2 = t3[e2++] | t3[e2++] << 8, n2 = t3[e2++] | t3[e2++] << 8, i2 = t3[e2++], a2 = i2 >> 7, o2 = 1 << (7 & i2) + 1;
  t3[e2++];
  t3[e2++];
  var s2 = null, c2 = null;
  a2 && (s2 = e2, c2 = o2, e2 += 3 * o2);
  var u2 = true, h2 = [], l2 = 0, f2 = null, d2 = 0, p5 = null;
  for (this.width = r2, this.height = n2; u2 && e2 < t3.length; )
    switch (t3[e2++]) {
      case 33:
        switch (t3[e2++]) {
          case 255:
            if (t3[e2] !== 11 || t3[e2 + 1] == 78 && t3[e2 + 2] == 69 && t3[e2 + 3] == 84 && t3[e2 + 4] == 83 && t3[e2 + 5] == 67 && t3[e2 + 6] == 65 && t3[e2 + 7] == 80 && t3[e2 + 8] == 69 && t3[e2 + 9] == 50 && t3[e2 + 10] == 46 && t3[e2 + 11] == 48 && t3[e2 + 12] == 3 && t3[e2 + 13] == 1 && t3[e2 + 16] == 0)
              e2 += 14, p5 = t3[e2++] | t3[e2++] << 8, e2++;
            else
              for (e2 += 12; ; ) {
                if (!((P2 = t3[e2++]) >= 0))
                  throw Error("Invalid block size");
                if (P2 === 0)
                  break;
                e2 += P2;
              }
            break;
          case 249:
            if (t3[e2++] !== 4 || t3[e2 + 4] !== 0)
              throw new Error("Invalid graphics extension block.");
            var g2 = t3[e2++];
            l2 = t3[e2++] | t3[e2++] << 8, f2 = t3[e2++], (1 & g2) == 0 && (f2 = null), d2 = g2 >> 2 & 7, e2++;
            break;
          case 254:
            for (; ; ) {
              if (!((P2 = t3[e2++]) >= 0))
                throw Error("Invalid block size");
              if (P2 === 0)
                break;
              e2 += P2;
            }
            break;
          default:
            throw new Error("Unknown graphic control label: 0x" + t3[e2 - 1].toString(16));
        }
        break;
      case 44:
        var m2 = t3[e2++] | t3[e2++] << 8, v2 = t3[e2++] | t3[e2++] << 8, b2 = t3[e2++] | t3[e2++] << 8, y2 = t3[e2++] | t3[e2++] << 8, w2 = t3[e2++], N2 = w2 >> 6 & 1, L2 = 1 << (7 & w2) + 1, A2 = s2, x2 = c2, S2 = false;
        if (w2 >> 7) {
          S2 = true;
          A2 = e2, x2 = L2, e2 += 3 * L2;
        }
        var _2 = e2;
        for (e2++; ; ) {
          var P2;
          if (!((P2 = t3[e2++]) >= 0))
            throw Error("Invalid block size");
          if (P2 === 0)
            break;
          e2 += P2;
        }
        h2.push({ x: m2, y: v2, width: b2, height: y2, has_local_palette: S2, palette_offset: A2, palette_size: x2, data_offset: _2, data_length: e2 - _2, transparent_index: f2, interlaced: !!N2, delay: l2, disposal: d2 });
        break;
      case 59:
        u2 = false;
        break;
      default:
        throw new Error("Unknown gif block: 0x" + t3[e2 - 1].toString(16));
    }
  this.numFrames = function() {
    return h2.length;
  }, this.loopCount = function() {
    return p5;
  }, this.frameInfo = function(t4) {
    if (t4 < 0 || t4 >= h2.length)
      throw new Error("Frame index out of range.");
    return h2[t4];
  }, this.decodeAndBlitFrameBGRA = function(e3, n3) {
    var i3 = this.frameInfo(e3), a3 = i3.width * i3.height, o3 = new Uint8Array(a3);
    $t(t3, i3.data_offset, o3, a3);
    var s3 = i3.palette_offset, c3 = i3.transparent_index;
    c3 === null && (c3 = 256);
    var u3 = i3.width, h3 = r2 - u3, l3 = u3, f3 = 4 * (i3.y * r2 + i3.x), d3 = 4 * ((i3.y + i3.height) * r2 + i3.x), p6 = f3, g3 = 4 * h3;
    i3.interlaced === true && (g3 += 4 * r2 * 7);
    for (var m3 = 8, v3 = 0, b3 = o3.length; v3 < b3; ++v3) {
      var y3 = o3[v3];
      if (l3 === 0 && (l3 = u3, (p6 += g3) >= d3 && (g3 = 4 * h3 + 4 * r2 * (m3 - 1), p6 = f3 + (u3 + h3) * (m3 << 1), m3 >>= 1)), y3 === c3)
        p6 += 4;
      else {
        var w3 = t3[s3 + 3 * y3], N3 = t3[s3 + 3 * y3 + 1], L3 = t3[s3 + 3 * y3 + 2];
        n3[p6++] = L3, n3[p6++] = N3, n3[p6++] = w3, n3[p6++] = 255;
      }
      --l3;
    }
  }, this.decodeAndBlitFrameRGBA = function(e3, n3) {
    var i3 = this.frameInfo(e3), a3 = i3.width * i3.height, o3 = new Uint8Array(a3);
    $t(t3, i3.data_offset, o3, a3);
    var s3 = i3.palette_offset, c3 = i3.transparent_index;
    c3 === null && (c3 = 256);
    var u3 = i3.width, h3 = r2 - u3, l3 = u3, f3 = 4 * (i3.y * r2 + i3.x), d3 = 4 * ((i3.y + i3.height) * r2 + i3.x), p6 = f3, g3 = 4 * h3;
    i3.interlaced === true && (g3 += 4 * r2 * 7);
    for (var m3 = 8, v3 = 0, b3 = o3.length; v3 < b3; ++v3) {
      var y3 = o3[v3];
      if (l3 === 0 && (l3 = u3, (p6 += g3) >= d3 && (g3 = 4 * h3 + 4 * r2 * (m3 - 1), p6 = f3 + (u3 + h3) * (m3 << 1), m3 >>= 1)), y3 === c3)
        p6 += 4;
      else {
        var w3 = t3[s3 + 3 * y3], N3 = t3[s3 + 3 * y3 + 1], L3 = t3[s3 + 3 * y3 + 2];
        n3[p6++] = w3, n3[p6++] = N3, n3[p6++] = L3, n3[p6++] = 255;
      }
      --l3;
    }
  };
}
function $t(t3, e2, r2, n2) {
  for (var i2 = t3[e2++], o2 = 1 << i2, s2 = o2 + 1, c2 = s2 + 1, u2 = i2 + 1, h2 = (1 << u2) - 1, l2 = 0, f2 = 0, d2 = 0, p5 = t3[e2++], g2 = new Int32Array(4096), m2 = null; ; ) {
    for (; l2 < 16 && p5 !== 0; )
      f2 |= t3[e2++] << l2, l2 += 8, p5 === 1 ? p5 = t3[e2++] : --p5;
    if (l2 < u2)
      break;
    var v2 = f2 & h2;
    if (f2 >>= u2, l2 -= u2, v2 !== o2) {
      if (v2 === s2)
        break;
      for (var b2 = v2 < c2 ? v2 : m2, y2 = 0, w2 = b2; w2 > o2; )
        w2 = g2[w2] >> 8, ++y2;
      var N2 = w2;
      if (d2 + y2 + (b2 !== v2 ? 1 : 0) > n2)
        return void a$2.log("Warning, gif stream longer than expected.");
      r2[d2++] = N2;
      var L2 = d2 += y2;
      for (b2 !== v2 && (r2[d2++] = N2), w2 = b2; y2--; )
        w2 = g2[w2], r2[--L2] = 255 & w2, w2 >>= 8;
      m2 !== null && c2 < 4096 && (g2[c2++] = m2 << 8 | N2, c2 >= h2 + 1 && u2 < 12 && (++u2, h2 = h2 << 1 | 1)), m2 = v2;
    } else
      c2 = s2 + 1, h2 = (1 << (u2 = i2 + 1)) - 1, m2 = null;
  }
  return d2 !== n2 && a$2.log("Warning, gif stream shorter than expected."), r2;
}
/**
 * @license
  Copyright (c) 2008, Adobe Systems Incorporated
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are
  met:

  * Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the 
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of Adobe Systems Incorporated nor the names of its 
    contributors may be used to endorse or promote products derived from 
    this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
function Qt(t3) {
  var e2, r2, n2, i2, a2, o2 = Math.floor, s2 = new Array(64), c2 = new Array(64), u2 = new Array(64), h2 = new Array(64), l2 = new Array(65535), f2 = new Array(65535), d2 = new Array(64), p5 = new Array(64), g2 = [], m2 = 0, v2 = 7, b2 = new Array(64), y2 = new Array(64), w2 = new Array(64), N2 = new Array(256), L2 = new Array(2048), A2 = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], x2 = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], S2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], _2 = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], P2 = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], k2 = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], I2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], F2 = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], C2 = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
  function j2(t4, e3) {
    for (var r3 = 0, n3 = 0, i3 = new Array(), a3 = 1; a3 <= 16; a3++) {
      for (var o3 = 1; o3 <= t4[a3]; o3++)
        i3[e3[n3]] = [], i3[e3[n3]][0] = r3, i3[e3[n3]][1] = a3, n3++, r3++;
      r3 *= 2;
    }
    return i3;
  }
  function O2(t4) {
    for (var e3 = t4[0], r3 = t4[1] - 1; r3 >= 0; )
      e3 & 1 << r3 && (m2 |= 1 << v2), r3--, --v2 < 0 && (m2 == 255 ? (B3(255), B3(0)) : B3(m2), v2 = 7, m2 = 0);
  }
  function B3(t4) {
    g2.push(t4);
  }
  function M2(t4) {
    B3(t4 >> 8 & 255), B3(255 & t4);
  }
  function E2(t4, e3, r3, n3, i3) {
    for (var a3, o3 = i3[0], s3 = i3[240], c3 = function(t5, e4) {
      var r4, n4, i4, a4, o4, s4, c4, u4, h4, l3, f3 = 0;
      for (h4 = 0; h4 < 8; ++h4) {
        r4 = t5[f3], n4 = t5[f3 + 1], i4 = t5[f3 + 2], a4 = t5[f3 + 3], o4 = t5[f3 + 4], s4 = t5[f3 + 5], c4 = t5[f3 + 6];
        var p6 = r4 + (u4 = t5[f3 + 7]), g4 = r4 - u4, m4 = n4 + c4, v4 = n4 - c4, b4 = i4 + s4, y4 = i4 - s4, w4 = a4 + o4, N3 = a4 - o4, L3 = p6 + w4, A3 = p6 - w4, x3 = m4 + b4, S3 = m4 - b4;
        t5[f3] = L3 + x3, t5[f3 + 4] = L3 - x3;
        var _3 = 0.707106781 * (S3 + A3);
        t5[f3 + 2] = A3 + _3, t5[f3 + 6] = A3 - _3;
        var P3 = 0.382683433 * ((L3 = N3 + y4) - (S3 = v4 + g4)), k3 = 0.5411961 * L3 + P3, I3 = 1.306562965 * S3 + P3, F3 = 0.707106781 * (x3 = y4 + v4), C3 = g4 + F3, j3 = g4 - F3;
        t5[f3 + 5] = j3 + k3, t5[f3 + 3] = j3 - k3, t5[f3 + 1] = C3 + I3, t5[f3 + 7] = C3 - I3, f3 += 8;
      }
      for (f3 = 0, h4 = 0; h4 < 8; ++h4) {
        r4 = t5[f3], n4 = t5[f3 + 8], i4 = t5[f3 + 16], a4 = t5[f3 + 24], o4 = t5[f3 + 32], s4 = t5[f3 + 40], c4 = t5[f3 + 48];
        var O3 = r4 + (u4 = t5[f3 + 56]), B4 = r4 - u4, M3 = n4 + c4, E3 = n4 - c4, q3 = i4 + s4, D2 = i4 - s4, R2 = a4 + o4, T2 = a4 - o4, z2 = O3 + R2, U2 = O3 - R2, H4 = M3 + q3, W2 = M3 - q3;
        t5[f3] = z2 + H4, t5[f3 + 32] = z2 - H4;
        var V2 = 0.707106781 * (W2 + U2);
        t5[f3 + 16] = U2 + V2, t5[f3 + 48] = U2 - V2;
        var G2 = 0.382683433 * ((z2 = T2 + D2) - (W2 = E3 + B4)), Y2 = 0.5411961 * z2 + G2, J2 = 1.306562965 * W2 + G2, X2 = 0.707106781 * (H4 = D2 + E3), K2 = B4 + X2, Z2 = B4 - X2;
        t5[f3 + 40] = Z2 + Y2, t5[f3 + 24] = Z2 - Y2, t5[f3 + 8] = K2 + J2, t5[f3 + 56] = K2 - J2, f3++;
      }
      for (h4 = 0; h4 < 64; ++h4)
        l3 = t5[h4] * e4[h4], d2[h4] = l3 > 0 ? l3 + 0.5 | 0 : l3 - 0.5 | 0;
      return d2;
    }(t4, e3), u3 = 0; u3 < 64; ++u3)
      p5[A2[u3]] = c3[u3];
    var h3 = p5[0] - r3;
    r3 = p5[0], h3 == 0 ? O2(n3[0]) : (O2(n3[f2[a3 = 32767 + h3]]), O2(l2[a3]));
    for (var g3 = 63; g3 > 0 && p5[g3] == 0; )
      g3--;
    if (g3 == 0)
      return O2(o3), r3;
    for (var m3, v3 = 1; v3 <= g3; ) {
      for (var b3 = v3; p5[v3] == 0 && v3 <= g3; )
        ++v3;
      var y3 = v3 - b3;
      if (y3 >= 16) {
        m3 = y3 >> 4;
        for (var w3 = 1; w3 <= m3; ++w3)
          O2(s3);
        y3 &= 15;
      }
      a3 = 32767 + p5[v3], O2(i3[(y3 << 4) + f2[a3]]), O2(l2[a3]), v3++;
    }
    return g3 != 63 && O2(o3), r3;
  }
  function q2(t4) {
    (t4 = Math.min(Math.max(t4, 1), 100), a2 != t4) && (!function(t5) {
      for (var e3 = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], r3 = 0; r3 < 64; r3++) {
        var n3 = o2((e3[r3] * t5 + 50) / 100);
        n3 = Math.min(Math.max(n3, 1), 255), s2[A2[r3]] = n3;
      }
      for (var i3 = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], a3 = 0; a3 < 64; a3++) {
        var l3 = o2((i3[a3] * t5 + 50) / 100);
        l3 = Math.min(Math.max(l3, 1), 255), c2[A2[a3]] = l3;
      }
      for (var f3 = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], d3 = 0, p6 = 0; p6 < 8; p6++)
        for (var g3 = 0; g3 < 8; g3++)
          u2[d3] = 1 / (s2[A2[d3]] * f3[p6] * f3[g3] * 8), h2[d3] = 1 / (c2[A2[d3]] * f3[p6] * f3[g3] * 8), d3++;
    }(t4 < 50 ? Math.floor(5e3 / t4) : Math.floor(200 - 2 * t4)), a2 = t4);
  }
  this.encode = function(t4, a3) {
    a3 && q2(a3), g2 = new Array(), m2 = 0, v2 = 7, M2(65496), M2(65504), M2(16), B3(74), B3(70), B3(73), B3(70), B3(0), B3(1), B3(1), B3(0), M2(1), M2(1), B3(0), B3(0), function() {
      M2(65499), M2(132), B3(0);
      for (var t5 = 0; t5 < 64; t5++)
        B3(s2[t5]);
      B3(1);
      for (var e3 = 0; e3 < 64; e3++)
        B3(c2[e3]);
    }(), function(t5, e3) {
      M2(65472), M2(17), B3(8), M2(e3), M2(t5), B3(3), B3(1), B3(17), B3(0), B3(2), B3(17), B3(1), B3(3), B3(17), B3(1);
    }(t4.width, t4.height), function() {
      M2(65476), M2(418), B3(0);
      for (var t5 = 0; t5 < 16; t5++)
        B3(x2[t5 + 1]);
      for (var e3 = 0; e3 <= 11; e3++)
        B3(S2[e3]);
      B3(16);
      for (var r3 = 0; r3 < 16; r3++)
        B3(_2[r3 + 1]);
      for (var n3 = 0; n3 <= 161; n3++)
        B3(P2[n3]);
      B3(1);
      for (var i3 = 0; i3 < 16; i3++)
        B3(k2[i3 + 1]);
      for (var a4 = 0; a4 <= 11; a4++)
        B3(I2[a4]);
      B3(17);
      for (var o4 = 0; o4 < 16; o4++)
        B3(F2[o4 + 1]);
      for (var s3 = 0; s3 <= 161; s3++)
        B3(C2[s3]);
    }(), M2(65498), M2(12), B3(3), B3(1), B3(0), B3(2), B3(17), B3(3), B3(17), B3(0), B3(63), B3(0);
    var o3 = 0, l3 = 0, f3 = 0;
    m2 = 0, v2 = 7, this.encode.displayName = "_encode_";
    for (var d3, p6, N3, A3, j3, D2, R2, T2, z2, U2 = t4.data, H4 = t4.width, W2 = t4.height, V2 = 4 * H4, G2 = 0; G2 < W2; ) {
      for (d3 = 0; d3 < V2; ) {
        for (j3 = V2 * G2 + d3, R2 = -1, T2 = 0, z2 = 0; z2 < 64; z2++)
          D2 = j3 + (T2 = z2 >> 3) * V2 + (R2 = 4 * (7 & z2)), G2 + T2 >= W2 && (D2 -= V2 * (G2 + 1 + T2 - W2)), d3 + R2 >= V2 && (D2 -= d3 + R2 - V2 + 4), p6 = U2[D2++], N3 = U2[D2++], A3 = U2[D2++], b2[z2] = (L2[p6] + L2[N3 + 256 >> 0] + L2[A3 + 512 >> 0] >> 16) - 128, y2[z2] = (L2[p6 + 768 >> 0] + L2[N3 + 1024 >> 0] + L2[A3 + 1280 >> 0] >> 16) - 128, w2[z2] = (L2[p6 + 1280 >> 0] + L2[N3 + 1536 >> 0] + L2[A3 + 1792 >> 0] >> 16) - 128;
        o3 = E2(b2, u2, o3, e2, n2), l3 = E2(y2, h2, l3, r2, i2), f3 = E2(w2, h2, f3, r2, i2), d3 += 32;
      }
      G2 += 8;
    }
    if (v2 >= 0) {
      var Y2 = [];
      Y2[1] = v2 + 1, Y2[0] = (1 << v2 + 1) - 1, O2(Y2);
    }
    return M2(65497), new Uint8Array(g2);
  }, t3 = t3 || 50, function() {
    for (var t4 = String.fromCharCode, e3 = 0; e3 < 256; e3++)
      N2[e3] = t4(e3);
  }(), e2 = j2(x2, S2), r2 = j2(k2, I2), n2 = j2(_2, P2), i2 = j2(F2, C2), function() {
    for (var t4 = 1, e3 = 2, r3 = 1; r3 <= 15; r3++) {
      for (var n3 = t4; n3 < e3; n3++)
        f2[32767 + n3] = r3, l2[32767 + n3] = [], l2[32767 + n3][1] = r3, l2[32767 + n3][0] = n3;
      for (var i3 = -(e3 - 1); i3 <= -t4; i3++)
        f2[32767 + i3] = r3, l2[32767 + i3] = [], l2[32767 + i3][1] = r3, l2[32767 + i3][0] = e3 - 1 + i3;
      t4 <<= 1, e3 <<= 1;
    }
  }(), function() {
    for (var t4 = 0; t4 < 256; t4++)
      L2[t4] = 19595 * t4, L2[t4 + 256 >> 0] = 38470 * t4, L2[t4 + 512 >> 0] = 7471 * t4 + 32768, L2[t4 + 768 >> 0] = -11059 * t4, L2[t4 + 1024 >> 0] = -21709 * t4, L2[t4 + 1280 >> 0] = 32768 * t4 + 8421375, L2[t4 + 1536 >> 0] = -27439 * t4, L2[t4 + 1792 >> 0] = -5329 * t4;
  }(), q2(t3);
}
/**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function te(t3, e2) {
  if (this.pos = 0, this.buffer = t3, this.datav = new DataView(t3.buffer), this.is_with_alpha = !!e2, this.bottom_up = true, this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]), this.pos += 2, ["BM", "BA", "CI", "CP", "IC", "PT"].indexOf(this.flag) === -1)
    throw new Error("Invalid BMP File");
  this.parseHeader(), this.parseBGR();
}
function ee(t3) {
  function e2(t4) {
    if (!t4)
      throw Error("assert :P");
  }
  function r2(t4, e3, r3) {
    for (var n3 = 0; 4 > n3; n3++)
      if (t4[e3 + n3] != r3.charCodeAt(n3))
        return true;
    return false;
  }
  function n2(t4, e3, r3, n3, i3) {
    for (var a3 = 0; a3 < i3; a3++)
      t4[e3 + a3] = r3[n3 + a3];
  }
  function i2(t4, e3, r3, n3) {
    for (var i3 = 0; i3 < n3; i3++)
      t4[e3 + i3] = r3;
  }
  function a2(t4) {
    return new Int32Array(t4);
  }
  function o2(t4, e3) {
    for (var r3 = [], n3 = 0; n3 < t4; n3++)
      r3.push(new e3());
    return r3;
  }
  function s2(t4, e3) {
    var r3 = [];
    return function t5(r4, n3, i3) {
      for (var a3 = i3[n3], o3 = 0; o3 < a3 && (r4.push(i3.length > n3 + 1 ? [] : new e3()), !(i3.length < n3 + 1)); o3++)
        t5(r4[o3], n3 + 1, i3);
    }(r3, 0, t4), r3;
  }
  var c2 = function() {
    var t4 = this;
    function c3(t5, e3) {
      for (var r3 = 1 << e3 - 1 >>> 0; t5 & r3; )
        r3 >>>= 1;
      return r3 ? (t5 & r3 - 1) + r3 : t5;
    }
    function u3(t5, r3, n3, i3, a3) {
      e2(!(i3 % n3));
      do {
        t5[r3 + (i3 -= n3)] = a3;
      } while (0 < i3);
    }
    function h3(t5, r3, n3, i3, o3) {
      if (e2(2328 >= o3), 512 >= o3)
        var s3 = a2(512);
      else if ((s3 = a2(o3)) == null)
        return 0;
      return function(t6, r4, n4, i4, o4, s4) {
        var h4, f4, d4 = r4, p7 = 1 << n4, g4 = a2(16), m4 = a2(16);
        for (e2(o4 != 0), e2(i4 != null), e2(t6 != null), e2(0 < n4), f4 = 0; f4 < o4; ++f4) {
          if (15 < i4[f4])
            return 0;
          ++g4[i4[f4]];
        }
        if (g4[0] == o4)
          return 0;
        for (m4[1] = 0, h4 = 1; 15 > h4; ++h4) {
          if (g4[h4] > 1 << h4)
            return 0;
          m4[h4 + 1] = m4[h4] + g4[h4];
        }
        for (f4 = 0; f4 < o4; ++f4)
          h4 = i4[f4], 0 < i4[f4] && (s4[m4[h4]++] = f4);
        if (m4[15] == 1)
          return (i4 = new l3()).g = 0, i4.value = s4[0], u3(t6, d4, 1, p7, i4), p7;
        var v4, b4 = -1, y4 = p7 - 1, w4 = 0, N4 = 1, L4 = 1, A4 = 1 << n4;
        for (f4 = 0, h4 = 1, o4 = 2; h4 <= n4; ++h4, o4 <<= 1) {
          if (N4 += L4 <<= 1, 0 > (L4 -= g4[h4]))
            return 0;
          for (; 0 < g4[h4]; --g4[h4])
            (i4 = new l3()).g = h4, i4.value = s4[f4++], u3(t6, d4 + w4, o4, A4, i4), w4 = c3(w4, h4);
        }
        for (h4 = n4 + 1, o4 = 2; 15 >= h4; ++h4, o4 <<= 1) {
          if (N4 += L4 <<= 1, 0 > (L4 -= g4[h4]))
            return 0;
          for (; 0 < g4[h4]; --g4[h4]) {
            if (i4 = new l3(), (w4 & y4) != b4) {
              for (d4 += A4, v4 = 1 << (b4 = h4) - n4; 15 > b4 && !(0 >= (v4 -= g4[b4])); )
                ++b4, v4 <<= 1;
              p7 += A4 = 1 << (v4 = b4 - n4), t6[r4 + (b4 = w4 & y4)].g = v4 + n4, t6[r4 + b4].value = d4 - r4 - b4;
            }
            i4.g = h4 - n4, i4.value = s4[f4++], u3(t6, d4 + (w4 >> n4), o4, A4, i4), w4 = c3(w4, h4);
          }
        }
        return N4 != 2 * m4[15] - 1 ? 0 : p7;
      }(t5, r3, n3, i3, o3, s3);
    }
    function l3() {
      this.value = this.g = 0;
    }
    function f3() {
      this.value = this.g = 0;
    }
    function d3() {
      this.G = o2(5, l3), this.H = a2(5), this.jc = this.Qb = this.qb = this.nd = 0, this.pd = o2(Dr, f3);
    }
    function p6(t5, r3, n3, i3) {
      e2(t5 != null), e2(r3 != null), e2(2147483648 > i3), t5.Ca = 254, t5.I = 0, t5.b = -8, t5.Ka = 0, t5.oa = r3, t5.pa = n3, t5.Jd = r3, t5.Yc = n3 + i3, t5.Zc = 4 <= i3 ? n3 + i3 - 4 + 1 : n3, _2(t5);
    }
    function g3(t5, e3) {
      for (var r3 = 0; 0 < e3--; )
        r3 |= k2(t5, 128) << e3;
      return r3;
    }
    function m3(t5, e3) {
      var r3 = g3(t5, e3);
      return P2(t5) ? -r3 : r3;
    }
    function v3(t5, r3, n3, i3) {
      var a3, o3 = 0;
      for (e2(t5 != null), e2(r3 != null), e2(4294967288 > i3), t5.Sb = i3, t5.Ra = 0, t5.u = 0, t5.h = 0, 4 < i3 && (i3 = 4), a3 = 0; a3 < i3; ++a3)
        o3 += r3[n3 + a3] << 8 * a3;
      t5.Ra = o3, t5.bb = i3, t5.oa = r3, t5.pa = n3;
    }
    function b3(t5) {
      for (; 8 <= t5.u && t5.bb < t5.Sb; )
        t5.Ra >>>= 8, t5.Ra += t5.oa[t5.pa + t5.bb] << zr - 8 >>> 0, ++t5.bb, t5.u -= 8;
      A3(t5) && (t5.h = 1, t5.u = 0);
    }
    function y3(t5, r3) {
      if (e2(0 <= r3), !t5.h && r3 <= Tr) {
        var n3 = L3(t5) & Rr[r3];
        return t5.u += r3, b3(t5), n3;
      }
      return t5.h = 1, t5.u = 0;
    }
    function w3() {
      this.b = this.Ca = this.I = 0, this.oa = [], this.pa = 0, this.Jd = [], this.Yc = 0, this.Zc = [], this.Ka = 0;
    }
    function N3() {
      this.Ra = 0, this.oa = [], this.h = this.u = this.bb = this.Sb = this.pa = 0;
    }
    function L3(t5) {
      return t5.Ra >>> (t5.u & zr - 1) >>> 0;
    }
    function A3(t5) {
      return e2(t5.bb <= t5.Sb), t5.h || t5.bb == t5.Sb && t5.u > zr;
    }
    function x2(t5, e3) {
      t5.u = e3, t5.h = A3(t5);
    }
    function S2(t5) {
      t5.u >= Ur && (e2(t5.u >= Ur), b3(t5));
    }
    function _2(t5) {
      e2(t5 != null && t5.oa != null), t5.pa < t5.Zc ? (t5.I = (t5.oa[t5.pa++] | t5.I << 8) >>> 0, t5.b += 8) : (e2(t5 != null && t5.oa != null), t5.pa < t5.Yc ? (t5.b += 8, t5.I = t5.oa[t5.pa++] | t5.I << 8) : t5.Ka ? t5.b = 0 : (t5.I <<= 8, t5.b += 8, t5.Ka = 1));
    }
    function P2(t5) {
      return g3(t5, 1);
    }
    function k2(t5, e3) {
      var r3 = t5.Ca;
      0 > t5.b && _2(t5);
      var n3 = t5.b, i3 = r3 * e3 >>> 8, a3 = (t5.I >>> n3 > i3) + 0;
      for (a3 ? (r3 -= i3, t5.I -= i3 + 1 << n3 >>> 0) : r3 = i3 + 1, n3 = r3, i3 = 0; 256 <= n3; )
        i3 += 8, n3 >>= 8;
      return n3 = 7 ^ i3 + Hr[n3], t5.b -= n3, t5.Ca = (r3 << n3) - 1, a3;
    }
    function I2(t5, e3, r3) {
      t5[e3 + 0] = r3 >> 24 & 255, t5[e3 + 1] = r3 >> 16 & 255, t5[e3 + 2] = r3 >> 8 & 255, t5[e3 + 3] = r3 >> 0 & 255;
    }
    function F2(t5, e3) {
      return t5[e3 + 0] << 0 | t5[e3 + 1] << 8;
    }
    function C2(t5, e3) {
      return F2(t5, e3) | t5[e3 + 2] << 16;
    }
    function j2(t5, e3) {
      return F2(t5, e3) | F2(t5, e3 + 2) << 16;
    }
    function O2(t5, r3) {
      var n3 = 1 << r3;
      return e2(t5 != null), e2(0 < r3), t5.X = a2(n3), t5.X == null ? 0 : (t5.Mb = 32 - r3, t5.Xa = r3, 1);
    }
    function B3(t5, r3) {
      e2(t5 != null), e2(r3 != null), e2(t5.Xa == r3.Xa), n2(r3.X, 0, t5.X, 0, 1 << r3.Xa);
    }
    function M2() {
      this.X = [], this.Xa = this.Mb = 0;
    }
    function E2(t5, r3, n3, i3) {
      e2(n3 != null), e2(i3 != null);
      var a3 = n3[0], o3 = i3[0];
      return a3 == 0 && (a3 = (t5 * o3 + r3 / 2) / r3), o3 == 0 && (o3 = (r3 * a3 + t5 / 2) / t5), 0 >= a3 || 0 >= o3 ? 0 : (n3[0] = a3, i3[0] = o3, 1);
    }
    function q2(t5, e3) {
      return t5 + (1 << e3) - 1 >>> e3;
    }
    function D2(t5, e3) {
      return ((4278255360 & t5) + (4278255360 & e3) >>> 0 & 4278255360) + ((16711935 & t5) + (16711935 & e3) >>> 0 & 16711935) >>> 0;
    }
    function R2(e3, r3) {
      t4[r3] = function(r4, n3, i3, a3, o3, s3, c4) {
        var u4;
        for (u4 = 0; u4 < o3; ++u4) {
          var h4 = t4[e3](s3[c4 + u4 - 1], i3, a3 + u4);
          s3[c4 + u4] = D2(r4[n3 + u4], h4);
        }
      };
    }
    function T2() {
      this.ud = this.hd = this.jd = 0;
    }
    function z2(t5, e3) {
      return ((4278124286 & (t5 ^ e3)) >>> 1) + (t5 & e3) >>> 0;
    }
    function U2(t5) {
      return 0 <= t5 && 256 > t5 ? t5 : 0 > t5 ? 0 : 255 < t5 ? 255 : void 0;
    }
    function H4(t5, e3) {
      return U2(t5 + (t5 - e3 + 0.5 >> 1));
    }
    function W2(t5, e3, r3) {
      return Math.abs(e3 - r3) - Math.abs(t5 - r3);
    }
    function V2(t5, e3, r3, n3, i3, a3, o3) {
      for (n3 = a3[o3 - 1], r3 = 0; r3 < i3; ++r3)
        a3[o3 + r3] = n3 = D2(t5[e3 + r3], n3);
    }
    function G2(t5, e3, r3, n3, i3) {
      var a3;
      for (a3 = 0; a3 < r3; ++a3) {
        var o3 = t5[e3 + a3], s3 = o3 >> 8 & 255, c4 = 16711935 & (c4 = (c4 = 16711935 & o3) + ((s3 << 16) + s3));
        n3[i3 + a3] = (4278255360 & o3) + c4 >>> 0;
      }
    }
    function Y2(t5, e3) {
      e3.jd = t5 >> 0 & 255, e3.hd = t5 >> 8 & 255, e3.ud = t5 >> 16 & 255;
    }
    function J2(t5, e3, r3, n3, i3, a3) {
      var o3;
      for (o3 = 0; o3 < n3; ++o3) {
        var s3 = e3[r3 + o3], c4 = s3 >>> 8, u4 = s3, h4 = 255 & (h4 = (h4 = s3 >>> 16) + ((t5.jd << 24 >> 24) * (c4 << 24 >> 24) >>> 5));
        u4 = 255 & (u4 = (u4 = u4 + ((t5.hd << 24 >> 24) * (c4 << 24 >> 24) >>> 5)) + ((t5.ud << 24 >> 24) * (h4 << 24 >> 24) >>> 5));
        i3[a3 + o3] = (4278255360 & s3) + (h4 << 16) + u4;
      }
    }
    function X2(e3, r3, n3, i3, a3) {
      t4[r3] = function(t5, e4, r4, n4, o3, s3, c4, u4, h4) {
        for (n4 = c4; n4 < u4; ++n4)
          for (c4 = 0; c4 < h4; ++c4)
            o3[s3++] = a3(r4[i3(t5[e4++])]);
      }, t4[e3] = function(e4, r4, o3, s3, c4, u4, h4) {
        var l4 = 8 >> e4.b, f4 = e4.Ea, d4 = e4.K[0], p7 = e4.w;
        if (8 > l4)
          for (e4 = (1 << e4.b) - 1, p7 = (1 << l4) - 1; r4 < o3; ++r4) {
            var g4, m4 = 0;
            for (g4 = 0; g4 < f4; ++g4)
              g4 & e4 || (m4 = i3(s3[c4++])), u4[h4++] = a3(d4[m4 & p7]), m4 >>= l4;
          }
        else
          t4["VP8LMapColor" + n3](s3, c4, d4, p7, u4, h4, r4, o3, f4);
      };
    }
    function K2(t5, e3, r3, n3, i3) {
      for (r3 = e3 + r3; e3 < r3; ) {
        var a3 = t5[e3++];
        n3[i3++] = a3 >> 16 & 255, n3[i3++] = a3 >> 8 & 255, n3[i3++] = a3 >> 0 & 255;
      }
    }
    function Z2(t5, e3, r3, n3, i3) {
      for (r3 = e3 + r3; e3 < r3; ) {
        var a3 = t5[e3++];
        n3[i3++] = a3 >> 16 & 255, n3[i3++] = a3 >> 8 & 255, n3[i3++] = a3 >> 0 & 255, n3[i3++] = a3 >> 24 & 255;
      }
    }
    function $2(t5, e3, r3, n3, i3) {
      for (r3 = e3 + r3; e3 < r3; ) {
        var a3 = (o3 = t5[e3++]) >> 16 & 240 | o3 >> 12 & 15, o3 = o3 >> 0 & 240 | o3 >> 28 & 15;
        n3[i3++] = a3, n3[i3++] = o3;
      }
    }
    function Q2(t5, e3, r3, n3, i3) {
      for (r3 = e3 + r3; e3 < r3; ) {
        var a3 = (o3 = t5[e3++]) >> 16 & 248 | o3 >> 13 & 7, o3 = o3 >> 5 & 224 | o3 >> 3 & 31;
        n3[i3++] = a3, n3[i3++] = o3;
      }
    }
    function tt2(t5, e3, r3, n3, i3) {
      for (r3 = e3 + r3; e3 < r3; ) {
        var a3 = t5[e3++];
        n3[i3++] = a3 >> 0 & 255, n3[i3++] = a3 >> 8 & 255, n3[i3++] = a3 >> 16 & 255;
      }
    }
    function et2(t5, e3, r3, i3, a3, o3) {
      if (o3 == 0)
        for (r3 = e3 + r3; e3 < r3; )
          I2(i3, ((o3 = t5[e3++])[0] >> 24 | o3[1] >> 8 & 65280 | o3[2] << 8 & 16711680 | o3[3] << 24) >>> 0), a3 += 32;
      else
        n2(i3, a3, t5, e3, r3);
    }
    function rt2(e3, r3) {
      t4[r3][0] = t4[e3 + "0"], t4[r3][1] = t4[e3 + "1"], t4[r3][2] = t4[e3 + "2"], t4[r3][3] = t4[e3 + "3"], t4[r3][4] = t4[e3 + "4"], t4[r3][5] = t4[e3 + "5"], t4[r3][6] = t4[e3 + "6"], t4[r3][7] = t4[e3 + "7"], t4[r3][8] = t4[e3 + "8"], t4[r3][9] = t4[e3 + "9"], t4[r3][10] = t4[e3 + "10"], t4[r3][11] = t4[e3 + "11"], t4[r3][12] = t4[e3 + "12"], t4[r3][13] = t4[e3 + "13"], t4[r3][14] = t4[e3 + "0"], t4[r3][15] = t4[e3 + "0"];
    }
    function nt2(t5) {
      return t5 == Hn || t5 == Wn || t5 == Vn || t5 == Gn;
    }
    function it2() {
      this.eb = [], this.size = this.A = this.fb = 0;
    }
    function at2() {
      this.y = [], this.f = [], this.ea = [], this.F = [], this.Tc = this.Ed = this.Cd = this.Fd = this.lb = this.Db = this.Ab = this.fa = this.J = this.W = this.N = this.O = 0;
    }
    function ot2() {
      this.Rd = this.height = this.width = this.S = 0, this.f = {}, this.f.RGBA = new it2(), this.f.kb = new at2(), this.sd = null;
    }
    function st2() {
      this.width = [0], this.height = [0], this.Pd = [0], this.Qd = [0], this.format = [0];
    }
    function ct2() {
      this.Id = this.fd = this.Md = this.hb = this.ib = this.da = this.bd = this.cd = this.j = this.v = this.Da = this.Sd = this.ob = 0;
    }
    function ut2(t5) {
      return alert("todo:WebPSamplerProcessPlane"), t5.T;
    }
    function ht2(t5, e3) {
      var r3 = t5.T, i3 = e3.ba.f.RGBA, a3 = i3.eb, o3 = i3.fb + t5.ka * i3.A, s3 = vi[e3.ba.S], c4 = t5.y, u4 = t5.O, h4 = t5.f, l4 = t5.N, f4 = t5.ea, d4 = t5.W, p7 = e3.cc, g4 = e3.dc, m4 = e3.Mc, v4 = e3.Nc, b4 = t5.ka, y4 = t5.ka + t5.T, w4 = t5.U, N4 = w4 + 1 >> 1;
      for (b4 == 0 ? s3(c4, u4, null, null, h4, l4, f4, d4, h4, l4, f4, d4, a3, o3, null, null, w4) : (s3(e3.ec, e3.fc, c4, u4, p7, g4, m4, v4, h4, l4, f4, d4, a3, o3 - i3.A, a3, o3, w4), ++r3); b4 + 2 < y4; b4 += 2)
        p7 = h4, g4 = l4, m4 = f4, v4 = d4, l4 += t5.Rc, d4 += t5.Rc, o3 += 2 * i3.A, s3(c4, (u4 += 2 * t5.fa) - t5.fa, c4, u4, p7, g4, m4, v4, h4, l4, f4, d4, a3, o3 - i3.A, a3, o3, w4);
      return u4 += t5.fa, t5.j + y4 < t5.o ? (n2(e3.ec, e3.fc, c4, u4, w4), n2(e3.cc, e3.dc, h4, l4, N4), n2(e3.Mc, e3.Nc, f4, d4, N4), r3--) : 1 & y4 || s3(c4, u4, null, null, h4, l4, f4, d4, h4, l4, f4, d4, a3, o3 + i3.A, null, null, w4), r3;
    }
    function lt2(t5, r3, n3) {
      var i3 = t5.F, a3 = [t5.J];
      if (i3 != null) {
        var o3 = t5.U, s3 = r3.ba.S, c4 = s3 == Tn || s3 == Vn;
        r3 = r3.ba.f.RGBA;
        var u4 = [0], h4 = t5.ka;
        u4[0] = t5.T, t5.Kb && (h4 == 0 ? --u4[0] : (--h4, a3[0] -= t5.width), t5.j + t5.ka + t5.T == t5.o && (u4[0] = t5.o - t5.j - h4));
        var l4 = r3.eb;
        h4 = r3.fb + h4 * r3.A;
        t5 = Sn(i3, a3[0], t5.width, o3, u4, l4, h4 + (c4 ? 0 : 3), r3.A), e2(n3 == u4), t5 && nt2(s3) && An(l4, h4, c4, o3, u4, r3.A);
      }
      return 0;
    }
    function ft2(t5) {
      var e3 = t5.ma, r3 = e3.ba.S, n3 = 11 > r3, i3 = r3 == qn || r3 == Rn || r3 == Tn || r3 == zn || r3 == 12 || nt2(r3);
      if (e3.memory = null, e3.Ib = null, e3.Jb = null, e3.Nd = null, !Mr(e3.Oa, t5, i3 ? 11 : 12))
        return 0;
      if (i3 && nt2(r3) && br(), t5.da)
        alert("todo:use_scaling");
      else {
        if (n3) {
          if (e3.Ib = ut2, t5.Kb) {
            if (r3 = t5.U + 1 >> 1, e3.memory = a2(t5.U + 2 * r3), e3.memory == null)
              return 0;
            e3.ec = e3.memory, e3.fc = 0, e3.cc = e3.ec, e3.dc = e3.fc + t5.U, e3.Mc = e3.cc, e3.Nc = e3.dc + r3, e3.Ib = ht2, br();
          }
        } else
          alert("todo:EmitYUV");
        i3 && (e3.Jb = lt2, n3 && mr());
      }
      if (n3 && !Ci) {
        for (t5 = 0; 256 > t5; ++t5)
          ji[t5] = 89858 * (t5 - 128) + _i >> Si, Mi[t5] = -22014 * (t5 - 128) + _i, Bi[t5] = -45773 * (t5 - 128), Oi[t5] = 113618 * (t5 - 128) + _i >> Si;
        for (t5 = Pi; t5 < ki; ++t5)
          e3 = 76283 * (t5 - 16) + _i >> Si, Ei[t5 - Pi] = Vt2(e3, 255), qi[t5 - Pi] = Vt2(e3 + 8 >> 4, 15);
        Ci = 1;
      }
      return 1;
    }
    function dt2(t5) {
      var r3 = t5.ma, n3 = t5.U, i3 = t5.T;
      return e2(!(1 & t5.ka)), 0 >= n3 || 0 >= i3 ? 0 : (n3 = r3.Ib(t5, r3), r3.Jb != null && r3.Jb(t5, r3, n3), r3.Dc += n3, 1);
    }
    function pt2(t5) {
      t5.ma.memory = null;
    }
    function gt2(t5, e3, r3, n3) {
      return y3(t5, 8) != 47 ? 0 : (e3[0] = y3(t5, 14) + 1, r3[0] = y3(t5, 14) + 1, n3[0] = y3(t5, 1), y3(t5, 3) != 0 ? 0 : !t5.h);
    }
    function mt2(t5, e3) {
      if (4 > t5)
        return t5 + 1;
      var r3 = t5 - 2 >> 1;
      return (2 + (1 & t5) << r3) + y3(e3, r3) + 1;
    }
    function vt2(t5, e3) {
      return 120 < e3 ? e3 - 120 : 1 <= (r3 = ((r3 = $n[e3 - 1]) >> 4) * t5 + (8 - (15 & r3))) ? r3 : 1;
      var r3;
    }
    function bt2(t5, e3, r3) {
      var n3 = L3(r3), i3 = t5[e3 += 255 & n3].g - 8;
      return 0 < i3 && (x2(r3, r3.u + 8), n3 = L3(r3), e3 += t5[e3].value, e3 += n3 & (1 << i3) - 1), x2(r3, r3.u + t5[e3].g), t5[e3].value;
    }
    function yt2(t5, r3, n3) {
      return n3.g += t5.g, n3.value += t5.value << r3 >>> 0, e2(8 >= n3.g), t5.g;
    }
    function wt2(t5, r3, n3) {
      var i3 = t5.xc;
      return e2((r3 = i3 == 0 ? 0 : t5.vc[t5.md * (n3 >> i3) + (r3 >> i3)]) < t5.Wb), t5.Ya[r3];
    }
    function Nt2(t5, r3, i3, a3) {
      var o3 = t5.ab, s3 = t5.c * r3, c4 = t5.C;
      r3 = c4 + r3;
      var u4 = i3, h4 = a3;
      for (a3 = t5.Ta, i3 = t5.Ua; 0 < o3--; ) {
        var l4 = t5.gc[o3], f4 = c4, d4 = r3, p7 = u4, g4 = h4, m4 = (h4 = a3, u4 = i3, l4.Ea);
        switch (e2(f4 < d4), e2(d4 <= l4.nc), l4.hc) {
          case 2:
            Gr(p7, g4, (d4 - f4) * m4, h4, u4);
            break;
          case 0:
            var v4 = f4, b4 = d4, y4 = h4, w4 = u4, N4 = (_3 = l4).Ea;
            v4 == 0 && (Wr(p7, g4, null, null, 1, y4, w4), V2(p7, g4 + 1, 0, 0, N4 - 1, y4, w4 + 1), g4 += N4, w4 += N4, ++v4);
            for (var L4 = 1 << _3.b, A4 = L4 - 1, x3 = q2(N4, _3.b), S3 = _3.K, _3 = _3.w + (v4 >> _3.b) * x3; v4 < b4; ) {
              var P3 = S3, k3 = _3, I3 = 1;
              for (Vr(p7, g4, y4, w4 - N4, 1, y4, w4); I3 < N4; ) {
                var F3 = (I3 & ~A4) + L4;
                F3 > N4 && (F3 = N4), (0, Zr[P3[k3++] >> 8 & 15])(p7, g4 + +I3, y4, w4 + I3 - N4, F3 - I3, y4, w4 + I3), I3 = F3;
              }
              g4 += N4, w4 += N4, ++v4 & A4 || (_3 += x3);
            }
            d4 != l4.nc && n2(h4, u4 - m4, h4, u4 + (d4 - f4 - 1) * m4, m4);
            break;
          case 1:
            for (m4 = p7, b4 = g4, N4 = (p7 = l4.Ea) - (w4 = p7 & ~(y4 = (g4 = 1 << l4.b) - 1)), v4 = q2(p7, l4.b), L4 = l4.K, l4 = l4.w + (f4 >> l4.b) * v4; f4 < d4; ) {
              for (A4 = L4, x3 = l4, S3 = new T2(), _3 = b4 + w4, P3 = b4 + p7; b4 < _3; )
                Y2(A4[x3++], S3), $r(S3, m4, b4, g4, h4, u4), b4 += g4, u4 += g4;
              b4 < P3 && (Y2(A4[x3++], S3), $r(S3, m4, b4, N4, h4, u4), b4 += N4, u4 += N4), ++f4 & y4 || (l4 += v4);
            }
            break;
          case 3:
            if (p7 == h4 && g4 == u4 && 0 < l4.b) {
              for (b4 = h4, p7 = m4 = u4 + (d4 - f4) * m4 - (w4 = (d4 - f4) * q2(l4.Ea, l4.b)), g4 = h4, y4 = u4, v4 = [], w4 = (N4 = w4) - 1; 0 <= w4; --w4)
                v4[w4] = g4[y4 + w4];
              for (w4 = N4 - 1; 0 <= w4; --w4)
                b4[p7 + w4] = v4[w4];
              Yr(l4, f4, d4, h4, m4, h4, u4);
            } else
              Yr(l4, f4, d4, p7, g4, h4, u4);
        }
        u4 = a3, h4 = i3;
      }
      h4 != i3 && n2(a3, i3, u4, h4, s3);
    }
    function Lt2(t5, r3) {
      var n3 = t5.V, i3 = t5.Ba + t5.c * t5.C, a3 = r3 - t5.C;
      if (e2(r3 <= t5.l.o), e2(16 >= a3), 0 < a3) {
        var o3 = t5.l, s3 = t5.Ta, c4 = t5.Ua, u4 = o3.width;
        if (Nt2(t5, a3, n3, i3), a3 = c4 = [c4], e2((n3 = t5.C) < (i3 = r3)), e2(o3.v < o3.va), i3 > o3.o && (i3 = o3.o), n3 < o3.j) {
          var h4 = o3.j - n3;
          n3 = o3.j;
          a3[0] += h4 * u4;
        }
        if (n3 >= i3 ? n3 = 0 : (a3[0] += 4 * o3.v, o3.ka = n3 - o3.j, o3.U = o3.va - o3.v, o3.T = i3 - n3, n3 = 1), n3) {
          if (c4 = c4[0], 11 > (n3 = t5.ca).S) {
            var l4 = n3.f.RGBA, f4 = (i3 = n3.S, a3 = o3.U, o3 = o3.T, h4 = l4.eb, l4.A), d4 = o3;
            for (l4 = l4.fb + t5.Ma * l4.A; 0 < d4--; ) {
              var p7 = s3, g4 = c4, m4 = a3, v4 = h4, b4 = l4;
              switch (i3) {
                case En:
                  Qr(p7, g4, m4, v4, b4);
                  break;
                case qn:
                  tn(p7, g4, m4, v4, b4);
                  break;
                case Hn:
                  tn(p7, g4, m4, v4, b4), An(v4, b4, 0, m4, 1, 0);
                  break;
                case Dn:
                  nn(p7, g4, m4, v4, b4);
                  break;
                case Rn:
                  et2(p7, g4, m4, v4, b4, 1);
                  break;
                case Wn:
                  et2(p7, g4, m4, v4, b4, 1), An(v4, b4, 0, m4, 1, 0);
                  break;
                case Tn:
                  et2(p7, g4, m4, v4, b4, 0);
                  break;
                case Vn:
                  et2(p7, g4, m4, v4, b4, 0), An(v4, b4, 1, m4, 1, 0);
                  break;
                case zn:
                  en(p7, g4, m4, v4, b4);
                  break;
                case Gn:
                  en(p7, g4, m4, v4, b4), xn(v4, b4, m4, 1, 0);
                  break;
                case Un:
                  rn(p7, g4, m4, v4, b4);
                  break;
                default:
                  e2(0);
              }
              c4 += u4, l4 += f4;
            }
            t5.Ma += o3;
          } else
            alert("todo:EmitRescaledRowsYUVA");
          e2(t5.Ma <= n3.height);
        }
      }
      t5.C = r3, e2(t5.C <= t5.i);
    }
    function At2(t5) {
      var e3;
      if (0 < t5.ua)
        return 0;
      for (e3 = 0; e3 < t5.Wb; ++e3) {
        var r3 = t5.Ya[e3].G, n3 = t5.Ya[e3].H;
        if (0 < r3[1][n3[1] + 0].g || 0 < r3[2][n3[2] + 0].g || 0 < r3[3][n3[3] + 0].g)
          return 0;
      }
      return 1;
    }
    function xt2(t5, r3, n3, i3, a3, o3) {
      if (t5.Z != 0) {
        var s3 = t5.qd, c4 = t5.rd;
        for (e2(mi[t5.Z] != null); r3 < n3; ++r3)
          mi[t5.Z](s3, c4, i3, a3, i3, a3, o3), s3 = i3, c4 = a3, a3 += o3;
        t5.qd = s3, t5.rd = c4;
      }
    }
    function St(t5, r3) {
      var n3 = t5.l.ma, i3 = n3.Z == 0 || n3.Z == 1 ? t5.l.j : t5.C;
      i3 = t5.C < i3 ? i3 : t5.C;
      if (e2(r3 <= t5.l.o), r3 > i3) {
        var a3 = t5.l.width, o3 = n3.ca, s3 = n3.tb + a3 * i3, c4 = t5.V, u4 = t5.Ba + t5.c * i3, h4 = t5.gc;
        e2(t5.ab == 1), e2(h4[0].hc == 3), Xr(h4[0], i3, r3, c4, u4, o3, s3), xt2(n3, i3, r3, o3, s3, a3);
      }
      t5.C = t5.Ma = r3;
    }
    function _t2(t5, r3, n3, i3, a3, o3, s3) {
      var c4 = t5.$ / i3, u4 = t5.$ % i3, h4 = t5.m, l4 = t5.s, f4 = n3 + t5.$, d4 = f4;
      a3 = n3 + i3 * a3;
      var p7 = n3 + i3 * o3, g4 = 280 + l4.ua, m4 = t5.Pb ? c4 : 16777216, v4 = 0 < l4.ua ? l4.Wa : null, b4 = l4.wc, y4 = f4 < p7 ? wt2(l4, u4, c4) : null;
      e2(t5.C < o3), e2(p7 <= a3);
      var w4 = false;
      t:
        for (; ; ) {
          for (; w4 || f4 < p7; ) {
            var N4 = 0;
            if (c4 >= m4) {
              var _3 = f4 - n3;
              e2((m4 = t5).Pb), m4.wd = m4.m, m4.xd = _3, 0 < m4.s.ua && B3(m4.s.Wa, m4.s.vb), m4 = c4 + ti;
            }
            if (u4 & b4 || (y4 = wt2(l4, u4, c4)), e2(y4 != null), y4.Qb && (r3[f4] = y4.qb, w4 = true), !w4)
              if (S2(h4), y4.jc) {
                N4 = h4, _3 = r3;
                var P3 = f4, k3 = y4.pd[L3(N4) & Dr - 1];
                e2(y4.jc), 256 > k3.g ? (x2(N4, N4.u + k3.g), _3[P3] = k3.value, N4 = 0) : (x2(N4, N4.u + k3.g - 256), e2(256 <= k3.value), N4 = k3.value), N4 == 0 && (w4 = true);
              } else
                N4 = bt2(y4.G[0], y4.H[0], h4);
            if (h4.h)
              break;
            if (w4 || 256 > N4) {
              if (!w4)
                if (y4.nd)
                  r3[f4] = (y4.qb | N4 << 8) >>> 0;
                else {
                  if (S2(h4), w4 = bt2(y4.G[1], y4.H[1], h4), S2(h4), _3 = bt2(y4.G[2], y4.H[2], h4), P3 = bt2(y4.G[3], y4.H[3], h4), h4.h)
                    break;
                  r3[f4] = (P3 << 24 | w4 << 16 | N4 << 8 | _3) >>> 0;
                }
              if (w4 = false, ++f4, ++u4 >= i3 && (u4 = 0, ++c4, s3 != null && c4 <= o3 && !(c4 % 16) && s3(t5, c4), v4 != null))
                for (; d4 < f4; )
                  N4 = r3[d4++], v4.X[(506832829 * N4 & 4294967295) >>> v4.Mb] = N4;
            } else if (280 > N4) {
              if (N4 = mt2(N4 - 256, h4), _3 = bt2(y4.G[4], y4.H[4], h4), S2(h4), _3 = vt2(i3, _3 = mt2(_3, h4)), h4.h)
                break;
              if (f4 - n3 < _3 || a3 - f4 < N4)
                break t;
              for (P3 = 0; P3 < N4; ++P3)
                r3[f4 + P3] = r3[f4 + P3 - _3];
              for (f4 += N4, u4 += N4; u4 >= i3; )
                u4 -= i3, ++c4, s3 != null && c4 <= o3 && !(c4 % 16) && s3(t5, c4);
              if (e2(f4 <= a3), u4 & b4 && (y4 = wt2(l4, u4, c4)), v4 != null)
                for (; d4 < f4; )
                  N4 = r3[d4++], v4.X[(506832829 * N4 & 4294967295) >>> v4.Mb] = N4;
            } else {
              if (!(N4 < g4))
                break t;
              for (w4 = N4 - 280, e2(v4 != null); d4 < f4; )
                N4 = r3[d4++], v4.X[(506832829 * N4 & 4294967295) >>> v4.Mb] = N4;
              N4 = f4, e2(!(w4 >>> (_3 = v4).Xa)), r3[N4] = _3.X[w4], w4 = true;
            }
            w4 || e2(h4.h == A3(h4));
          }
          if (t5.Pb && h4.h && f4 < a3)
            e2(t5.m.h), t5.a = 5, t5.m = t5.wd, t5.$ = t5.xd, 0 < t5.s.ua && B3(t5.s.vb, t5.s.Wa);
          else {
            if (h4.h)
              break t;
            s3 != null && s3(t5, c4 > o3 ? o3 : c4), t5.a = 0, t5.$ = f4 - n3;
          }
          return 1;
        }
      return t5.a = 3, 0;
    }
    function Pt2(t5) {
      e2(t5 != null), t5.vc = null, t5.yc = null, t5.Ya = null;
      var r3 = t5.Wa;
      r3 != null && (r3.X = null), t5.vb = null, e2(t5 != null);
    }
    function kt2() {
      var e3 = new or();
      return e3 == null ? null : (e3.a = 0, e3.xb = gi, rt2("Predictor", "VP8LPredictors"), rt2("Predictor", "VP8LPredictors_C"), rt2("PredictorAdd", "VP8LPredictorsAdd"), rt2("PredictorAdd", "VP8LPredictorsAdd_C"), Gr = G2, $r = J2, Qr = K2, tn = Z2, en = $2, rn = Q2, nn = tt2, t4.VP8LMapColor32b = Jr, t4.VP8LMapColor8b = Kr, e3);
    }
    function It2(t5, r3, n3, s3, c4) {
      var u4 = 1, f4 = [t5], p7 = [r3], g4 = s3.m, m4 = s3.s, v4 = null, b4 = 0;
      t:
        for (; ; ) {
          if (n3)
            for (; u4 && y3(g4, 1); ) {
              var w4 = f4, N4 = p7, A4 = s3, _3 = 1, P3 = A4.m, k3 = A4.gc[A4.ab], I3 = y3(P3, 2);
              if (A4.Oc & 1 << I3)
                u4 = 0;
              else {
                switch (A4.Oc |= 1 << I3, k3.hc = I3, k3.Ea = w4[0], k3.nc = N4[0], k3.K = [null], ++A4.ab, e2(4 >= A4.ab), I3) {
                  case 0:
                  case 1:
                    k3.b = y3(P3, 3) + 2, _3 = It2(q2(k3.Ea, k3.b), q2(k3.nc, k3.b), 0, A4, k3.K), k3.K = k3.K[0];
                    break;
                  case 3:
                    var F3, C3 = y3(P3, 8) + 1, j3 = 16 < C3 ? 0 : 4 < C3 ? 1 : 2 < C3 ? 2 : 3;
                    if (w4[0] = q2(k3.Ea, j3), k3.b = j3, F3 = _3 = It2(C3, 1, 0, A4, k3.K)) {
                      var B4, M3 = C3, E3 = k3, R3 = 1 << (8 >> E3.b), T3 = a2(R3);
                      if (T3 == null)
                        F3 = 0;
                      else {
                        var z3 = E3.K[0], U3 = E3.w;
                        for (T3[0] = E3.K[0][0], B4 = 1; B4 < 1 * M3; ++B4)
                          T3[B4] = D2(z3[U3 + B4], T3[B4 - 1]);
                        for (; B4 < 4 * R3; ++B4)
                          T3[B4] = 0;
                        E3.K[0] = null, E3.K[0] = T3, F3 = 1;
                      }
                    }
                    _3 = F3;
                    break;
                  case 2:
                    break;
                  default:
                    e2(0);
                }
                u4 = _3;
              }
            }
          if (f4 = f4[0], p7 = p7[0], u4 && y3(g4, 1) && !(u4 = 1 <= (b4 = y3(g4, 4)) && 11 >= b4)) {
            s3.a = 3;
            break t;
          }
          var H5;
          if (H5 = u4)
            e: {
              var W3, V3, G3, Y3 = s3, J3 = f4, X3 = p7, K3 = b4, Z3 = n3, $3 = Y3.m, Q3 = Y3.s, tt3 = [null], et3 = 1, rt3 = 0, nt3 = Qn[K3];
              r:
                for (; ; ) {
                  if (Z3 && y3($3, 1)) {
                    var it3 = y3($3, 3) + 2, at3 = q2(J3, it3), ot3 = q2(X3, it3), st3 = at3 * ot3;
                    if (!It2(at3, ot3, 0, Y3, tt3))
                      break r;
                    for (tt3 = tt3[0], Q3.xc = it3, W3 = 0; W3 < st3; ++W3) {
                      var ct3 = tt3[W3] >> 8 & 65535;
                      tt3[W3] = ct3, ct3 >= et3 && (et3 = ct3 + 1);
                    }
                  }
                  if ($3.h)
                    break r;
                  for (V3 = 0; 5 > V3; ++V3) {
                    var ut3 = Xn2[V3];
                    !V3 && 0 < K3 && (ut3 += 1 << K3), rt3 < ut3 && (rt3 = ut3);
                  }
                  var ht3 = o2(et3 * nt3, l3), lt3 = et3, ft3 = o2(lt3, d3);
                  if (ft3 == null)
                    var dt3 = null;
                  else
                    e2(65536 >= lt3), dt3 = ft3;
                  var pt3 = a2(rt3);
                  if (dt3 == null || pt3 == null || ht3 == null) {
                    Y3.a = 1;
                    break r;
                  }
                  var gt3 = ht3;
                  for (W3 = G3 = 0; W3 < et3; ++W3) {
                    var mt3 = dt3[W3], vt3 = mt3.G, bt3 = mt3.H, wt3 = 0, Nt3 = 1, Lt3 = 0;
                    for (V3 = 0; 5 > V3; ++V3) {
                      ut3 = Xn2[V3], vt3[V3] = gt3, bt3[V3] = G3, !V3 && 0 < K3 && (ut3 += 1 << K3);
                      n: {
                        var At3, xt3 = ut3, St2 = Y3, kt3 = pt3, Ft3 = gt3, Ct3 = G3, jt3 = 0, Ot3 = St2.m, Bt3 = y3(Ot3, 1);
                        if (i2(kt3, 0, 0, xt3), Bt3) {
                          var Mt3 = y3(Ot3, 1) + 1, Et3 = y3(Ot3, 1), qt3 = y3(Ot3, Et3 == 0 ? 1 : 8);
                          kt3[qt3] = 1, Mt3 == 2 && (kt3[qt3 = y3(Ot3, 8)] = 1);
                          var Dt3 = 1;
                        } else {
                          var Rt3 = a2(19), Tt3 = y3(Ot3, 4) + 4;
                          if (19 < Tt3) {
                            St2.a = 3;
                            var zt3 = 0;
                            break n;
                          }
                          for (At3 = 0; At3 < Tt3; ++At3)
                            Rt3[Zn2[At3]] = y3(Ot3, 3);
                          var Ut3 = void 0, Ht3 = void 0, Wt3 = St2, Vt3 = Rt3, Gt3 = xt3, Yt3 = kt3, Jt3 = 0, Xt3 = Wt3.m, Kt3 = 8, Zt3 = o2(128, l3);
                          i:
                            for (; h3(Zt3, 0, 7, Vt3, 19); ) {
                              if (y3(Xt3, 1)) {
                                var $t3 = 2 + 2 * y3(Xt3, 3);
                                if ((Ut3 = 2 + y3(Xt3, $t3)) > Gt3)
                                  break i;
                              } else
                                Ut3 = Gt3;
                              for (Ht3 = 0; Ht3 < Gt3 && Ut3--; ) {
                                S2(Xt3);
                                var Qt3 = Zt3[0 + (127 & L3(Xt3))];
                                x2(Xt3, Xt3.u + Qt3.g);
                                var te3 = Qt3.value;
                                if (16 > te3)
                                  Yt3[Ht3++] = te3, te3 != 0 && (Kt3 = te3);
                                else {
                                  var ee3 = te3 == 16, re3 = te3 - 16, ne3 = Jn[re3], ie3 = y3(Xt3, Yn2[re3]) + ne3;
                                  if (Ht3 + ie3 > Gt3)
                                    break i;
                                  for (var ae3 = ee3 ? Kt3 : 0; 0 < ie3--; )
                                    Yt3[Ht3++] = ae3;
                                }
                              }
                              Jt3 = 1;
                              break i;
                            }
                          Jt3 || (Wt3.a = 3), Dt3 = Jt3;
                        }
                        (Dt3 = Dt3 && !Ot3.h) && (jt3 = h3(Ft3, Ct3, 8, kt3, xt3)), Dt3 && jt3 != 0 ? zt3 = jt3 : (St2.a = 3, zt3 = 0);
                      }
                      if (zt3 == 0)
                        break r;
                      if (Nt3 && Kn[V3] == 1 && (Nt3 = gt3[G3].g == 0), wt3 += gt3[G3].g, G3 += zt3, 3 >= V3) {
                        var oe3, se3 = pt3[0];
                        for (oe3 = 1; oe3 < ut3; ++oe3)
                          pt3[oe3] > se3 && (se3 = pt3[oe3]);
                        Lt3 += se3;
                      }
                    }
                    if (mt3.nd = Nt3, mt3.Qb = 0, Nt3 && (mt3.qb = (vt3[3][bt3[3] + 0].value << 24 | vt3[1][bt3[1] + 0].value << 16 | vt3[2][bt3[2] + 0].value) >>> 0, wt3 == 0 && 256 > vt3[0][bt3[0] + 0].value && (mt3.Qb = 1, mt3.qb += vt3[0][bt3[0] + 0].value << 8)), mt3.jc = !mt3.Qb && 6 > Lt3, mt3.jc) {
                      var ce3, ue3 = mt3;
                      for (ce3 = 0; ce3 < Dr; ++ce3) {
                        var he3 = ce3, le3 = ue3.pd[he3], fe3 = ue3.G[0][ue3.H[0] + he3];
                        256 <= fe3.value ? (le3.g = fe3.g + 256, le3.value = fe3.value) : (le3.g = 0, le3.value = 0, he3 >>= yt2(fe3, 8, le3), he3 >>= yt2(ue3.G[1][ue3.H[1] + he3], 16, le3), he3 >>= yt2(ue3.G[2][ue3.H[2] + he3], 0, le3), yt2(ue3.G[3][ue3.H[3] + he3], 24, le3));
                      }
                    }
                  }
                  Q3.vc = tt3, Q3.Wb = et3, Q3.Ya = dt3, Q3.yc = ht3, H5 = 1;
                  break e;
                }
              H5 = 0;
            }
          if (!(u4 = H5)) {
            s3.a = 3;
            break t;
          }
          if (0 < b4) {
            if (m4.ua = 1 << b4, !O2(m4.Wa, b4)) {
              s3.a = 1, u4 = 0;
              break t;
            }
          } else
            m4.ua = 0;
          var de3 = s3, pe3 = f4, ge3 = p7, me3 = de3.s, ve3 = me3.xc;
          if (de3.c = pe3, de3.i = ge3, me3.md = q2(pe3, ve3), me3.wc = ve3 == 0 ? -1 : (1 << ve3) - 1, n3) {
            s3.xb = pi;
            break t;
          }
          if ((v4 = a2(f4 * p7)) == null) {
            s3.a = 1, u4 = 0;
            break t;
          }
          u4 = (u4 = _t2(s3, v4, 0, f4, p7, p7, null)) && !g4.h;
          break t;
        }
      return u4 ? (c4 != null ? c4[0] = v4 : (e2(v4 == null), e2(n3)), s3.$ = 0, n3 || Pt2(m4)) : Pt2(m4), u4;
    }
    function Ft2(t5, r3) {
      var n3 = t5.c * t5.i, i3 = n3 + r3 + 16 * r3;
      return e2(t5.c <= r3), t5.V = a2(i3), t5.V == null ? (t5.Ta = null, t5.Ua = 0, t5.a = 1, 0) : (t5.Ta = t5.V, t5.Ua = t5.Ba + n3 + r3, 1);
    }
    function Ct2(t5, r3) {
      var n3 = t5.C, i3 = r3 - n3, a3 = t5.V, o3 = t5.Ba + t5.c * n3;
      for (e2(r3 <= t5.l.o); 0 < i3; ) {
        var s3 = 16 < i3 ? 16 : i3, c4 = t5.l.ma, u4 = t5.l.width, h4 = u4 * s3, l4 = c4.ca, f4 = c4.tb + u4 * n3, d4 = t5.Ta, p7 = t5.Ua;
        Nt2(t5, s3, a3, o3), _n(d4, p7, l4, f4, h4), xt2(c4, n3, n3 + s3, l4, f4, u4), i3 -= s3, a3 += s3 * t5.c, n3 += s3;
      }
      e2(n3 == r3), t5.C = t5.Ma = r3;
    }
    function jt2() {
      this.ub = this.yd = this.td = this.Rb = 0;
    }
    function Ot2() {
      this.Kd = this.Ld = this.Ud = this.Td = this.i = this.c = 0;
    }
    function Bt2() {
      this.Fb = this.Bb = this.Cb = 0, this.Zb = a2(4), this.Lb = a2(4);
    }
    function Mt2() {
      this.Yb = function() {
        var t5 = [];
        return function t6(e3, r3, n3) {
          for (var i3 = n3[r3], a3 = 0; a3 < i3 && (e3.push(n3.length > r3 + 1 ? [] : 0), !(n3.length < r3 + 1)); a3++)
            t6(e3[a3], r3 + 1, n3);
        }(t5, 0, [3, 11]), t5;
      }();
    }
    function Et2() {
      this.jb = a2(3), this.Wc = s2([4, 8], Mt2), this.Xc = s2([4, 17], Mt2);
    }
    function qt2() {
      this.Pc = this.wb = this.Tb = this.zd = 0, this.vd = new a2(4), this.od = new a2(4);
    }
    function Dt2() {
      this.ld = this.La = this.dd = this.tc = 0;
    }
    function Rt2() {
      this.Na = this.la = 0;
    }
    function Tt2() {
      this.Sc = [0, 0], this.Eb = [0, 0], this.Qc = [0, 0], this.ia = this.lc = 0;
    }
    function zt2() {
      this.ad = a2(384), this.Za = 0, this.Ob = a2(16), this.$b = this.Ad = this.ia = this.Gc = this.Hc = this.Dd = 0;
    }
    function Ut2() {
      this.uc = this.M = this.Nb = 0, this.wa = Array(new Dt2()), this.Y = 0, this.ya = Array(new zt2()), this.aa = 0, this.l = new Gt2();
    }
    function Ht2() {
      this.y = a2(16), this.f = a2(8), this.ea = a2(8);
    }
    function Wt2() {
      this.cb = this.a = 0, this.sc = "", this.m = new w3(), this.Od = new jt2(), this.Kc = new Ot2(), this.ed = new qt2(), this.Qa = new Bt2(), this.Ic = this.$c = this.Aa = 0, this.D = new Ut2(), this.Xb = this.Va = this.Hb = this.zb = this.yb = this.Ub = this.za = 0, this.Jc = o2(8, w3), this.ia = 0, this.pb = o2(4, Tt2), this.Pa = new Et2(), this.Bd = this.kc = 0, this.Ac = [], this.Bc = 0, this.zc = [0, 0, 0, 0], this.Gd = Array(new Ht2()), this.Hd = 0, this.rb = Array(new Rt2()), this.sb = 0, this.wa = Array(new Dt2()), this.Y = 0, this.oc = [], this.pc = 0, this.sa = [], this.ta = 0, this.qa = [], this.ra = 0, this.Ha = [], this.B = this.R = this.Ia = 0, this.Ec = [], this.M = this.ja = this.Vb = this.Fc = 0, this.ya = Array(new zt2()), this.L = this.aa = 0, this.gd = s2([4, 2], Dt2), this.ga = null, this.Fa = [], this.Cc = this.qc = this.P = 0, this.Gb = [], this.Uc = 0, this.mb = [], this.nb = 0, this.rc = [], this.Ga = this.Vc = 0;
    }
    function Vt2(t5, e3) {
      return 0 > t5 ? 0 : t5 > e3 ? e3 : t5;
    }
    function Gt2() {
      this.T = this.U = this.ka = this.height = this.width = 0, this.y = [], this.f = [], this.ea = [], this.Rc = this.fa = this.W = this.N = this.O = 0, this.ma = "void", this.put = "VP8IoPutHook", this.ac = "VP8IoSetupHook", this.bc = "VP8IoTeardownHook", this.ha = this.Kb = 0, this.data = [], this.hb = this.ib = this.da = this.o = this.j = this.va = this.v = this.Da = this.ob = this.w = 0, this.F = [], this.J = 0;
    }
    function Yt2() {
      var t5 = new Wt2();
      return t5 != null && (t5.a = 0, t5.sc = "OK", t5.cb = 0, t5.Xb = 0, ni || (ni = Zt2)), t5;
    }
    function Jt2(t5, e3, r3) {
      return t5.a == 0 && (t5.a = e3, t5.sc = r3, t5.cb = 0), 0;
    }
    function Xt2(t5, e3, r3) {
      return 3 <= r3 && t5[e3 + 0] == 157 && t5[e3 + 1] == 1 && t5[e3 + 2] == 42;
    }
    function Kt2(t5, r3) {
      if (t5 == null)
        return 0;
      if (t5.a = 0, t5.sc = "OK", r3 == null)
        return Jt2(t5, 2, "null VP8Io passed to VP8GetHeaders()");
      var n3 = r3.data, a3 = r3.w, o3 = r3.ha;
      if (4 > o3)
        return Jt2(t5, 7, "Truncated header.");
      var s3 = n3[a3 + 0] | n3[a3 + 1] << 8 | n3[a3 + 2] << 16, c4 = t5.Od;
      if (c4.Rb = !(1 & s3), c4.td = s3 >> 1 & 7, c4.yd = s3 >> 4 & 1, c4.ub = s3 >> 5, 3 < c4.td)
        return Jt2(t5, 3, "Incorrect keyframe parameters.");
      if (!c4.yd)
        return Jt2(t5, 4, "Frame not displayable.");
      a3 += 3, o3 -= 3;
      var u4 = t5.Kc;
      if (c4.Rb) {
        if (7 > o3)
          return Jt2(t5, 7, "cannot parse picture header");
        if (!Xt2(n3, a3, o3))
          return Jt2(t5, 3, "Bad code word");
        u4.c = 16383 & (n3[a3 + 4] << 8 | n3[a3 + 3]), u4.Td = n3[a3 + 4] >> 6, u4.i = 16383 & (n3[a3 + 6] << 8 | n3[a3 + 5]), u4.Ud = n3[a3 + 6] >> 6, a3 += 7, o3 -= 7, t5.za = u4.c + 15 >> 4, t5.Ub = u4.i + 15 >> 4, r3.width = u4.c, r3.height = u4.i, r3.Da = 0, r3.j = 0, r3.v = 0, r3.va = r3.width, r3.o = r3.height, r3.da = 0, r3.ib = r3.width, r3.hb = r3.height, r3.U = r3.width, r3.T = r3.height, i2((s3 = t5.Pa).jb, 0, 255, s3.jb.length), e2((s3 = t5.Qa) != null), s3.Cb = 0, s3.Bb = 0, s3.Fb = 1, i2(s3.Zb, 0, 0, s3.Zb.length), i2(s3.Lb, 0, 0, s3.Lb);
      }
      if (c4.ub > o3)
        return Jt2(t5, 7, "bad partition length");
      p6(s3 = t5.m, n3, a3, c4.ub), a3 += c4.ub, o3 -= c4.ub, c4.Rb && (u4.Ld = P2(s3), u4.Kd = P2(s3)), u4 = t5.Qa;
      var h4, l4 = t5.Pa;
      if (e2(s3 != null), e2(u4 != null), u4.Cb = P2(s3), u4.Cb) {
        if (u4.Bb = P2(s3), P2(s3)) {
          for (u4.Fb = P2(s3), h4 = 0; 4 > h4; ++h4)
            u4.Zb[h4] = P2(s3) ? m3(s3, 7) : 0;
          for (h4 = 0; 4 > h4; ++h4)
            u4.Lb[h4] = P2(s3) ? m3(s3, 6) : 0;
        }
        if (u4.Bb)
          for (h4 = 0; 3 > h4; ++h4)
            l4.jb[h4] = P2(s3) ? g3(s3, 8) : 255;
      } else
        u4.Bb = 0;
      if (s3.Ka)
        return Jt2(t5, 3, "cannot parse segment header");
      if ((u4 = t5.ed).zd = P2(s3), u4.Tb = g3(s3, 6), u4.wb = g3(s3, 3), u4.Pc = P2(s3), u4.Pc && P2(s3)) {
        for (l4 = 0; 4 > l4; ++l4)
          P2(s3) && (u4.vd[l4] = m3(s3, 6));
        for (l4 = 0; 4 > l4; ++l4)
          P2(s3) && (u4.od[l4] = m3(s3, 6));
      }
      if (t5.L = u4.Tb == 0 ? 0 : u4.zd ? 1 : 2, s3.Ka)
        return Jt2(t5, 3, "cannot parse filter header");
      var f4 = o3;
      if (o3 = h4 = a3, a3 = h4 + f4, u4 = f4, t5.Xb = (1 << g3(t5.m, 2)) - 1, f4 < 3 * (l4 = t5.Xb))
        n3 = 7;
      else {
        for (h4 += 3 * l4, u4 -= 3 * l4, f4 = 0; f4 < l4; ++f4) {
          var d4 = n3[o3 + 0] | n3[o3 + 1] << 8 | n3[o3 + 2] << 16;
          d4 > u4 && (d4 = u4), p6(t5.Jc[+f4], n3, h4, d4), h4 += d4, u4 -= d4, o3 += 3;
        }
        p6(t5.Jc[+l4], n3, h4, u4), n3 = h4 < a3 ? 0 : 5;
      }
      if (n3 != 0)
        return Jt2(t5, n3, "cannot parse partitions");
      for (n3 = g3(h4 = t5.m, 7), o3 = P2(h4) ? m3(h4, 4) : 0, a3 = P2(h4) ? m3(h4, 4) : 0, u4 = P2(h4) ? m3(h4, 4) : 0, l4 = P2(h4) ? m3(h4, 4) : 0, h4 = P2(h4) ? m3(h4, 4) : 0, f4 = t5.Qa, d4 = 0; 4 > d4; ++d4) {
        if (f4.Cb) {
          var v4 = f4.Zb[d4];
          f4.Fb || (v4 += n3);
        } else {
          if (0 < d4) {
            t5.pb[d4] = t5.pb[0];
            continue;
          }
          v4 = n3;
        }
        var b4 = t5.pb[d4];
        b4.Sc[0] = ei[Vt2(v4 + o3, 127)], b4.Sc[1] = ri[Vt2(v4 + 0, 127)], b4.Eb[0] = 2 * ei[Vt2(v4 + a3, 127)], b4.Eb[1] = 101581 * ri[Vt2(v4 + u4, 127)] >> 16, 8 > b4.Eb[1] && (b4.Eb[1] = 8), b4.Qc[0] = ei[Vt2(v4 + l4, 117)], b4.Qc[1] = ri[Vt2(v4 + h4, 127)], b4.lc = v4 + h4;
      }
      if (!c4.Rb)
        return Jt2(t5, 4, "Not a key frame.");
      for (P2(s3), c4 = t5.Pa, n3 = 0; 4 > n3; ++n3) {
        for (o3 = 0; 8 > o3; ++o3)
          for (a3 = 0; 3 > a3; ++a3)
            for (u4 = 0; 11 > u4; ++u4)
              l4 = k2(s3, ui[n3][o3][a3][u4]) ? g3(s3, 8) : si[n3][o3][a3][u4], c4.Wc[n3][o3].Yb[a3][u4] = l4;
        for (o3 = 0; 17 > o3; ++o3)
          c4.Xc[n3][o3] = c4.Wc[n3][hi[o3]];
      }
      return t5.kc = P2(s3), t5.kc && (t5.Bd = g3(s3, 8)), t5.cb = 1;
    }
    function Zt2(t5, e3, r3, n3, i3, a3, o3) {
      var s3 = e3[i3].Yb[r3];
      for (r3 = 0; 16 > i3; ++i3) {
        if (!k2(t5, s3[r3 + 0]))
          return i3;
        for (; !k2(t5, s3[r3 + 1]); )
          if (s3 = e3[++i3].Yb[0], r3 = 0, i3 == 16)
            return 16;
        var c4 = e3[i3 + 1].Yb;
        if (k2(t5, s3[r3 + 2])) {
          var u4 = t5, h4 = 0;
          if (k2(u4, (f4 = s3)[(l4 = r3) + 3]))
            if (k2(u4, f4[l4 + 6])) {
              for (s3 = 0, l4 = 2 * (h4 = k2(u4, f4[l4 + 8])) + (f4 = k2(u4, f4[l4 + 9 + h4])), h4 = 0, f4 = ii[l4]; f4[s3]; ++s3)
                h4 += h4 + k2(u4, f4[s3]);
              h4 += 3 + (8 << l4);
            } else
              k2(u4, f4[l4 + 7]) ? (h4 = 7 + 2 * k2(u4, 165), h4 += k2(u4, 145)) : h4 = 5 + k2(u4, 159);
          else
            h4 = k2(u4, f4[l4 + 4]) ? 3 + k2(u4, f4[l4 + 5]) : 2;
          s3 = c4[2];
        } else
          h4 = 1, s3 = c4[1];
        c4 = o3 + ai[i3], 0 > (u4 = t5).b && _2(u4);
        var l4, f4 = u4.b, d4 = (l4 = u4.Ca >> 1) - (u4.I >> f4) >> 31;
        --u4.b, u4.Ca += d4, u4.Ca |= 1, u4.I -= (l4 + 1 & d4) << f4, a3[c4] = ((h4 ^ d4) - d4) * n3[(0 < i3) + 0];
      }
      return 16;
    }
    function $t2(t5) {
      var e3 = t5.rb[t5.sb - 1];
      e3.la = 0, e3.Na = 0, i2(t5.zc, 0, 0, t5.zc.length), t5.ja = 0;
    }
    function Qt2(t5, r3) {
      if (t5 == null)
        return 0;
      if (r3 == null)
        return Jt2(t5, 2, "NULL VP8Io parameter in VP8Decode().");
      if (!t5.cb && !Kt2(t5, r3))
        return 0;
      if (e2(t5.cb), r3.ac == null || r3.ac(r3)) {
        r3.ob && (t5.L = 0);
        var s3 = Ri[t5.L];
        if (t5.L == 2 ? (t5.yb = 0, t5.zb = 0) : (t5.yb = r3.v - s3 >> 4, t5.zb = r3.j - s3 >> 4, 0 > t5.yb && (t5.yb = 0), 0 > t5.zb && (t5.zb = 0)), t5.Va = r3.o + 15 + s3 >> 4, t5.Hb = r3.va + 15 + s3 >> 4, t5.Hb > t5.za && (t5.Hb = t5.za), t5.Va > t5.Ub && (t5.Va = t5.Ub), 0 < t5.L) {
          var c4 = t5.ed;
          for (s3 = 0; 4 > s3; ++s3) {
            var u4;
            if (t5.Qa.Cb) {
              var h4 = t5.Qa.Lb[s3];
              t5.Qa.Fb || (h4 += c4.Tb);
            } else
              h4 = c4.Tb;
            for (u4 = 0; 1 >= u4; ++u4) {
              var l4 = t5.gd[s3][u4], f4 = h4;
              if (c4.Pc && (f4 += c4.vd[0], u4 && (f4 += c4.od[0])), 0 < (f4 = 0 > f4 ? 0 : 63 < f4 ? 63 : f4)) {
                var d4 = f4;
                0 < c4.wb && ((d4 = 4 < c4.wb ? d4 >> 2 : d4 >> 1) > 9 - c4.wb && (d4 = 9 - c4.wb)), 1 > d4 && (d4 = 1), l4.dd = d4, l4.tc = 2 * f4 + d4, l4.ld = 40 <= f4 ? 2 : 15 <= f4 ? 1 : 0;
              } else
                l4.tc = 0;
              l4.La = u4;
            }
          }
        }
        s3 = 0;
      } else
        Jt2(t5, 6, "Frame setup failed"), s3 = t5.a;
      if (s3 = s3 == 0) {
        if (s3) {
          t5.$c = 0, 0 < t5.Aa || (t5.Ic = zi);
          t: {
            s3 = t5.Ic;
            c4 = 4 * (d4 = t5.za);
            var p7 = 32 * d4, g4 = d4 + 1, m4 = 0 < t5.L ? d4 * (0 < t5.Aa ? 2 : 1) : 0, v4 = (t5.Aa == 2 ? 2 : 1) * d4;
            if ((l4 = c4 + 832 + (u4 = 3 * (16 * s3 + Ri[t5.L]) / 2 * p7) + (h4 = t5.Fa != null && 0 < t5.Fa.length ? t5.Kc.c * t5.Kc.i : 0)) != l4)
              s3 = 0;
            else {
              if (l4 > t5.Vb) {
                if (t5.Vb = 0, t5.Ec = a2(l4), t5.Fc = 0, t5.Ec == null) {
                  s3 = Jt2(t5, 1, "no memory during frame initialization.");
                  break t;
                }
                t5.Vb = l4;
              }
              l4 = t5.Ec, f4 = t5.Fc, t5.Ac = l4, t5.Bc = f4, f4 += c4, t5.Gd = o2(p7, Ht2), t5.Hd = 0, t5.rb = o2(g4 + 1, Rt2), t5.sb = 1, t5.wa = m4 ? o2(m4, Dt2) : null, t5.Y = 0, t5.D.Nb = 0, t5.D.wa = t5.wa, t5.D.Y = t5.Y, 0 < t5.Aa && (t5.D.Y += d4), e2(true), t5.oc = l4, t5.pc = f4, f4 += 832, t5.ya = o2(v4, zt2), t5.aa = 0, t5.D.ya = t5.ya, t5.D.aa = t5.aa, t5.Aa == 2 && (t5.D.aa += d4), t5.R = 16 * d4, t5.B = 8 * d4, d4 = (p7 = Ri[t5.L]) * t5.R, p7 = p7 / 2 * t5.B, t5.sa = l4, t5.ta = f4 + d4, t5.qa = t5.sa, t5.ra = t5.ta + 16 * s3 * t5.R + p7, t5.Ha = t5.qa, t5.Ia = t5.ra + 8 * s3 * t5.B + p7, t5.$c = 0, f4 += u4, t5.mb = h4 ? l4 : null, t5.nb = h4 ? f4 : null, e2(f4 + h4 <= t5.Fc + t5.Vb), $t2(t5), i2(t5.Ac, t5.Bc, 0, c4), s3 = 1;
            }
          }
          if (s3) {
            if (r3.ka = 0, r3.y = t5.sa, r3.O = t5.ta, r3.f = t5.qa, r3.N = t5.ra, r3.ea = t5.Ha, r3.Vd = t5.Ia, r3.fa = t5.R, r3.Rc = t5.B, r3.F = null, r3.J = 0, !Cn) {
              for (s3 = -255; 255 >= s3; ++s3)
                Pn[255 + s3] = 0 > s3 ? -s3 : s3;
              for (s3 = -1020; 1020 >= s3; ++s3)
                kn[1020 + s3] = -128 > s3 ? -128 : 127 < s3 ? 127 : s3;
              for (s3 = -112; 112 >= s3; ++s3)
                In[112 + s3] = -16 > s3 ? -16 : 15 < s3 ? 15 : s3;
              for (s3 = -255; 510 >= s3; ++s3)
                Fn[255 + s3] = 0 > s3 ? 0 : 255 < s3 ? 255 : s3;
              Cn = 1;
            }
            an = ue2, on = ae2, cn = oe2, un = se2, hn = ce2, sn = ie2, ln2 = Je, fn = Xe, dn = $e, pn = Qe, gn = Ke, mn = Ze, vn = tr, bn = er, yn = Ue, wn = He, Nn = We, Ln = Ve, fi[0] = xe, fi[1] = le2, fi[2] = Le2, fi[3] = Ae, fi[4] = Se, fi[5] = Pe, fi[6] = _e, fi[7] = ke, fi[8] = Fe, fi[9] = Ie, li[0] = ve2, li[1] = de2, li[2] = pe2, li[3] = ge2, li[4] = be2, li[5] = ye2, li[6] = we2, di[0] = Be, di[1] = fe2, di[2] = Ce, di[3] = je, di[4] = Ee, di[5] = Me, di[6] = qe, s3 = 1;
          } else
            s3 = 0;
        }
        s3 && (s3 = function(t6, r4) {
          for (t6.M = 0; t6.M < t6.Va; ++t6.M) {
            var o3, s4 = t6.Jc[t6.M & t6.Xb], c5 = t6.m, u5 = t6;
            for (o3 = 0; o3 < u5.za; ++o3) {
              var h5 = c5, l5 = u5, f5 = l5.Ac, d5 = l5.Bc + 4 * o3, p8 = l5.zc, g5 = l5.ya[l5.aa + o3];
              if (l5.Qa.Bb ? g5.$b = k2(h5, l5.Pa.jb[0]) ? 2 + k2(h5, l5.Pa.jb[2]) : k2(h5, l5.Pa.jb[1]) : g5.$b = 0, l5.kc && (g5.Ad = k2(h5, l5.Bd)), g5.Za = !k2(h5, 145) + 0, g5.Za) {
                var m5 = g5.Ob, v5 = 0;
                for (l5 = 0; 4 > l5; ++l5) {
                  var b4, y4 = p8[0 + l5];
                  for (b4 = 0; 4 > b4; ++b4) {
                    y4 = ci[f5[d5 + b4]][y4];
                    for (var w4 = oi[k2(h5, y4[0])]; 0 < w4; )
                      w4 = oi[2 * w4 + k2(h5, y4[w4])];
                    y4 = -w4, f5[d5 + b4] = y4;
                  }
                  n2(m5, v5, f5, d5, 4), v5 += 4, p8[0 + l5] = y4;
                }
              } else
                y4 = k2(h5, 156) ? k2(h5, 128) ? 1 : 3 : k2(h5, 163) ? 2 : 0, g5.Ob[0] = y4, i2(f5, d5, y4, 4), i2(p8, 0, y4, 4);
              g5.Dd = k2(h5, 142) ? k2(h5, 114) ? k2(h5, 183) ? 1 : 3 : 2 : 0;
            }
            if (u5.m.Ka)
              return Jt2(t6, 7, "Premature end-of-partition0 encountered.");
            for (; t6.ja < t6.za; ++t6.ja) {
              if (u5 = s4, h5 = (c5 = t6).rb[c5.sb - 1], f5 = c5.rb[c5.sb + c5.ja], o3 = c5.ya[c5.aa + c5.ja], d5 = c5.kc ? o3.Ad : 0)
                h5.la = f5.la = 0, o3.Za || (h5.Na = f5.Na = 0), o3.Hc = 0, o3.Gc = 0, o3.ia = 0;
              else {
                var N4, L4;
                h5 = f5, f5 = u5, d5 = c5.Pa.Xc, p8 = c5.ya[c5.aa + c5.ja], g5 = c5.pb[p8.$b];
                if (l5 = p8.ad, m5 = 0, v5 = c5.rb[c5.sb - 1], y4 = b4 = 0, i2(l5, m5, 0, 384), p8.Za)
                  var A4 = 0, x3 = d5[3];
                else {
                  w4 = a2(16);
                  var S3 = h5.Na + v5.Na;
                  if (S3 = ni(f5, d5[1], S3, g5.Eb, 0, w4, 0), h5.Na = v5.Na = (0 < S3) + 0, 1 < S3)
                    an(w4, 0, l5, m5);
                  else {
                    var _3 = w4[0] + 3 >> 3;
                    for (w4 = 0; 256 > w4; w4 += 16)
                      l5[m5 + w4] = _3;
                  }
                  A4 = 1, x3 = d5[0];
                }
                var P3 = 15 & h5.la, I3 = 15 & v5.la;
                for (w4 = 0; 4 > w4; ++w4) {
                  var F3 = 1 & I3;
                  for (_3 = L4 = 0; 4 > _3; ++_3)
                    P3 = P3 >> 1 | (F3 = (S3 = ni(f5, x3, S3 = F3 + (1 & P3), g5.Sc, A4, l5, m5)) > A4) << 7, L4 = L4 << 2 | (3 < S3 ? 3 : 1 < S3 ? 2 : l5[m5 + 0] != 0), m5 += 16;
                  P3 >>= 4, I3 = I3 >> 1 | F3 << 7, b4 = (b4 << 8 | L4) >>> 0;
                }
                for (x3 = P3, A4 = I3 >> 4, N4 = 0; 4 > N4; N4 += 2) {
                  for (L4 = 0, P3 = h5.la >> 4 + N4, I3 = v5.la >> 4 + N4, w4 = 0; 2 > w4; ++w4) {
                    for (F3 = 1 & I3, _3 = 0; 2 > _3; ++_3)
                      S3 = F3 + (1 & P3), P3 = P3 >> 1 | (F3 = 0 < (S3 = ni(f5, d5[2], S3, g5.Qc, 0, l5, m5))) << 3, L4 = L4 << 2 | (3 < S3 ? 3 : 1 < S3 ? 2 : l5[m5 + 0] != 0), m5 += 16;
                    P3 >>= 2, I3 = I3 >> 1 | F3 << 5;
                  }
                  y4 |= L4 << 4 * N4, x3 |= P3 << 4 << N4, A4 |= (240 & I3) << N4;
                }
                h5.la = x3, v5.la = A4, p8.Hc = b4, p8.Gc = y4, p8.ia = 43690 & y4 ? 0 : g5.ia, d5 = !(b4 | y4);
              }
              if (0 < c5.L && (c5.wa[c5.Y + c5.ja] = c5.gd[o3.$b][o3.Za], c5.wa[c5.Y + c5.ja].La |= !d5), u5.Ka)
                return Jt2(t6, 7, "Premature end-of-file encountered.");
            }
            if ($t2(t6), c5 = r4, u5 = 1, o3 = (s4 = t6).D, h5 = 0 < s4.L && s4.M >= s4.zb && s4.M <= s4.Va, s4.Aa == 0)
              t: {
                if (o3.M = s4.M, o3.uc = h5, Or(s4, o3), u5 = 1, o3 = (L4 = s4.D).Nb, h5 = (y4 = Ri[s4.L]) * s4.R, f5 = y4 / 2 * s4.B, w4 = 16 * o3 * s4.R, _3 = 8 * o3 * s4.B, d5 = s4.sa, p8 = s4.ta - h5 + w4, g5 = s4.qa, l5 = s4.ra - f5 + _3, m5 = s4.Ha, v5 = s4.Ia - f5 + _3, I3 = (P3 = L4.M) == 0, b4 = P3 >= s4.Va - 1, s4.Aa == 2 && Or(s4, L4), L4.uc)
                  for (F3 = (S3 = s4).D.M, e2(S3.D.uc), L4 = S3.yb; L4 < S3.Hb; ++L4) {
                    A4 = L4, x3 = F3;
                    var C3 = (j3 = (z3 = S3).D).Nb;
                    N4 = z3.R;
                    var j3 = j3.wa[j3.Y + A4], O3 = z3.sa, B4 = z3.ta + 16 * C3 * N4 + 16 * A4, M3 = j3.dd, E3 = j3.tc;
                    if (E3 != 0)
                      if (e2(3 <= E3), z3.L == 1)
                        0 < A4 && wn(O3, B4, N4, E3 + 4), j3.La && Ln(O3, B4, N4, E3), 0 < x3 && yn(O3, B4, N4, E3 + 4), j3.La && Nn(O3, B4, N4, E3);
                      else {
                        var q3 = z3.B, D3 = z3.qa, R3 = z3.ra + 8 * C3 * q3 + 8 * A4, T3 = z3.Ha, z3 = z3.Ia + 8 * C3 * q3 + 8 * A4;
                        C3 = j3.ld;
                        0 < A4 && (fn(O3, B4, N4, E3 + 4, M3, C3), pn(D3, R3, T3, z3, q3, E3 + 4, M3, C3)), j3.La && (mn(O3, B4, N4, E3, M3, C3), bn(D3, R3, T3, z3, q3, E3, M3, C3)), 0 < x3 && (ln2(O3, B4, N4, E3 + 4, M3, C3), dn(D3, R3, T3, z3, q3, E3 + 4, M3, C3)), j3.La && (gn(O3, B4, N4, E3, M3, C3), vn(D3, R3, T3, z3, q3, E3, M3, C3));
                      }
                  }
                if (s4.ia && alert("todo:DitherRow"), c5.put != null) {
                  if (L4 = 16 * P3, P3 = 16 * (P3 + 1), I3 ? (c5.y = s4.sa, c5.O = s4.ta + w4, c5.f = s4.qa, c5.N = s4.ra + _3, c5.ea = s4.Ha, c5.W = s4.Ia + _3) : (L4 -= y4, c5.y = d5, c5.O = p8, c5.f = g5, c5.N = l5, c5.ea = m5, c5.W = v5), b4 || (P3 -= y4), P3 > c5.o && (P3 = c5.o), c5.F = null, c5.J = null, s4.Fa != null && 0 < s4.Fa.length && L4 < P3 && (c5.J = lr(s4, c5, L4, P3 - L4), c5.F = s4.mb, c5.F == null && c5.F.length == 0)) {
                    u5 = Jt2(s4, 3, "Could not decode alpha data.");
                    break t;
                  }
                  L4 < c5.j && (y4 = c5.j - L4, L4 = c5.j, e2(!(1 & y4)), c5.O += s4.R * y4, c5.N += s4.B * (y4 >> 1), c5.W += s4.B * (y4 >> 1), c5.F != null && (c5.J += c5.width * y4)), L4 < P3 && (c5.O += c5.v, c5.N += c5.v >> 1, c5.W += c5.v >> 1, c5.F != null && (c5.J += c5.v), c5.ka = L4 - c5.j, c5.U = c5.va - c5.v, c5.T = P3 - L4, u5 = c5.put(c5));
                }
                o3 + 1 != s4.Ic || b4 || (n2(s4.sa, s4.ta - h5, d5, p8 + 16 * s4.R, h5), n2(s4.qa, s4.ra - f5, g5, l5 + 8 * s4.B, f5), n2(s4.Ha, s4.Ia - f5, m5, v5 + 8 * s4.B, f5));
              }
            if (!u5)
              return Jt2(t6, 6, "Output aborted.");
          }
          return 1;
        }(t5, r3)), r3.bc != null && r3.bc(r3), s3 &= 1;
      }
      return s3 ? (t5.cb = 0, s3) : 0;
    }
    function te2(t5, e3, r3, n3, i3) {
      i3 = t5[e3 + r3 + 32 * n3] + (i3 >> 3), t5[e3 + r3 + 32 * n3] = -256 & i3 ? 0 > i3 ? 0 : 255 : i3;
    }
    function ee2(t5, e3, r3, n3, i3, a3) {
      te2(t5, e3, 0, r3, n3 + i3), te2(t5, e3, 1, r3, n3 + a3), te2(t5, e3, 2, r3, n3 - a3), te2(t5, e3, 3, r3, n3 - i3);
    }
    function re2(t5) {
      return (20091 * t5 >> 16) + t5;
    }
    function ne2(t5, e3, r3, n3) {
      var i3, o3 = 0, s3 = a2(16);
      for (i3 = 0; 4 > i3; ++i3) {
        var c4 = t5[e3 + 0] + t5[e3 + 8], u4 = t5[e3 + 0] - t5[e3 + 8], h4 = (35468 * t5[e3 + 4] >> 16) - re2(t5[e3 + 12]), l4 = re2(t5[e3 + 4]) + (35468 * t5[e3 + 12] >> 16);
        s3[o3 + 0] = c4 + l4, s3[o3 + 1] = u4 + h4, s3[o3 + 2] = u4 - h4, s3[o3 + 3] = c4 - l4, o3 += 4, e3++;
      }
      for (i3 = o3 = 0; 4 > i3; ++i3)
        c4 = (t5 = s3[o3 + 0] + 4) + s3[o3 + 8], u4 = t5 - s3[o3 + 8], h4 = (35468 * s3[o3 + 4] >> 16) - re2(s3[o3 + 12]), te2(r3, n3, 0, 0, c4 + (l4 = re2(s3[o3 + 4]) + (35468 * s3[o3 + 12] >> 16))), te2(r3, n3, 1, 0, u4 + h4), te2(r3, n3, 2, 0, u4 - h4), te2(r3, n3, 3, 0, c4 - l4), o3++, n3 += 32;
    }
    function ie2(t5, e3, r3, n3) {
      var i3 = t5[e3 + 0] + 4, a3 = 35468 * t5[e3 + 4] >> 16, o3 = re2(t5[e3 + 4]), s3 = 35468 * t5[e3 + 1] >> 16;
      ee2(r3, n3, 0, i3 + o3, t5 = re2(t5[e3 + 1]), s3), ee2(r3, n3, 1, i3 + a3, t5, s3), ee2(r3, n3, 2, i3 - a3, t5, s3), ee2(r3, n3, 3, i3 - o3, t5, s3);
    }
    function ae2(t5, e3, r3, n3, i3) {
      ne2(t5, e3, r3, n3), i3 && ne2(t5, e3 + 16, r3, n3 + 4);
    }
    function oe2(t5, e3, r3, n3) {
      on(t5, e3 + 0, r3, n3, 1), on(t5, e3 + 32, r3, n3 + 128, 1);
    }
    function se2(t5, e3, r3, n3) {
      var i3;
      for (t5 = t5[e3 + 0] + 4, i3 = 0; 4 > i3; ++i3)
        for (e3 = 0; 4 > e3; ++e3)
          te2(r3, n3, e3, i3, t5);
    }
    function ce2(t5, e3, r3, n3) {
      t5[e3 + 0] && un(t5, e3 + 0, r3, n3), t5[e3 + 16] && un(t5, e3 + 16, r3, n3 + 4), t5[e3 + 32] && un(t5, e3 + 32, r3, n3 + 128), t5[e3 + 48] && un(t5, e3 + 48, r3, n3 + 128 + 4);
    }
    function ue2(t5, e3, r3, n3) {
      var i3, o3 = a2(16);
      for (i3 = 0; 4 > i3; ++i3) {
        var s3 = t5[e3 + 0 + i3] + t5[e3 + 12 + i3], c4 = t5[e3 + 4 + i3] + t5[e3 + 8 + i3], u4 = t5[e3 + 4 + i3] - t5[e3 + 8 + i3], h4 = t5[e3 + 0 + i3] - t5[e3 + 12 + i3];
        o3[0 + i3] = s3 + c4, o3[8 + i3] = s3 - c4, o3[4 + i3] = h4 + u4, o3[12 + i3] = h4 - u4;
      }
      for (i3 = 0; 4 > i3; ++i3)
        s3 = (t5 = o3[0 + 4 * i3] + 3) + o3[3 + 4 * i3], c4 = o3[1 + 4 * i3] + o3[2 + 4 * i3], u4 = o3[1 + 4 * i3] - o3[2 + 4 * i3], h4 = t5 - o3[3 + 4 * i3], r3[n3 + 0] = s3 + c4 >> 3, r3[n3 + 16] = h4 + u4 >> 3, r3[n3 + 32] = s3 - c4 >> 3, r3[n3 + 48] = h4 - u4 >> 3, n3 += 64;
    }
    function he2(t5, e3, r3) {
      var n3, i3 = e3 - 32, a3 = Bn, o3 = 255 - t5[i3 - 1];
      for (n3 = 0; n3 < r3; ++n3) {
        var s3, c4 = a3, u4 = o3 + t5[e3 - 1];
        for (s3 = 0; s3 < r3; ++s3)
          t5[e3 + s3] = c4[u4 + t5[i3 + s3]];
        e3 += 32;
      }
    }
    function le2(t5, e3) {
      he2(t5, e3, 4);
    }
    function fe2(t5, e3) {
      he2(t5, e3, 8);
    }
    function de2(t5, e3) {
      he2(t5, e3, 16);
    }
    function pe2(t5, e3) {
      var r3;
      for (r3 = 0; 16 > r3; ++r3)
        n2(t5, e3 + 32 * r3, t5, e3 - 32, 16);
    }
    function ge2(t5, e3) {
      var r3;
      for (r3 = 16; 0 < r3; --r3)
        i2(t5, e3, t5[e3 - 1], 16), e3 += 32;
    }
    function me2(t5, e3, r3) {
      var n3;
      for (n3 = 0; 16 > n3; ++n3)
        i2(e3, r3 + 32 * n3, t5, 16);
    }
    function ve2(t5, e3) {
      var r3, n3 = 16;
      for (r3 = 0; 16 > r3; ++r3)
        n3 += t5[e3 - 1 + 32 * r3] + t5[e3 + r3 - 32];
      me2(n3 >> 5, t5, e3);
    }
    function be2(t5, e3) {
      var r3, n3 = 8;
      for (r3 = 0; 16 > r3; ++r3)
        n3 += t5[e3 - 1 + 32 * r3];
      me2(n3 >> 4, t5, e3);
    }
    function ye2(t5, e3) {
      var r3, n3 = 8;
      for (r3 = 0; 16 > r3; ++r3)
        n3 += t5[e3 + r3 - 32];
      me2(n3 >> 4, t5, e3);
    }
    function we2(t5, e3) {
      me2(128, t5, e3);
    }
    function Ne2(t5, e3, r3) {
      return t5 + 2 * e3 + r3 + 2 >> 2;
    }
    function Le2(t5, e3) {
      var r3, i3 = e3 - 32;
      i3 = new Uint8Array([Ne2(t5[i3 - 1], t5[i3 + 0], t5[i3 + 1]), Ne2(t5[i3 + 0], t5[i3 + 1], t5[i3 + 2]), Ne2(t5[i3 + 1], t5[i3 + 2], t5[i3 + 3]), Ne2(t5[i3 + 2], t5[i3 + 3], t5[i3 + 4])]);
      for (r3 = 0; 4 > r3; ++r3)
        n2(t5, e3 + 32 * r3, i3, 0, i3.length);
    }
    function Ae(t5, e3) {
      var r3 = t5[e3 - 1], n3 = t5[e3 - 1 + 32], i3 = t5[e3 - 1 + 64], a3 = t5[e3 - 1 + 96];
      I2(t5, e3 + 0, 16843009 * Ne2(t5[e3 - 1 - 32], r3, n3)), I2(t5, e3 + 32, 16843009 * Ne2(r3, n3, i3)), I2(t5, e3 + 64, 16843009 * Ne2(n3, i3, a3)), I2(t5, e3 + 96, 16843009 * Ne2(i3, a3, a3));
    }
    function xe(t5, e3) {
      var r3, n3 = 4;
      for (r3 = 0; 4 > r3; ++r3)
        n3 += t5[e3 + r3 - 32] + t5[e3 - 1 + 32 * r3];
      for (n3 >>= 3, r3 = 0; 4 > r3; ++r3)
        i2(t5, e3 + 32 * r3, n3, 4);
    }
    function Se(t5, e3) {
      var r3 = t5[e3 - 1 + 0], n3 = t5[e3 - 1 + 32], i3 = t5[e3 - 1 + 64], a3 = t5[e3 - 1 - 32], o3 = t5[e3 + 0 - 32], s3 = t5[e3 + 1 - 32], c4 = t5[e3 + 2 - 32], u4 = t5[e3 + 3 - 32];
      t5[e3 + 0 + 96] = Ne2(n3, i3, t5[e3 - 1 + 96]), t5[e3 + 1 + 96] = t5[e3 + 0 + 64] = Ne2(r3, n3, i3), t5[e3 + 2 + 96] = t5[e3 + 1 + 64] = t5[e3 + 0 + 32] = Ne2(a3, r3, n3), t5[e3 + 3 + 96] = t5[e3 + 2 + 64] = t5[e3 + 1 + 32] = t5[e3 + 0 + 0] = Ne2(o3, a3, r3), t5[e3 + 3 + 64] = t5[e3 + 2 + 32] = t5[e3 + 1 + 0] = Ne2(s3, o3, a3), t5[e3 + 3 + 32] = t5[e3 + 2 + 0] = Ne2(c4, s3, o3), t5[e3 + 3 + 0] = Ne2(u4, c4, s3);
    }
    function _e(t5, e3) {
      var r3 = t5[e3 + 1 - 32], n3 = t5[e3 + 2 - 32], i3 = t5[e3 + 3 - 32], a3 = t5[e3 + 4 - 32], o3 = t5[e3 + 5 - 32], s3 = t5[e3 + 6 - 32], c4 = t5[e3 + 7 - 32];
      t5[e3 + 0 + 0] = Ne2(t5[e3 + 0 - 32], r3, n3), t5[e3 + 1 + 0] = t5[e3 + 0 + 32] = Ne2(r3, n3, i3), t5[e3 + 2 + 0] = t5[e3 + 1 + 32] = t5[e3 + 0 + 64] = Ne2(n3, i3, a3), t5[e3 + 3 + 0] = t5[e3 + 2 + 32] = t5[e3 + 1 + 64] = t5[e3 + 0 + 96] = Ne2(i3, a3, o3), t5[e3 + 3 + 32] = t5[e3 + 2 + 64] = t5[e3 + 1 + 96] = Ne2(a3, o3, s3), t5[e3 + 3 + 64] = t5[e3 + 2 + 96] = Ne2(o3, s3, c4), t5[e3 + 3 + 96] = Ne2(s3, c4, c4);
    }
    function Pe(t5, e3) {
      var r3 = t5[e3 - 1 + 0], n3 = t5[e3 - 1 + 32], i3 = t5[e3 - 1 + 64], a3 = t5[e3 - 1 - 32], o3 = t5[e3 + 0 - 32], s3 = t5[e3 + 1 - 32], c4 = t5[e3 + 2 - 32], u4 = t5[e3 + 3 - 32];
      t5[e3 + 0 + 0] = t5[e3 + 1 + 64] = a3 + o3 + 1 >> 1, t5[e3 + 1 + 0] = t5[e3 + 2 + 64] = o3 + s3 + 1 >> 1, t5[e3 + 2 + 0] = t5[e3 + 3 + 64] = s3 + c4 + 1 >> 1, t5[e3 + 3 + 0] = c4 + u4 + 1 >> 1, t5[e3 + 0 + 96] = Ne2(i3, n3, r3), t5[e3 + 0 + 64] = Ne2(n3, r3, a3), t5[e3 + 0 + 32] = t5[e3 + 1 + 96] = Ne2(r3, a3, o3), t5[e3 + 1 + 32] = t5[e3 + 2 + 96] = Ne2(a3, o3, s3), t5[e3 + 2 + 32] = t5[e3 + 3 + 96] = Ne2(o3, s3, c4), t5[e3 + 3 + 32] = Ne2(s3, c4, u4);
    }
    function ke(t5, e3) {
      var r3 = t5[e3 + 0 - 32], n3 = t5[e3 + 1 - 32], i3 = t5[e3 + 2 - 32], a3 = t5[e3 + 3 - 32], o3 = t5[e3 + 4 - 32], s3 = t5[e3 + 5 - 32], c4 = t5[e3 + 6 - 32], u4 = t5[e3 + 7 - 32];
      t5[e3 + 0 + 0] = r3 + n3 + 1 >> 1, t5[e3 + 1 + 0] = t5[e3 + 0 + 64] = n3 + i3 + 1 >> 1, t5[e3 + 2 + 0] = t5[e3 + 1 + 64] = i3 + a3 + 1 >> 1, t5[e3 + 3 + 0] = t5[e3 + 2 + 64] = a3 + o3 + 1 >> 1, t5[e3 + 0 + 32] = Ne2(r3, n3, i3), t5[e3 + 1 + 32] = t5[e3 + 0 + 96] = Ne2(n3, i3, a3), t5[e3 + 2 + 32] = t5[e3 + 1 + 96] = Ne2(i3, a3, o3), t5[e3 + 3 + 32] = t5[e3 + 2 + 96] = Ne2(a3, o3, s3), t5[e3 + 3 + 64] = Ne2(o3, s3, c4), t5[e3 + 3 + 96] = Ne2(s3, c4, u4);
    }
    function Ie(t5, e3) {
      var r3 = t5[e3 - 1 + 0], n3 = t5[e3 - 1 + 32], i3 = t5[e3 - 1 + 64], a3 = t5[e3 - 1 + 96];
      t5[e3 + 0 + 0] = r3 + n3 + 1 >> 1, t5[e3 + 2 + 0] = t5[e3 + 0 + 32] = n3 + i3 + 1 >> 1, t5[e3 + 2 + 32] = t5[e3 + 0 + 64] = i3 + a3 + 1 >> 1, t5[e3 + 1 + 0] = Ne2(r3, n3, i3), t5[e3 + 3 + 0] = t5[e3 + 1 + 32] = Ne2(n3, i3, a3), t5[e3 + 3 + 32] = t5[e3 + 1 + 64] = Ne2(i3, a3, a3), t5[e3 + 3 + 64] = t5[e3 + 2 + 64] = t5[e3 + 0 + 96] = t5[e3 + 1 + 96] = t5[e3 + 2 + 96] = t5[e3 + 3 + 96] = a3;
    }
    function Fe(t5, e3) {
      var r3 = t5[e3 - 1 + 0], n3 = t5[e3 - 1 + 32], i3 = t5[e3 - 1 + 64], a3 = t5[e3 - 1 + 96], o3 = t5[e3 - 1 - 32], s3 = t5[e3 + 0 - 32], c4 = t5[e3 + 1 - 32], u4 = t5[e3 + 2 - 32];
      t5[e3 + 0 + 0] = t5[e3 + 2 + 32] = r3 + o3 + 1 >> 1, t5[e3 + 0 + 32] = t5[e3 + 2 + 64] = n3 + r3 + 1 >> 1, t5[e3 + 0 + 64] = t5[e3 + 2 + 96] = i3 + n3 + 1 >> 1, t5[e3 + 0 + 96] = a3 + i3 + 1 >> 1, t5[e3 + 3 + 0] = Ne2(s3, c4, u4), t5[e3 + 2 + 0] = Ne2(o3, s3, c4), t5[e3 + 1 + 0] = t5[e3 + 3 + 32] = Ne2(r3, o3, s3), t5[e3 + 1 + 32] = t5[e3 + 3 + 64] = Ne2(n3, r3, o3), t5[e3 + 1 + 64] = t5[e3 + 3 + 96] = Ne2(i3, n3, r3), t5[e3 + 1 + 96] = Ne2(a3, i3, n3);
    }
    function Ce(t5, e3) {
      var r3;
      for (r3 = 0; 8 > r3; ++r3)
        n2(t5, e3 + 32 * r3, t5, e3 - 32, 8);
    }
    function je(t5, e3) {
      var r3;
      for (r3 = 0; 8 > r3; ++r3)
        i2(t5, e3, t5[e3 - 1], 8), e3 += 32;
    }
    function Oe(t5, e3, r3) {
      var n3;
      for (n3 = 0; 8 > n3; ++n3)
        i2(e3, r3 + 32 * n3, t5, 8);
    }
    function Be(t5, e3) {
      var r3, n3 = 8;
      for (r3 = 0; 8 > r3; ++r3)
        n3 += t5[e3 + r3 - 32] + t5[e3 - 1 + 32 * r3];
      Oe(n3 >> 4, t5, e3);
    }
    function Me(t5, e3) {
      var r3, n3 = 4;
      for (r3 = 0; 8 > r3; ++r3)
        n3 += t5[e3 + r3 - 32];
      Oe(n3 >> 3, t5, e3);
    }
    function Ee(t5, e3) {
      var r3, n3 = 4;
      for (r3 = 0; 8 > r3; ++r3)
        n3 += t5[e3 - 1 + 32 * r3];
      Oe(n3 >> 3, t5, e3);
    }
    function qe(t5, e3) {
      Oe(128, t5, e3);
    }
    function De(t5, e3, r3) {
      var n3 = t5[e3 - r3], i3 = t5[e3 + 0], a3 = 3 * (i3 - n3) + jn[1020 + t5[e3 - 2 * r3] - t5[e3 + r3]], o3 = On[112 + (a3 + 4 >> 3)];
      t5[e3 - r3] = Bn[255 + n3 + On[112 + (a3 + 3 >> 3)]], t5[e3 + 0] = Bn[255 + i3 - o3];
    }
    function Re(t5, e3, r3, n3) {
      var i3 = t5[e3 + 0], a3 = t5[e3 + r3];
      return Mn[255 + t5[e3 - 2 * r3] - t5[e3 - r3]] > n3 || Mn[255 + a3 - i3] > n3;
    }
    function Te(t5, e3, r3, n3) {
      return 4 * Mn[255 + t5[e3 - r3] - t5[e3 + 0]] + Mn[255 + t5[e3 - 2 * r3] - t5[e3 + r3]] <= n3;
    }
    function ze(t5, e3, r3, n3, i3) {
      var a3 = t5[e3 - 3 * r3], o3 = t5[e3 - 2 * r3], s3 = t5[e3 - r3], c4 = t5[e3 + 0], u4 = t5[e3 + r3], h4 = t5[e3 + 2 * r3], l4 = t5[e3 + 3 * r3];
      return 4 * Mn[255 + s3 - c4] + Mn[255 + o3 - u4] > n3 ? 0 : Mn[255 + t5[e3 - 4 * r3] - a3] <= i3 && Mn[255 + a3 - o3] <= i3 && Mn[255 + o3 - s3] <= i3 && Mn[255 + l4 - h4] <= i3 && Mn[255 + h4 - u4] <= i3 && Mn[255 + u4 - c4] <= i3;
    }
    function Ue(t5, e3, r3, n3) {
      var i3 = 2 * n3 + 1;
      for (n3 = 0; 16 > n3; ++n3)
        Te(t5, e3 + n3, r3, i3) && De(t5, e3 + n3, r3);
    }
    function He(t5, e3, r3, n3) {
      var i3 = 2 * n3 + 1;
      for (n3 = 0; 16 > n3; ++n3)
        Te(t5, e3 + n3 * r3, 1, i3) && De(t5, e3 + n3 * r3, 1);
    }
    function We(t5, e3, r3, n3) {
      var i3;
      for (i3 = 3; 0 < i3; --i3)
        Ue(t5, e3 += 4 * r3, r3, n3);
    }
    function Ve(t5, e3, r3, n3) {
      var i3;
      for (i3 = 3; 0 < i3; --i3)
        He(t5, e3 += 4, r3, n3);
    }
    function Ge(t5, e3, r3, n3, i3, a3, o3, s3) {
      for (a3 = 2 * a3 + 1; 0 < i3--; ) {
        if (ze(t5, e3, r3, a3, o3))
          if (Re(t5, e3, r3, s3))
            De(t5, e3, r3);
          else {
            var c4 = t5, u4 = e3, h4 = r3, l4 = c4[u4 - 2 * h4], f4 = c4[u4 - h4], d4 = c4[u4 + 0], p7 = c4[u4 + h4], g4 = c4[u4 + 2 * h4], m4 = 27 * (b4 = jn[1020 + 3 * (d4 - f4) + jn[1020 + l4 - p7]]) + 63 >> 7, v4 = 18 * b4 + 63 >> 7, b4 = 9 * b4 + 63 >> 7;
            c4[u4 - 3 * h4] = Bn[255 + c4[u4 - 3 * h4] + b4], c4[u4 - 2 * h4] = Bn[255 + l4 + v4], c4[u4 - h4] = Bn[255 + f4 + m4], c4[u4 + 0] = Bn[255 + d4 - m4], c4[u4 + h4] = Bn[255 + p7 - v4], c4[u4 + 2 * h4] = Bn[255 + g4 - b4];
          }
        e3 += n3;
      }
    }
    function Ye(t5, e3, r3, n3, i3, a3, o3, s3) {
      for (a3 = 2 * a3 + 1; 0 < i3--; ) {
        if (ze(t5, e3, r3, a3, o3))
          if (Re(t5, e3, r3, s3))
            De(t5, e3, r3);
          else {
            var c4 = t5, u4 = e3, h4 = r3, l4 = c4[u4 - h4], f4 = c4[u4 + 0], d4 = c4[u4 + h4], p7 = On[112 + ((g4 = 3 * (f4 - l4)) + 4 >> 3)], g4 = On[112 + (g4 + 3 >> 3)], m4 = p7 + 1 >> 1;
            c4[u4 - 2 * h4] = Bn[255 + c4[u4 - 2 * h4] + m4], c4[u4 - h4] = Bn[255 + l4 + g4], c4[u4 + 0] = Bn[255 + f4 - p7], c4[u4 + h4] = Bn[255 + d4 - m4];
          }
        e3 += n3;
      }
    }
    function Je(t5, e3, r3, n3, i3, a3) {
      Ge(t5, e3, r3, 1, 16, n3, i3, a3);
    }
    function Xe(t5, e3, r3, n3, i3, a3) {
      Ge(t5, e3, 1, r3, 16, n3, i3, a3);
    }
    function Ke(t5, e3, r3, n3, i3, a3) {
      var o3;
      for (o3 = 3; 0 < o3; --o3)
        Ye(t5, e3 += 4 * r3, r3, 1, 16, n3, i3, a3);
    }
    function Ze(t5, e3, r3, n3, i3, a3) {
      var o3;
      for (o3 = 3; 0 < o3; --o3)
        Ye(t5, e3 += 4, 1, r3, 16, n3, i3, a3);
    }
    function $e(t5, e3, r3, n3, i3, a3, o3, s3) {
      Ge(t5, e3, i3, 1, 8, a3, o3, s3), Ge(r3, n3, i3, 1, 8, a3, o3, s3);
    }
    function Qe(t5, e3, r3, n3, i3, a3, o3, s3) {
      Ge(t5, e3, 1, i3, 8, a3, o3, s3), Ge(r3, n3, 1, i3, 8, a3, o3, s3);
    }
    function tr(t5, e3, r3, n3, i3, a3, o3, s3) {
      Ye(t5, e3 + 4 * i3, i3, 1, 8, a3, o3, s3), Ye(r3, n3 + 4 * i3, i3, 1, 8, a3, o3, s3);
    }
    function er(t5, e3, r3, n3, i3, a3, o3, s3) {
      Ye(t5, e3 + 4, 1, i3, 8, a3, o3, s3), Ye(r3, n3 + 4, 1, i3, 8, a3, o3, s3);
    }
    function rr() {
      this.ba = new ot2(), this.ec = [], this.cc = [], this.Mc = [], this.Dc = this.Nc = this.dc = this.fc = 0, this.Oa = new ct2(), this.memory = 0, this.Ib = "OutputFunc", this.Jb = "OutputAlphaFunc", this.Nd = "OutputRowFunc";
    }
    function nr() {
      this.data = [], this.offset = this.kd = this.ha = this.w = 0, this.na = [], this.xa = this.gb = this.Ja = this.Sa = this.P = 0;
    }
    function ir() {
      this.nc = this.Ea = this.b = this.hc = 0, this.K = [], this.w = 0;
    }
    function ar() {
      this.ua = 0, this.Wa = new M2(), this.vb = new M2(), this.md = this.xc = this.wc = 0, this.vc = [], this.Wb = 0, this.Ya = new d3(), this.yc = new l3();
    }
    function or() {
      this.xb = this.a = 0, this.l = new Gt2(), this.ca = new ot2(), this.V = [], this.Ba = 0, this.Ta = [], this.Ua = 0, this.m = new N3(), this.Pb = 0, this.wd = new N3(), this.Ma = this.$ = this.C = this.i = this.c = this.xd = 0, this.s = new ar(), this.ab = 0, this.gc = o2(4, ir), this.Oc = 0;
    }
    function sr() {
      this.Lc = this.Z = this.$a = this.i = this.c = 0, this.l = new Gt2(), this.ic = 0, this.ca = [], this.tb = 0, this.qd = null, this.rd = 0;
    }
    function cr(t5, e3, r3, n3, i3, a3, o3) {
      for (t5 = t5 == null ? 0 : t5[e3 + 0], e3 = 0; e3 < o3; ++e3)
        i3[a3 + e3] = t5 + r3[n3 + e3] & 255, t5 = i3[a3 + e3];
    }
    function ur(t5, e3, r3, n3, i3, a3, o3) {
      var s3;
      if (t5 == null)
        cr(null, null, r3, n3, i3, a3, o3);
      else
        for (s3 = 0; s3 < o3; ++s3)
          i3[a3 + s3] = t5[e3 + s3] + r3[n3 + s3] & 255;
    }
    function hr(t5, e3, r3, n3, i3, a3, o3) {
      if (t5 == null)
        cr(null, null, r3, n3, i3, a3, o3);
      else {
        var s3, c4 = t5[e3 + 0], u4 = c4, h4 = c4;
        for (s3 = 0; s3 < o3; ++s3)
          u4 = h4 + (c4 = t5[e3 + s3]) - u4, h4 = r3[n3 + s3] + (-256 & u4 ? 0 > u4 ? 0 : 255 : u4) & 255, u4 = c4, i3[a3 + s3] = h4;
      }
    }
    function lr(t5, r3, i3, o3) {
      var s3 = r3.width, c4 = r3.o;
      if (e2(t5 != null && r3 != null), 0 > i3 || 0 >= o3 || i3 + o3 > c4)
        return null;
      if (!t5.Cc) {
        if (t5.ga == null) {
          var u4;
          if (t5.ga = new sr(), (u4 = t5.ga == null) || (u4 = r3.width * r3.o, e2(t5.Gb.length == 0), t5.Gb = a2(u4), t5.Uc = 0, t5.Gb == null ? u4 = 0 : (t5.mb = t5.Gb, t5.nb = t5.Uc, t5.rc = null, u4 = 1), u4 = !u4), !u4) {
            u4 = t5.ga;
            var h4 = t5.Fa, l4 = t5.P, f4 = t5.qc, d4 = t5.mb, p7 = t5.nb, g4 = l4 + 1, m4 = f4 - 1, b4 = u4.l;
            if (e2(h4 != null && d4 != null && r3 != null), mi[0] = null, mi[1] = cr, mi[2] = ur, mi[3] = hr, u4.ca = d4, u4.tb = p7, u4.c = r3.width, u4.i = r3.height, e2(0 < u4.c && 0 < u4.i), 1 >= f4)
              r3 = 0;
            else if (u4.$a = h4[l4 + 0] >> 0 & 3, u4.Z = h4[l4 + 0] >> 2 & 3, u4.Lc = h4[l4 + 0] >> 4 & 3, l4 = h4[l4 + 0] >> 6 & 3, 0 > u4.$a || 1 < u4.$a || 4 <= u4.Z || 1 < u4.Lc || l4)
              r3 = 0;
            else if (b4.put = dt2, b4.ac = ft2, b4.bc = pt2, b4.ma = u4, b4.width = r3.width, b4.height = r3.height, b4.Da = r3.Da, b4.v = r3.v, b4.va = r3.va, b4.j = r3.j, b4.o = r3.o, u4.$a)
              t: {
                e2(u4.$a == 1), r3 = kt2();
                e:
                  for (; ; ) {
                    if (r3 == null) {
                      r3 = 0;
                      break t;
                    }
                    if (e2(u4 != null), u4.mc = r3, r3.c = u4.c, r3.i = u4.i, r3.l = u4.l, r3.l.ma = u4, r3.l.width = u4.c, r3.l.height = u4.i, r3.a = 0, v3(r3.m, h4, g4, m4), !It2(u4.c, u4.i, 1, r3, null))
                      break e;
                    if (r3.ab == 1 && r3.gc[0].hc == 3 && At2(r3.s) ? (u4.ic = 1, h4 = r3.c * r3.i, r3.Ta = null, r3.Ua = 0, r3.V = a2(h4), r3.Ba = 0, r3.V == null ? (r3.a = 1, r3 = 0) : r3 = 1) : (u4.ic = 0, r3 = Ft2(r3, u4.c)), !r3)
                      break e;
                    r3 = 1;
                    break t;
                  }
                u4.mc = null, r3 = 0;
              }
            else
              r3 = m4 >= u4.c * u4.i;
            u4 = !r3;
          }
          if (u4)
            return null;
          t5.ga.Lc != 1 ? t5.Ga = 0 : o3 = c4 - i3;
        }
        e2(t5.ga != null), e2(i3 + o3 <= c4);
        t: {
          if (r3 = (h4 = t5.ga).c, c4 = h4.l.o, h4.$a == 0) {
            if (g4 = t5.rc, m4 = t5.Vc, b4 = t5.Fa, l4 = t5.P + 1 + i3 * r3, f4 = t5.mb, d4 = t5.nb + i3 * r3, e2(l4 <= t5.P + t5.qc), h4.Z != 0)
              for (e2(mi[h4.Z] != null), u4 = 0; u4 < o3; ++u4)
                mi[h4.Z](g4, m4, b4, l4, f4, d4, r3), g4 = f4, m4 = d4, d4 += r3, l4 += r3;
            else
              for (u4 = 0; u4 < o3; ++u4)
                n2(f4, d4, b4, l4, r3), g4 = f4, m4 = d4, d4 += r3, l4 += r3;
            t5.rc = g4, t5.Vc = m4;
          } else {
            if (e2(h4.mc != null), r3 = i3 + o3, e2((u4 = h4.mc) != null), e2(r3 <= u4.i), u4.C >= r3)
              r3 = 1;
            else if (h4.ic || mr(), h4.ic) {
              h4 = u4.V, g4 = u4.Ba, m4 = u4.c;
              var y4 = u4.i, w4 = (b4 = 1, l4 = u4.$ / m4, f4 = u4.$ % m4, d4 = u4.m, p7 = u4.s, u4.$), N4 = m4 * y4, L4 = m4 * r3, x3 = p7.wc, _3 = w4 < L4 ? wt2(p7, f4, l4) : null;
              e2(w4 <= N4), e2(r3 <= y4), e2(At2(p7));
              e:
                for (; ; ) {
                  for (; !d4.h && w4 < L4; ) {
                    if (f4 & x3 || (_3 = wt2(p7, f4, l4)), e2(_3 != null), S2(d4), 256 > (y4 = bt2(_3.G[0], _3.H[0], d4)))
                      h4[g4 + w4] = y4, ++w4, ++f4 >= m4 && (f4 = 0, ++l4 <= r3 && !(l4 % 16) && St(u4, l4));
                    else {
                      if (!(280 > y4)) {
                        b4 = 0;
                        break e;
                      }
                      y4 = mt2(y4 - 256, d4);
                      var P3, k3 = bt2(_3.G[4], _3.H[4], d4);
                      if (S2(d4), !(w4 >= (k3 = vt2(m4, k3 = mt2(k3, d4))) && N4 - w4 >= y4)) {
                        b4 = 0;
                        break e;
                      }
                      for (P3 = 0; P3 < y4; ++P3)
                        h4[g4 + w4 + P3] = h4[g4 + w4 + P3 - k3];
                      for (w4 += y4, f4 += y4; f4 >= m4; )
                        f4 -= m4, ++l4 <= r3 && !(l4 % 16) && St(u4, l4);
                      w4 < L4 && f4 & x3 && (_3 = wt2(p7, f4, l4));
                    }
                    e2(d4.h == A3(d4));
                  }
                  St(u4, l4 > r3 ? r3 : l4);
                  break e;
                }
              !b4 || d4.h && w4 < N4 ? (b4 = 0, u4.a = d4.h ? 5 : 3) : u4.$ = w4, r3 = b4;
            } else
              r3 = _t2(u4, u4.V, u4.Ba, u4.c, u4.i, r3, Ct2);
            if (!r3) {
              o3 = 0;
              break t;
            }
          }
          i3 + o3 >= c4 && (t5.Cc = 1), o3 = 1;
        }
        if (!o3)
          return null;
        if (t5.Cc && ((o3 = t5.ga) != null && (o3.mc = null), t5.ga = null, 0 < t5.Ga))
          return alert("todo:WebPDequantizeLevels"), null;
      }
      return t5.nb + i3 * s3;
    }
    function fr(t5, e3, r3, n3, i3, a3) {
      for (; 0 < i3--; ) {
        var o3, s3 = t5, c4 = e3 + (r3 ? 1 : 0), u4 = t5, h4 = e3 + (r3 ? 0 : 3);
        for (o3 = 0; o3 < n3; ++o3) {
          var l4 = u4[h4 + 4 * o3];
          l4 != 255 && (l4 *= 32897, s3[c4 + 4 * o3 + 0] = s3[c4 + 4 * o3 + 0] * l4 >> 23, s3[c4 + 4 * o3 + 1] = s3[c4 + 4 * o3 + 1] * l4 >> 23, s3[c4 + 4 * o3 + 2] = s3[c4 + 4 * o3 + 2] * l4 >> 23);
        }
        e3 += a3;
      }
    }
    function dr(t5, e3, r3, n3, i3) {
      for (; 0 < n3--; ) {
        var a3;
        for (a3 = 0; a3 < r3; ++a3) {
          var o3 = t5[e3 + 2 * a3 + 0], s3 = 15 & (u4 = t5[e3 + 2 * a3 + 1]), c4 = 4369 * s3, u4 = (240 & u4 | u4 >> 4) * c4 >> 16;
          t5[e3 + 2 * a3 + 0] = (240 & o3 | o3 >> 4) * c4 >> 16 & 240 | (15 & o3 | o3 << 4) * c4 >> 16 >> 4 & 15, t5[e3 + 2 * a3 + 1] = 240 & u4 | s3;
        }
        e3 += i3;
      }
    }
    function pr(t5, e3, r3, n3, i3, a3, o3, s3) {
      var c4, u4, h4 = 255;
      for (u4 = 0; u4 < i3; ++u4) {
        for (c4 = 0; c4 < n3; ++c4) {
          var l4 = t5[e3 + c4];
          a3[o3 + 4 * c4] = l4, h4 &= l4;
        }
        e3 += r3, o3 += s3;
      }
      return h4 != 255;
    }
    function gr(t5, e3, r3, n3, i3) {
      var a3;
      for (a3 = 0; a3 < i3; ++a3)
        r3[n3 + a3] = t5[e3 + a3] >> 8;
    }
    function mr() {
      An = fr, xn = dr, Sn = pr, _n = gr;
    }
    function vr(r3, n3, i3) {
      t4[r3] = function(t5, r4, a3, o3, s3, c4, u4, h4, l4, f4, d4, p7, g4, m4, v4, b4, y4) {
        var w4, N4 = y4 - 1 >> 1, L4 = s3[c4 + 0] | u4[h4 + 0] << 16, A4 = l4[f4 + 0] | d4[p7 + 0] << 16;
        e2(t5 != null);
        var x3 = 3 * L4 + A4 + 131074 >> 2;
        for (n3(t5[r4 + 0], 255 & x3, x3 >> 16, g4, m4), a3 != null && (x3 = 3 * A4 + L4 + 131074 >> 2, n3(a3[o3 + 0], 255 & x3, x3 >> 16, v4, b4)), w4 = 1; w4 <= N4; ++w4) {
          var S3 = s3[c4 + w4] | u4[h4 + w4] << 16, _3 = l4[f4 + w4] | d4[p7 + w4] << 16, P3 = L4 + S3 + A4 + _3 + 524296, k3 = P3 + 2 * (S3 + A4) >> 3;
          x3 = k3 + L4 >> 1, L4 = (P3 = P3 + 2 * (L4 + _3) >> 3) + S3 >> 1, n3(t5[r4 + 2 * w4 - 1], 255 & x3, x3 >> 16, g4, m4 + (2 * w4 - 1) * i3), n3(t5[r4 + 2 * w4 - 0], 255 & L4, L4 >> 16, g4, m4 + (2 * w4 - 0) * i3), a3 != null && (x3 = P3 + A4 >> 1, L4 = k3 + _3 >> 1, n3(a3[o3 + 2 * w4 - 1], 255 & x3, x3 >> 16, v4, b4 + (2 * w4 - 1) * i3), n3(a3[o3 + 2 * w4 + 0], 255 & L4, L4 >> 16, v4, b4 + (2 * w4 + 0) * i3)), L4 = S3, A4 = _3;
        }
        1 & y4 || (x3 = 3 * L4 + A4 + 131074 >> 2, n3(t5[r4 + y4 - 1], 255 & x3, x3 >> 16, g4, m4 + (y4 - 1) * i3), a3 != null && (x3 = 3 * A4 + L4 + 131074 >> 2, n3(a3[o3 + y4 - 1], 255 & x3, x3 >> 16, v4, b4 + (y4 - 1) * i3)));
      };
    }
    function br() {
      vi[En] = bi, vi[qn] = wi, vi[Dn] = yi, vi[Rn] = Ni, vi[Tn] = Li, vi[zn] = Ai, vi[Un] = xi, vi[Hn] = wi, vi[Wn] = Ni, vi[Vn] = Li, vi[Gn] = Ai;
    }
    function yr(t5) {
      return t5 & ~Fi ? 0 > t5 ? 0 : 255 : t5 >> Ii;
    }
    function wr(t5, e3) {
      return yr((19077 * t5 >> 8) + (26149 * e3 >> 8) - 14234);
    }
    function Nr(t5, e3, r3) {
      return yr((19077 * t5 >> 8) - (6419 * e3 >> 8) - (13320 * r3 >> 8) + 8708);
    }
    function Lr(t5, e3) {
      return yr((19077 * t5 >> 8) + (33050 * e3 >> 8) - 17685);
    }
    function Ar(t5, e3, r3, n3, i3) {
      n3[i3 + 0] = wr(t5, r3), n3[i3 + 1] = Nr(t5, e3, r3), n3[i3 + 2] = Lr(t5, e3);
    }
    function xr(t5, e3, r3, n3, i3) {
      n3[i3 + 0] = Lr(t5, e3), n3[i3 + 1] = Nr(t5, e3, r3), n3[i3 + 2] = wr(t5, r3);
    }
    function Sr(t5, e3, r3, n3, i3) {
      var a3 = Nr(t5, e3, r3);
      e3 = a3 << 3 & 224 | Lr(t5, e3) >> 3, n3[i3 + 0] = 248 & wr(t5, r3) | a3 >> 5, n3[i3 + 1] = e3;
    }
    function _r(t5, e3, r3, n3, i3) {
      var a3 = 240 & Lr(t5, e3) | 15;
      n3[i3 + 0] = 240 & wr(t5, r3) | Nr(t5, e3, r3) >> 4, n3[i3 + 1] = a3;
    }
    function Pr(t5, e3, r3, n3, i3) {
      n3[i3 + 0] = 255, Ar(t5, e3, r3, n3, i3 + 1);
    }
    function kr(t5, e3, r3, n3, i3) {
      xr(t5, e3, r3, n3, i3), n3[i3 + 3] = 255;
    }
    function Ir(t5, e3, r3, n3, i3) {
      Ar(t5, e3, r3, n3, i3), n3[i3 + 3] = 255;
    }
    function Vt2(t5, e3) {
      return 0 > t5 ? 0 : t5 > e3 ? e3 : t5;
    }
    function Fr(e3, r3, n3) {
      t4[e3] = function(t5, e4, i3, a3, o3, s3, c4, u4, h4) {
        for (var l4 = u4 + (-2 & h4) * n3; u4 != l4; )
          r3(t5[e4 + 0], i3[a3 + 0], o3[s3 + 0], c4, u4), r3(t5[e4 + 1], i3[a3 + 0], o3[s3 + 0], c4, u4 + n3), e4 += 2, ++a3, ++s3, u4 += 2 * n3;
        1 & h4 && r3(t5[e4 + 0], i3[a3 + 0], o3[s3 + 0], c4, u4);
      };
    }
    function Cr(t5, e3, r3) {
      return r3 == 0 ? t5 == 0 ? e3 == 0 ? 6 : 5 : e3 == 0 ? 4 : 0 : r3;
    }
    function jr(t5, e3, r3, n3, i3) {
      switch (t5 >>> 30) {
        case 3:
          on(e3, r3, n3, i3, 0);
          break;
        case 2:
          sn(e3, r3, n3, i3);
          break;
        case 1:
          un(e3, r3, n3, i3);
      }
    }
    function Or(t5, e3) {
      var r3, a3, o3 = e3.M, s3 = e3.Nb, c4 = t5.oc, u4 = t5.pc + 40, h4 = t5.oc, l4 = t5.pc + 584, f4 = t5.oc, d4 = t5.pc + 600;
      for (r3 = 0; 16 > r3; ++r3)
        c4[u4 + 32 * r3 - 1] = 129;
      for (r3 = 0; 8 > r3; ++r3)
        h4[l4 + 32 * r3 - 1] = 129, f4[d4 + 32 * r3 - 1] = 129;
      for (0 < o3 ? c4[u4 - 1 - 32] = h4[l4 - 1 - 32] = f4[d4 - 1 - 32] = 129 : (i2(c4, u4 - 32 - 1, 127, 21), i2(h4, l4 - 32 - 1, 127, 9), i2(f4, d4 - 32 - 1, 127, 9)), a3 = 0; a3 < t5.za; ++a3) {
        var p7 = e3.ya[e3.aa + a3];
        if (0 < a3) {
          for (r3 = -1; 16 > r3; ++r3)
            n2(c4, u4 + 32 * r3 - 4, c4, u4 + 32 * r3 + 12, 4);
          for (r3 = -1; 8 > r3; ++r3)
            n2(h4, l4 + 32 * r3 - 4, h4, l4 + 32 * r3 + 4, 4), n2(f4, d4 + 32 * r3 - 4, f4, d4 + 32 * r3 + 4, 4);
        }
        var g4 = t5.Gd, m4 = t5.Hd + a3, v4 = p7.ad, b4 = p7.Hc;
        if (0 < o3 && (n2(c4, u4 - 32, g4[m4].y, 0, 16), n2(h4, l4 - 32, g4[m4].f, 0, 8), n2(f4, d4 - 32, g4[m4].ea, 0, 8)), p7.Za) {
          var y4 = c4, w4 = u4 - 32 + 16;
          for (0 < o3 && (a3 >= t5.za - 1 ? i2(y4, w4, g4[m4].y[15], 4) : n2(y4, w4, g4[m4 + 1].y, 0, 4)), r3 = 0; 4 > r3; r3++)
            y4[w4 + 128 + r3] = y4[w4 + 256 + r3] = y4[w4 + 384 + r3] = y4[w4 + 0 + r3];
          for (r3 = 0; 16 > r3; ++r3, b4 <<= 2)
            y4 = c4, w4 = u4 + Di[r3], fi[p7.Ob[r3]](y4, w4), jr(b4, v4, 16 * +r3, y4, w4);
        } else if (y4 = Cr(a3, o3, p7.Ob[0]), li[y4](c4, u4), b4 != 0)
          for (r3 = 0; 16 > r3; ++r3, b4 <<= 2)
            jr(b4, v4, 16 * +r3, c4, u4 + Di[r3]);
        for (r3 = p7.Gc, y4 = Cr(a3, o3, p7.Dd), di[y4](h4, l4), di[y4](f4, d4), b4 = v4, y4 = h4, w4 = l4, 255 & (p7 = r3 >> 0) && (170 & p7 ? cn(b4, 256, y4, w4) : hn(b4, 256, y4, w4)), p7 = f4, b4 = d4, 255 & (r3 >>= 8) && (170 & r3 ? cn(v4, 320, p7, b4) : hn(v4, 320, p7, b4)), o3 < t5.Ub - 1 && (n2(g4[m4].y, 0, c4, u4 + 480, 16), n2(g4[m4].f, 0, h4, l4 + 224, 8), n2(g4[m4].ea, 0, f4, d4 + 224, 8)), r3 = 8 * s3 * t5.B, g4 = t5.sa, m4 = t5.ta + 16 * a3 + 16 * s3 * t5.R, v4 = t5.qa, p7 = t5.ra + 8 * a3 + r3, b4 = t5.Ha, y4 = t5.Ia + 8 * a3 + r3, r3 = 0; 16 > r3; ++r3)
          n2(g4, m4 + r3 * t5.R, c4, u4 + 32 * r3, 16);
        for (r3 = 0; 8 > r3; ++r3)
          n2(v4, p7 + r3 * t5.B, h4, l4 + 32 * r3, 8), n2(b4, y4 + r3 * t5.B, f4, d4 + 32 * r3, 8);
      }
    }
    function Br(t5, n3, i3, a3, o3, s3, c4, u4, h4) {
      var l4 = [0], f4 = [0], d4 = 0, p7 = h4 != null ? h4.kd : 0, g4 = h4 != null ? h4 : new nr();
      if (t5 == null || 12 > i3)
        return 7;
      g4.data = t5, g4.w = n3, g4.ha = i3, n3 = [n3], i3 = [i3], g4.gb = [g4.gb];
      t: {
        var m4 = n3, b4 = i3, y4 = g4.gb;
        if (e2(t5 != null), e2(b4 != null), e2(y4 != null), y4[0] = 0, 12 <= b4[0] && !r2(t5, m4[0], "RIFF")) {
          if (r2(t5, m4[0] + 8, "WEBP")) {
            y4 = 3;
            break t;
          }
          var w4 = j2(t5, m4[0] + 4);
          if (12 > w4 || 4294967286 < w4) {
            y4 = 3;
            break t;
          }
          if (p7 && w4 > b4[0] - 8) {
            y4 = 7;
            break t;
          }
          y4[0] = w4, m4[0] += 12, b4[0] -= 12;
        }
        y4 = 0;
      }
      if (y4 != 0)
        return y4;
      for (w4 = 0 < g4.gb[0], i3 = i3[0]; ; ) {
        t: {
          var L4 = t5;
          b4 = n3, y4 = i3;
          var A4 = l4, x3 = f4, S3 = m4 = [0];
          if ((k3 = d4 = [d4])[0] = 0, 8 > y4[0])
            y4 = 7;
          else {
            if (!r2(L4, b4[0], "VP8X")) {
              if (j2(L4, b4[0] + 4) != 10) {
                y4 = 3;
                break t;
              }
              if (18 > y4[0]) {
                y4 = 7;
                break t;
              }
              var _3 = j2(L4, b4[0] + 8), P3 = 1 + C2(L4, b4[0] + 12);
              if (2147483648 <= P3 * (L4 = 1 + C2(L4, b4[0] + 15))) {
                y4 = 3;
                break t;
              }
              S3 != null && (S3[0] = _3), A4 != null && (A4[0] = P3), x3 != null && (x3[0] = L4), b4[0] += 18, y4[0] -= 18, k3[0] = 1;
            }
            y4 = 0;
          }
        }
        if (d4 = d4[0], m4 = m4[0], y4 != 0)
          return y4;
        if (b4 = !!(2 & m4), !w4 && d4)
          return 3;
        if (s3 != null && (s3[0] = !!(16 & m4)), c4 != null && (c4[0] = b4), u4 != null && (u4[0] = 0), c4 = l4[0], m4 = f4[0], d4 && b4 && h4 == null) {
          y4 = 0;
          break;
        }
        if (4 > i3) {
          y4 = 7;
          break;
        }
        if (w4 && d4 || !w4 && !d4 && !r2(t5, n3[0], "ALPH")) {
          i3 = [i3], g4.na = [g4.na], g4.P = [g4.P], g4.Sa = [g4.Sa];
          t: {
            _3 = t5, y4 = n3, w4 = i3;
            var k3 = g4.gb;
            A4 = g4.na, x3 = g4.P, S3 = g4.Sa;
            P3 = 22, e2(_3 != null), e2(w4 != null), L4 = y4[0];
            var I3 = w4[0];
            for (e2(A4 != null), e2(S3 != null), A4[0] = null, x3[0] = null, S3[0] = 0; ; ) {
              if (y4[0] = L4, w4[0] = I3, 8 > I3) {
                y4 = 7;
                break t;
              }
              var F3 = j2(_3, L4 + 4);
              if (4294967286 < F3) {
                y4 = 3;
                break t;
              }
              var O3 = 8 + F3 + 1 & -2;
              if (P3 += O3, 0 < k3 && P3 > k3) {
                y4 = 3;
                break t;
              }
              if (!r2(_3, L4, "VP8 ") || !r2(_3, L4, "VP8L")) {
                y4 = 0;
                break t;
              }
              if (I3[0] < O3) {
                y4 = 7;
                break t;
              }
              r2(_3, L4, "ALPH") || (A4[0] = _3, x3[0] = L4 + 8, S3[0] = F3), L4 += O3, I3 -= O3;
            }
          }
          if (i3 = i3[0], g4.na = g4.na[0], g4.P = g4.P[0], g4.Sa = g4.Sa[0], y4 != 0)
            break;
        }
        i3 = [i3], g4.Ja = [g4.Ja], g4.xa = [g4.xa];
        t:
          if (k3 = t5, y4 = n3, w4 = i3, A4 = g4.gb[0], x3 = g4.Ja, S3 = g4.xa, _3 = y4[0], L4 = !r2(k3, _3, "VP8 "), P3 = !r2(k3, _3, "VP8L"), e2(k3 != null), e2(w4 != null), e2(x3 != null), e2(S3 != null), 8 > w4[0])
            y4 = 7;
          else {
            if (L4 || P3) {
              if (k3 = j2(k3, _3 + 4), 12 <= A4 && k3 > A4 - 12) {
                y4 = 3;
                break t;
              }
              if (p7 && k3 > w4[0] - 8) {
                y4 = 7;
                break t;
              }
              x3[0] = k3, y4[0] += 8, w4[0] -= 8, S3[0] = P3;
            } else
              S3[0] = 5 <= w4[0] && k3[_3 + 0] == 47 && !(k3[_3 + 4] >> 5), x3[0] = w4[0];
            y4 = 0;
          }
        if (i3 = i3[0], g4.Ja = g4.Ja[0], g4.xa = g4.xa[0], n3 = n3[0], y4 != 0)
          break;
        if (4294967286 < g4.Ja)
          return 3;
        if (u4 == null || b4 || (u4[0] = g4.xa ? 2 : 1), c4 = [c4], m4 = [m4], g4.xa) {
          if (5 > i3) {
            y4 = 7;
            break;
          }
          u4 = c4, p7 = m4, b4 = s3, t5 == null || 5 > i3 ? t5 = 0 : 5 <= i3 && t5[n3 + 0] == 47 && !(t5[n3 + 4] >> 5) ? (w4 = [0], k3 = [0], A4 = [0], v3(x3 = new N3(), t5, n3, i3), gt2(x3, w4, k3, A4) ? (u4 != null && (u4[0] = w4[0]), p7 != null && (p7[0] = k3[0]), b4 != null && (b4[0] = A4[0]), t5 = 1) : t5 = 0) : t5 = 0;
        } else {
          if (10 > i3) {
            y4 = 7;
            break;
          }
          u4 = m4, t5 == null || 10 > i3 || !Xt2(t5, n3 + 3, i3 - 3) ? t5 = 0 : (p7 = t5[n3 + 0] | t5[n3 + 1] << 8 | t5[n3 + 2] << 16, b4 = 16383 & (t5[n3 + 7] << 8 | t5[n3 + 6]), t5 = 16383 & (t5[n3 + 9] << 8 | t5[n3 + 8]), 1 & p7 || 3 < (p7 >> 1 & 7) || !(p7 >> 4 & 1) || p7 >> 5 >= g4.Ja || !b4 || !t5 ? t5 = 0 : (c4 && (c4[0] = b4), u4 && (u4[0] = t5), t5 = 1));
        }
        if (!t5)
          return 3;
        if (c4 = c4[0], m4 = m4[0], d4 && (l4[0] != c4 || f4[0] != m4))
          return 3;
        h4 != null && (h4[0] = g4, h4.offset = n3 - h4.w, e2(4294967286 > n3 - h4.w), e2(h4.offset == h4.ha - i3));
        break;
      }
      return y4 == 0 || y4 == 7 && d4 && h4 == null ? (s3 != null && (s3[0] |= g4.na != null && 0 < g4.na.length), a3 != null && (a3[0] = c4), o3 != null && (o3[0] = m4), 0) : y4;
    }
    function Mr(t5, e3, r3) {
      var n3 = e3.width, i3 = e3.height, a3 = 0, o3 = 0, s3 = n3, c4 = i3;
      if (e3.Da = t5 != null && 0 < t5.Da, e3.Da && (s3 = t5.cd, c4 = t5.bd, a3 = t5.v, o3 = t5.j, 11 > r3 || (a3 &= -2, o3 &= -2), 0 > a3 || 0 > o3 || 0 >= s3 || 0 >= c4 || a3 + s3 > n3 || o3 + c4 > i3))
        return 0;
      if (e3.v = a3, e3.j = o3, e3.va = a3 + s3, e3.o = o3 + c4, e3.U = s3, e3.T = c4, e3.da = t5 != null && 0 < t5.da, e3.da) {
        if (!E2(s3, c4, r3 = [t5.ib], a3 = [t5.hb]))
          return 0;
        e3.ib = r3[0], e3.hb = a3[0];
      }
      return e3.ob = t5 != null && t5.ob, e3.Kb = t5 == null || !t5.Sd, e3.da && (e3.ob = e3.ib < 3 * n3 / 4 && e3.hb < 3 * i3 / 4, e3.Kb = 0), 1;
    }
    function Er(t5) {
      if (t5 == null)
        return 2;
      if (11 > t5.S) {
        var e3 = t5.f.RGBA;
        e3.fb += (t5.height - 1) * e3.A, e3.A = -e3.A;
      } else
        e3 = t5.f.kb, t5 = t5.height, e3.O += (t5 - 1) * e3.fa, e3.fa = -e3.fa, e3.N += (t5 - 1 >> 1) * e3.Ab, e3.Ab = -e3.Ab, e3.W += (t5 - 1 >> 1) * e3.Db, e3.Db = -e3.Db, e3.F != null && (e3.J += (t5 - 1) * e3.lb, e3.lb = -e3.lb);
      return 0;
    }
    function qr(t5, e3, r3, n3) {
      if (n3 == null || 0 >= t5 || 0 >= e3)
        return 2;
      if (r3 != null) {
        if (r3.Da) {
          var i3 = r3.cd, o3 = r3.bd, s3 = -2 & r3.v, c4 = -2 & r3.j;
          if (0 > s3 || 0 > c4 || 0 >= i3 || 0 >= o3 || s3 + i3 > t5 || c4 + o3 > e3)
            return 2;
          t5 = i3, e3 = o3;
        }
        if (r3.da) {
          if (!E2(t5, e3, i3 = [r3.ib], o3 = [r3.hb]))
            return 2;
          t5 = i3[0], e3 = o3[0];
        }
      }
      n3.width = t5, n3.height = e3;
      t: {
        var u4 = n3.width, h4 = n3.height;
        if (t5 = n3.S, 0 >= u4 || 0 >= h4 || !(t5 >= En && 13 > t5))
          t5 = 2;
        else {
          if (0 >= n3.Rd && n3.sd == null) {
            s3 = o3 = i3 = e3 = 0;
            var l4 = (c4 = u4 * Ui[t5]) * h4;
            if (11 > t5 || (o3 = (h4 + 1) / 2 * (e3 = (u4 + 1) / 2), t5 == 12 && (s3 = (i3 = u4) * h4)), (h4 = a2(l4 + 2 * o3 + s3)) == null) {
              t5 = 1;
              break t;
            }
            n3.sd = h4, 11 > t5 ? ((u4 = n3.f.RGBA).eb = h4, u4.fb = 0, u4.A = c4, u4.size = l4) : ((u4 = n3.f.kb).y = h4, u4.O = 0, u4.fa = c4, u4.Fd = l4, u4.f = h4, u4.N = 0 + l4, u4.Ab = e3, u4.Cd = o3, u4.ea = h4, u4.W = 0 + l4 + o3, u4.Db = e3, u4.Ed = o3, t5 == 12 && (u4.F = h4, u4.J = 0 + l4 + 2 * o3), u4.Tc = s3, u4.lb = i3);
          }
          if (e3 = 1, i3 = n3.S, o3 = n3.width, s3 = n3.height, i3 >= En && 13 > i3)
            if (11 > i3)
              t5 = n3.f.RGBA, e3 &= (c4 = Math.abs(t5.A)) * (s3 - 1) + o3 <= t5.size, e3 &= c4 >= o3 * Ui[i3], e3 &= t5.eb != null;
            else {
              t5 = n3.f.kb, c4 = (o3 + 1) / 2, l4 = (s3 + 1) / 2, u4 = Math.abs(t5.fa);
              h4 = Math.abs(t5.Ab);
              var f4 = Math.abs(t5.Db), d4 = Math.abs(t5.lb), p7 = d4 * (s3 - 1) + o3;
              e3 &= u4 * (s3 - 1) + o3 <= t5.Fd, e3 &= h4 * (l4 - 1) + c4 <= t5.Cd, e3 = (e3 &= f4 * (l4 - 1) + c4 <= t5.Ed) & u4 >= o3 & h4 >= c4 & f4 >= c4, e3 &= t5.y != null, e3 &= t5.f != null, e3 &= t5.ea != null, i3 == 12 && (e3 &= d4 >= o3, e3 &= p7 <= t5.Tc, e3 &= t5.F != null);
            }
          else
            e3 = 0;
          t5 = e3 ? 0 : 2;
        }
      }
      return t5 != 0 || r3 != null && r3.fd && (t5 = Er(n3)), t5;
    }
    var Dr = 64, Rr = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215], Tr = 24, zr = 32, Ur = 8, Hr = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7];
    R2("Predictor0", "PredictorAdd0"), t4.Predictor0 = function() {
      return 4278190080;
    }, t4.Predictor1 = function(t5) {
      return t5;
    }, t4.Predictor2 = function(t5, e3, r3) {
      return e3[r3 + 0];
    }, t4.Predictor3 = function(t5, e3, r3) {
      return e3[r3 + 1];
    }, t4.Predictor4 = function(t5, e3, r3) {
      return e3[r3 - 1];
    }, t4.Predictor5 = function(t5, e3, r3) {
      return z2(z2(t5, e3[r3 + 1]), e3[r3 + 0]);
    }, t4.Predictor6 = function(t5, e3, r3) {
      return z2(t5, e3[r3 - 1]);
    }, t4.Predictor7 = function(t5, e3, r3) {
      return z2(t5, e3[r3 + 0]);
    }, t4.Predictor8 = function(t5, e3, r3) {
      return z2(e3[r3 - 1], e3[r3 + 0]);
    }, t4.Predictor9 = function(t5, e3, r3) {
      return z2(e3[r3 + 0], e3[r3 + 1]);
    }, t4.Predictor10 = function(t5, e3, r3) {
      return z2(z2(t5, e3[r3 - 1]), z2(e3[r3 + 0], e3[r3 + 1]));
    }, t4.Predictor11 = function(t5, e3, r3) {
      var n3 = e3[r3 + 0];
      return 0 >= W2(n3 >> 24 & 255, t5 >> 24 & 255, (e3 = e3[r3 - 1]) >> 24 & 255) + W2(n3 >> 16 & 255, t5 >> 16 & 255, e3 >> 16 & 255) + W2(n3 >> 8 & 255, t5 >> 8 & 255, e3 >> 8 & 255) + W2(255 & n3, 255 & t5, 255 & e3) ? n3 : t5;
    }, t4.Predictor12 = function(t5, e3, r3) {
      var n3 = e3[r3 + 0];
      return (U2((t5 >> 24 & 255) + (n3 >> 24 & 255) - ((e3 = e3[r3 - 1]) >> 24 & 255)) << 24 | U2((t5 >> 16 & 255) + (n3 >> 16 & 255) - (e3 >> 16 & 255)) << 16 | U2((t5 >> 8 & 255) + (n3 >> 8 & 255) - (e3 >> 8 & 255)) << 8 | U2((255 & t5) + (255 & n3) - (255 & e3))) >>> 0;
    }, t4.Predictor13 = function(t5, e3, r3) {
      var n3 = e3[r3 - 1];
      return (H4((t5 = z2(t5, e3[r3 + 0])) >> 24 & 255, n3 >> 24 & 255) << 24 | H4(t5 >> 16 & 255, n3 >> 16 & 255) << 16 | H4(t5 >> 8 & 255, n3 >> 8 & 255) << 8 | H4(t5 >> 0 & 255, n3 >> 0 & 255)) >>> 0;
    };
    var Wr = t4.PredictorAdd0;
    t4.PredictorAdd1 = V2, R2("Predictor2", "PredictorAdd2"), R2("Predictor3", "PredictorAdd3"), R2("Predictor4", "PredictorAdd4"), R2("Predictor5", "PredictorAdd5"), R2("Predictor6", "PredictorAdd6"), R2("Predictor7", "PredictorAdd7"), R2("Predictor8", "PredictorAdd8"), R2("Predictor9", "PredictorAdd9"), R2("Predictor10", "PredictorAdd10"), R2("Predictor11", "PredictorAdd11"), R2("Predictor12", "PredictorAdd12"), R2("Predictor13", "PredictorAdd13");
    var Vr = t4.PredictorAdd2;
    X2("ColorIndexInverseTransform", "MapARGB", "32b", function(t5) {
      return t5 >> 8 & 255;
    }, function(t5) {
      return t5;
    }), X2("VP8LColorIndexInverseTransformAlpha", "MapAlpha", "8b", function(t5) {
      return t5;
    }, function(t5) {
      return t5 >> 8 & 255;
    });
    var Gr, Yr = t4.ColorIndexInverseTransform, Jr = t4.MapARGB, Xr = t4.VP8LColorIndexInverseTransformAlpha, Kr = t4.MapAlpha, Zr = t4.VP8LPredictorsAdd = [];
    Zr.length = 16, (t4.VP8LPredictors = []).length = 16, (t4.VP8LPredictorsAdd_C = []).length = 16, (t4.VP8LPredictors_C = []).length = 16;
    var $r, Qr, tn, en, rn, nn, an, on, sn, cn, un, hn, ln2, fn, dn, pn, gn, mn, vn, bn, yn, wn, Nn, Ln, An, xn, Sn, _n, Pn = a2(511), kn = a2(2041), In = a2(225), Fn = a2(767), Cn = 0, jn = kn, On = In, Bn = Fn, Mn = Pn, En = 0, qn = 1, Dn = 2, Rn = 3, Tn = 4, zn = 5, Un = 6, Hn = 7, Wn = 8, Vn = 9, Gn = 10, Yn2 = [2, 3, 7], Jn = [3, 3, 11], Xn2 = [280, 256, 256, 256, 40], Kn = [0, 1, 1, 1, 0], Zn2 = [17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], $n = [24, 7, 23, 25, 40, 6, 39, 41, 22, 26, 38, 42, 56, 5, 55, 57, 21, 27, 54, 58, 37, 43, 72, 4, 71, 73, 20, 28, 53, 59, 70, 74, 36, 44, 88, 69, 75, 52, 60, 3, 87, 89, 19, 29, 86, 90, 35, 45, 68, 76, 85, 91, 51, 61, 104, 2, 103, 105, 18, 30, 102, 106, 34, 46, 84, 92, 67, 77, 101, 107, 50, 62, 120, 1, 119, 121, 83, 93, 17, 31, 100, 108, 66, 78, 118, 122, 33, 47, 117, 123, 49, 63, 99, 109, 82, 94, 0, 116, 124, 65, 79, 16, 32, 98, 110, 48, 115, 125, 81, 95, 64, 114, 126, 97, 111, 80, 113, 127, 96, 112], Qn = [2954, 2956, 2958, 2962, 2970, 2986, 3018, 3082, 3212, 3468, 3980, 5004], ti = 8, ei = [4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157], ri = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284], ni = null, ii = [[173, 148, 140, 0], [176, 155, 140, 135, 0], [180, 157, 141, 134, 130, 0], [254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0]], ai = [0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15], oi = [-0, 1, -1, 2, -2, 3, 4, 6, -3, 5, -4, -5, -6, 7, -7, 8, -8, -9], si = [[[[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]], [[253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128], [189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128], [106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128]], [[1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128], [181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128], [78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128]], [[1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128], [184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128], [77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128]], [[1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128], [170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128], [37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128]], [[1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128], [207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128], [102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128]], [[1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128], [177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128], [80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62], [131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1], [68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128]], [[1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128], [184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128], [81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128]], [[1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128], [99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128], [23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128]], [[1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128], [109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128], [44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128]], [[1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128], [94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128], [22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128]], [[1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128], [124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128], [35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128]], [[1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128], [121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128], [45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128]], [[1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128], [203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128], [137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128]]], [[[253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128], [175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128], [73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128]], [[1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128], [239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128], [155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128]], [[1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128], [201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128], [69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128]], [[1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128], [223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128], [141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128]], [[1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128], [190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128], [149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128], [247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128], [240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128], [213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128], [55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255], [126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128], [61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128]], [[1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128], [166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128], [39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128]], [[1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128], [124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128], [24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128]], [[1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128], [149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128], [28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128]], [[1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128], [123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128], [20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128]], [[1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128], [168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128], [47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128]], [[1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128], [141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128], [42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]]]], ci = [[[231, 120, 48, 89, 115, 113, 120, 152, 112], [152, 179, 64, 126, 170, 118, 46, 70, 95], [175, 69, 143, 80, 85, 82, 72, 155, 103], [56, 58, 10, 171, 218, 189, 17, 13, 152], [114, 26, 17, 163, 44, 195, 21, 10, 173], [121, 24, 80, 195, 26, 62, 44, 64, 85], [144, 71, 10, 38, 171, 213, 144, 34, 26], [170, 46, 55, 19, 136, 160, 33, 206, 71], [63, 20, 8, 114, 114, 208, 12, 9, 226], [81, 40, 11, 96, 182, 84, 29, 16, 36]], [[134, 183, 89, 137, 98, 101, 106, 165, 148], [72, 187, 100, 130, 157, 111, 32, 75, 80], [66, 102, 167, 99, 74, 62, 40, 234, 128], [41, 53, 9, 178, 241, 141, 26, 8, 107], [74, 43, 26, 146, 73, 166, 49, 23, 157], [65, 38, 105, 160, 51, 52, 31, 115, 128], [104, 79, 12, 27, 217, 255, 87, 17, 7], [87, 68, 71, 44, 114, 51, 15, 186, 23], [47, 41, 14, 110, 182, 183, 21, 17, 194], [66, 45, 25, 102, 197, 189, 23, 18, 22]], [[88, 88, 147, 150, 42, 46, 45, 196, 205], [43, 97, 183, 117, 85, 38, 35, 179, 61], [39, 53, 200, 87, 26, 21, 43, 232, 171], [56, 34, 51, 104, 114, 102, 29, 93, 77], [39, 28, 85, 171, 58, 165, 90, 98, 64], [34, 22, 116, 206, 23, 34, 43, 166, 73], [107, 54, 32, 26, 51, 1, 81, 43, 31], [68, 25, 106, 22, 64, 171, 36, 225, 114], [34, 19, 21, 102, 132, 188, 16, 76, 124], [62, 18, 78, 95, 85, 57, 50, 48, 51]], [[193, 101, 35, 159, 215, 111, 89, 46, 111], [60, 148, 31, 172, 219, 228, 21, 18, 111], [112, 113, 77, 85, 179, 255, 38, 120, 114], [40, 42, 1, 196, 245, 209, 10, 25, 109], [88, 43, 29, 140, 166, 213, 37, 43, 154], [61, 63, 30, 155, 67, 45, 68, 1, 209], [100, 80, 8, 43, 154, 1, 51, 26, 71], [142, 78, 78, 16, 255, 128, 34, 197, 171], [41, 40, 5, 102, 211, 183, 4, 1, 221], [51, 50, 17, 168, 209, 192, 23, 25, 82]], [[138, 31, 36, 171, 27, 166, 38, 44, 229], [67, 87, 58, 169, 82, 115, 26, 59, 179], [63, 59, 90, 180, 59, 166, 93, 73, 154], [40, 40, 21, 116, 143, 209, 34, 39, 175], [47, 15, 16, 183, 34, 223, 49, 45, 183], [46, 17, 33, 183, 6, 98, 15, 32, 183], [57, 46, 22, 24, 128, 1, 54, 17, 37], [65, 32, 73, 115, 28, 128, 23, 128, 205], [40, 3, 9, 115, 51, 192, 18, 6, 223], [87, 37, 9, 115, 59, 77, 64, 21, 47]], [[104, 55, 44, 218, 9, 54, 53, 130, 226], [64, 90, 70, 205, 40, 41, 23, 26, 57], [54, 57, 112, 184, 5, 41, 38, 166, 213], [30, 34, 26, 133, 152, 116, 10, 32, 134], [39, 19, 53, 221, 26, 114, 32, 73, 255], [31, 9, 65, 234, 2, 15, 1, 118, 73], [75, 32, 12, 51, 192, 255, 160, 43, 51], [88, 31, 35, 67, 102, 85, 55, 186, 85], [56, 21, 23, 111, 59, 205, 45, 37, 192], [55, 38, 70, 124, 73, 102, 1, 34, 98]], [[125, 98, 42, 88, 104, 85, 117, 175, 82], [95, 84, 53, 89, 128, 100, 113, 101, 45], [75, 79, 123, 47, 51, 128, 81, 171, 1], [57, 17, 5, 71, 102, 57, 53, 41, 49], [38, 33, 13, 121, 57, 73, 26, 1, 85], [41, 10, 67, 138, 77, 110, 90, 47, 114], [115, 21, 2, 10, 102, 255, 166, 23, 6], [101, 29, 16, 10, 85, 128, 101, 196, 26], [57, 18, 10, 102, 102, 213, 34, 20, 43], [117, 20, 15, 36, 163, 128, 68, 1, 26]], [[102, 61, 71, 37, 34, 53, 31, 243, 192], [69, 60, 71, 38, 73, 119, 28, 222, 37], [68, 45, 128, 34, 1, 47, 11, 245, 171], [62, 17, 19, 70, 146, 85, 55, 62, 70], [37, 43, 37, 154, 100, 163, 85, 160, 1], [63, 9, 92, 136, 28, 64, 32, 201, 85], [75, 15, 9, 9, 64, 255, 184, 119, 16], [86, 6, 28, 5, 64, 255, 25, 248, 1], [56, 8, 17, 132, 137, 255, 55, 116, 128], [58, 15, 20, 82, 135, 57, 26, 121, 40]], [[164, 50, 31, 137, 154, 133, 25, 35, 218], [51, 103, 44, 131, 131, 123, 31, 6, 158], [86, 40, 64, 135, 148, 224, 45, 183, 128], [22, 26, 17, 131, 240, 154, 14, 1, 209], [45, 16, 21, 91, 64, 222, 7, 1, 197], [56, 21, 39, 155, 60, 138, 23, 102, 213], [83, 12, 13, 54, 192, 255, 68, 47, 28], [85, 26, 85, 85, 128, 128, 32, 146, 171], [18, 11, 7, 63, 144, 171, 4, 4, 246], [35, 27, 10, 146, 174, 171, 12, 26, 128]], [[190, 80, 35, 99, 180, 80, 126, 54, 45], [85, 126, 47, 87, 176, 51, 41, 20, 32], [101, 75, 128, 139, 118, 146, 116, 128, 85], [56, 41, 15, 176, 236, 85, 37, 9, 62], [71, 30, 17, 119, 118, 255, 17, 18, 138], [101, 38, 60, 138, 55, 70, 43, 26, 142], [146, 36, 19, 30, 171, 255, 97, 27, 20], [138, 45, 61, 62, 219, 1, 81, 188, 64], [32, 41, 20, 117, 151, 142, 20, 21, 163], [112, 19, 12, 61, 195, 128, 48, 4, 24]]], ui = [[[[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255], [249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255], [234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255], [239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255], [250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255], [234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255], [247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255], [234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255], [251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255], [248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255], [248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255], [249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]]], hi = [0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0], li = [], fi = [], di = [], pi = 1, gi = 2, mi = [], vi = [];
    vr("UpsampleRgbLinePair", Ar, 3), vr("UpsampleBgrLinePair", xr, 3), vr("UpsampleRgbaLinePair", Ir, 4), vr("UpsampleBgraLinePair", kr, 4), vr("UpsampleArgbLinePair", Pr, 4), vr("UpsampleRgba4444LinePair", _r, 2), vr("UpsampleRgb565LinePair", Sr, 2);
    var bi = t4.UpsampleRgbLinePair, yi = t4.UpsampleBgrLinePair, wi = t4.UpsampleRgbaLinePair, Ni = t4.UpsampleBgraLinePair, Li = t4.UpsampleArgbLinePair, Ai = t4.UpsampleRgba4444LinePair, xi = t4.UpsampleRgb565LinePair, Si = 16, _i = 1 << Si - 1, Pi = -227, ki = 482, Ii = 6, Fi = (256 << Ii) - 1, Ci = 0, ji = a2(256), Oi = a2(256), Bi = a2(256), Mi = a2(256), Ei = a2(ki - Pi), qi = a2(ki - Pi);
    Fr("YuvToRgbRow", Ar, 3), Fr("YuvToBgrRow", xr, 3), Fr("YuvToRgbaRow", Ir, 4), Fr("YuvToBgraRow", kr, 4), Fr("YuvToArgbRow", Pr, 4), Fr("YuvToRgba4444Row", _r, 2), Fr("YuvToRgb565Row", Sr, 2);
    var Di = [0, 4, 8, 12, 128, 132, 136, 140, 256, 260, 264, 268, 384, 388, 392, 396], Ri = [0, 2, 8], Ti = [8, 7, 6, 4, 4, 2, 2, 2, 1, 1, 1, 1], zi = 1;
    this.WebPDecodeRGBA = function(t5, r3, n3, i3, a3) {
      var o3 = qn, s3 = new rr(), c4 = new ot2();
      s3.ba = c4, c4.S = o3, c4.width = [c4.width], c4.height = [c4.height];
      var u4 = c4.width, h4 = c4.height, l4 = new st2();
      if (l4 == null || t5 == null)
        var f4 = 2;
      else
        e2(l4 != null), f4 = Br(t5, r3, n3, l4.width, l4.height, l4.Pd, l4.Qd, l4.format, null);
      if (f4 != 0 ? u4 = 0 : (u4 != null && (u4[0] = l4.width[0]), h4 != null && (h4[0] = l4.height[0]), u4 = 1), u4) {
        c4.width = c4.width[0], c4.height = c4.height[0], i3 != null && (i3[0] = c4.width), a3 != null && (a3[0] = c4.height);
        t: {
          if (i3 = new Gt2(), (a3 = new nr()).data = t5, a3.w = r3, a3.ha = n3, a3.kd = 1, r3 = [0], e2(a3 != null), ((t5 = Br(a3.data, a3.w, a3.ha, null, null, null, r3, null, a3)) == 0 || t5 == 7) && r3[0] && (t5 = 4), (r3 = t5) == 0) {
            if (e2(s3 != null), i3.data = a3.data, i3.w = a3.w + a3.offset, i3.ha = a3.ha - a3.offset, i3.put = dt2, i3.ac = ft2, i3.bc = pt2, i3.ma = s3, a3.xa) {
              if ((t5 = kt2()) == null) {
                s3 = 1;
                break t;
              }
              if (function(t6, r4) {
                var n4 = [0], i4 = [0], a4 = [0];
                e:
                  for (; ; ) {
                    if (t6 == null)
                      return 0;
                    if (r4 == null)
                      return t6.a = 2, 0;
                    if (t6.l = r4, t6.a = 0, v3(t6.m, r4.data, r4.w, r4.ha), !gt2(t6.m, n4, i4, a4)) {
                      t6.a = 3;
                      break e;
                    }
                    if (t6.xb = gi, r4.width = n4[0], r4.height = i4[0], !It2(n4[0], i4[0], 1, t6, null))
                      break e;
                    return 1;
                  }
                return e2(t6.a != 0), 0;
              }(t5, i3)) {
                if (i3 = (r3 = qr(i3.width, i3.height, s3.Oa, s3.ba)) == 0) {
                  e: {
                    i3 = t5;
                    r:
                      for (; ; ) {
                        if (i3 == null) {
                          i3 = 0;
                          break e;
                        }
                        if (e2(i3.s.yc != null), e2(i3.s.Ya != null), e2(0 < i3.s.Wb), e2((n3 = i3.l) != null), e2((a3 = n3.ma) != null), i3.xb != 0) {
                          if (i3.ca = a3.ba, i3.tb = a3.tb, e2(i3.ca != null), !Mr(a3.Oa, n3, Rn)) {
                            i3.a = 2;
                            break r;
                          }
                          if (!Ft2(i3, n3.width))
                            break r;
                          if (n3.da)
                            break r;
                          if ((n3.da || nt2(i3.ca.S)) && mr(), 11 > i3.ca.S || (alert("todo:WebPInitConvertARGBToYUV"), i3.ca.f.kb.F != null && mr()), i3.Pb && 0 < i3.s.ua && i3.s.vb.X == null && !O2(i3.s.vb, i3.s.Wa.Xa)) {
                            i3.a = 1;
                            break r;
                          }
                          i3.xb = 0;
                        }
                        if (!_t2(i3, i3.V, i3.Ba, i3.c, i3.i, n3.o, Lt2))
                          break r;
                        a3.Dc = i3.Ma, i3 = 1;
                        break e;
                      }
                    e2(i3.a != 0), i3 = 0;
                  }
                  i3 = !i3;
                }
                i3 && (r3 = t5.a);
              } else
                r3 = t5.a;
            } else {
              if ((t5 = new Yt2()) == null) {
                s3 = 1;
                break t;
              }
              if (t5.Fa = a3.na, t5.P = a3.P, t5.qc = a3.Sa, Kt2(t5, i3)) {
                if ((r3 = qr(i3.width, i3.height, s3.Oa, s3.ba)) == 0) {
                  if (t5.Aa = 0, n3 = s3.Oa, e2((a3 = t5) != null), n3 != null) {
                    if (0 < (u4 = 0 > (u4 = n3.Md) ? 0 : 100 < u4 ? 255 : 255 * u4 / 100)) {
                      for (h4 = l4 = 0; 4 > h4; ++h4)
                        12 > (f4 = a3.pb[h4]).lc && (f4.ia = u4 * Ti[0 > f4.lc ? 0 : f4.lc] >> 3), l4 |= f4.ia;
                      l4 && (alert("todo:VP8InitRandom"), a3.ia = 1);
                    }
                    a3.Ga = n3.Id, 100 < a3.Ga ? a3.Ga = 100 : 0 > a3.Ga && (a3.Ga = 0);
                  }
                  Qt2(t5, i3) || (r3 = t5.a);
                }
              } else
                r3 = t5.a;
            }
            r3 == 0 && s3.Oa != null && s3.Oa.fd && (r3 = Er(s3.ba));
          }
          s3 = r3;
        }
        o3 = s3 != 0 ? null : 11 > o3 ? c4.f.RGBA.eb : c4.f.kb.y;
      } else
        o3 = null;
      return o3;
    };
    var Ui = [3, 4, 3, 4, 4, 2, 2, 4, 4, 4, 2, 1, 1];
  };
  function u2(t4, e3) {
    for (var r3 = "", n3 = 0; n3 < 4; n3++)
      r3 += String.fromCharCode(t4[e3++]);
    return r3;
  }
  function h2(t4, e3) {
    return (t4[e3 + 0] << 0 | t4[e3 + 1] << 8 | t4[e3 + 2] << 16) >>> 0;
  }
  function l2(t4, e3) {
    return (t4[e3 + 0] << 0 | t4[e3 + 1] << 8 | t4[e3 + 2] << 16 | t4[e3 + 3] << 24) >>> 0;
  }
  new c2();
  var f2 = [0], d2 = [0], p5 = [], g2 = new c2(), m2 = t3, v2 = function(t4, e3) {
    var r3 = {}, n3 = 0, i3 = false, a3 = 0, o3 = 0;
    if (r3.frames = [], !function(t5, e4, r4, n4) {
      for (var i4 = 0; i4 < n4; i4++)
        if (t5[e4 + i4] != r4.charCodeAt(i4))
          return true;
      return false;
    }(t4, e3, "RIFF", 4)) {
      var s3, c3;
      l2(t4, e3 += 4);
      for (e3 += 8; e3 < t4.length; ) {
        var f3 = u2(t4, e3), d3 = l2(t4, e3 += 4);
        e3 += 4;
        var p6 = d3 + (1 & d3);
        switch (f3) {
          case "VP8 ":
          case "VP8L":
            r3.frames[n3] === void 0 && (r3.frames[n3] = {});
            (v3 = r3.frames[n3]).src_off = i3 ? o3 : e3 - 8, v3.src_size = a3 + d3 + 8, n3++, i3 && (i3 = false, a3 = 0, o3 = 0);
            break;
          case "VP8X":
            (v3 = r3.header = {}).feature_flags = t4[e3];
            var g3 = e3 + 4;
            v3.canvas_width = 1 + h2(t4, g3);
            g3 += 3;
            v3.canvas_height = 1 + h2(t4, g3);
            g3 += 3;
            break;
          case "ALPH":
            i3 = true, a3 = p6 + 8, o3 = e3 - 8;
            break;
          case "ANIM":
            (v3 = r3.header).bgcolor = l2(t4, e3);
            g3 = e3 + 4;
            v3.loop_count = (s3 = t4)[(c3 = g3) + 0] << 0 | s3[c3 + 1] << 8;
            g3 += 2;
            break;
          case "ANMF":
            var m3, v3;
            (v3 = r3.frames[n3] = {}).offset_x = 2 * h2(t4, e3), e3 += 3, v3.offset_y = 2 * h2(t4, e3), e3 += 3, v3.width = 1 + h2(t4, e3), e3 += 3, v3.height = 1 + h2(t4, e3), e3 += 3, v3.duration = h2(t4, e3), e3 += 3, m3 = t4[e3++], v3.dispose = 1 & m3, v3.blend = m3 >> 1 & 1;
        }
        f3 != "ANMF" && (e3 += p6);
      }
      return r3;
    }
  }(m2, 0);
  v2.response = m2, v2.rgbaoutput = true, v2.dataurl = false;
  var b2 = v2.header ? v2.header : null, y2 = v2.frames ? v2.frames : null;
  if (b2) {
    b2.loop_counter = b2.loop_count, f2 = [b2.canvas_height], d2 = [b2.canvas_width];
    for (var w2 = 0; w2 < y2.length && y2[w2].blend != 0; w2++)
      ;
  }
  var N2 = y2[0], L2 = g2.WebPDecodeRGBA(m2, N2.src_off, N2.src_size, d2, f2);
  N2.rgba = L2, N2.imgwidth = d2[0], N2.imgheight = f2[0];
  for (var A2 = 0; A2 < d2[0] * f2[0] * 4; A2++)
    p5[A2] = L2[A2];
  return this.width = d2, this.height = f2, this.data = p5, this;
}
!function(t3) {
  var r2 = function() {
    return typeof zlibSync == "function";
  }, n2 = function(r3, n3, a3, h3) {
    var l3 = 4, f3 = s2;
    switch (h3) {
      case t3.image_compression.FAST:
        l3 = 1, f3 = o2;
        break;
      case t3.image_compression.MEDIUM:
        l3 = 6, f3 = c2;
        break;
      case t3.image_compression.SLOW:
        l3 = 9, f3 = u2;
    }
    r3 = i2(r3, n3, a3, f3);
    var d2 = zlibSync(r3, { level: l3 });
    return t3.__addimage__.arrayBufferToBinaryString(d2);
  }, i2 = function(t4, e2, r3, n3) {
    for (var i3, a3, o3, s3 = t4.length / e2, c3 = new Uint8Array(t4.length + s3), u3 = l2(), h3 = 0; h3 < s3; h3 += 1) {
      if (o3 = h3 * e2, i3 = t4.subarray(o3, o3 + e2), n3)
        c3.set(n3(i3, r3, a3), o3 + h3);
      else {
        for (var d2, p5 = u3.length, g2 = []; d2 < p5; d2 += 1)
          g2[d2] = u3[d2](i3, r3, a3);
        var m2 = f2(g2.concat());
        c3.set(g2[m2], o3 + h3);
      }
      a3 = i3;
    }
    return c3;
  }, a2 = function(t4) {
    var e2 = Array.apply([], t4);
    return e2.unshift(0), e2;
  }, o2 = function(t4, e2) {
    var r3, n3 = [], i3 = t4.length;
    n3[0] = 1;
    for (var a3 = 0; a3 < i3; a3 += 1)
      r3 = t4[a3 - e2] || 0, n3[a3 + 1] = t4[a3] - r3 + 256 & 255;
    return n3;
  }, s2 = function(t4, e2, r3) {
    var n3, i3 = [], a3 = t4.length;
    i3[0] = 2;
    for (var o3 = 0; o3 < a3; o3 += 1)
      n3 = r3 && r3[o3] || 0, i3[o3 + 1] = t4[o3] - n3 + 256 & 255;
    return i3;
  }, c2 = function(t4, e2, r3) {
    var n3, i3, a3 = [], o3 = t4.length;
    a3[0] = 3;
    for (var s3 = 0; s3 < o3; s3 += 1)
      n3 = t4[s3 - e2] || 0, i3 = r3 && r3[s3] || 0, a3[s3 + 1] = t4[s3] + 256 - (n3 + i3 >>> 1) & 255;
    return a3;
  }, u2 = function(t4, e2, r3) {
    var n3, i3, a3, o3, s3 = [], c3 = t4.length;
    s3[0] = 4;
    for (var u3 = 0; u3 < c3; u3 += 1)
      n3 = t4[u3 - e2] || 0, i3 = r3 && r3[u3] || 0, a3 = r3 && r3[u3 - e2] || 0, o3 = h2(n3, i3, a3), s3[u3 + 1] = t4[u3] - o3 + 256 & 255;
    return s3;
  }, h2 = function(t4, e2, r3) {
    if (t4 === e2 && e2 === r3)
      return t4;
    var n3 = Math.abs(e2 - r3), i3 = Math.abs(t4 - r3), a3 = Math.abs(t4 + e2 - r3 - r3);
    return n3 <= i3 && n3 <= a3 ? t4 : i3 <= a3 ? e2 : r3;
  }, l2 = function() {
    return [a2, o2, s2, c2, u2];
  }, f2 = function(t4) {
    var e2 = t4.map(function(t5) {
      return t5.reduce(function(t6, e3) {
        return t6 + Math.abs(e3);
      }, 0);
    });
    return e2.indexOf(Math.min.apply(null, e2));
  };
  t3.processPNG = function(e2, i3, a3, o3) {
    var s3, c3, u3, h3, l3, f3, d2, p5, g2, m2, v2, b2, y2, w2, N2, L2 = this.decode.FLATE_DECODE, A2 = "";
    if (this.__addimage__.isArrayBuffer(e2) && (e2 = new Uint8Array(e2)), this.__addimage__.isArrayBufferView(e2)) {
      if (e2 = (u3 = new Kt(e2)).imgData, c3 = u3.bits, s3 = u3.colorSpace, l3 = u3.colors, [4, 6].indexOf(u3.colorType) !== -1) {
        if (u3.bits === 8) {
          g2 = (p5 = u3.pixelBitlength == 32 ? new Uint32Array(u3.decodePixels().buffer) : u3.pixelBitlength == 16 ? new Uint16Array(u3.decodePixels().buffer) : new Uint8Array(u3.decodePixels().buffer)).length, v2 = new Uint8Array(g2 * u3.colors), m2 = new Uint8Array(g2);
          var x2, S2 = u3.pixelBitlength - u3.bits;
          for (w2 = 0, N2 = 0; w2 < g2; w2++) {
            for (y2 = p5[w2], x2 = 0; x2 < S2; )
              v2[N2++] = y2 >>> x2 & 255, x2 += u3.bits;
            m2[w2] = y2 >>> x2 & 255;
          }
        }
        if (u3.bits === 16) {
          g2 = (p5 = new Uint32Array(u3.decodePixels().buffer)).length, v2 = new Uint8Array(g2 * (32 / u3.pixelBitlength) * u3.colors), m2 = new Uint8Array(g2 * (32 / u3.pixelBitlength)), b2 = u3.colors > 1, w2 = 0, N2 = 0;
          for (var _2 = 0; w2 < g2; )
            y2 = p5[w2++], v2[N2++] = y2 >>> 0 & 255, b2 && (v2[N2++] = y2 >>> 16 & 255, y2 = p5[w2++], v2[N2++] = y2 >>> 0 & 255), m2[_2++] = y2 >>> 16 & 255;
          c3 = 8;
        }
        o3 !== t3.image_compression.NONE && r2() ? (e2 = n2(v2, u3.width * u3.colors, u3.colors, o3), d2 = n2(m2, u3.width, 1, o3)) : (e2 = v2, d2 = m2, L2 = void 0);
      }
      if (u3.colorType === 3 && (s3 = this.color_spaces.INDEXED, f3 = u3.palette, u3.transparency.indexed)) {
        var P2 = u3.transparency.indexed, k2 = 0;
        for (w2 = 0, g2 = P2.length; w2 < g2; ++w2)
          k2 += P2[w2];
        if ((k2 /= 255) === g2 - 1 && P2.indexOf(0) !== -1)
          h3 = [P2.indexOf(0)];
        else if (k2 !== g2) {
          for (p5 = u3.decodePixels(), m2 = new Uint8Array(p5.length), w2 = 0, g2 = p5.length; w2 < g2; w2++)
            m2[w2] = P2[p5[w2]];
          d2 = n2(m2, u3.width, 1);
        }
      }
      var I2 = function(e3) {
        var r3;
        switch (e3) {
          case t3.image_compression.FAST:
            r3 = 11;
            break;
          case t3.image_compression.MEDIUM:
            r3 = 13;
            break;
          case t3.image_compression.SLOW:
            r3 = 14;
            break;
          default:
            r3 = 12;
        }
        return r3;
      }(o3);
      return L2 === this.decode.FLATE_DECODE && (A2 = "/Predictor " + I2 + " "), A2 += "/Colors " + l3 + " /BitsPerComponent " + c3 + " /Columns " + u3.width, (this.__addimage__.isArrayBuffer(e2) || this.__addimage__.isArrayBufferView(e2)) && (e2 = this.__addimage__.arrayBufferToBinaryString(e2)), (d2 && this.__addimage__.isArrayBuffer(d2) || this.__addimage__.isArrayBufferView(d2)) && (d2 = this.__addimage__.arrayBufferToBinaryString(d2)), { alias: a3, data: e2, index: i3, filter: L2, decodeParameters: A2, transparency: h3, palette: f3, sMask: d2, predictor: I2, width: u3.width, height: u3.height, bitsPerComponent: c3, colorSpace: s3 };
    }
  };
}(E$1.API), function(t3) {
  t3.processGIF89A = function(e2, r2, n2, i2) {
    var a2 = new Zt(e2), o2 = a2.width, s2 = a2.height, c2 = [];
    a2.decodeAndBlitFrameRGBA(0, c2);
    var u2 = { data: c2, width: o2, height: s2 }, h2 = new Qt(100).encode(u2, 100);
    return t3.processJPEG.call(this, h2, r2, n2, i2);
  }, t3.processGIF87A = t3.processGIF89A;
}(E$1.API), te.prototype.parseHeader = function() {
  if (this.fileSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.reserved = this.datav.getUint32(this.pos, true), this.pos += 4, this.offset = this.datav.getUint32(this.pos, true), this.pos += 4, this.headerSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.width = this.datav.getUint32(this.pos, true), this.pos += 4, this.height = this.datav.getInt32(this.pos, true), this.pos += 4, this.planes = this.datav.getUint16(this.pos, true), this.pos += 2, this.bitPP = this.datav.getUint16(this.pos, true), this.pos += 2, this.compress = this.datav.getUint32(this.pos, true), this.pos += 4, this.rawSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.hr = this.datav.getUint32(this.pos, true), this.pos += 4, this.vr = this.datav.getUint32(this.pos, true), this.pos += 4, this.colors = this.datav.getUint32(this.pos, true), this.pos += 4, this.importantColors = this.datav.getUint32(this.pos, true), this.pos += 4, this.bitPP === 16 && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
    var t3 = this.colors === 0 ? 1 << this.bitPP : this.colors;
    this.palette = new Array(t3);
    for (var e2 = 0; e2 < t3; e2++) {
      var r2 = this.datav.getUint8(this.pos++, true), n2 = this.datav.getUint8(this.pos++, true), i2 = this.datav.getUint8(this.pos++, true), a2 = this.datav.getUint8(this.pos++, true);
      this.palette[e2] = { red: i2, green: n2, blue: r2, quad: a2 };
    }
  }
  this.height < 0 && (this.height *= -1, this.bottom_up = false);
}, te.prototype.parseBGR = function() {
  this.pos = this.offset;
  try {
    var t3 = "bit" + this.bitPP, e2 = this.width * this.height * 4;
    this.data = new Uint8Array(e2), this[t3]();
  } catch (t4) {
    a$2.log("bit decode error:" + t4);
  }
}, te.prototype.bit1 = function() {
  var t3, e2 = Math.ceil(this.width / 8), r2 = e2 % 4;
  for (t3 = this.height - 1; t3 >= 0; t3--) {
    for (var n2 = this.bottom_up ? t3 : this.height - 1 - t3, i2 = 0; i2 < e2; i2++)
      for (var a2 = this.datav.getUint8(this.pos++, true), o2 = n2 * this.width * 4 + 8 * i2 * 4, s2 = 0; s2 < 8 && 8 * i2 + s2 < this.width; s2++) {
        var c2 = this.palette[a2 >> 7 - s2 & 1];
        this.data[o2 + 4 * s2] = c2.blue, this.data[o2 + 4 * s2 + 1] = c2.green, this.data[o2 + 4 * s2 + 2] = c2.red, this.data[o2 + 4 * s2 + 3] = 255;
      }
    r2 !== 0 && (this.pos += 4 - r2);
  }
}, te.prototype.bit4 = function() {
  for (var t3 = Math.ceil(this.width / 2), e2 = t3 % 4, r2 = this.height - 1; r2 >= 0; r2--) {
    for (var n2 = this.bottom_up ? r2 : this.height - 1 - r2, i2 = 0; i2 < t3; i2++) {
      var a2 = this.datav.getUint8(this.pos++, true), o2 = n2 * this.width * 4 + 2 * i2 * 4, s2 = a2 >> 4, c2 = 15 & a2, u2 = this.palette[s2];
      if (this.data[o2] = u2.blue, this.data[o2 + 1] = u2.green, this.data[o2 + 2] = u2.red, this.data[o2 + 3] = 255, 2 * i2 + 1 >= this.width)
        break;
      u2 = this.palette[c2], this.data[o2 + 4] = u2.blue, this.data[o2 + 4 + 1] = u2.green, this.data[o2 + 4 + 2] = u2.red, this.data[o2 + 4 + 3] = 255;
    }
    e2 !== 0 && (this.pos += 4 - e2);
  }
}, te.prototype.bit8 = function() {
  for (var t3 = this.width % 4, e2 = this.height - 1; e2 >= 0; e2--) {
    for (var r2 = this.bottom_up ? e2 : this.height - 1 - e2, n2 = 0; n2 < this.width; n2++) {
      var i2 = this.datav.getUint8(this.pos++, true), a2 = r2 * this.width * 4 + 4 * n2;
      if (i2 < this.palette.length) {
        var o2 = this.palette[i2];
        this.data[a2] = o2.red, this.data[a2 + 1] = o2.green, this.data[a2 + 2] = o2.blue, this.data[a2 + 3] = 255;
      } else
        this.data[a2] = 255, this.data[a2 + 1] = 255, this.data[a2 + 2] = 255, this.data[a2 + 3] = 255;
    }
    t3 !== 0 && (this.pos += 4 - t3);
  }
}, te.prototype.bit15 = function() {
  for (var t3 = this.width % 3, e2 = parseInt("11111", 2), r2 = this.height - 1; r2 >= 0; r2--) {
    for (var n2 = this.bottom_up ? r2 : this.height - 1 - r2, i2 = 0; i2 < this.width; i2++) {
      var a2 = this.datav.getUint16(this.pos, true);
      this.pos += 2;
      var o2 = (a2 & e2) / e2 * 255 | 0, s2 = (a2 >> 5 & e2) / e2 * 255 | 0, c2 = (a2 >> 10 & e2) / e2 * 255 | 0, u2 = a2 >> 15 ? 255 : 0, h2 = n2 * this.width * 4 + 4 * i2;
      this.data[h2] = c2, this.data[h2 + 1] = s2, this.data[h2 + 2] = o2, this.data[h2 + 3] = u2;
    }
    this.pos += t3;
  }
}, te.prototype.bit16 = function() {
  for (var t3 = this.width % 3, e2 = parseInt("11111", 2), r2 = parseInt("111111", 2), n2 = this.height - 1; n2 >= 0; n2--) {
    for (var i2 = this.bottom_up ? n2 : this.height - 1 - n2, a2 = 0; a2 < this.width; a2++) {
      var o2 = this.datav.getUint16(this.pos, true);
      this.pos += 2;
      var s2 = (o2 & e2) / e2 * 255 | 0, c2 = (o2 >> 5 & r2) / r2 * 255 | 0, u2 = (o2 >> 11) / e2 * 255 | 0, h2 = i2 * this.width * 4 + 4 * a2;
      this.data[h2] = u2, this.data[h2 + 1] = c2, this.data[h2 + 2] = s2, this.data[h2 + 3] = 255;
    }
    this.pos += t3;
  }
}, te.prototype.bit24 = function() {
  for (var t3 = this.height - 1; t3 >= 0; t3--) {
    for (var e2 = this.bottom_up ? t3 : this.height - 1 - t3, r2 = 0; r2 < this.width; r2++) {
      var n2 = this.datav.getUint8(this.pos++, true), i2 = this.datav.getUint8(this.pos++, true), a2 = this.datav.getUint8(this.pos++, true), o2 = e2 * this.width * 4 + 4 * r2;
      this.data[o2] = a2, this.data[o2 + 1] = i2, this.data[o2 + 2] = n2, this.data[o2 + 3] = 255;
    }
    this.pos += this.width % 4;
  }
}, te.prototype.bit32 = function() {
  for (var t3 = this.height - 1; t3 >= 0; t3--)
    for (var e2 = this.bottom_up ? t3 : this.height - 1 - t3, r2 = 0; r2 < this.width; r2++) {
      var n2 = this.datav.getUint8(this.pos++, true), i2 = this.datav.getUint8(this.pos++, true), a2 = this.datav.getUint8(this.pos++, true), o2 = this.datav.getUint8(this.pos++, true), s2 = e2 * this.width * 4 + 4 * r2;
      this.data[s2] = a2, this.data[s2 + 1] = i2, this.data[s2 + 2] = n2, this.data[s2 + 3] = o2;
    }
}, te.prototype.getData = function() {
  return this.data;
}, function(t3) {
  t3.processBMP = function(e2, r2, n2, i2) {
    var a2 = new te(e2, false), o2 = a2.width, s2 = a2.height, c2 = { data: a2.getData(), width: o2, height: s2 }, u2 = new Qt(100).encode(c2, 100);
    return t3.processJPEG.call(this, u2, r2, n2, i2);
  };
}(E$1.API), ee.prototype.getData = function() {
  return this.data;
}, function(t3) {
  t3.processWEBP = function(e2, r2, n2, i2) {
    var a2 = new ee(e2, false), o2 = a2.width, s2 = a2.height, c2 = { data: a2.getData(), width: o2, height: s2 }, u2 = new Qt(100).encode(c2, 100);
    return t3.processJPEG.call(this, u2, r2, n2, i2);
  };
}(E$1.API), E$1.API.processRGBA = function(t3, e2, r2) {
  for (var n2 = t3.data, i2 = n2.length, a2 = new Uint8Array(i2 / 4 * 3), o2 = new Uint8Array(i2 / 4), s2 = 0, c2 = 0, u2 = 0; u2 < i2; u2 += 4) {
    var h2 = n2[u2], l2 = n2[u2 + 1], f2 = n2[u2 + 2], d2 = n2[u2 + 3];
    a2[s2++] = h2, a2[s2++] = l2, a2[s2++] = f2, o2[c2++] = d2;
  }
  var p5 = this.__addimage__.arrayBufferToBinaryString(a2);
  return { alpha: this.__addimage__.arrayBufferToBinaryString(o2), data: p5, index: e2, alias: r2, colorSpace: "DeviceRGB", bitsPerComponent: 8, width: t3.width, height: t3.height };
}, E$1.API.setLanguage = function(t3) {
  return this.internal.languageSettings === void 0 && (this.internal.languageSettings = {}, this.internal.languageSettings.isSubscribed = false), { af: "Afrikaans", sq: "Albanian", ar: "Arabic (Standard)", "ar-DZ": "Arabic (Algeria)", "ar-BH": "Arabic (Bahrain)", "ar-EG": "Arabic (Egypt)", "ar-IQ": "Arabic (Iraq)", "ar-JO": "Arabic (Jordan)", "ar-KW": "Arabic (Kuwait)", "ar-LB": "Arabic (Lebanon)", "ar-LY": "Arabic (Libya)", "ar-MA": "Arabic (Morocco)", "ar-OM": "Arabic (Oman)", "ar-QA": "Arabic (Qatar)", "ar-SA": "Arabic (Saudi Arabia)", "ar-SY": "Arabic (Syria)", "ar-TN": "Arabic (Tunisia)", "ar-AE": "Arabic (U.A.E.)", "ar-YE": "Arabic (Yemen)", an: "Aragonese", hy: "Armenian", as: "Assamese", ast: "Asturian", az: "Azerbaijani", eu: "Basque", be: "Belarusian", bn: "Bengali", bs: "Bosnian", br: "Breton", bg: "Bulgarian", my: "Burmese", ca: "Catalan", ch: "Chamorro", ce: "Chechen", zh: "Chinese", "zh-HK": "Chinese (Hong Kong)", "zh-CN": "Chinese (PRC)", "zh-SG": "Chinese (Singapore)", "zh-TW": "Chinese (Taiwan)", cv: "Chuvash", co: "Corsican", cr: "Cree", hr: "Croatian", cs: "Czech", da: "Danish", nl: "Dutch (Standard)", "nl-BE": "Dutch (Belgian)", en: "English", "en-AU": "English (Australia)", "en-BZ": "English (Belize)", "en-CA": "English (Canada)", "en-IE": "English (Ireland)", "en-JM": "English (Jamaica)", "en-NZ": "English (New Zealand)", "en-PH": "English (Philippines)", "en-ZA": "English (South Africa)", "en-TT": "English (Trinidad & Tobago)", "en-GB": "English (United Kingdom)", "en-US": "English (United States)", "en-ZW": "English (Zimbabwe)", eo: "Esperanto", et: "Estonian", fo: "Faeroese", fj: "Fijian", fi: "Finnish", fr: "French (Standard)", "fr-BE": "French (Belgium)", "fr-CA": "French (Canada)", "fr-FR": "French (France)", "fr-LU": "French (Luxembourg)", "fr-MC": "French (Monaco)", "fr-CH": "French (Switzerland)", fy: "Frisian", fur: "Friulian", gd: "Gaelic (Scots)", "gd-IE": "Gaelic (Irish)", gl: "Galacian", ka: "Georgian", de: "German (Standard)", "de-AT": "German (Austria)", "de-DE": "German (Germany)", "de-LI": "German (Liechtenstein)", "de-LU": "German (Luxembourg)", "de-CH": "German (Switzerland)", el: "Greek", gu: "Gujurati", ht: "Haitian", he: "Hebrew", hi: "Hindi", hu: "Hungarian", is: "Icelandic", id: "Indonesian", iu: "Inuktitut", ga: "Irish", it: "Italian (Standard)", "it-CH": "Italian (Switzerland)", ja: "Japanese", kn: "Kannada", ks: "Kashmiri", kk: "Kazakh", km: "Khmer", ky: "Kirghiz", tlh: "Klingon", ko: "Korean", "ko-KP": "Korean (North Korea)", "ko-KR": "Korean (South Korea)", la: "Latin", lv: "Latvian", lt: "Lithuanian", lb: "Luxembourgish", mk: "North Macedonia", ms: "Malay", ml: "Malayalam", mt: "Maltese", mi: "Maori", mr: "Marathi", mo: "Moldavian", nv: "Navajo", ng: "Ndonga", ne: "Nepali", no: "Norwegian", nb: "Norwegian (Bokmal)", nn: "Norwegian (Nynorsk)", oc: "Occitan", or: "Oriya", om: "Oromo", fa: "Persian", "fa-IR": "Persian/Iran", pl: "Polish", pt: "Portuguese", "pt-BR": "Portuguese (Brazil)", pa: "Punjabi", "pa-IN": "Punjabi (India)", "pa-PK": "Punjabi (Pakistan)", qu: "Quechua", rm: "Rhaeto-Romanic", ro: "Romanian", "ro-MO": "Romanian (Moldavia)", ru: "Russian", "ru-MO": "Russian (Moldavia)", sz: "Sami (Lappish)", sg: "Sango", sa: "Sanskrit", sc: "Sardinian", sd: "Sindhi", si: "Singhalese", sr: "Serbian", sk: "Slovak", sl: "Slovenian", so: "Somani", sb: "Sorbian", es: "Spanish", "es-AR": "Spanish (Argentina)", "es-BO": "Spanish (Bolivia)", "es-CL": "Spanish (Chile)", "es-CO": "Spanish (Colombia)", "es-CR": "Spanish (Costa Rica)", "es-DO": "Spanish (Dominican Republic)", "es-EC": "Spanish (Ecuador)", "es-SV": "Spanish (El Salvador)", "es-GT": "Spanish (Guatemala)", "es-HN": "Spanish (Honduras)", "es-MX": "Spanish (Mexico)", "es-NI": "Spanish (Nicaragua)", "es-PA": "Spanish (Panama)", "es-PY": "Spanish (Paraguay)", "es-PE": "Spanish (Peru)", "es-PR": "Spanish (Puerto Rico)", "es-ES": "Spanish (Spain)", "es-UY": "Spanish (Uruguay)", "es-VE": "Spanish (Venezuela)", sx: "Sutu", sw: "Swahili", sv: "Swedish", "sv-FI": "Swedish (Finland)", "sv-SV": "Swedish (Sweden)", ta: "Tamil", tt: "Tatar", te: "Teluga", th: "Thai", tig: "Tigre", ts: "Tsonga", tn: "Tswana", tr: "Turkish", tk: "Turkmen", uk: "Ukrainian", hsb: "Upper Sorbian", ur: "Urdu", ve: "Venda", vi: "Vietnamese", vo: "Volapuk", wa: "Walloon", cy: "Welsh", xh: "Xhosa", ji: "Yiddish", zu: "Zulu" }[t3] !== void 0 && (this.internal.languageSettings.languageCode = t3, this.internal.languageSettings.isSubscribed === false && (this.internal.events.subscribe("putCatalog", function() {
    this.internal.write("/Lang (" + this.internal.languageSettings.languageCode + ")");
  }), this.internal.languageSettings.isSubscribed = true)), this;
}, Vt = E$1.API, Gt = Vt.getCharWidthsArray = function(e2, r2) {
  var n2, i2, a2 = (r2 = r2 || {}).font || this.internal.getFont(), o2 = r2.fontSize || this.internal.getFontSize(), s2 = r2.charSpace || this.internal.getCharSpace(), c2 = r2.widths ? r2.widths : a2.metadata.Unicode.widths, u2 = c2.fof ? c2.fof : 1, h2 = r2.kerning ? r2.kerning : a2.metadata.Unicode.kerning, l2 = h2.fof ? h2.fof : 1, f2 = r2.doKerning !== false, d2 = 0, p5 = e2.length, g2 = 0, m2 = c2[0] || u2, v2 = [];
  for (n2 = 0; n2 < p5; n2++)
    i2 = e2.charCodeAt(n2), typeof a2.metadata.widthOfString == "function" ? v2.push((a2.metadata.widthOfGlyph(a2.metadata.characterToGlyph(i2)) + s2 * (1e3 / o2) || 0) / 1e3) : (d2 = f2 && _typeof$2(h2[i2]) === "object" && !isNaN(parseInt(h2[i2][g2], 10)) ? h2[i2][g2] / l2 : 0, v2.push((c2[i2] || m2) / u2 + d2)), g2 = i2;
  return v2;
}, Yt = Vt.getStringUnitWidth = function(t3, e2) {
  var r2 = (e2 = e2 || {}).fontSize || this.internal.getFontSize(), n2 = e2.font || this.internal.getFont(), i2 = e2.charSpace || this.internal.getCharSpace();
  return Vt.processArabic && (t3 = Vt.processArabic(t3)), typeof n2.metadata.widthOfString == "function" ? n2.metadata.widthOfString(t3, r2, i2) / r2 : Gt.apply(this, arguments).reduce(function(t4, e3) {
    return t4 + e3;
  }, 0);
}, Jt = function(t3, e2, r2, n2) {
  for (var i2 = [], a2 = 0, o2 = t3.length, s2 = 0; a2 !== o2 && s2 + e2[a2] < r2; )
    s2 += e2[a2], a2++;
  i2.push(t3.slice(0, a2));
  var c2 = a2;
  for (s2 = 0; a2 !== o2; )
    s2 + e2[a2] > n2 && (i2.push(t3.slice(c2, a2)), s2 = 0, c2 = a2), s2 += e2[a2], a2++;
  return c2 !== a2 && i2.push(t3.slice(c2, a2)), i2;
}, Xt = function(t3, e2, r2) {
  r2 || (r2 = {});
  var n2, i2, a2, o2, s2, c2, u2, h2 = [], l2 = [h2], f2 = r2.textIndent || 0, d2 = 0, p5 = 0, g2 = t3.split(" "), m2 = Gt.apply(this, [" ", r2])[0];
  if (c2 = r2.lineIndent === -1 ? g2[0].length + 2 : r2.lineIndent || 0) {
    var v2 = Array(c2).join(" "), b2 = [];
    g2.map(function(t4) {
      (t4 = t4.split(/\s*\n/)).length > 1 ? b2 = b2.concat(t4.map(function(t5, e3) {
        return (e3 && t5.length ? "\n" : "") + t5;
      })) : b2.push(t4[0]);
    }), g2 = b2, c2 = Yt.apply(this, [v2, r2]);
  }
  for (a2 = 0, o2 = g2.length; a2 < o2; a2++) {
    var y2 = 0;
    if (n2 = g2[a2], c2 && n2[0] == "\n" && (n2 = n2.substr(1), y2 = 1), f2 + d2 + (p5 = (i2 = Gt.apply(this, [n2, r2])).reduce(function(t4, e3) {
      return t4 + e3;
    }, 0)) > e2 || y2) {
      if (p5 > e2) {
        for (s2 = Jt.apply(this, [n2, i2, e2 - (f2 + d2), e2]), h2.push(s2.shift()), h2 = [s2.pop()]; s2.length; )
          l2.push([s2.shift()]);
        p5 = i2.slice(n2.length - (h2[0] ? h2[0].length : 0)).reduce(function(t4, e3) {
          return t4 + e3;
        }, 0);
      } else
        h2 = [n2];
      l2.push(h2), f2 = p5 + c2, d2 = m2;
    } else
      h2.push(n2), f2 += d2 + p5, d2 = m2;
  }
  return u2 = c2 ? function(t4, e3) {
    return (e3 ? v2 : "") + t4.join(" ");
  } : function(t4) {
    return t4.join(" ");
  }, l2.map(u2);
}, Vt.splitTextToSize = function(t3, e2, r2) {
  var n2, i2 = (r2 = r2 || {}).fontSize || this.internal.getFontSize(), a2 = function(t4) {
    if (t4.widths && t4.kerning)
      return { widths: t4.widths, kerning: t4.kerning };
    var e3 = this.internal.getFont(t4.fontName, t4.fontStyle);
    return e3.metadata.Unicode ? { widths: e3.metadata.Unicode.widths || { 0: 1 }, kerning: e3.metadata.Unicode.kerning || {} } : { font: e3.metadata, fontSize: this.internal.getFontSize(), charSpace: this.internal.getCharSpace() };
  }.call(this, r2);
  n2 = Array.isArray(t3) ? t3 : String(t3).split(/\r?\n/);
  var o2 = 1 * this.internal.scaleFactor * e2 / i2;
  a2.textIndent = r2.textIndent ? 1 * r2.textIndent * this.internal.scaleFactor / i2 : 0, a2.lineIndent = r2.lineIndent;
  var s2, c2, u2 = [];
  for (s2 = 0, c2 = n2.length; s2 < c2; s2++)
    u2 = u2.concat(Xt.apply(this, [n2[s2], o2, a2]));
  return u2;
}, function(e2) {
  e2.__fontmetrics__ = e2.__fontmetrics__ || {};
  for (var r2 = "klmnopqrstuvwxyz", n2 = {}, i2 = {}, a2 = 0; a2 < r2.length; a2++)
    n2[r2[a2]] = "0123456789abcdef"[a2], i2["0123456789abcdef"[a2]] = r2[a2];
  var o2 = function(t3) {
    return "0x" + parseInt(t3, 10).toString(16);
  }, s2 = e2.__fontmetrics__.compress = function(e3) {
    var r3, n3, a3, c3, u3 = ["{"];
    for (var h3 in e3) {
      if (r3 = e3[h3], isNaN(parseInt(h3, 10)) ? n3 = "'" + h3 + "'" : (h3 = parseInt(h3, 10), n3 = (n3 = o2(h3).slice(2)).slice(0, -1) + i2[n3.slice(-1)]), typeof r3 == "number")
        r3 < 0 ? (a3 = o2(r3).slice(3), c3 = "-") : (a3 = o2(r3).slice(2), c3 = ""), a3 = c3 + a3.slice(0, -1) + i2[a3.slice(-1)];
      else {
        if (_typeof$2(r3) !== "object")
          throw new Error("Don't know what to do with value type " + _typeof$2(r3) + ".");
        a3 = s2(r3);
      }
      u3.push(n3 + a3);
    }
    return u3.push("}"), u3.join("");
  }, c2 = e2.__fontmetrics__.uncompress = function(t3) {
    if (typeof t3 != "string")
      throw new Error("Invalid argument passed to uncompress.");
    for (var e3, r3, i3, a3, o3 = {}, s3 = 1, c3 = o3, u3 = [], h3 = "", l3 = "", f2 = t3.length - 1, d2 = 1; d2 < f2; d2 += 1)
      (a3 = t3[d2]) == "'" ? e3 ? (i3 = e3.join(""), e3 = void 0) : e3 = [] : e3 ? e3.push(a3) : a3 == "{" ? (u3.push([c3, i3]), c3 = {}, i3 = void 0) : a3 == "}" ? ((r3 = u3.pop())[0][r3[1]] = c3, i3 = void 0, c3 = r3[0]) : a3 == "-" ? s3 = -1 : i3 === void 0 ? n2.hasOwnProperty(a3) ? (h3 += n2[a3], i3 = parseInt(h3, 16) * s3, s3 = 1, h3 = "") : h3 += a3 : n2.hasOwnProperty(a3) ? (l3 += n2[a3], c3[i3] = parseInt(l3, 16) * s3, s3 = 1, i3 = void 0, l3 = "") : l3 += a3;
    return o3;
  }, u2 = { codePages: ["WinAnsiEncoding"], WinAnsiEncoding: c2("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}") }, h2 = { Unicode: { Courier: u2, "Courier-Bold": u2, "Courier-BoldOblique": u2, "Courier-Oblique": u2, Helvetica: u2, "Helvetica-Bold": u2, "Helvetica-BoldOblique": u2, "Helvetica-Oblique": u2, "Times-Roman": u2, "Times-Bold": u2, "Times-BoldItalic": u2, "Times-Italic": u2 } }, l2 = { Unicode: { "Courier-Oblique": c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-BoldItalic": c2("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"), "Helvetica-Bold": c2("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), Courier: c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-BoldOblique": c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Bold": c2("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"), Symbol: c2("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"), Helvetica: c2("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"), "Helvetica-BoldOblique": c2("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), ZapfDingbats: c2("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-Bold": c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Italic": c2("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"), "Times-Roman": c2("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"), "Helvetica-Oblique": c2("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}") } };
  e2.events.push(["addFont", function(t3) {
    var e3 = t3.font, r3 = l2.Unicode[e3.postScriptName];
    r3 && (e3.metadata.Unicode = {}, e3.metadata.Unicode.widths = r3.widths, e3.metadata.Unicode.kerning = r3.kerning);
    var n3 = h2.Unicode[e3.postScriptName];
    n3 && (e3.metadata.Unicode.encoding = n3, e3.encoding = n3.codePages[0]);
  }]);
}(E$1.API), function(t3) {
  var e2 = function(t4) {
    for (var e3 = t4.length, r2 = new Uint8Array(e3), n2 = 0; n2 < e3; n2++)
      r2[n2] = t4.charCodeAt(n2);
    return r2;
  };
  t3.API.events.push(["addFont", function(r2) {
    var n2 = void 0, i2 = r2.font, a2 = r2.instance;
    if (!i2.isStandardFont) {
      if (a2 === void 0)
        throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('" + i2.postScriptName + "').");
      if (typeof (n2 = a2.existsFileInVFS(i2.postScriptName) === false ? a2.loadFile(i2.postScriptName) : a2.getFileFromVFS(i2.postScriptName)) != "string")
        throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('" + i2.postScriptName + "').");
      !function(r3, n3) {
        n3 = /^\x00\x01\x00\x00/.test(n3) ? e2(n3) : e2(u$2(n3)), r3.metadata = t3.API.TTFFont.open(n3), r3.metadata.Unicode = r3.metadata.Unicode || { encoding: {}, kerning: {}, widths: [] }, r3.metadata.glyIdsUsed = [0];
      }(i2, n2);
    }
  }]);
}(E$1), function(t3) {
  function e2() {
    return (n$1.canvg ? Promise.resolve(n$1.canvg) : Promise.resolve().then(function() {
      return index_es;
    })).catch(function(t4) {
      return Promise.reject(new Error("Could not load canvg: " + t4));
    }).then(function(t4) {
      return t4.default ? t4.default : t4;
    });
  }
  E$1.API.addSvgAsImage = function(t4, r2, n2, i2, o2, s2, c2, u2) {
    if (isNaN(r2) || isNaN(n2))
      throw a$2.error("jsPDF.addSvgAsImage: Invalid coordinates", arguments), new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");
    if (isNaN(i2) || isNaN(o2))
      throw a$2.error("jsPDF.addSvgAsImage: Invalid measurements", arguments), new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");
    var h2 = document.createElement("canvas");
    h2.width = i2, h2.height = o2;
    var l2 = h2.getContext("2d");
    l2.fillStyle = "#fff", l2.fillRect(0, 0, h2.width, h2.height);
    var f2 = { ignoreMouse: true, ignoreAnimation: true, ignoreDimensions: true }, d2 = this;
    return e2().then(function(e3) {
      return e3.fromString(l2, t4, f2);
    }, function() {
      return Promise.reject(new Error("Could not load canvg."));
    }).then(function(t5) {
      return t5.render(f2);
    }).then(function() {
      d2.addImage(h2.toDataURL("image/jpeg", 1), r2, n2, i2, o2, c2, u2);
    });
  };
}(), E$1.API.putTotalPages = function(t3) {
  var e2, r2 = 0;
  parseInt(this.internal.getFont().id.substr(1), 10) < 15 ? (e2 = new RegExp(t3, "g"), r2 = this.internal.getNumberOfPages()) : (e2 = new RegExp(this.pdfEscape16(t3, this.internal.getFont()), "g"), r2 = this.pdfEscape16(this.internal.getNumberOfPages() + "", this.internal.getFont()));
  for (var n2 = 1; n2 <= this.internal.getNumberOfPages(); n2++)
    for (var i2 = 0; i2 < this.internal.pages[n2].length; i2++)
      this.internal.pages[n2][i2] = this.internal.pages[n2][i2].replace(e2, r2);
  return this;
}, E$1.API.viewerPreferences = function(e2, r2) {
  var n2;
  e2 = e2 || {}, r2 = r2 || false;
  var i2, a2, o2, s2 = { HideToolbar: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, HideMenubar: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, HideWindowUI: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, FitWindow: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, CenterWindow: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, DisplayDocTitle: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.4 }, NonFullScreenPageMode: { defaultValue: "UseNone", value: "UseNone", type: "name", explicitSet: false, valueSet: ["UseNone", "UseOutlines", "UseThumbs", "UseOC"], pdfVersion: 1.3 }, Direction: { defaultValue: "L2R", value: "L2R", type: "name", explicitSet: false, valueSet: ["L2R", "R2L"], pdfVersion: 1.3 }, ViewArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, ViewClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintScaling: { defaultValue: "AppDefault", value: "AppDefault", type: "name", explicitSet: false, valueSet: ["AppDefault", "None"], pdfVersion: 1.6 }, Duplex: { defaultValue: "", value: "none", type: "name", explicitSet: false, valueSet: ["Simplex", "DuplexFlipShortEdge", "DuplexFlipLongEdge", "none"], pdfVersion: 1.7 }, PickTrayByPDFSize: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.7 }, PrintPageRange: { defaultValue: "", value: "", type: "array", explicitSet: false, valueSet: null, pdfVersion: 1.7 }, NumCopies: { defaultValue: 1, value: 1, type: "integer", explicitSet: false, valueSet: null, pdfVersion: 1.7 } }, c2 = Object.keys(s2), u2 = [], h2 = 0, l2 = 0, f2 = 0;
  function d2(t3, e3) {
    var r3, n3 = false;
    for (r3 = 0; r3 < t3.length; r3 += 1)
      t3[r3] === e3 && (n3 = true);
    return n3;
  }
  if (this.internal.viewerpreferences === void 0 && (this.internal.viewerpreferences = {}, this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(s2)), this.internal.viewerpreferences.isSubscribed = false), n2 = this.internal.viewerpreferences.configuration, e2 === "reset" || r2 === true) {
    var p5 = c2.length;
    for (f2 = 0; f2 < p5; f2 += 1)
      n2[c2[f2]].value = n2[c2[f2]].defaultValue, n2[c2[f2]].explicitSet = false;
  }
  if (_typeof$2(e2) === "object") {
    for (a2 in e2)
      if (o2 = e2[a2], d2(c2, a2) && o2 !== void 0) {
        if (n2[a2].type === "boolean" && typeof o2 == "boolean")
          n2[a2].value = o2;
        else if (n2[a2].type === "name" && d2(n2[a2].valueSet, o2))
          n2[a2].value = o2;
        else if (n2[a2].type === "integer" && Number.isInteger(o2))
          n2[a2].value = o2;
        else if (n2[a2].type === "array") {
          for (h2 = 0; h2 < o2.length; h2 += 1)
            if (i2 = true, o2[h2].length === 1 && typeof o2[h2][0] == "number")
              u2.push(String(o2[h2] - 1));
            else if (o2[h2].length > 1) {
              for (l2 = 0; l2 < o2[h2].length; l2 += 1)
                typeof o2[h2][l2] != "number" && (i2 = false);
              i2 === true && u2.push([o2[h2][0] - 1, o2[h2][1] - 1].join(" "));
            }
          n2[a2].value = "[" + u2.join(" ") + "]";
        } else
          n2[a2].value = n2[a2].defaultValue;
        n2[a2].explicitSet = true;
      }
  }
  return this.internal.viewerpreferences.isSubscribed === false && (this.internal.events.subscribe("putCatalog", function() {
    var t3, e3 = [];
    for (t3 in n2)
      n2[t3].explicitSet === true && (n2[t3].type === "name" ? e3.push("/" + t3 + " /" + n2[t3].value) : e3.push("/" + t3 + " " + n2[t3].value));
    e3.length !== 0 && this.internal.write("/ViewerPreferences\n<<\n" + e3.join("\n") + "\n>>");
  }), this.internal.viewerpreferences.isSubscribed = true), this.internal.viewerpreferences.configuration = n2, this;
}, function(t3) {
  var e2 = function() {
    var t4 = '<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="' + this.internal.__metadata__.namespaceuri + '"><jspdf:metadata>', e3 = unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')), r3 = unescape(encodeURIComponent(t4)), n2 = unescape(encodeURIComponent(this.internal.__metadata__.metadata)), i2 = unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")), a2 = unescape(encodeURIComponent("</x:xmpmeta>")), o2 = r3.length + n2.length + i2.length + e3.length + a2.length;
    this.internal.__metadata__.metadata_object_number = this.internal.newObject(), this.internal.write("<< /Type /Metadata /Subtype /XML /Length " + o2 + " >>"), this.internal.write("stream"), this.internal.write(e3 + r3 + n2 + i2 + a2), this.internal.write("endstream"), this.internal.write("endobj");
  }, r2 = function() {
    this.internal.__metadata__.metadata_object_number && this.internal.write("/Metadata " + this.internal.__metadata__.metadata_object_number + " 0 R");
  };
  t3.addMetadata = function(t4, n2) {
    return this.internal.__metadata__ === void 0 && (this.internal.__metadata__ = { metadata: t4, namespaceuri: n2 || "http://jspdf.default.namespaceuri/" }, this.internal.events.subscribe("putCatalog", r2), this.internal.events.subscribe("postPutResources", e2)), this;
  };
}(E$1.API), function(t3) {
  var e2 = t3.API, r2 = e2.pdfEscape16 = function(t4, e3) {
    for (var r3, n3 = e3.metadata.Unicode.widths, i3 = ["", "0", "00", "000", "0000"], a2 = [""], o2 = 0, s2 = t4.length; o2 < s2; ++o2) {
      if (r3 = e3.metadata.characterToGlyph(t4.charCodeAt(o2)), e3.metadata.glyIdsUsed.push(r3), e3.metadata.toUnicode[r3] = t4.charCodeAt(o2), n3.indexOf(r3) == -1 && (n3.push(r3), n3.push([parseInt(e3.metadata.widthOfGlyph(r3), 10)])), r3 == "0")
        return a2.join("");
      r3 = r3.toString(16), a2.push(i3[4 - r3.length], r3);
    }
    return a2.join("");
  }, n2 = function(t4) {
    var e3, r3, n3, i3, a2, o2, s2;
    for (a2 = "/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000><ffff>\nendcodespacerange", n3 = [], o2 = 0, s2 = (r3 = Object.keys(t4).sort(function(t5, e4) {
      return t5 - e4;
    })).length; o2 < s2; o2++)
      e3 = r3[o2], n3.length >= 100 && (a2 += "\n" + n3.length + " beginbfchar\n" + n3.join("\n") + "\nendbfchar", n3 = []), t4[e3] !== void 0 && t4[e3] !== null && typeof t4[e3].toString == "function" && (i3 = ("0000" + t4[e3].toString(16)).slice(-4), e3 = ("0000" + (+e3).toString(16)).slice(-4), n3.push("<" + e3 + "><" + i3 + ">"));
    return n3.length && (a2 += "\n" + n3.length + " beginbfchar\n" + n3.join("\n") + "\nendbfchar\n"), a2 += "endcmap\nCMapName currentdict /CMap defineresource pop\nend\nend";
  };
  e2.events.push(["putFont", function(e3) {
    !function(e4) {
      var r3 = e4.font, i3 = e4.out, a2 = e4.newObject, o2 = e4.putStream;
      if (r3.metadata instanceof t3.API.TTFFont && r3.encoding === "Identity-H") {
        for (var s2 = r3.metadata.Unicode.widths, c2 = r3.metadata.subset.encode(r3.metadata.glyIdsUsed, 1), u2 = "", h2 = 0; h2 < c2.length; h2++)
          u2 += String.fromCharCode(c2[h2]);
        var l2 = a2();
        o2({ data: u2, addLength1: true, objectId: l2 }), i3("endobj");
        var f2 = a2();
        o2({ data: n2(r3.metadata.toUnicode), addLength1: true, objectId: f2 }), i3("endobj");
        var d2 = a2();
        i3("<<"), i3("/Type /FontDescriptor"), i3("/FontName /" + F$1(r3.fontName)), i3("/FontFile2 " + l2 + " 0 R"), i3("/FontBBox " + t3.API.PDFObject.convert(r3.metadata.bbox)), i3("/Flags " + r3.metadata.flags), i3("/StemV " + r3.metadata.stemV), i3("/ItalicAngle " + r3.metadata.italicAngle), i3("/Ascent " + r3.metadata.ascender), i3("/Descent " + r3.metadata.decender), i3("/CapHeight " + r3.metadata.capHeight), i3(">>"), i3("endobj");
        var p5 = a2();
        i3("<<"), i3("/Type /Font"), i3("/BaseFont /" + F$1(r3.fontName)), i3("/FontDescriptor " + d2 + " 0 R"), i3("/W " + t3.API.PDFObject.convert(s2)), i3("/CIDToGIDMap /Identity"), i3("/DW 1000"), i3("/Subtype /CIDFontType2"), i3("/CIDSystemInfo"), i3("<<"), i3("/Supplement 0"), i3("/Registry (Adobe)"), i3("/Ordering (" + r3.encoding + ")"), i3(">>"), i3(">>"), i3("endobj"), r3.objectNumber = a2(), i3("<<"), i3("/Type /Font"), i3("/Subtype /Type0"), i3("/ToUnicode " + f2 + " 0 R"), i3("/BaseFont /" + F$1(r3.fontName)), i3("/Encoding /" + r3.encoding), i3("/DescendantFonts [" + p5 + " 0 R]"), i3(">>"), i3("endobj"), r3.isAlreadyPutted = true;
      }
    }(e3);
  }]);
  e2.events.push(["putFont", function(e3) {
    !function(e4) {
      var r3 = e4.font, i3 = e4.out, a2 = e4.newObject, o2 = e4.putStream;
      if (r3.metadata instanceof t3.API.TTFFont && r3.encoding === "WinAnsiEncoding") {
        for (var s2 = r3.metadata.rawData, c2 = "", u2 = 0; u2 < s2.length; u2++)
          c2 += String.fromCharCode(s2[u2]);
        var h2 = a2();
        o2({ data: c2, addLength1: true, objectId: h2 }), i3("endobj");
        var l2 = a2();
        o2({ data: n2(r3.metadata.toUnicode), addLength1: true, objectId: l2 }), i3("endobj");
        var f2 = a2();
        i3("<<"), i3("/Descent " + r3.metadata.decender), i3("/CapHeight " + r3.metadata.capHeight), i3("/StemV " + r3.metadata.stemV), i3("/Type /FontDescriptor"), i3("/FontFile2 " + h2 + " 0 R"), i3("/Flags 96"), i3("/FontBBox " + t3.API.PDFObject.convert(r3.metadata.bbox)), i3("/FontName /" + F$1(r3.fontName)), i3("/ItalicAngle " + r3.metadata.italicAngle), i3("/Ascent " + r3.metadata.ascender), i3(">>"), i3("endobj"), r3.objectNumber = a2();
        for (var d2 = 0; d2 < r3.metadata.hmtx.widths.length; d2++)
          r3.metadata.hmtx.widths[d2] = parseInt(r3.metadata.hmtx.widths[d2] * (1e3 / r3.metadata.head.unitsPerEm));
        i3("<</Subtype/TrueType/Type/Font/ToUnicode " + l2 + " 0 R/BaseFont/" + F$1(r3.fontName) + "/FontDescriptor " + f2 + " 0 R/Encoding/" + r3.encoding + " /FirstChar 29 /LastChar 255 /Widths " + t3.API.PDFObject.convert(r3.metadata.hmtx.widths) + ">>"), i3("endobj"), r3.isAlreadyPutted = true;
      }
    }(e3);
  }]);
  var i2 = function(t4) {
    var e3, n3 = t4.text || "", i3 = t4.x, a2 = t4.y, o2 = t4.options || {}, s2 = t4.mutex || {}, c2 = s2.pdfEscape, u2 = s2.activeFontKey, h2 = s2.fonts, l2 = u2, f2 = "", d2 = 0, p5 = "", g2 = h2[l2].encoding;
    if (h2[l2].encoding !== "Identity-H")
      return { text: n3, x: i3, y: a2, options: o2, mutex: s2 };
    for (p5 = n3, l2 = u2, Array.isArray(n3) && (p5 = n3[0]), d2 = 0; d2 < p5.length; d2 += 1)
      h2[l2].metadata.hasOwnProperty("cmap") && (e3 = h2[l2].metadata.cmap.unicode.codeMap[p5[d2].charCodeAt(0)]), e3 || p5[d2].charCodeAt(0) < 256 && h2[l2].metadata.hasOwnProperty("Unicode") ? f2 += p5[d2] : f2 += "";
    var m2 = "";
    return parseInt(l2.slice(1)) < 14 || g2 === "WinAnsiEncoding" ? m2 = c2(f2, l2).split("").map(function(t5) {
      return t5.charCodeAt(0).toString(16);
    }).join("") : g2 === "Identity-H" && (m2 = r2(f2, h2[l2])), s2.isHex = true, { text: m2, x: i3, y: a2, options: o2, mutex: s2 };
  };
  e2.events.push(["postProcessText", function(t4) {
    var e3 = t4.text || "", r3 = [], n3 = { text: e3, x: t4.x, y: t4.y, options: t4.options, mutex: t4.mutex };
    if (Array.isArray(e3)) {
      var a2 = 0;
      for (a2 = 0; a2 < e3.length; a2 += 1)
        Array.isArray(e3[a2]) && e3[a2].length === 3 ? r3.push([i2(Object.assign({}, n3, { text: e3[a2][0] })).text, e3[a2][1], e3[a2][2]]) : r3.push(i2(Object.assign({}, n3, { text: e3[a2] })).text);
      t4.text = r3;
    } else
      t4.text = i2(Object.assign({}, n3, { text: e3 })).text;
  }]);
}(E$1), function(t3) {
  var e2 = function() {
    return this.internal.vFS === void 0 && (this.internal.vFS = {}), true;
  };
  t3.existsFileInVFS = function(t4) {
    return e2.call(this), this.internal.vFS[t4] !== void 0;
  }, t3.addFileToVFS = function(t4, r2) {
    return e2.call(this), this.internal.vFS[t4] = r2, this;
  }, t3.getFileFromVFS = function(t4) {
    return e2.call(this), this.internal.vFS[t4] !== void 0 ? this.internal.vFS[t4] : null;
  };
}(E$1.API), function(t3) {
  t3.__bidiEngine__ = t3.prototype.__bidiEngine__ = function(t4) {
    var r3, n2, i2, a2, o2, s2, c2, u2 = e2, h2 = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 17, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 21, 21, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]], l2 = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 33, 3, 1, 1]], f2 = { L: 0, R: 1, EN: 2, AN: 3, N: 4, B: 5, S: 6 }, d2 = { 0: 0, 5: 1, 6: 2, 7: 3, 32: 4, 251: 5, 254: 6, 255: 7 }, p5 = ["(", ")", "(", "<", ">", "<", "[", "]", "[", "{", "}", "{", "\xAB", "\xBB", "\xAB", "\u2039", "\u203A", "\u2039", "\u2045", "\u2046", "\u2045", "\u207D", "\u207E", "\u207D", "\u208D", "\u208E", "\u208D", "\u2264", "\u2265", "\u2264", "\u2329", "\u232A", "\u2329", "\uFE59", "\uFE5A", "\uFE59", "\uFE5B", "\uFE5C", "\uFE5B", "\uFE5D", "\uFE5E", "\uFE5D", "\uFE64", "\uFE65", "\uFE64"], g2 = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/), m2 = false, v2 = 0;
    this.__bidiEngine__ = {};
    var b2 = function(t5) {
      var e3 = t5.charCodeAt(), r4 = e3 >> 8, n3 = d2[r4];
      return n3 !== void 0 ? u2[256 * n3 + (255 & e3)] : r4 === 252 || r4 === 253 ? "AL" : g2.test(r4) ? "L" : r4 === 8 ? "R" : "N";
    }, y2 = function(t5) {
      for (var e3, r4 = 0; r4 < t5.length; r4++) {
        if ((e3 = b2(t5.charAt(r4))) === "L")
          return false;
        if (e3 === "R")
          return true;
      }
      return false;
    }, w2 = function(t5, e3, o3, s3) {
      var c3, u3, h3, l3, f3 = e3[s3];
      switch (f3) {
        case "L":
        case "R":
          m2 = false;
          break;
        case "N":
        case "AN":
          break;
        case "EN":
          m2 && (f3 = "AN");
          break;
        case "AL":
          m2 = true, f3 = "R";
          break;
        case "WS":
          f3 = "N";
          break;
        case "CS":
          s3 < 1 || s3 + 1 >= e3.length || (c3 = o3[s3 - 1]) !== "EN" && c3 !== "AN" || (u3 = e3[s3 + 1]) !== "EN" && u3 !== "AN" ? f3 = "N" : m2 && (u3 = "AN"), f3 = u3 === c3 ? u3 : "N";
          break;
        case "ES":
          f3 = (c3 = s3 > 0 ? o3[s3 - 1] : "B") === "EN" && s3 + 1 < e3.length && e3[s3 + 1] === "EN" ? "EN" : "N";
          break;
        case "ET":
          if (s3 > 0 && o3[s3 - 1] === "EN") {
            f3 = "EN";
            break;
          }
          if (m2) {
            f3 = "N";
            break;
          }
          for (h3 = s3 + 1, l3 = e3.length; h3 < l3 && e3[h3] === "ET"; )
            h3++;
          f3 = h3 < l3 && e3[h3] === "EN" ? "EN" : "N";
          break;
        case "NSM":
          if (i2 && !a2) {
            for (l3 = e3.length, h3 = s3 + 1; h3 < l3 && e3[h3] === "NSM"; )
              h3++;
            if (h3 < l3) {
              var d3 = t5[s3], p6 = d3 >= 1425 && d3 <= 2303 || d3 === 64286;
              if (c3 = e3[h3], p6 && (c3 === "R" || c3 === "AL")) {
                f3 = "R";
                break;
              }
            }
          }
          f3 = s3 < 1 || (c3 = e3[s3 - 1]) === "B" ? "N" : o3[s3 - 1];
          break;
        case "B":
          m2 = false, r3 = true, f3 = v2;
          break;
        case "S":
          n2 = true, f3 = "N";
          break;
        case "LRE":
        case "RLE":
        case "LRO":
        case "RLO":
        case "PDF":
          m2 = false;
          break;
        case "BN":
          f3 = "N";
      }
      return f3;
    }, N2 = function(t5, e3, r4) {
      var n3 = t5.split("");
      return r4 && L2(n3, r4, { hiLevel: v2 }), n3.reverse(), e3 && e3.reverse(), n3.join("");
    }, L2 = function(t5, e3, i3) {
      var a3, o3, s3, c3, u3, d3 = -1, p6 = t5.length, g3 = 0, y3 = [], N3 = v2 ? l2 : h2, L3 = [];
      for (m2 = false, r3 = false, n2 = false, o3 = 0; o3 < p6; o3++)
        L3[o3] = b2(t5[o3]);
      for (s3 = 0; s3 < p6; s3++) {
        if (u3 = g3, y3[s3] = w2(t5, L3, y3, s3), a3 = 240 & (g3 = N3[u3][f2[y3[s3]]]), g3 &= 15, e3[s3] = c3 = N3[g3][5], a3 > 0)
          if (a3 === 16) {
            for (o3 = d3; o3 < s3; o3++)
              e3[o3] = 1;
            d3 = -1;
          } else
            d3 = -1;
        if (N3[g3][6])
          d3 === -1 && (d3 = s3);
        else if (d3 > -1) {
          for (o3 = d3; o3 < s3; o3++)
            e3[o3] = c3;
          d3 = -1;
        }
        L3[s3] === "B" && (e3[s3] = 0), i3.hiLevel |= c3;
      }
      n2 && function(t6, e4, r4) {
        for (var n3 = 0; n3 < r4; n3++)
          if (t6[n3] === "S") {
            e4[n3] = v2;
            for (var i4 = n3 - 1; i4 >= 0 && t6[i4] === "WS"; i4--)
              e4[i4] = v2;
          }
      }(L3, e3, p6);
    }, A2 = function(t5, e3, n3, i3, a3) {
      if (!(a3.hiLevel < t5)) {
        if (t5 === 1 && v2 === 1 && !r3)
          return e3.reverse(), void (n3 && n3.reverse());
        for (var o3, s3, c3, u3, h3 = e3.length, l3 = 0; l3 < h3; ) {
          if (i3[l3] >= t5) {
            for (c3 = l3 + 1; c3 < h3 && i3[c3] >= t5; )
              c3++;
            for (u3 = l3, s3 = c3 - 1; u3 < s3; u3++, s3--)
              o3 = e3[u3], e3[u3] = e3[s3], e3[s3] = o3, n3 && (o3 = n3[u3], n3[u3] = n3[s3], n3[s3] = o3);
            l3 = c3;
          }
          l3++;
        }
      }
    }, x2 = function(t5, e3, r4) {
      var n3 = t5.split(""), i3 = { hiLevel: v2 };
      return r4 || (r4 = []), L2(n3, r4, i3), function(t6, e4, r5) {
        if (r5.hiLevel !== 0 && c2)
          for (var n4, i4 = 0; i4 < t6.length; i4++)
            e4[i4] === 1 && (n4 = p5.indexOf(t6[i4])) >= 0 && (t6[i4] = p5[n4 + 1]);
      }(n3, r4, i3), A2(2, n3, e3, r4, i3), A2(1, n3, e3, r4, i3), n3.join("");
    };
    return this.__bidiEngine__.doBidiReorder = function(t5, e3, r4) {
      if (function(t6, e4) {
        if (e4)
          for (var r5 = 0; r5 < t6.length; r5++)
            e4[r5] = r5;
        a2 === void 0 && (a2 = y2(t6)), s2 === void 0 && (s2 = y2(t6));
      }(t5, e3), i2 || !o2 || s2)
        if (i2 && o2 && a2 ^ s2)
          v2 = a2 ? 1 : 0, t5 = N2(t5, e3, r4);
        else if (!i2 && o2 && s2)
          v2 = a2 ? 1 : 0, t5 = x2(t5, e3, r4), t5 = N2(t5, e3);
        else if (!i2 || a2 || o2 || s2) {
          if (i2 && !o2 && a2 ^ s2)
            t5 = N2(t5, e3), a2 ? (v2 = 0, t5 = x2(t5, e3, r4)) : (v2 = 1, t5 = x2(t5, e3, r4), t5 = N2(t5, e3));
          else if (i2 && a2 && !o2 && s2)
            v2 = 1, t5 = x2(t5, e3, r4), t5 = N2(t5, e3);
          else if (!i2 && !o2 && a2 ^ s2) {
            var n3 = c2;
            a2 ? (v2 = 1, t5 = x2(t5, e3, r4), v2 = 0, c2 = false, t5 = x2(t5, e3, r4), c2 = n3) : (v2 = 0, t5 = x2(t5, e3, r4), t5 = N2(t5, e3), v2 = 1, c2 = false, t5 = x2(t5, e3, r4), c2 = n3, t5 = N2(t5, e3));
          }
        } else
          v2 = 0, t5 = x2(t5, e3, r4);
      else
        v2 = a2 ? 1 : 0, t5 = x2(t5, e3, r4);
      return t5;
    }, this.__bidiEngine__.setOptions = function(t5) {
      t5 && (i2 = t5.isInputVisual, o2 = t5.isOutputVisual, a2 = t5.isInputRtl, s2 = t5.isOutputRtl, c2 = t5.isSymmetricSwapping);
    }, this.__bidiEngine__.setOptions(t4), this.__bidiEngine__;
  };
  var e2 = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "N", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "L", "N", "N", "BN", "N", "N", "ET", "ET", "EN", "EN", "N", "L", "N", "N", "N", "EN", "L", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "N", "N", "N", "N", "N", "ET", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "NSM", "R", "NSM", "NSM", "R", "NSM", "NSM", "R", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AN", "AN", "AN", "AN", "AN", "AN", "N", "N", "AL", "ET", "ET", "AL", "CS", "AL", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "N", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "R", "N", "N", "N", "N", "R", "N", "N", "N", "N", "N", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "BN", "BN", "BN", "L", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "B", "LRE", "RLE", "PDF", "LRO", "RLO", "CS", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "BN", "BN", "BN", "BN", "BN", "N", "LRI", "RLI", "FSI", "PDI", "BN", "BN", "BN", "BN", "BN", "BN", "EN", "L", "N", "N", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "L", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "R", "NSM", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "ES", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "R", "R", "R", "R", "R", "N", "R", "N", "R", "R", "N", "R", "R", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "CS", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "ET", "N", "N", "ES", "ES", "N", "N", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "BN", "N", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "N", "N", "N", "ET", "ET", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N"], r2 = new t3.__bidiEngine__({ isInputVisual: true });
  t3.API.events.push(["postProcessText", function(t4) {
    var e3 = t4.text, n2 = (t4.x, t4.y, t4.options || {}), i2 = (t4.mutex, n2.lang, []);
    if (n2.isInputVisual = typeof n2.isInputVisual != "boolean" || n2.isInputVisual, r2.setOptions(n2), Object.prototype.toString.call(e3) === "[object Array]") {
      var a2 = 0;
      for (i2 = [], a2 = 0; a2 < e3.length; a2 += 1)
        Object.prototype.toString.call(e3[a2]) === "[object Array]" ? i2.push([r2.doBidiReorder(e3[a2][0]), e3[a2][1], e3[a2][2]]) : i2.push([r2.doBidiReorder(e3[a2])]);
      t4.text = i2;
    } else
      t4.text = r2.doBidiReorder(e3);
    r2.setOptions({ isInputVisual: true });
  }]);
}(E$1), E$1.API.TTFFont = function() {
  function t3(t4) {
    var e2;
    if (this.rawData = t4, e2 = this.contents = new ne(t4), this.contents.pos = 4, e2.readString(4) === "ttcf")
      throw new Error("TTCF not supported.");
    e2.pos = 0, this.parse(), this.subset = new Le(this), this.registerTTF();
  }
  return t3.open = function(e2) {
    return new t3(e2);
  }, t3.prototype.parse = function() {
    return this.directory = new ie(this.contents), this.head = new se(this), this.name = new pe(this), this.cmap = new ue(this), this.toUnicode = {}, this.hhea = new he(this), this.maxp = new ge(this), this.hmtx = new me(this), this.post = new fe(this), this.os2 = new le(this), this.loca = new Ne(this), this.glyf = new be(this), this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender, this.decender = this.os2.exists && this.os2.decender || this.hhea.decender, this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap, this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax];
  }, t3.prototype.registerTTF = function() {
    var t4, e2, r2, n2, i2;
    if (this.scaleFactor = 1e3 / this.head.unitsPerEm, this.bbox = function() {
      var e3, r3, n3, i3;
      for (i3 = [], e3 = 0, r3 = (n3 = this.bbox).length; e3 < r3; e3++)
        t4 = n3[e3], i3.push(Math.round(t4 * this.scaleFactor));
      return i3;
    }.call(this), this.stemV = 0, this.post.exists ? (r2 = 255 & (n2 = this.post.italic_angle), (32768 & (e2 = n2 >> 16)) != 0 && (e2 = -(1 + (65535 ^ e2))), this.italicAngle = +(e2 + "." + r2)) : this.italicAngle = 0, this.ascender = Math.round(this.ascender * this.scaleFactor), this.decender = Math.round(this.decender * this.scaleFactor), this.lineGap = Math.round(this.lineGap * this.scaleFactor), this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender, this.xHeight = this.os2.exists && this.os2.xHeight || 0, this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8, this.isSerif = (i2 = this.familyClass) === 1 || i2 === 2 || i2 === 3 || i2 === 4 || i2 === 5 || i2 === 7, this.isScript = this.familyClass === 10, this.flags = 0, this.post.isFixedPitch && (this.flags |= 1), this.isSerif && (this.flags |= 2), this.isScript && (this.flags |= 8), this.italicAngle !== 0 && (this.flags |= 64), this.flags |= 32, !this.cmap.unicode)
      throw new Error("No unicode cmap for font");
  }, t3.prototype.characterToGlyph = function(t4) {
    var e2;
    return ((e2 = this.cmap.unicode) != null ? e2.codeMap[t4] : void 0) || 0;
  }, t3.prototype.widthOfGlyph = function(t4) {
    var e2;
    return e2 = 1e3 / this.head.unitsPerEm, this.hmtx.forGlyph(t4).advance * e2;
  }, t3.prototype.widthOfString = function(t4, e2, r2) {
    var n2, i2, a2, o2;
    for (a2 = 0, i2 = 0, o2 = (t4 = "" + t4).length; 0 <= o2 ? i2 < o2 : i2 > o2; i2 = 0 <= o2 ? ++i2 : --i2)
      n2 = t4.charCodeAt(i2), a2 += this.widthOfGlyph(this.characterToGlyph(n2)) + r2 * (1e3 / e2) || 0;
    return a2 * (e2 / 1e3);
  }, t3.prototype.lineHeight = function(t4, e2) {
    var r2;
    return e2 == null && (e2 = false), r2 = e2 ? this.lineGap : 0, (this.ascender + r2 - this.decender) / 1e3 * t4;
  }, t3;
}();
var re, ne = function() {
  function t3(t4) {
    this.data = t4 != null ? t4 : [], this.pos = 0, this.length = this.data.length;
  }
  return t3.prototype.readByte = function() {
    return this.data[this.pos++];
  }, t3.prototype.writeByte = function(t4) {
    return this.data[this.pos++] = t4;
  }, t3.prototype.readUInt32 = function() {
    return 16777216 * this.readByte() + (this.readByte() << 16) + (this.readByte() << 8) + this.readByte();
  }, t3.prototype.writeUInt32 = function(t4) {
    return this.writeByte(t4 >>> 24 & 255), this.writeByte(t4 >> 16 & 255), this.writeByte(t4 >> 8 & 255), this.writeByte(255 & t4);
  }, t3.prototype.readInt32 = function() {
    var t4;
    return (t4 = this.readUInt32()) >= 2147483648 ? t4 - 4294967296 : t4;
  }, t3.prototype.writeInt32 = function(t4) {
    return t4 < 0 && (t4 += 4294967296), this.writeUInt32(t4);
  }, t3.prototype.readUInt16 = function() {
    return this.readByte() << 8 | this.readByte();
  }, t3.prototype.writeUInt16 = function(t4) {
    return this.writeByte(t4 >> 8 & 255), this.writeByte(255 & t4);
  }, t3.prototype.readInt16 = function() {
    var t4;
    return (t4 = this.readUInt16()) >= 32768 ? t4 - 65536 : t4;
  }, t3.prototype.writeInt16 = function(t4) {
    return t4 < 0 && (t4 += 65536), this.writeUInt16(t4);
  }, t3.prototype.readString = function(t4) {
    var e2, r2;
    for (r2 = [], e2 = 0; 0 <= t4 ? e2 < t4 : e2 > t4; e2 = 0 <= t4 ? ++e2 : --e2)
      r2[e2] = String.fromCharCode(this.readByte());
    return r2.join("");
  }, t3.prototype.writeString = function(t4) {
    var e2, r2, n2;
    for (n2 = [], e2 = 0, r2 = t4.length; 0 <= r2 ? e2 < r2 : e2 > r2; e2 = 0 <= r2 ? ++e2 : --e2)
      n2.push(this.writeByte(t4.charCodeAt(e2)));
    return n2;
  }, t3.prototype.readShort = function() {
    return this.readInt16();
  }, t3.prototype.writeShort = function(t4) {
    return this.writeInt16(t4);
  }, t3.prototype.readLongLong = function() {
    var t4, e2, r2, n2, i2, a2, o2, s2;
    return t4 = this.readByte(), e2 = this.readByte(), r2 = this.readByte(), n2 = this.readByte(), i2 = this.readByte(), a2 = this.readByte(), o2 = this.readByte(), s2 = this.readByte(), 128 & t4 ? -1 * (72057594037927940 * (255 ^ t4) + 281474976710656 * (255 ^ e2) + 1099511627776 * (255 ^ r2) + 4294967296 * (255 ^ n2) + 16777216 * (255 ^ i2) + 65536 * (255 ^ a2) + 256 * (255 ^ o2) + (255 ^ s2) + 1) : 72057594037927940 * t4 + 281474976710656 * e2 + 1099511627776 * r2 + 4294967296 * n2 + 16777216 * i2 + 65536 * a2 + 256 * o2 + s2;
  }, t3.prototype.writeLongLong = function(t4) {
    var e2, r2;
    return e2 = Math.floor(t4 / 4294967296), r2 = 4294967295 & t4, this.writeByte(e2 >> 24 & 255), this.writeByte(e2 >> 16 & 255), this.writeByte(e2 >> 8 & 255), this.writeByte(255 & e2), this.writeByte(r2 >> 24 & 255), this.writeByte(r2 >> 16 & 255), this.writeByte(r2 >> 8 & 255), this.writeByte(255 & r2);
  }, t3.prototype.readInt = function() {
    return this.readInt32();
  }, t3.prototype.writeInt = function(t4) {
    return this.writeInt32(t4);
  }, t3.prototype.read = function(t4) {
    var e2, r2;
    for (e2 = [], r2 = 0; 0 <= t4 ? r2 < t4 : r2 > t4; r2 = 0 <= t4 ? ++r2 : --r2)
      e2.push(this.readByte());
    return e2;
  }, t3.prototype.write = function(t4) {
    var e2, r2, n2, i2;
    for (i2 = [], r2 = 0, n2 = t4.length; r2 < n2; r2++)
      e2 = t4[r2], i2.push(this.writeByte(e2));
    return i2;
  }, t3;
}(), ie = function() {
  var t3;
  function e2(t4) {
    var e3, r2, n2;
    for (this.scalarType = t4.readInt(), this.tableCount = t4.readShort(), this.searchRange = t4.readShort(), this.entrySelector = t4.readShort(), this.rangeShift = t4.readShort(), this.tables = {}, r2 = 0, n2 = this.tableCount; 0 <= n2 ? r2 < n2 : r2 > n2; r2 = 0 <= n2 ? ++r2 : --r2)
      e3 = { tag: t4.readString(4), checksum: t4.readInt(), offset: t4.readInt(), length: t4.readInt() }, this.tables[e3.tag] = e3;
  }
  return e2.prototype.encode = function(e3) {
    var r2, n2, i2, a2, o2, s2, c2, u2, h2, l2, f2, d2, p5;
    for (p5 in f2 = Object.keys(e3).length, s2 = Math.log(2), h2 = 16 * Math.floor(Math.log(f2) / s2), a2 = Math.floor(h2 / s2), u2 = 16 * f2 - h2, (n2 = new ne()).writeInt(this.scalarType), n2.writeShort(f2), n2.writeShort(h2), n2.writeShort(a2), n2.writeShort(u2), i2 = 16 * f2, c2 = n2.pos + i2, o2 = null, d2 = [], e3)
      for (l2 = e3[p5], n2.writeString(p5), n2.writeInt(t3(l2)), n2.writeInt(c2), n2.writeInt(l2.length), d2 = d2.concat(l2), p5 === "head" && (o2 = c2), c2 += l2.length; c2 % 4; )
        d2.push(0), c2++;
    return n2.write(d2), r2 = 2981146554 - t3(n2.data), n2.pos = o2 + 8, n2.writeUInt32(r2), n2.data;
  }, t3 = function(t4) {
    var e3, r2, n2, i2;
    for (t4 = ve.call(t4); t4.length % 4; )
      t4.push(0);
    for (n2 = new ne(t4), r2 = 0, e3 = 0, i2 = t4.length; e3 < i2; e3 = e3 += 4)
      r2 += n2.readUInt32();
    return 4294967295 & r2;
  }, e2;
}(), ae = {}.hasOwnProperty, oe = function(t3, e2) {
  for (var r2 in e2)
    ae.call(e2, r2) && (t3[r2] = e2[r2]);
  function n2() {
    this.constructor = t3;
  }
  return n2.prototype = e2.prototype, t3.prototype = new n2(), t3.__super__ = e2.prototype, t3;
};
re = function() {
  function t3(t4) {
    var e2;
    this.file = t4, e2 = this.file.directory.tables[this.tag], this.exists = !!e2, e2 && (this.offset = e2.offset, this.length = e2.length, this.parse(this.file.contents));
  }
  return t3.prototype.parse = function() {
  }, t3.prototype.encode = function() {
  }, t3.prototype.raw = function() {
    return this.exists ? (this.file.contents.pos = this.offset, this.file.contents.read(this.length)) : null;
  }, t3;
}();
var se = function(t3) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "head", e2.prototype.parse = function(t4) {
    return t4.pos = this.offset, this.version = t4.readInt(), this.revision = t4.readInt(), this.checkSumAdjustment = t4.readInt(), this.magicNumber = t4.readInt(), this.flags = t4.readShort(), this.unitsPerEm = t4.readShort(), this.created = t4.readLongLong(), this.modified = t4.readLongLong(), this.xMin = t4.readShort(), this.yMin = t4.readShort(), this.xMax = t4.readShort(), this.yMax = t4.readShort(), this.macStyle = t4.readShort(), this.lowestRecPPEM = t4.readShort(), this.fontDirectionHint = t4.readShort(), this.indexToLocFormat = t4.readShort(), this.glyphDataFormat = t4.readShort();
  }, e2.prototype.encode = function(t4) {
    var e3;
    return (e3 = new ne()).writeInt(this.version), e3.writeInt(this.revision), e3.writeInt(this.checkSumAdjustment), e3.writeInt(this.magicNumber), e3.writeShort(this.flags), e3.writeShort(this.unitsPerEm), e3.writeLongLong(this.created), e3.writeLongLong(this.modified), e3.writeShort(this.xMin), e3.writeShort(this.yMin), e3.writeShort(this.xMax), e3.writeShort(this.yMax), e3.writeShort(this.macStyle), e3.writeShort(this.lowestRecPPEM), e3.writeShort(this.fontDirectionHint), e3.writeShort(t4), e3.writeShort(this.glyphDataFormat), e3.data;
  }, e2;
}(), ce = function() {
  function t3(t4, e2) {
    var r2, n2, i2, a2, o2, s2, c2, u2, h2, l2, f2, d2, p5, g2, m2, v2, b2;
    switch (this.platformID = t4.readUInt16(), this.encodingID = t4.readShort(), this.offset = e2 + t4.readInt(), h2 = t4.pos, t4.pos = this.offset, this.format = t4.readUInt16(), this.length = t4.readUInt16(), this.language = t4.readUInt16(), this.isUnicode = this.platformID === 3 && this.encodingID === 1 && this.format === 4 || this.platformID === 0 && this.format === 4, this.codeMap = {}, this.format) {
      case 0:
        for (s2 = 0; s2 < 256; ++s2)
          this.codeMap[s2] = t4.readByte();
        break;
      case 4:
        for (f2 = t4.readUInt16(), l2 = f2 / 2, t4.pos += 6, i2 = function() {
          var e3, r3;
          for (r3 = [], s2 = e3 = 0; 0 <= l2 ? e3 < l2 : e3 > l2; s2 = 0 <= l2 ? ++e3 : --e3)
            r3.push(t4.readUInt16());
          return r3;
        }(), t4.pos += 2, p5 = function() {
          var e3, r3;
          for (r3 = [], s2 = e3 = 0; 0 <= l2 ? e3 < l2 : e3 > l2; s2 = 0 <= l2 ? ++e3 : --e3)
            r3.push(t4.readUInt16());
          return r3;
        }(), c2 = function() {
          var e3, r3;
          for (r3 = [], s2 = e3 = 0; 0 <= l2 ? e3 < l2 : e3 > l2; s2 = 0 <= l2 ? ++e3 : --e3)
            r3.push(t4.readUInt16());
          return r3;
        }(), u2 = function() {
          var e3, r3;
          for (r3 = [], s2 = e3 = 0; 0 <= l2 ? e3 < l2 : e3 > l2; s2 = 0 <= l2 ? ++e3 : --e3)
            r3.push(t4.readUInt16());
          return r3;
        }(), n2 = (this.length - t4.pos + this.offset) / 2, o2 = function() {
          var e3, r3;
          for (r3 = [], s2 = e3 = 0; 0 <= n2 ? e3 < n2 : e3 > n2; s2 = 0 <= n2 ? ++e3 : --e3)
            r3.push(t4.readUInt16());
          return r3;
        }(), s2 = m2 = 0, b2 = i2.length; m2 < b2; s2 = ++m2)
          for (g2 = i2[s2], r2 = v2 = d2 = p5[s2]; d2 <= g2 ? v2 <= g2 : v2 >= g2; r2 = d2 <= g2 ? ++v2 : --v2)
            u2[s2] === 0 ? a2 = r2 + c2[s2] : (a2 = o2[u2[s2] / 2 + (r2 - d2) - (l2 - s2)] || 0) !== 0 && (a2 += c2[s2]), this.codeMap[r2] = 65535 & a2;
    }
    t4.pos = h2;
  }
  return t3.encode = function(t4, e2) {
    var r2, n2, i2, a2, o2, s2, c2, u2, h2, l2, f2, d2, p5, g2, m2, v2, b2, y2, w2, N2, L2, A2, x2, S2, _2, P2, k2, I2, F2, C2, j2, O2, B3, M2, E2, q2, D2, R2, T2, z2, U2, H4, W2, V2, G2, Y2;
    switch (I2 = new ne(), a2 = Object.keys(t4).sort(function(t5, e3) {
      return t5 - e3;
    }), e2) {
      case "macroman":
        for (p5 = 0, g2 = function() {
          var t5 = [];
          for (d2 = 0; d2 < 256; ++d2)
            t5.push(0);
          return t5;
        }(), v2 = { 0: 0 }, i2 = {}, F2 = 0, B3 = a2.length; F2 < B3; F2++)
          v2[W2 = t4[n2 = a2[F2]]] == null && (v2[W2] = ++p5), i2[n2] = { old: t4[n2], new: v2[t4[n2]] }, g2[n2] = v2[t4[n2]];
        return I2.writeUInt16(1), I2.writeUInt16(0), I2.writeUInt32(12), I2.writeUInt16(0), I2.writeUInt16(262), I2.writeUInt16(0), I2.write(g2), { charMap: i2, subtable: I2.data, maxGlyphID: p5 + 1 };
      case "unicode":
        for (P2 = [], h2 = [], b2 = 0, v2 = {}, r2 = {}, m2 = c2 = null, C2 = 0, M2 = a2.length; C2 < M2; C2++)
          v2[w2 = t4[n2 = a2[C2]]] == null && (v2[w2] = ++b2), r2[n2] = { old: w2, new: v2[w2] }, o2 = v2[w2] - n2, m2 != null && o2 === c2 || (m2 && h2.push(m2), P2.push(n2), c2 = o2), m2 = n2;
        for (m2 && h2.push(m2), h2.push(65535), P2.push(65535), S2 = 2 * (x2 = P2.length), A2 = 2 * Math.pow(Math.log(x2) / Math.LN2, 2), l2 = Math.log(A2 / 2) / Math.LN2, L2 = 2 * x2 - A2, s2 = [], N2 = [], f2 = [], d2 = j2 = 0, E2 = P2.length; j2 < E2; d2 = ++j2) {
          if (_2 = P2[d2], u2 = h2[d2], _2 === 65535) {
            s2.push(0), N2.push(0);
            break;
          }
          if (_2 - (k2 = r2[_2].new) >= 32768)
            for (s2.push(0), N2.push(2 * (f2.length + x2 - d2)), n2 = O2 = _2; _2 <= u2 ? O2 <= u2 : O2 >= u2; n2 = _2 <= u2 ? ++O2 : --O2)
              f2.push(r2[n2].new);
          else
            s2.push(k2 - _2), N2.push(0);
        }
        for (I2.writeUInt16(3), I2.writeUInt16(1), I2.writeUInt32(12), I2.writeUInt16(4), I2.writeUInt16(16 + 8 * x2 + 2 * f2.length), I2.writeUInt16(0), I2.writeUInt16(S2), I2.writeUInt16(A2), I2.writeUInt16(l2), I2.writeUInt16(L2), U2 = 0, q2 = h2.length; U2 < q2; U2++)
          n2 = h2[U2], I2.writeUInt16(n2);
        for (I2.writeUInt16(0), H4 = 0, D2 = P2.length; H4 < D2; H4++)
          n2 = P2[H4], I2.writeUInt16(n2);
        for (V2 = 0, R2 = s2.length; V2 < R2; V2++)
          o2 = s2[V2], I2.writeUInt16(o2);
        for (G2 = 0, T2 = N2.length; G2 < T2; G2++)
          y2 = N2[G2], I2.writeUInt16(y2);
        for (Y2 = 0, z2 = f2.length; Y2 < z2; Y2++)
          p5 = f2[Y2], I2.writeUInt16(p5);
        return { charMap: r2, subtable: I2.data, maxGlyphID: b2 + 1 };
    }
  }, t3;
}(), ue = function(t3) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "cmap", e2.prototype.parse = function(t4) {
    var e3, r2, n2;
    for (t4.pos = this.offset, this.version = t4.readUInt16(), n2 = t4.readUInt16(), this.tables = [], this.unicode = null, r2 = 0; 0 <= n2 ? r2 < n2 : r2 > n2; r2 = 0 <= n2 ? ++r2 : --r2)
      e3 = new ce(t4, this.offset), this.tables.push(e3), e3.isUnicode && this.unicode == null && (this.unicode = e3);
    return true;
  }, e2.encode = function(t4, e3) {
    var r2, n2;
    return e3 == null && (e3 = "macroman"), r2 = ce.encode(t4, e3), (n2 = new ne()).writeUInt16(0), n2.writeUInt16(1), r2.table = n2.data.concat(r2.subtable), r2;
  }, e2;
}(), he = function(t3) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "hhea", e2.prototype.parse = function(t4) {
    return t4.pos = this.offset, this.version = t4.readInt(), this.ascender = t4.readShort(), this.decender = t4.readShort(), this.lineGap = t4.readShort(), this.advanceWidthMax = t4.readShort(), this.minLeftSideBearing = t4.readShort(), this.minRightSideBearing = t4.readShort(), this.xMaxExtent = t4.readShort(), this.caretSlopeRise = t4.readShort(), this.caretSlopeRun = t4.readShort(), this.caretOffset = t4.readShort(), t4.pos += 8, this.metricDataFormat = t4.readShort(), this.numberOfMetrics = t4.readUInt16();
  }, e2;
}(), le = function(t3) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "OS/2", e2.prototype.parse = function(t4) {
    if (t4.pos = this.offset, this.version = t4.readUInt16(), this.averageCharWidth = t4.readShort(), this.weightClass = t4.readUInt16(), this.widthClass = t4.readUInt16(), this.type = t4.readShort(), this.ySubscriptXSize = t4.readShort(), this.ySubscriptYSize = t4.readShort(), this.ySubscriptXOffset = t4.readShort(), this.ySubscriptYOffset = t4.readShort(), this.ySuperscriptXSize = t4.readShort(), this.ySuperscriptYSize = t4.readShort(), this.ySuperscriptXOffset = t4.readShort(), this.ySuperscriptYOffset = t4.readShort(), this.yStrikeoutSize = t4.readShort(), this.yStrikeoutPosition = t4.readShort(), this.familyClass = t4.readShort(), this.panose = function() {
      var e3, r2;
      for (r2 = [], e3 = 0; e3 < 10; ++e3)
        r2.push(t4.readByte());
      return r2;
    }(), this.charRange = function() {
      var e3, r2;
      for (r2 = [], e3 = 0; e3 < 4; ++e3)
        r2.push(t4.readInt());
      return r2;
    }(), this.vendorID = t4.readString(4), this.selection = t4.readShort(), this.firstCharIndex = t4.readShort(), this.lastCharIndex = t4.readShort(), this.version > 0 && (this.ascent = t4.readShort(), this.descent = t4.readShort(), this.lineGap = t4.readShort(), this.winAscent = t4.readShort(), this.winDescent = t4.readShort(), this.codePageRange = function() {
      var e3, r2;
      for (r2 = [], e3 = 0; e3 < 2; e3 = ++e3)
        r2.push(t4.readInt());
      return r2;
    }(), this.version > 1))
      return this.xHeight = t4.readShort(), this.capHeight = t4.readShort(), this.defaultChar = t4.readShort(), this.breakChar = t4.readShort(), this.maxContext = t4.readShort();
  }, e2;
}(), fe = function(t3) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "post", e2.prototype.parse = function(t4) {
    var e3, r2, n2;
    switch (t4.pos = this.offset, this.format = t4.readInt(), this.italicAngle = t4.readInt(), this.underlinePosition = t4.readShort(), this.underlineThickness = t4.readShort(), this.isFixedPitch = t4.readInt(), this.minMemType42 = t4.readInt(), this.maxMemType42 = t4.readInt(), this.minMemType1 = t4.readInt(), this.maxMemType1 = t4.readInt(), this.format) {
      case 65536:
        break;
      case 131072:
        var i2;
        for (r2 = t4.readUInt16(), this.glyphNameIndex = [], i2 = 0; 0 <= r2 ? i2 < r2 : i2 > r2; i2 = 0 <= r2 ? ++i2 : --i2)
          this.glyphNameIndex.push(t4.readUInt16());
        for (this.names = [], n2 = []; t4.pos < this.offset + this.length; )
          e3 = t4.readByte(), n2.push(this.names.push(t4.readString(e3)));
        return n2;
      case 151552:
        return r2 = t4.readUInt16(), this.offsets = t4.read(r2);
      case 196608:
        break;
      case 262144:
        return this.map = function() {
          var e4, r3, n3;
          for (n3 = [], i2 = e4 = 0, r3 = this.file.maxp.numGlyphs; 0 <= r3 ? e4 < r3 : e4 > r3; i2 = 0 <= r3 ? ++e4 : --e4)
            n3.push(t4.readUInt32());
          return n3;
        }.call(this);
    }
  }, e2;
}(), de = function(t3, e2) {
  this.raw = t3, this.length = t3.length, this.platformID = e2.platformID, this.encodingID = e2.encodingID, this.languageID = e2.languageID;
}, pe = function(t3) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "name", e2.prototype.parse = function(t4) {
    var e3, r2, n2, i2, a2, o2, s2, c2, u2, h2, l2;
    for (t4.pos = this.offset, t4.readShort(), e3 = t4.readShort(), o2 = t4.readShort(), r2 = [], i2 = 0; 0 <= e3 ? i2 < e3 : i2 > e3; i2 = 0 <= e3 ? ++i2 : --i2)
      r2.push({ platformID: t4.readShort(), encodingID: t4.readShort(), languageID: t4.readShort(), nameID: t4.readShort(), length: t4.readShort(), offset: this.offset + o2 + t4.readShort() });
    for (s2 = {}, i2 = u2 = 0, h2 = r2.length; u2 < h2; i2 = ++u2)
      n2 = r2[i2], t4.pos = n2.offset, c2 = t4.readString(n2.length), a2 = new de(c2, n2), s2[l2 = n2.nameID] == null && (s2[l2] = []), s2[n2.nameID].push(a2);
    this.strings = s2, this.copyright = s2[0], this.fontFamily = s2[1], this.fontSubfamily = s2[2], this.uniqueSubfamily = s2[3], this.fontName = s2[4], this.version = s2[5];
    try {
      this.postscriptName = s2[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    } catch (t5) {
      this.postscriptName = s2[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    }
    return this.trademark = s2[7], this.manufacturer = s2[8], this.designer = s2[9], this.description = s2[10], this.vendorUrl = s2[11], this.designerUrl = s2[12], this.license = s2[13], this.licenseUrl = s2[14], this.preferredFamily = s2[15], this.preferredSubfamily = s2[17], this.compatibleFull = s2[18], this.sampleText = s2[19];
  }, e2;
}(), ge = function(t3) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "maxp", e2.prototype.parse = function(t4) {
    return t4.pos = this.offset, this.version = t4.readInt(), this.numGlyphs = t4.readUInt16(), this.maxPoints = t4.readUInt16(), this.maxContours = t4.readUInt16(), this.maxCompositePoints = t4.readUInt16(), this.maxComponentContours = t4.readUInt16(), this.maxZones = t4.readUInt16(), this.maxTwilightPoints = t4.readUInt16(), this.maxStorage = t4.readUInt16(), this.maxFunctionDefs = t4.readUInt16(), this.maxInstructionDefs = t4.readUInt16(), this.maxStackElements = t4.readUInt16(), this.maxSizeOfInstructions = t4.readUInt16(), this.maxComponentElements = t4.readUInt16(), this.maxComponentDepth = t4.readUInt16();
  }, e2;
}(), me = function(t3) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "hmtx", e2.prototype.parse = function(t4) {
    var e3, r2, n2, i2, a2, o2, s2;
    for (t4.pos = this.offset, this.metrics = [], e3 = 0, o2 = this.file.hhea.numberOfMetrics; 0 <= o2 ? e3 < o2 : e3 > o2; e3 = 0 <= o2 ? ++e3 : --e3)
      this.metrics.push({ advance: t4.readUInt16(), lsb: t4.readInt16() });
    for (n2 = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics, this.leftSideBearings = function() {
      var r3, i3;
      for (i3 = [], e3 = r3 = 0; 0 <= n2 ? r3 < n2 : r3 > n2; e3 = 0 <= n2 ? ++r3 : --r3)
        i3.push(t4.readInt16());
      return i3;
    }(), this.widths = function() {
      var t5, e4, r3, n3;
      for (n3 = [], t5 = 0, e4 = (r3 = this.metrics).length; t5 < e4; t5++)
        i2 = r3[t5], n3.push(i2.advance);
      return n3;
    }.call(this), r2 = this.widths[this.widths.length - 1], s2 = [], e3 = a2 = 0; 0 <= n2 ? a2 < n2 : a2 > n2; e3 = 0 <= n2 ? ++a2 : --a2)
      s2.push(this.widths.push(r2));
    return s2;
  }, e2.prototype.forGlyph = function(t4) {
    return t4 in this.metrics ? this.metrics[t4] : { advance: this.metrics[this.metrics.length - 1].advance, lsb: this.leftSideBearings[t4 - this.metrics.length] };
  }, e2;
}(), ve = [].slice, be = function(t3) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "glyf", e2.prototype.parse = function() {
    return this.cache = {};
  }, e2.prototype.glyphFor = function(t4) {
    var e3, r2, n2, i2, a2, o2, s2, c2, u2, h2;
    return t4 in this.cache ? this.cache[t4] : (i2 = this.file.loca, e3 = this.file.contents, r2 = i2.indexOf(t4), (n2 = i2.lengthOf(t4)) === 0 ? this.cache[t4] = null : (e3.pos = this.offset + r2, a2 = (o2 = new ne(e3.read(n2))).readShort(), c2 = o2.readShort(), h2 = o2.readShort(), s2 = o2.readShort(), u2 = o2.readShort(), this.cache[t4] = a2 === -1 ? new we(o2, c2, h2, s2, u2) : new ye(o2, a2, c2, h2, s2, u2), this.cache[t4]));
  }, e2.prototype.encode = function(t4, e3, r2) {
    var n2, i2, a2, o2, s2;
    for (a2 = [], i2 = [], o2 = 0, s2 = e3.length; o2 < s2; o2++)
      n2 = t4[e3[o2]], i2.push(a2.length), n2 && (a2 = a2.concat(n2.encode(r2)));
    return i2.push(a2.length), { table: a2, offsets: i2 };
  }, e2;
}(), ye = function() {
  function t3(t4, e2, r2, n2, i2, a2) {
    this.raw = t4, this.numberOfContours = e2, this.xMin = r2, this.yMin = n2, this.xMax = i2, this.yMax = a2, this.compound = false;
  }
  return t3.prototype.encode = function() {
    return this.raw.data;
  }, t3;
}(), we = function() {
  function t3(t4, e2, r2, n2, i2) {
    var a2, o2;
    for (this.raw = t4, this.xMin = e2, this.yMin = r2, this.xMax = n2, this.yMax = i2, this.compound = true, this.glyphIDs = [], this.glyphOffsets = [], a2 = this.raw; o2 = a2.readShort(), this.glyphOffsets.push(a2.pos), this.glyphIDs.push(a2.readUInt16()), 32 & o2; )
      a2.pos += 1 & o2 ? 4 : 2, 128 & o2 ? a2.pos += 8 : 64 & o2 ? a2.pos += 4 : 8 & o2 && (a2.pos += 2);
  }
  return t3.prototype.encode = function() {
    var t4, e2, r2;
    for (e2 = new ne(ve.call(this.raw.data)), t4 = 0, r2 = this.glyphIDs.length; t4 < r2; ++t4)
      e2.pos = this.glyphOffsets[t4];
    return e2.data;
  }, t3;
}(), Ne = function(t3) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "loca", e2.prototype.parse = function(t4) {
    var e3, r2;
    return t4.pos = this.offset, e3 = this.file.head.indexToLocFormat, this.offsets = e3 === 0 ? function() {
      var e4, n2;
      for (n2 = [], r2 = 0, e4 = this.length; r2 < e4; r2 += 2)
        n2.push(2 * t4.readUInt16());
      return n2;
    }.call(this) : function() {
      var e4, n2;
      for (n2 = [], r2 = 0, e4 = this.length; r2 < e4; r2 += 4)
        n2.push(t4.readUInt32());
      return n2;
    }.call(this);
  }, e2.prototype.indexOf = function(t4) {
    return this.offsets[t4];
  }, e2.prototype.lengthOf = function(t4) {
    return this.offsets[t4 + 1] - this.offsets[t4];
  }, e2.prototype.encode = function(t4, e3) {
    for (var r2 = new Uint32Array(this.offsets.length), n2 = 0, i2 = 0, a2 = 0; a2 < r2.length; ++a2)
      if (r2[a2] = n2, i2 < e3.length && e3[i2] == a2) {
        ++i2, r2[a2] = n2;
        var o2 = this.offsets[a2], s2 = this.offsets[a2 + 1] - o2;
        s2 > 0 && (n2 += s2);
      }
    for (var c2 = new Array(4 * r2.length), u2 = 0; u2 < r2.length; ++u2)
      c2[4 * u2 + 3] = 255 & r2[u2], c2[4 * u2 + 2] = (65280 & r2[u2]) >> 8, c2[4 * u2 + 1] = (16711680 & r2[u2]) >> 16, c2[4 * u2] = (4278190080 & r2[u2]) >> 24;
    return c2;
  }, e2;
}(), Le = function() {
  function t3(t4) {
    this.font = t4, this.subset = {}, this.unicodes = {}, this.next = 33;
  }
  return t3.prototype.generateCmap = function() {
    var t4, e2, r2, n2, i2;
    for (e2 in n2 = this.font.cmap.tables[0].codeMap, t4 = {}, i2 = this.subset)
      r2 = i2[e2], t4[e2] = n2[r2];
    return t4;
  }, t3.prototype.glyphsFor = function(t4) {
    var e2, r2, n2, i2, a2, o2, s2;
    for (n2 = {}, a2 = 0, o2 = t4.length; a2 < o2; a2++)
      n2[i2 = t4[a2]] = this.font.glyf.glyphFor(i2);
    for (i2 in e2 = [], n2)
      ((r2 = n2[i2]) != null ? r2.compound : void 0) && e2.push.apply(e2, r2.glyphIDs);
    if (e2.length > 0)
      for (i2 in s2 = this.glyphsFor(e2))
        r2 = s2[i2], n2[i2] = r2;
    return n2;
  }, t3.prototype.encode = function(t4, e2) {
    var r2, n2, i2, a2, o2, s2, c2, u2, h2, l2, f2, d2, p5, g2, m2;
    for (n2 in r2 = ue.encode(this.generateCmap(), "unicode"), a2 = this.glyphsFor(t4), f2 = { 0: 0 }, m2 = r2.charMap)
      f2[(s2 = m2[n2]).old] = s2.new;
    for (d2 in l2 = r2.maxGlyphID, a2)
      d2 in f2 || (f2[d2] = l2++);
    return u2 = function(t5) {
      var e3, r3;
      for (e3 in r3 = {}, t5)
        r3[t5[e3]] = e3;
      return r3;
    }(f2), h2 = Object.keys(u2).sort(function(t5, e3) {
      return t5 - e3;
    }), p5 = function() {
      var t5, e3, r3;
      for (r3 = [], t5 = 0, e3 = h2.length; t5 < e3; t5++)
        o2 = h2[t5], r3.push(u2[o2]);
      return r3;
    }(), i2 = this.font.glyf.encode(a2, p5, f2), c2 = this.font.loca.encode(i2.offsets, p5), g2 = { cmap: this.font.cmap.raw(), glyf: i2.table, loca: c2, hmtx: this.font.hmtx.raw(), hhea: this.font.hhea.raw(), maxp: this.font.maxp.raw(), post: this.font.post.raw(), name: this.font.name.raw(), head: this.font.head.encode(e2) }, this.font.os2.exists && (g2["OS/2"] = this.font.os2.raw()), this.font.directory.encode(g2);
  }, t3;
}();
E$1.API.PDFObject = function() {
  var t3;
  function e2() {
  }
  return t3 = function(t4, e3) {
    return (Array(e3 + 1).join("0") + t4).slice(-e3);
  }, e2.convert = function(r2) {
    var n2, i2, a2, o2;
    if (Array.isArray(r2))
      return "[" + function() {
        var t4, i3, a3;
        for (a3 = [], t4 = 0, i3 = r2.length; t4 < i3; t4++)
          n2 = r2[t4], a3.push(e2.convert(n2));
        return a3;
      }().join(" ") + "]";
    if (typeof r2 == "string")
      return "/" + r2;
    if (r2 != null ? r2.isString : void 0)
      return "(" + r2 + ")";
    if (r2 instanceof Date)
      return "(D:" + t3(r2.getUTCFullYear(), 4) + t3(r2.getUTCMonth(), 2) + t3(r2.getUTCDate(), 2) + t3(r2.getUTCHours(), 2) + t3(r2.getUTCMinutes(), 2) + t3(r2.getUTCSeconds(), 2) + "Z)";
    if ({}.toString.call(r2) === "[object Object]") {
      for (i2 in a2 = ["<<"], r2)
        o2 = r2[i2], a2.push("/" + i2 + " " + e2.convert(o2));
      return a2.push(">>"), a2.join("\n");
    }
    return "" + r2;
  }, e2;
}();
const _sfc_main$w = {
  name: "ol-control-printdialog",
  setup(props, context2) {
    const {
      control
    } = useControl(ol_control_PrintDialog, props, context2);
    control.value.on(["print", "error"], function(e2) {
      if (e2.image) {
        if (e2.pdf) {
          var pdf = new E$1({
            orientation: e2.print.orientation,
            unit: e2.print.unit,
            format: e2.print.size
          });
          pdf.addImage(e2.image, "JPEG", e2.print.position[0], e2.print.position[0], e2.print.imageWidth, e2.print.imageHeight);
          pdf.save(e2.print.legend ? "legend.pdf" : "map.pdf");
        } else {
          e2.canvas.toBlob(function(blob) {
            var name = (e2.print.legend ? "legend." : "map.") + e2.imageType.replace("image/", "");
            FileSaver_min.exports.saveAs(blob, name);
          }, e2.imageType, e2.quality);
        }
      } else {
        console.warn("No canvas to export");
      }
    });
    return {
      control
    };
  },
  props: {
    lang: {
      type: String
    }
  }
};
function _sfc_render$w(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var PrintDialog = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["render", _sfc_render$w]]);
var ol_control_VideoRecorder = function(options) {
  if (!options)
    options = {};
  var element = ol_ext_element.create("DIV", {
    className: (options.className || "ol-videorec") + " ol-unselectable ol-control"
  });
  ol_ext_element.create("BUTTON", {
    type: "button",
    className: "ol-start",
    title: "start",
    click: function() {
      this.start();
    }.bind(this),
    parent: element
  });
  ol_ext_element.create("BUTTON", {
    type: "button",
    className: "ol-stop",
    title: "stop",
    click: function() {
      this.stop();
    }.bind(this),
    parent: element
  });
  ol_ext_element.create("BUTTON", {
    type: "button",
    className: "ol-pause",
    title: "pause",
    click: function() {
      this.pause();
    }.bind(this),
    parent: element
  });
  ol_ext_element.create("BUTTON", {
    type: "button",
    className: "ol-resume",
    title: "resume",
    click: function() {
      this.resume();
    }.bind(this),
    parent: element
  });
  Control$1.call(this, {
    element,
    target: options.target
  });
  this.set("framerate", 30);
  this.set("videoBitsPerSecond", 5e6);
  if (options.videoTarget === "DIALOG") {
    this._dialog = new ol_control_Dialog({
      className: "ol-fullscreen-dialog",
      target: document.body,
      closeBox: true
    });
    this._videoTarget = this._dialog.getContentElement();
  } else {
    this._videoTarget = options.videoTarget;
  }
  this._printCtrl = new ol_control_Print({
    target: ol_ext_element.create("DIV")
  });
};
ol_ext_inherits(ol_control_VideoRecorder, Control$1);
ol_control_VideoRecorder.prototype.setMap = function(map) {
  if (this.getMap()) {
    this.getMap().removeControl(this._printCtrl);
    if (this._dialog)
      this.getMap().removeControl(this._dialog);
  }
  Control$1.prototype.setMap.call(this, map);
  if (this.getMap()) {
    this.getMap().addControl(this._printCtrl);
    if (this._dialog)
      this.getMap().addControl(this._dialog);
  }
};
ol_control_VideoRecorder.prototype.start = function() {
  var print = this._printCtrl;
  var stop = false;
  function capture(canvas) {
    if (stop)
      return;
    print.fastPrint({
      canvas
    }, capture);
  }
  print.fastPrint({}, function(canvas) {
    var videoStream;
    try {
      videoStream = canvas.captureStream(this.get("framerate") || 30);
    } catch (e2) {
      this.dispatchEvent({
        type: "error",
        error: e2
      });
      return;
    }
    this._mediaRecorder = new MediaRecorder(videoStream, {
      videoBitsPerSecond: this.get("videoBitsPerSecond") || 5e6
    });
    var chunks = [];
    this._mediaRecorder.ondataavailable = function(e2) {
      chunks.push(e2.data);
    };
    this._mediaRecorder.onstop = function() {
      stop = true;
      var blob = new Blob(chunks, { "type": "video/mp4" });
      chunks = [];
      if (this._videoTarget instanceof Element) {
        var video;
        if (this._videoTarget.tagName === "VIDEO") {
          video = this._videoTarget;
        } else {
          video = this._videoTarget.querySelector("video");
          if (!video) {
            video = ol_ext_element.create("VIDEO", {
              controls: "",
              parent: this._videoTarget
            });
          }
        }
        if (this._dialog)
          this._dialog.show();
        video.src = URL.createObjectURL(blob);
        this.dispatchEvent({ type: "stop", videoURL: video.src });
      } else {
        this.dispatchEvent({ type: "stop", videoURL: URL.createObjectURL(blob) });
      }
    }.bind(this);
    this._mediaRecorder.onpause = function() {
      stop = true;
      this.dispatchEvent({ type: "pause" });
    }.bind(this);
    this._mediaRecorder.onresume = function() {
      stop = false;
      capture(canvas);
      this.dispatchEvent({ type: "resume" });
    }.bind(this);
    this._mediaRecorder.onerror = function(e2) {
      this.dispatchEvent({ type: "error", error: e2 });
    }.bind(this);
    stop = false;
    capture(canvas);
    this._mediaRecorder.start();
    this.dispatchEvent({ type: "start", canvas });
    this.element.setAttribute("data-state", "rec");
  }.bind(this));
};
ol_control_VideoRecorder.prototype.stop = function() {
  if (this._mediaRecorder) {
    this._mediaRecorder.stop();
    this._mediaRecorder = null;
    this.element.setAttribute("data-state", "inactive");
  }
};
ol_control_VideoRecorder.prototype.pause = function() {
  if (this._mediaRecorder) {
    this._mediaRecorder.pause();
    this.element.setAttribute("data-state", "pause");
  }
};
ol_control_VideoRecorder.prototype.resume = function() {
  if (this._mediaRecorder) {
    this._mediaRecorder.resume();
    this.element.setAttribute("data-state", "rec");
  }
};
const _sfc_main$v = {
  name: "ol-control-videorecorder",
  emits: ["start", "stop"],
  setup(props, context2) {
    const {
      control
    } = useControl(ol_control_VideoRecorder, props, context2);
    const { downloadName } = toRefs(props);
    control.value.on("start", (event) => {
      context2.emit("start", event);
    });
    control.value.on("stop", (event) => {
      context2.emit("stop", event);
      FileSaver_min.exports.saveAs(event.videoURL, downloadName.value);
    });
    return {
      control
    };
  },
  props: {
    className: {
      type: String
    },
    framerate: {
      type: Number,
      default: 30
    },
    videoBitsPerSecond: {
      type: Number,
      default: 5e6
    },
    videoTarget: {
      type: String
    },
    downloadName: {
      type: String,
      default: "mapVideo.mp4"
    }
  }
};
function _sfc_render$v(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var VideoRecorderControl = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["render", _sfc_render$v]]);
const IMAGE_REPLAYS = {
  "image": ["Polygon", "Circle", "LineString", "Image", "Text"],
  "hybrid": ["Polygon", "LineString"],
  "vector": []
};
const VECTOR_REPLAYS = {
  "hybrid": ["Image", "Text", "Default"],
  "vector": ["Polygon", "Circle", "LineString", "Image", "Text", "Default"]
};
class CanvasVectorTileLayerRenderer extends CanvasTileLayerRenderer {
  constructor(layer) {
    super(layer);
    this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this);
    this.renderedLayerRevision_;
    this.renderedPixelToCoordinateTransform_ = null;
    this.renderedRotation_;
    this.tmpTransform_ = create$7();
  }
  prepareTile(tile2, pixelRatio, projection) {
    let render2;
    const state = tile2.getState();
    if (state === TileState.LOADED || state === TileState.ERROR) {
      this.updateExecutorGroup_(tile2, pixelRatio, projection);
      if (this.tileImageNeedsRender_(tile2)) {
        render2 = true;
      }
    }
    return render2;
  }
  getTile(z2, x2, y2, frameState) {
    const pixelRatio = frameState.pixelRatio;
    const viewState = frameState.viewState;
    const resolution = viewState.resolution;
    const projection = viewState.projection;
    const layer = this.getLayer();
    const tile2 = layer.getSource().getTile(z2, x2, y2, pixelRatio, projection);
    const viewHints = frameState.viewHints;
    const hifi = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);
    if (hifi || !tile2.wantedResolution) {
      tile2.wantedResolution = resolution;
    }
    const render2 = this.prepareTile(tile2, pixelRatio, projection);
    if (render2 && (hifi || Date.now() - frameState.time < 8) && layer.getRenderMode() !== "vector") {
      this.renderTileImage_(tile2, frameState);
    }
    return super.getTile(z2, x2, y2, frameState);
  }
  isDrawableTile(tile2) {
    const layer = this.getLayer();
    return super.isDrawableTile(tile2) && (layer.getRenderMode() === "vector" ? getUid(layer) in tile2.executorGroups : tile2.hasContext(layer));
  }
  getTileImage(tile2) {
    return tile2.getImage(this.getLayer());
  }
  prepareFrame(frameState) {
    const layerRevision = this.getLayer().getRevision();
    if (this.renderedLayerRevision_ !== layerRevision) {
      this.renderedLayerRevision_ = layerRevision;
      this.renderedTiles.length = 0;
    }
    return super.prepareFrame(frameState);
  }
  updateExecutorGroup_(tile2, pixelRatio, projection) {
    const layer = this.getLayer();
    const revision = layer.getRevision();
    const renderOrder = layer.getRenderOrder() || null;
    const resolution = tile2.wantedResolution;
    const builderState = tile2.getReplayState(layer);
    if (!builderState.dirty && builderState.renderedResolution === resolution && builderState.renderedRevision == revision && builderState.renderedRenderOrder == renderOrder) {
      return;
    }
    const source = layer.getSource();
    const declutter = layer.getDeclutter();
    const sourceTileGrid = source.getTileGrid();
    const tileGrid = source.getTileGridForProjection(projection);
    const tileExtent = tileGrid.getTileCoordExtent(tile2.wrappedTileCoord);
    const sourceTiles = source.getSourceTiles(pixelRatio, projection, tile2);
    const layerUid = getUid(layer);
    delete tile2.hitDetectionImageData[layerUid];
    tile2.executorGroups[layerUid] = [];
    if (declutter) {
      tile2.declutterExecutorGroups[layerUid] = [];
    }
    builderState.dirty = false;
    for (let t3 = 0, tt2 = sourceTiles.length; t3 < tt2; ++t3) {
      const sourceTile = sourceTiles[t3];
      if (sourceTile.getState() != TileState.LOADED) {
        continue;
      }
      const sourceTileCoord = sourceTile.tileCoord;
      const sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);
      const sharedExtent = getIntersection(tileExtent, sourceTileExtent);
      const builderExtent = buffer$2(sharedExtent, layer.getRenderBuffer() * resolution, this.tmpExtent);
      const bufferedExtent = equals$2(sourceTileExtent, sharedExtent) ? null : builderExtent;
      const builderGroup = new BuilderGroup(0, builderExtent, resolution, pixelRatio);
      const declutterBuilderGroup = declutter ? new BuilderGroup(0, sharedExtent, resolution, pixelRatio) : void 0;
      const squaredTolerance = getSquaredTolerance(resolution, pixelRatio);
      const render2 = function(feature) {
        let styles;
        const styleFunction = feature.getStyleFunction() || layer.getStyleFunction();
        if (styleFunction) {
          styles = styleFunction(feature, resolution);
        }
        if (styles) {
          const dirty = this.renderFeature(feature, squaredTolerance, styles, builderGroup, declutterBuilderGroup);
          builderState.dirty = builderState.dirty || dirty;
        }
      };
      const features = sourceTile.getFeatures();
      if (renderOrder && renderOrder !== builderState.renderedRenderOrder) {
        features.sort(renderOrder);
      }
      for (let i2 = 0, ii = features.length; i2 < ii; ++i2) {
        const feature = features[i2];
        if (!bufferedExtent || intersects$2(bufferedExtent, feature.getGeometry().getExtent())) {
          render2.call(this, feature);
        }
      }
      const executorGroupInstructions = builderGroup.finish();
      const replayExtent = layer.getRenderMode() !== "vector" && declutter && sourceTiles.length === 1 ? null : sharedExtent;
      const renderingReplayGroup = new ExecutorGroup(replayExtent, resolution, pixelRatio, source.getOverlaps(), executorGroupInstructions, layer.getRenderBuffer());
      tile2.executorGroups[layerUid].push(renderingReplayGroup);
      if (declutterBuilderGroup) {
        const declutterExecutorGroup = new ExecutorGroup(null, resolution, pixelRatio, source.getOverlaps(), declutterBuilderGroup.finish(), layer.getRenderBuffer());
        tile2.declutterExecutorGroups[layerUid].push(declutterExecutorGroup);
      }
    }
    builderState.renderedRevision = revision;
    builderState.renderedRenderOrder = renderOrder;
    builderState.renderedResolution = resolution;
  }
  forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {
    const resolution = frameState.viewState.resolution;
    const rotation = frameState.viewState.rotation;
    hitTolerance = hitTolerance == void 0 ? 0 : hitTolerance;
    const layer = this.getLayer();
    const source = layer.getSource();
    const tileGrid = source.getTileGridForProjection(frameState.viewState.projection);
    const hitExtent = boundingExtent([coordinate]);
    buffer$2(hitExtent, resolution * hitTolerance, hitExtent);
    const features = {};
    const featureCallback = function(feature, geometry, distanceSq) {
      let key = feature.getId();
      if (key === void 0) {
        key = getUid(feature);
      }
      const match2 = features[key];
      if (!match2) {
        if (distanceSq === 0) {
          features[key] = true;
          return callback(feature, layer, geometry);
        }
        matches.push(features[key] = {
          feature,
          layer,
          geometry,
          distanceSq,
          callback
        });
      } else if (match2 !== true && distanceSq < match2.distanceSq) {
        if (distanceSq === 0) {
          features[key] = true;
          matches.splice(matches.lastIndexOf(match2), 1);
          return callback(feature, layer, geometry);
        }
        match2.geometry = geometry;
        match2.distanceSq = distanceSq;
      }
      return void 0;
    };
    const renderedTiles = this.renderedTiles;
    let found;
    for (let i2 = 0, ii = renderedTiles.length; !found && i2 < ii; ++i2) {
      const tile2 = renderedTiles[i2];
      const tileExtent = tileGrid.getTileCoordExtent(tile2.wrappedTileCoord);
      if (!intersects$2(tileExtent, hitExtent)) {
        continue;
      }
      const layerUid = getUid(layer);
      const executorGroups = [tile2.executorGroups[layerUid]];
      const declutterExecutorGroups = tile2.declutterExecutorGroups[layerUid];
      if (declutterExecutorGroups) {
        executorGroups.push(declutterExecutorGroups);
      }
      executorGroups.some((executorGroups2) => {
        const declutteredFeatures = executorGroups2 === declutterExecutorGroups ? frameState.declutterTree.all().map((item) => item.value) : null;
        for (let t3 = 0, tt2 = executorGroups2.length; t3 < tt2; ++t3) {
          const executorGroup = executorGroups2[t3];
          found = executorGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, featureCallback, declutteredFeatures);
          if (found) {
            return true;
          }
        }
      });
    }
    return found;
  }
  getFeatures(pixel) {
    return new Promise((resolve2, reject2) => {
      const layer = this.getLayer();
      const layerUid = getUid(layer);
      const source = layer.getSource();
      const projection = this.renderedProjection;
      const projectionExtent = projection.getExtent();
      const resolution = this.renderedResolution;
      const tileGrid = source.getTileGridForProjection(projection);
      const coordinate = apply$5(this.renderedPixelToCoordinateTransform_, pixel.slice());
      const tileCoord = tileGrid.getTileCoordForCoordAndResolution(coordinate, resolution);
      let tile2;
      for (let i2 = 0, ii = this.renderedTiles.length; i2 < ii; ++i2) {
        if (tileCoord.toString() === this.renderedTiles[i2].tileCoord.toString()) {
          tile2 = this.renderedTiles[i2];
          if (tile2.getState() === TileState.LOADED) {
            const extent3 = tileGrid.getTileCoordExtent(tile2.tileCoord);
            if (source.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, extent3)) {
              wrapX$1(coordinate, projection);
            }
            break;
          }
          tile2 = void 0;
        }
      }
      if (!tile2 || tile2.loadingSourceTiles > 0) {
        resolve2([]);
        return;
      }
      const extent2 = tileGrid.getTileCoordExtent(tile2.wrappedTileCoord);
      const corner = getTopLeft(extent2);
      const tilePixel = [
        (coordinate[0] - corner[0]) / resolution,
        (corner[1] - coordinate[1]) / resolution
      ];
      const features = tile2.getSourceTiles().reduce(function(accumulator, sourceTile) {
        return accumulator.concat(sourceTile.getFeatures());
      }, []);
      let hitDetectionImageData = tile2.hitDetectionImageData[layerUid];
      if (!hitDetectionImageData) {
        const tileSize = toSize(tileGrid.getTileSize(tileGrid.getZForResolution(resolution, source.zDirection)));
        const rotation = this.renderedRotation_;
        const transforms2 = [
          this.getRenderTransform(tileGrid.getTileCoordCenter(tile2.wrappedTileCoord), resolution, 0, HIT_DETECT_RESOLUTION, tileSize[0] * HIT_DETECT_RESOLUTION, tileSize[1] * HIT_DETECT_RESOLUTION, 0)
        ];
        hitDetectionImageData = createHitDetectionImageData(tileSize, transforms2, features, layer.getStyleFunction(), tileGrid.getTileCoordExtent(tile2.wrappedTileCoord), tile2.getReplayState(layer).renderedResolution, rotation);
        tile2.hitDetectionImageData[layerUid] = hitDetectionImageData;
      }
      resolve2(hitDetect(tilePixel, features, hitDetectionImageData));
    });
  }
  handleFontsChanged() {
    const layer = this.getLayer();
    if (layer.getVisible() && this.renderedLayerRevision_ !== void 0) {
      layer.changed();
    }
  }
  handleStyleImageChange_(event) {
    this.renderIfReadyAndVisible();
  }
  renderDeclutter(frameState) {
    const context2 = this.context;
    const alpha = context2.globalAlpha;
    context2.globalAlpha = this.getLayer().getOpacity();
    const viewHints = frameState.viewHints;
    const hifi = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);
    const tiles = this.renderedTiles;
    for (let i2 = 0, ii = tiles.length; i2 < ii; ++i2) {
      const tile2 = tiles[i2];
      const declutterExecutorGroups = tile2.declutterExecutorGroups[getUid(this.getLayer())];
      if (declutterExecutorGroups) {
        for (let j2 = declutterExecutorGroups.length - 1; j2 >= 0; --j2) {
          declutterExecutorGroups[j2].execute(this.context, 1, this.getTileRenderTransform(tile2, frameState), frameState.viewState.rotation, hifi, void 0, frameState.declutterTree);
        }
      }
    }
    context2.globalAlpha = alpha;
  }
  getTileRenderTransform(tile2, frameState) {
    const pixelRatio = frameState.pixelRatio;
    const viewState = frameState.viewState;
    const center = viewState.center;
    const resolution = viewState.resolution;
    const rotation = viewState.rotation;
    const size = frameState.size;
    const width = Math.round(size[0] * pixelRatio);
    const height = Math.round(size[1] * pixelRatio);
    const source = this.getLayer().getSource();
    const tileGrid = source.getTileGridForProjection(frameState.viewState.projection);
    const tileCoord = tile2.tileCoord;
    const tileExtent = tileGrid.getTileCoordExtent(tile2.wrappedTileCoord);
    const worldOffset = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent)[0] - tileExtent[0];
    const transform2 = multiply(scale$3(this.inversePixelTransform.slice(), 1 / pixelRatio, 1 / pixelRatio), this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, worldOffset));
    return transform2;
  }
  postRender(context2, frameState) {
    const viewHints = frameState.viewHints;
    const hifi = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);
    this.renderedPixelToCoordinateTransform_ = frameState.pixelToCoordinateTransform.slice();
    this.renderedRotation_ = frameState.viewState.rotation;
    const layer = this.getLayer();
    const renderMode = layer.getRenderMode();
    const alpha = context2.globalAlpha;
    context2.globalAlpha = layer.getOpacity();
    const replayTypes = VECTOR_REPLAYS[renderMode];
    const viewState = frameState.viewState;
    const rotation = viewState.rotation;
    const tileSource = layer.getSource();
    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);
    const z2 = tileGrid.getZForResolution(viewState.resolution, tileSource.zDirection);
    const tiles = this.renderedTiles;
    const clips = [];
    const clipZs = [];
    let ready = true;
    for (let i2 = tiles.length - 1; i2 >= 0; --i2) {
      const tile2 = tiles[i2];
      ready = ready && !tile2.getReplayState(layer).dirty;
      const executorGroups = tile2.executorGroups[getUid(layer)].filter((group) => group.hasExecutors(replayTypes));
      if (executorGroups.length === 0) {
        continue;
      }
      const transform2 = this.getTileRenderTransform(tile2, frameState);
      const currentZ = tile2.tileCoord[0];
      let contextSaved = false;
      const currentClip = executorGroups[0].getClipCoords(transform2);
      if (currentClip) {
        for (let j2 = 0, jj = clips.length; j2 < jj; ++j2) {
          if (z2 !== currentZ && currentZ < clipZs[j2]) {
            const clip = clips[j2];
            if (intersects$2([
              currentClip[0],
              currentClip[3],
              currentClip[4],
              currentClip[7]
            ], [clip[0], clip[3], clip[4], clip[7]])) {
              if (!contextSaved) {
                context2.save();
                contextSaved = true;
              }
              context2.beginPath();
              context2.moveTo(currentClip[0], currentClip[1]);
              context2.lineTo(currentClip[2], currentClip[3]);
              context2.lineTo(currentClip[4], currentClip[5]);
              context2.lineTo(currentClip[6], currentClip[7]);
              context2.moveTo(clip[6], clip[7]);
              context2.lineTo(clip[4], clip[5]);
              context2.lineTo(clip[2], clip[3]);
              context2.lineTo(clip[0], clip[1]);
              context2.clip();
            }
          }
        }
        clips.push(currentClip);
        clipZs.push(currentZ);
      }
      for (let t3 = 0, tt2 = executorGroups.length; t3 < tt2; ++t3) {
        const executorGroup = executorGroups[t3];
        executorGroup.execute(context2, 1, transform2, rotation, hifi, replayTypes);
      }
      if (contextSaved) {
        context2.restore();
      }
    }
    context2.globalAlpha = alpha;
    this.ready = ready;
    super.postRender(context2, frameState);
  }
  renderFeature(feature, squaredTolerance, styles, builderGroup, declutterBuilderGroup) {
    if (!styles) {
      return false;
    }
    let loading = false;
    if (Array.isArray(styles)) {
      for (let i2 = 0, ii = styles.length; i2 < ii; ++i2) {
        loading = renderFeature(builderGroup, feature, styles[i2], squaredTolerance, this.boundHandleStyleImageChange_, void 0, declutterBuilderGroup) || loading;
      }
    } else {
      loading = renderFeature(builderGroup, feature, styles, squaredTolerance, this.boundHandleStyleImageChange_, void 0, declutterBuilderGroup);
    }
    return loading;
  }
  tileImageNeedsRender_(tile2) {
    const layer = this.getLayer();
    if (layer.getRenderMode() === "vector") {
      return false;
    }
    const replayState = tile2.getReplayState(layer);
    const revision = layer.getRevision();
    const resolution = tile2.wantedResolution;
    return replayState.renderedTileResolution !== resolution || replayState.renderedTileRevision !== revision;
  }
  renderTileImage_(tile2, frameState) {
    const layer = this.getLayer();
    const replayState = tile2.getReplayState(layer);
    const revision = layer.getRevision();
    const executorGroups = tile2.executorGroups[getUid(layer)];
    replayState.renderedTileRevision = revision;
    const tileCoord = tile2.wrappedTileCoord;
    const z2 = tileCoord[0];
    const source = layer.getSource();
    let pixelRatio = frameState.pixelRatio;
    const viewState = frameState.viewState;
    const projection = viewState.projection;
    const tileGrid = source.getTileGridForProjection(projection);
    const tileResolution = tileGrid.getResolution(tile2.tileCoord[0]);
    const renderPixelRatio = frameState.pixelRatio / tile2.wantedResolution * tileResolution;
    const resolution = tileGrid.getResolution(z2);
    const context2 = tile2.getContext(layer);
    pixelRatio = Math.round(Math.max(pixelRatio, renderPixelRatio / pixelRatio));
    const size = source.getTilePixelSize(z2, pixelRatio, projection);
    context2.canvas.width = size[0];
    context2.canvas.height = size[1];
    const renderScale = pixelRatio / renderPixelRatio;
    if (renderScale !== 1) {
      const canvasTransform = reset(this.tmpTransform_);
      scale$3(canvasTransform, renderScale, renderScale);
      context2.setTransform.apply(context2, canvasTransform);
    }
    const tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);
    const pixelScale = renderPixelRatio / resolution;
    const transform2 = reset(this.tmpTransform_);
    scale$3(transform2, pixelScale, -pixelScale);
    translate$1(transform2, -tileExtent[0], -tileExtent[3]);
    for (let i2 = 0, ii = executorGroups.length; i2 < ii; ++i2) {
      const executorGroup = executorGroups[i2];
      executorGroup.execute(context2, renderScale, transform2, 0, true, IMAGE_REPLAYS[layer.getRenderMode()]);
    }
    replayState.renderedTileResolution = tile2.wantedResolution;
  }
}
class VectorTileLayer extends BaseVectorLayer {
  constructor(options) {
    options = options ? options : {};
    const baseOptions = Object.assign({}, options);
    delete baseOptions.preload;
    delete baseOptions.useInterimTilesOnError;
    super(baseOptions);
    this.on;
    this.once;
    this.un;
    const renderMode = options.renderMode || "hybrid";
    assert(renderMode == "hybrid" || renderMode == "vector", 28);
    this.renderMode_ = renderMode;
    this.setPreload(options.preload ? options.preload : 0);
    this.setUseInterimTilesOnError(options.useInterimTilesOnError !== void 0 ? options.useInterimTilesOnError : true);
    this.getBackground;
    this.setBackground;
  }
  createRenderer() {
    return new CanvasVectorTileLayerRenderer(this);
  }
  getFeatures(pixel) {
    return super.getFeatures(pixel);
  }
  getRenderMode() {
    return this.renderMode_;
  }
  getPreload() {
    return this.get(TileProperty.PRELOAD);
  }
  getUseInterimTilesOnError() {
    return this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR);
  }
  setPreload(preload) {
    this.set(TileProperty.PRELOAD, preload);
  }
  setUseInterimTilesOnError(useInterimTilesOnError) {
    this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
  }
}
var ol_control_LayerSwitcher = function(options) {
  options = options || {};
  var self2 = this;
  this.dcount = 0;
  this.show_progress = options.show_progress;
  this.oninfo = typeof options.oninfo == "function" ? options.oninfo : null;
  this.onextent = typeof options.onextent == "function" ? options.onextent : null;
  this.hasextent = options.extent || options.onextent;
  this.hastrash = options.trash;
  this.reordering = options.reordering !== false;
  this._layers = [];
  this._layerGroup = options.layerGroup && options.layerGroup.getLayers ? options.layerGroup : null;
  this.onchangeCheck = typeof options.onchangeCheck == "function" ? options.onchangeCheck : null;
  if (typeof options.displayInLayerSwitcher === "function") {
    this.displayInLayerSwitcher = options.displayInLayerSwitcher;
  }
  var element;
  if (options.target) {
    element = ol_ext_element.create("DIV", {
      className: options.switcherClass || "ol-layerswitcher"
    });
  } else {
    element = ol_ext_element.create("DIV", {
      className: (options.switcherClass || "ol-layerswitcher") + " ol-unselectable ol-control"
    });
    if (options.collapsed !== false)
      element.classList.add("ol-collapsed");
    else
      element.classList.add("ol-forceopen");
    this.button = ol_ext_element.create("BUTTON", {
      type: "button",
      parent: element
    });
    this.button.addEventListener("touchstart", function(e2) {
      element.classList.toggle("ol-forceopen");
      element.classList.add("ol-collapsed");
      self2.dispatchEvent({ type: "toggle", collapsed: element.classList.contains("ol-collapsed") });
      e2.preventDefault();
      self2.overflow();
    });
    this.button.addEventListener("click", function() {
      element.classList.toggle("ol-forceopen");
      element.classList.add("ol-collapsed");
      self2.dispatchEvent({ type: "toggle", collapsed: !element.classList.contains("ol-forceopen") });
      self2.overflow();
    });
    if (options.mouseover) {
      element.addEventListener("mouseleave", function() {
        element.classList.add("ol-collapsed");
        self2.dispatchEvent({ type: "toggle", collapsed: true });
      });
      element.addEventListener("mouseover", function() {
        element.classList.remove("ol-collapsed");
        self2.dispatchEvent({ type: "toggle", collapsed: false });
      });
    }
    if (options.minibar)
      options.noScroll = true;
    if (!options.noScroll) {
      this.topv = ol_ext_element.create("DIV", {
        className: "ol-switchertopdiv",
        parent: element,
        click: function() {
          self2.overflow("+50%");
        }
      });
      this.botv = ol_ext_element.create("DIV", {
        className: "ol-switcherbottomdiv",
        parent: element,
        click: function() {
          self2.overflow("-50%");
        }
      });
    }
    this._noScroll = options.noScroll;
  }
  this.panel_ = ol_ext_element.create("UL", {
    className: "panel"
  });
  this.panelContainer_ = ol_ext_element.create("DIV", {
    className: "panel-container",
    html: this.panel_,
    parent: element
  });
  if (!options.target && !options.noScroll) {
    ol_ext_element.addListener(this.panel_, "mousewheel DOMMouseScroll onmousewheel", function(e2) {
      if (self2.overflow(Math.max(-1, Math.min(1, e2.wheelDelta || -e2.detail)))) {
        e2.stopPropagation();
        e2.preventDefault();
      }
    });
  }
  this.header_ = ol_ext_element.create("LI", {
    className: "ol-header",
    parent: this.panel_
  });
  Control$1.call(this, {
    element,
    target: options.target
  });
  this.set("drawDelay", options.drawDelay || 0);
  this.set("selection", options.selection);
  if (options.minibar) {
    setTimeout(function() {
      var mbar = ol_ext_element.scrollDiv(this.panelContainer_, {
        mousewheel: true,
        vertical: true,
        minibar: true
      });
      this.on(["drawlist", "toggle"], function() {
        mbar.refresh();
      });
    }.bind(this));
  }
};
ol_ext_inherits(ol_control_LayerSwitcher, Control$1);
ol_control_LayerSwitcher.prototype.tip = {
  up: "up/down",
  down: "down",
  info: "informations...",
  extent: "zoom to extent",
  trash: "remove layer",
  plus: "expand/shrink"
};
ol_control_LayerSwitcher.prototype.displayInLayerSwitcher = function(layer) {
  return layer.get("displayInLayerSwitcher") !== false;
};
ol_control_LayerSwitcher.prototype.setMap = function(map) {
  Control$1.prototype.setMap.call(this, map);
  this.drawPanel();
  if (this._listener) {
    for (var i2 in this._listener)
      unByKey(this._listener[i2]);
  }
  this._listener = null;
  if (map) {
    this._listener = {
      moveend: map.on("moveend", this.viewChange.bind(this)),
      size: map.on("change:size", this.overflow.bind(this))
    };
    if (this._layerGroup) {
      this._listener.change = this._layerGroup.getLayers().on("change:length", this.drawPanel.bind(this));
    } else {
      this._listener.change = map.getLayerGroup().getLayers().on("change:length", this.drawPanel.bind(this));
    }
  }
};
ol_control_LayerSwitcher.prototype.show = function() {
  this.element.classList.add("ol-forceopen");
  this.overflow();
  self.dispatchEvent({ type: "toggle", collapsed: false });
};
ol_control_LayerSwitcher.prototype.hide = function() {
  this.element.classList.remove("ol-forceopen");
  this.overflow();
  self.dispatchEvent({ type: "toggle", collapsed: true });
};
ol_control_LayerSwitcher.prototype.toggle = function() {
  this.element.classList.toggle("ol-forceopen");
  this.overflow();
};
ol_control_LayerSwitcher.prototype.isOpen = function() {
  return this.element.classList.contains("ol-forceopen");
};
ol_control_LayerSwitcher.prototype.setHeader = function(html2) {
  ol_ext_element.setHTML(this.header_, html2);
};
ol_control_LayerSwitcher.prototype.overflow = function(dir) {
  if (this.button && !this._noScroll) {
    if (ol_ext_element.hidden(this.panel_)) {
      ol_ext_element.setStyle(this.element, { height: "auto" });
      return;
    }
    var h2 = ol_ext_element.outerHeight(this.element);
    var hp = ol_ext_element.outerHeight(this.panel_);
    var dh = this.button.offsetTop + ol_ext_element.outerHeight(this.button);
    var top = this.panel_.offsetTop - dh;
    if (hp > h2 - dh) {
      ol_ext_element.setStyle(this.element, { height: "100%" });
      var li = this.panel_.querySelectorAll("li.visible .li-content")[0];
      var lh = li ? 2 * ol_ext_element.getStyle(li, "height") : 0;
      switch (dir) {
        case 1:
          top += lh;
          break;
        case -1:
          top -= lh;
          break;
        case "+50%":
          top += Math.round(h2 / 2);
          break;
        case "-50%":
          top -= Math.round(h2 / 2);
          break;
      }
      if (top + hp <= h2 - 3 * dh / 2) {
        top = h2 - 3 * dh / 2 - hp;
        ol_ext_element.hide(this.botv);
      } else {
        ol_ext_element.show(this.botv);
      }
      if (top >= 0) {
        top = 0;
        ol_ext_element.hide(this.topv);
      } else {
        ol_ext_element.show(this.topv);
      }
      ol_ext_element.setStyle(this.panel_, { top: top + "px" });
      return true;
    } else {
      ol_ext_element.setStyle(this.element, { height: "auto" });
      ol_ext_element.setStyle(this.panel_, { top: 0 });
      ol_ext_element.hide(this.botv);
      ol_ext_element.hide(this.topv);
      return false;
    }
  } else
    return false;
};
ol_control_LayerSwitcher.prototype._setLayerForLI = function(li, layer) {
  var listeners = [];
  if (layer.getLayers) {
    listeners.push(layer.getLayers().on("change:length", this.drawPanel.bind(this)));
  }
  if (li) {
    listeners.push(layer.on("change:opacity", function() {
      this.setLayerOpacity(layer, li);
    }.bind(this)));
    listeners.push(layer.on("change:visible", function() {
      this.setLayerVisibility(layer, li);
    }.bind(this)));
  }
  listeners.push(layer.on("propertychange", function(e2) {
    if (e2.key === "displayInLayerSwitcher" || e2.key === "openInLayerSwitcher") {
      this.drawPanel(e2);
    }
  }.bind(this)));
  this._layers.push({ li, layer, listeners });
};
ol_control_LayerSwitcher.prototype.setLayerOpacity = function(layer, li) {
  var i2 = li.querySelector(".layerswitcher-opacity-cursor");
  if (i2)
    i2.style.left = layer.getOpacity() * 100 + "%";
  this.dispatchEvent({ type: "layer:opacity", layer });
};
ol_control_LayerSwitcher.prototype.setLayerVisibility = function(layer, li) {
  var i2 = li.querySelector(".ol-visibility");
  if (i2)
    i2.checked = layer.getVisible();
  if (layer.getVisible())
    li.classList.add("ol-visible");
  else
    li.classList.remove("ol-visible");
  this.dispatchEvent({ type: "layer:visible", layer });
};
ol_control_LayerSwitcher.prototype._clearLayerForLI = function() {
  this._layers.forEach(function(li) {
    li.listeners.forEach(function(l2) {
      unByKey(l2);
    });
  });
  this._layers = [];
};
ol_control_LayerSwitcher.prototype._getLayerForLI = function(li) {
  for (var i2 = 0, l2; l2 = this._layers[i2]; i2++) {
    if (l2.li === li)
      return l2.layer;
  }
  return null;
};
ol_control_LayerSwitcher.prototype.viewChange = function() {
  this.panel_.querySelectorAll("li").forEach(function(li) {
    var l2 = this._getLayerForLI(li);
    if (l2) {
      if (this.testLayerVisibility(l2))
        li.classList.remove("ol-layer-hidden");
      else
        li.classList.add("ol-layer-hidden");
    }
  }.bind(this));
};
ol_control_LayerSwitcher.prototype.getPanel = function() {
  return this.panelContainer_;
};
ol_control_LayerSwitcher.prototype.drawPanel = function() {
  if (!this.getMap())
    return;
  var self2 = this;
  this.dcount++;
  setTimeout(function() {
    self2.drawPanel_();
  }, this.get("drawDelay") || 0);
};
ol_control_LayerSwitcher.prototype.drawPanel_ = function() {
  if (--this.dcount || this.dragging_)
    return;
  var scrollTop = this.panelContainer_.scrollTop;
  this._clearLayerForLI();
  this.panel_.querySelectorAll("li").forEach(function(li) {
    if (!li.classList.contains("ol-header"))
      li.remove();
  }.bind(this));
  if (this._layerGroup)
    this.drawList(this.panel_, this._layerGroup.getLayers());
  else if (this.getMap())
    this.drawList(this.panel_, this.getMap().getLayers());
  this.panelContainer_.scrollTop = scrollTop;
};
ol_control_LayerSwitcher.prototype.switchLayerVisibility = function(l2, layers) {
  if (!l2.get("baseLayer")) {
    l2.setVisible(!l2.getVisible());
  } else {
    if (!l2.getVisible())
      l2.setVisible(true);
    layers.forEach(function(li) {
      if (l2 !== li && li.get("baseLayer") && li.getVisible())
        li.setVisible(false);
    });
  }
};
ol_control_LayerSwitcher.prototype.testLayerVisibility = function(layer) {
  if (!this.getMap())
    return true;
  var res = this.getMap().getView().getResolution();
  var zoom = this.getMap().getView().getZoom();
  if (layer.getMaxResolution() <= res || layer.getMinResolution() >= res) {
    return false;
  } else if (layer.getMinZoom && (layer.getMinZoom() >= zoom || layer.getMaxZoom() < zoom)) {
    return false;
  } else {
    var ex0 = layer.getExtent();
    if (ex0) {
      var ex = this.getMap().getView().calculateExtent(this.getMap().getSize());
      return intersects$2(ex, ex0);
    }
    return true;
  }
};
ol_control_LayerSwitcher.prototype.dragOrdering_ = function(e2) {
  e2.stopPropagation();
  e2.preventDefault();
  var self2 = this;
  var elt = e2.currentTarget.parentNode.parentNode;
  var start2 = true;
  var panel = this.panel_;
  var pageY;
  var pageY0 = e2.pageY || e2.touches && e2.touches.length && e2.touches[0].pageY || e2.changedTouches && e2.changedTouches.length && e2.changedTouches[0].pageY;
  var target, dragElt;
  var layer, group;
  elt.parentNode.classList.add("drag");
  function stop() {
    if (target) {
      var drop = layer;
      var isSelected = self2.getSelection() === drop;
      if (drop && target) {
        var collection;
        if (group)
          collection = group.getLayers();
        else
          collection = self2._layerGroup ? self2._layerGroup.getLayers() : self2.getMap().getLayers();
        var layers = collection.getArray();
        for (var i2 = 0; i2 < layers.length; i2++) {
          if (layers[i2] == drop) {
            collection.removeAt(i2);
            break;
          }
        }
        for (var j2 = 0; j2 < layers.length; j2++) {
          if (layers[j2] === target) {
            if (i2 > j2)
              collection.insertAt(j2, drop);
            else
              collection.insertAt(j2 + 1, drop);
            break;
          }
        }
      }
      if (isSelected)
        self2.selectLayer(drop);
      self2.dispatchEvent({ type: "reorder-end", layer: drop, group });
    }
    elt.parentNode.querySelectorAll("li").forEach(function(li) {
      li.classList.remove("dropover");
      li.classList.remove("dropover-after");
      li.classList.remove("dropover-before");
    });
    elt.classList.remove("drag");
    elt.parentNode.classList.remove("drag");
    self2.element.classList.remove("drag");
    if (dragElt)
      dragElt.remove();
    ol_ext_element.removeListener(document, "mousemove touchmove", move);
    ol_ext_element.removeListener(document, "mouseup touchend touchcancel", stop);
  }
  function move(e3) {
    pageY = e3.pageY || e3.touches && e3.touches.length && e3.touches[0].pageY || e3.changedTouches && e3.changedTouches.length && e3.changedTouches[0].pageY;
    if (start2 && Math.abs(pageY0 - pageY) > 2) {
      start2 = false;
      elt.classList.add("drag");
      layer = self2._getLayerForLI(elt);
      target = false;
      group = self2._getLayerForLI(elt.parentNode.parentNode);
      dragElt = ol_ext_element.create("LI", {
        className: "ol-dragover",
        html: elt.innerHTML,
        style: {
          position: "absolute",
          "z-index": 1e4,
          left: elt.offsetLeft,
          opacity: 0.5,
          width: ol_ext_element.outerWidth(elt),
          height: ol_ext_element.getStyle(elt, "height")
        },
        parent: panel
      });
      self2.element.classList.add("drag");
      self2.dispatchEvent({ type: "reorder-start", layer, group });
    }
    if (!start2) {
      e3.preventDefault();
      e3.stopPropagation();
      ol_ext_element.setStyle(dragElt, { top: pageY - ol_ext_element.offsetRect(panel).top + panel.scrollTop + 5 });
      var li;
      if (!e3.touches) {
        li = e3.target;
      } else {
        li = document.elementFromPoint(e3.touches[0].clientX, e3.touches[0].clientY);
      }
      if (li.classList.contains("ol-switcherbottomdiv")) {
        self2.overflow(-1);
      } else if (li.classList.contains("ol-switchertopdiv")) {
        self2.overflow(1);
      }
      while (li && li.tagName !== "LI") {
        li = li.parentNode;
      }
      if (!li || !li.classList.contains("dropover")) {
        elt.parentNode.querySelectorAll("li").forEach(function(li2) {
          li2.classList.remove("dropover");
          li2.classList.remove("dropover-after");
          li2.classList.remove("dropover-before");
        });
      }
      if (li && li.parentNode.classList.contains("drag") && li !== elt) {
        target = self2._getLayerForLI(li);
        if (target && !target.get("allwaysOnTop") == !layer.get("allwaysOnTop")) {
          li.classList.add("dropover");
          li.classList.add(elt.offsetTop < li.offsetTop ? "dropover-after" : "dropover-before");
        } else {
          target = false;
        }
        ol_ext_element.show(dragElt);
      } else {
        target = false;
        if (li === elt)
          ol_ext_element.hide(dragElt);
        else
          ol_ext_element.show(dragElt);
      }
      if (!target)
        dragElt.classList.add("forbidden");
      else
        dragElt.classList.remove("forbidden");
    }
  }
  ol_ext_element.addListener(document, "mousemove touchmove", move);
  ol_ext_element.addListener(document, "mouseup touchend touchcancel", stop);
};
ol_control_LayerSwitcher.prototype.dragOpacity_ = function(e2) {
  e2.stopPropagation();
  e2.preventDefault();
  var self2 = this;
  var elt = e2.target;
  var layer = this._getLayerForLI(elt.parentNode.parentNode.parentNode);
  if (!layer)
    return;
  var x2 = e2.pageX || e2.touches && e2.touches.length && e2.touches[0].pageX || e2.changedTouches && e2.changedTouches.length && e2.changedTouches[0].pageX;
  var start2 = ol_ext_element.getStyle(elt, "left") - x2;
  self2.dragging_ = true;
  function stop() {
    ol_ext_element.removeListener(document, "mouseup touchend touchcancel", stop);
    ol_ext_element.removeListener(document, "mousemove touchmove", move);
    self2.dragging_ = false;
  }
  function move(e3) {
    var x3 = e3.pageX || e3.touches && e3.touches.length && e3.touches[0].pageX || e3.changedTouches && e3.changedTouches.length && e3.changedTouches[0].pageX;
    var delta = (start2 + x3) / ol_ext_element.getStyle(elt.parentNode, "width");
    var opacity2 = Math.max(0, Math.min(1, delta));
    ol_ext_element.setStyle(elt, { left: opacity2 * 100 + "%" });
    elt.parentNode.nextElementSibling.innerHTML = Math.round(opacity2 * 100);
    layer.setOpacity(opacity2);
  }
  ol_ext_element.addListener(document, "mouseup touchend touchcancel", stop);
  ol_ext_element.addListener(document, "mousemove touchmove", move);
};
ol_control_LayerSwitcher.prototype.drawList = function(ul, collection) {
  var self2 = this;
  var layers = collection.getArray();
  var setVisibility = function(e2) {
    e2.stopPropagation();
    e2.preventDefault();
    var l2 = self2._getLayerForLI(this.parentNode.parentNode);
    self2.switchLayerVisibility(l2, collection);
    if (self2.get("selection") && l2.getVisible()) {
      self2.selectLayer(l2);
    }
    if (self2.onchangeCheck) {
      self2.onchangeCheck(l2);
    }
  };
  function onInfo(e2) {
    e2.stopPropagation();
    e2.preventDefault();
    var l2 = self2._getLayerForLI(this.parentNode.parentNode);
    self2.oninfo(l2);
    self2.dispatchEvent({ type: "info", layer: l2 });
  }
  function zoomExtent(e2) {
    e2.stopPropagation();
    e2.preventDefault();
    var l2 = self2._getLayerForLI(this.parentNode.parentNode);
    if (self2.onextent)
      self2.onextent(l2);
    else
      self2.getMap().getView().fit(l2.getExtent(), self2.getMap().getSize());
    self2.dispatchEvent({ type: "extent", layer: l2 });
  }
  function removeLayer(e2) {
    e2.stopPropagation();
    e2.preventDefault();
    var li = this.parentNode.parentNode.parentNode.parentNode;
    var layer, group = self2._getLayerForLI(li);
    if (group) {
      layer = self2._getLayerForLI(this.parentNode.parentNode);
      group.getLayers().remove(layer);
      if (group.getLayers().getLength() == 0 && !group.get("noSwitcherDelete")) {
        removeLayer.call(li.querySelectorAll(".layerTrash")[0], e2);
      }
    } else {
      li = this.parentNode.parentNode;
      self2.getMap().removeLayer(self2._getLayerForLI(li));
    }
  }
  function createLi(layer) {
    if (!this.displayInLayerSwitcher(layer)) {
      this._setLayerForLI(null, layer);
      return;
    }
    var li = ol_ext_element.create("LI", {
      className: (layer.getVisible() ? "visible " : " ") + (layer.get("baseLayer") ? "baselayer" : ""),
      parent: ul
    });
    this._setLayerForLI(li, layer);
    if (this._selectedLayer === layer) {
      li.classList.add("ol-layer-select");
    }
    var layer_buttons = ol_ext_element.create("DIV", {
      className: "ol-layerswitcher-buttons",
      parent: li
    });
    var d2 = ol_ext_element.create("DIV", {
      className: "li-content",
      parent: li
    });
    ol_ext_element.create("INPUT", {
      type: layer.get("baseLayer") ? "radio" : "checkbox",
      className: "ol-visibility",
      checked: layer.getVisible(),
      click: setVisibility,
      parent: d2
    });
    var label = ol_ext_element.create("LABEL", {
      title: layer.get("title") || layer.get("name"),
      click: setVisibility,
      unselectable: "on",
      style: {
        userSelect: "none"
      },
      parent: d2
    });
    label.addEventListener("selectstart", function() {
      return false;
    });
    ol_ext_element.create("SPAN", {
      html: layer.get("title") || layer.get("name"),
      click: function(e2) {
        if (this.get("selection")) {
          e2.stopPropagation();
          this.selectLayer(layer);
        }
      }.bind(this),
      parent: label
    });
    if (this.reordering) {
      if (i2 < layers.length - 1 && (layer.get("allwaysOnTop") || !layers[i2 + 1].get("allwaysOnTop")) || i2 > 0 && (!layer.get("allwaysOnTop") || layers[i2 - 1].get("allwaysOnTop"))) {
        ol_ext_element.create("DIV", {
          className: "layerup ol-noscroll",
          title: this.tip.up,
          on: { "mousedown touchstart": function(e2) {
            self2.dragOrdering_(e2);
          } },
          parent: layer_buttons
        });
      }
    }
    if (layer.getLayers) {
      var nb = 0;
      layer.getLayers().forEach(function(l2) {
        if (self2.displayInLayerSwitcher(l2))
          nb++;
      });
      if (nb) {
        ol_ext_element.create("DIV", {
          className: layer.get("openInLayerSwitcher") ? "collapse-layers" : "expend-layers",
          title: this.tip.plus,
          click: function() {
            var l2 = self2._getLayerForLI(this.parentNode.parentNode);
            l2.set("openInLayerSwitcher", !l2.get("openInLayerSwitcher"));
          },
          parent: layer_buttons
        });
      }
    }
    if (this.oninfo) {
      ol_ext_element.create("DIV", {
        className: "layerInfo",
        title: this.tip.info,
        click: onInfo,
        parent: layer_buttons
      });
    }
    if (this.hastrash && !layer.get("noSwitcherDelete")) {
      ol_ext_element.create("DIV", {
        className: "layerTrash",
        title: this.tip.trash,
        click: removeLayer,
        parent: layer_buttons
      });
    }
    if (this.hasextent && layers[i2].getExtent()) {
      var ex = layers[i2].getExtent();
      if (ex.length == 4 && ex[0] < ex[2] && ex[1] < ex[3]) {
        ol_ext_element.create("DIV", {
          className: "layerExtent",
          title: this.tip.extent,
          click: zoomExtent,
          parent: layer_buttons
        });
      }
    }
    if (this.show_progress && layer instanceof TileLayer$1) {
      var p5 = ol_ext_element.create("DIV", {
        className: "layerswitcher-progress",
        parent: d2
      });
      this.setprogress_(layer);
      layer.layerswitcher_progress = ol_ext_element.create("DIV", { parent: p5 });
    }
    var opacity2 = ol_ext_element.create("DIV", {
      className: "layerswitcher-opacity",
      click: function(e2) {
        if (e2.target !== this)
          return;
        e2.stopPropagation();
        e2.preventDefault();
        var op = Math.max(0, Math.min(1, e2.offsetX / ol_ext_element.getStyle(this, "width")));
        self2._getLayerForLI(this.parentNode.parentNode).setOpacity(op);
      },
      parent: d2
    });
    ol_ext_element.create("DIV", {
      className: "layerswitcher-opacity-cursor ol-noscroll",
      style: { left: layer.getOpacity() * 100 + "%" },
      on: {
        "mousedown touchstart": function(e2) {
          self2.dragOpacity_(e2);
        }
      },
      parent: opacity2
    });
    ol_ext_element.create("DIV", {
      className: "layerswitcher-opacity-label",
      html: Math.round(layer.getOpacity() * 100),
      parent: d2
    });
    if (layer.getLayers) {
      li.classList.add("ol-layer-group");
      if (layer.get("openInLayerSwitcher") === true) {
        var ul2 = ol_ext_element.create("UL", {
          parent: li
        });
        this.drawList(ul2, layer.getLayers());
      }
    }
    li.classList.add(this.getLayerClass(layer));
    this.dispatchEvent({ type: "drawlist", layer, li });
  }
  for (var i2 = layers.length - 1; i2 >= 0; i2--) {
    createLi.call(this, layers[i2]);
  }
  this.viewChange();
  if (ul === this.panel_)
    this.overflow();
};
ol_control_LayerSwitcher.prototype.getLayerClass = function(layer) {
  if (!layer)
    return "none";
  if (layer.getLayers)
    return "ol-layer-group";
  if (layer instanceof VectorLayer$1)
    return "ol-layer-vector";
  if (layer instanceof VectorTileLayer)
    return "ol-layer-vectortile";
  if (layer instanceof TileLayer$1)
    return "ol-layer-tile";
  if (layer instanceof ImageLayer$1)
    return "ol-layer-image";
  if (layer instanceof Heatmap)
    return "ol-layer-heatmap";
  if (layer.getFeatures)
    return "ol-layer-vectorimage";
  return "unknown";
};
ol_control_LayerSwitcher.prototype.selectLayer = function(layer, silent) {
  if (!layer) {
    if (!this.getMap())
      return;
    layer = this.getMap().getLayers().item(this.getMap().getLayers().getLength() - 1);
  }
  this._selectedLayer = layer;
  this.drawPanel();
  if (!silent)
    this.dispatchEvent({ type: "select", layer });
};
ol_control_LayerSwitcher.prototype.getSelection = function() {
  return this._selectedLayer;
};
ol_control_LayerSwitcher.prototype.setprogress_ = function(layer) {
  if (!layer.layerswitcher_progress) {
    var loaded = 0;
    var loading = 0;
    var draw = function() {
      if (loading === loaded) {
        loading = loaded = 0;
        ol_ext_element.setStyle(layer.layerswitcher_progress, { width: 0 });
      } else {
        ol_ext_element.setStyle(layer.layerswitcher_progress, { width: (loaded / loading * 100).toFixed(1) + "%" });
      }
    };
    layer.getSource().on("tileloadstart", function() {
      loading++;
      draw();
    });
    layer.getSource().on("tileloadend", function() {
      loaded++;
      draw();
    });
    layer.getSource().on("tileloaderror", function() {
      loaded++;
      draw();
    });
  }
};
const _sfc_main$u = {
  name: "ol-layerswitcher-control",
  setup(props, context2) {
    const {
      control
    } = useControl(ol_control_LayerSwitcher, props, context2);
    return {
      control
    };
  },
  props: {
    selection: {
      type: Boolean
    },
    displayInLayerSwitcher: {
      type: Function
    },
    show_progress: {
      type: Boolean,
      default: false
    },
    mouseover: {
      type: Boolean,
      default: false
    },
    reordering: {
      type: Boolean,
      default: true
    },
    trash: {
      type: Boolean,
      default: false
    },
    oninfo: {
      type: Function
    },
    extent: {
      type: Boolean
    },
    onextent: {
      type: Function
    },
    drawDelay: {
      type: Number
    },
    collapsed: {
      type: Boolean,
      default: true
    },
    layerGroup: {
      type: Object
    },
    noScroll: {
      type: Boolean,
      default: false
    }
  }
};
function _sfc_render$u(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var LayerSwitcherControl = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["render", _sfc_render$u]]);
Source.prototype.getPreview = function() {
  return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAk6QAAJOkBUCTn+AAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAANeSURBVHic7ZpPiE1RHMc/780MBhkik79JSUlIUbOxI+wkI2yRhYSUlJLNpJF/xcpiJBmZGBZsNM1CkmhKITGkGbH0/BuPmXnP4rxbb/TOn3fvOffeec6nfqvb/b7f93fveeec37ng8Xg8Ho/nf6Uu4d+fDswFssCvhHOJhaXAMeApMAQUyyIPPAdOAiuTStAVy4EHjDWsix5gdRLJ2mY34ulWYz6IEeA4kIk9awtkgTOEM/5vdAKT4k0/Ou3YMR/ELcbRm9AKFLBbgCJwNE4TYZkJfMG++SIwDCyLz0o4bI17WdyJz0r1TAZ+oDcxCBwAFgIzEIuhvcBbg3sLwOK4DFXLFvQGniCGSSUagS4DjUPOHESkA3XiOWCORqMR6Nfo9DjI3QqPUSd+ylBnv0Zn0GrWFvmIOvGNhjqrNDp/EAutyFgRKUM2tgO+Gur81FxvAKYZaimxXYBvmuuLDHWWaK4X0RfJCNsF6NdcbzXU2a65PohYFKWOc+jn8PUajbWIXaBKp9NB7lZYh34OzwFbFfd/NtDYYSth27urLGIm0M31AL3APWAAmIooymaDnPIl/Vz4NN1yHrd7gcvxWQnHAuA3bsyPop8hUsE13BSgK04TUViBeFo2zedJ8S6wElexW4D2eNOPTjNi6WvD/DtEr8E6tk6GGoAmxFY2iFHE9NZiQf8gogiB9gTEH23izAZuE77vHyU+ANucO1QwD3hD/MbLowAcdm20EmkwXx4n3NodS9rMB2HabYpEWs0HcRqHp0fNwAvJD+eBTZr7p6BvmQVxUaEzEbiruNfJekH15L8jtrEm7JJolEcOmKXRqQOuKDQuY7HZY8s8iNfzkSLxIuI43FTrkkLnOlBfRW4VsWk+oAX5weknxFAxJQNckGgVgZuIRVoomoGXEmGTMa+iQ6K7M4SW7k24QYgiuDQPYinbhugiF4H3RGtzZYCzyIvQXfpNI1ybLyeLpf5+iTbkRbiP2EcocTHm4+YI8iI8RFHwWjAfsA95Q+YZFU6wasl8wB7kReijtNbIILa0vcg/PRlGfPQwHmlCviDqAzaA+OREtzqr1ejOIDorxlNEjTGUBV4nnUWCvAJxGDlA8q9j3DEArAn2zvXAfOwfl6eVAmJrPpJ0Ih6Px+PxeJLjLwPul3vj5d0eAAAAAElFTkSuQmCC";
};
TileSource.prototype.getPreview = function(lonlat, resolution) {
  if (!lonlat)
    lonlat = [21020, 6355964];
  if (!resolution)
    resolution = 150;
  var coord = this.getTileGrid().getTileCoordForCoordAndResolution(lonlat, resolution);
  var fn = this.getTileUrlFunction();
  return fn.call(this, coord, this.getProjection());
};
TileWMS.prototype.getPreview = function(lonlat, resolution) {
  if (!lonlat)
    lonlat = [21020, 6355964];
  if (!resolution)
    resolution = 150;
  var fn = this.getTileUrlFunction();
  if (fn) {
    var tileGrid = this.getTileGrid() || this.getTileGridForProjection(this.getProjection());
    var coord = tileGrid.getTileCoordForCoordAndResolution(lonlat, resolution);
    return fn.call(this, coord, 1, this.getProjection());
  }
  var url = this.getGetFeatureInfoUrl ? this.getGetFeatureInfoUrl(lonlat, resolution, this.getProjection() || "EPSG:3857", {}) : this.getFeatureInfoUrl(lonlat, resolution, this.getProjection() || "EPSG:3857", {});
  url = url.replace(/getfeatureinfo/i, "GetMap");
  return url;
};
Layer.prototype.getPreview = function(lonlat, resolution, projection) {
  if (this.get("preview"))
    return [this.get("preview")];
  if (!resolution)
    resolution = 150;
  if (resolution < this.getMinResolution() || resolution > this.getMaxResolution()) {
    var rmin = this.getMinResolution(), rmax = this.getMaxResolution();
    if (rmax > 1e5)
      rmax = 156543;
    if (rmin < 0.15)
      rmin = 0.15;
    resolution = rmax;
    while (rmax > rmin) {
      rmin *= 2;
      rmax /= 2;
      resolution = rmin;
    }
  }
  var e2 = this.getExtent();
  if (!lonlat)
    lonlat = [21020, 6355964];
  if (e2 && !containsCoordinate(e2, lonlat))
    lonlat = [(e2[0] + e2[2]) / 2, (e2[1] + e2[3]) / 2];
  if (projection)
    lonlat = transform$3(lonlat, projection, this.getSource().getProjection());
  if (this.getSource && this.getSource()) {
    return [this.getSource().getPreview(lonlat, resolution)];
  }
  return [];
};
LayerGroup.prototype.getPreview = function(lonlat, resolution) {
  if (this.get("preview"))
    return [this.get("preview")];
  var t3 = [];
  if (this.getLayers) {
    var l2 = this.getLayers().getArray();
    for (var i2 = 0; i2 < l2.length; i2++) {
      t3 = t3.concat(l2[i2].getPreview(lonlat, resolution));
    }
  }
  return t3;
};
var ol_control_LayerSwitcherImage = function(options) {
  options = options || {};
  options.switcherClass = "ol-layerswitcher-image";
  if (options.mouseover !== false)
    options.mouseover = true;
  ol_control_LayerSwitcher.call(this, options);
};
ol_ext_inherits(ol_control_LayerSwitcherImage, ol_control_LayerSwitcher);
ol_control_LayerSwitcherImage.prototype.drawList = function(ul, layers) {
  var self2 = this;
  var setVisibility = function(e2) {
    e2.preventDefault();
    var l2 = self2._getLayerForLI(this);
    self2.switchLayerVisibility(l2, layers);
    if (e2.type == "touchstart")
      self2.element.classList.add("ol-collapsed");
  };
  ol_ext_element.setStyle(ul, { height: "auto" });
  layers.forEach(function(layer) {
    if (self2.displayInLayerSwitcher(layer)) {
      var preview = layer.getPreview ? layer.getPreview() : ["none"];
      var d2 = ol_ext_element.create("LI", {
        className: "ol-imgcontainer" + (layer.getVisible() ? " ol-visible" : ""),
        on: { "touchstart click": setVisibility },
        parent: ul
      });
      self2._setLayerForLI(d2, layer);
      preview.forEach(function(img) {
        ol_ext_element.create("IMG", {
          src: img,
          parent: d2
        });
      });
      ol_ext_element.create("p", {
        html: layer.get("title") || layer.get("name"),
        parent: d2
      });
      if (self2.testLayerVisibility(layer))
        d2.classList.add("ol-layer-hidden");
    }
  });
};
ol_control_LayerSwitcherImage.prototype.overflow = function() {
};
const _sfc_main$t = {
  name: "ol-layerswitcherimage-control",
  extends: LayerSwitcherControl,
  setup(props, context2) {
    const {
      control
    } = useControl(ol_control_LayerSwitcherImage, props, context2);
    return {
      control
    };
  }
};
function _sfc_render$t(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var LayerSwitcherImageControl = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["render", _sfc_render$t]]);
var ol_control_MapZone = function(options) {
  if (!options)
    options = {};
  var element = document.createElement("div");
  if (options.target) {
    element = ol_ext_element.create("DIV", {
      className: options.className || "ol-mapzone"
    });
  } else {
    element = ol_ext_element.create("DIV", {
      className: (options.className || "ol-mapzone") + " ol-unselectable ol-control ol-collapsed"
    });
    var bt2 = ol_ext_element.create("BUTTON", {
      type: "button",
      on: {
        "click": function() {
          element.classList.toggle("ol-collapsed");
          maps.forEach(function(m2) {
            m2.updateSize();
          });
        }.bind(this)
      },
      parent: element
    });
    ol_ext_element.create("I", {
      parent: bt2
    });
  }
  Control$1.call(this, {
    element,
    target: options.target
  });
  this.set("centerOnClick", options.centerOnClick);
  var maps = this._maps = [];
  this._projection = options.projection;
  this._layer = options.layer;
  options.zones.forEach(this.addZone.bind(this));
  setTimeout(function() {
    maps.forEach(function(m2) {
      m2.updateSize();
    });
  });
};
ol_ext_inherits(ol_control_MapZone, Control$1);
ol_control_MapZone.prototype.setCollapsed = function(b2) {
  if (b2) {
    this.element.classList.remove("ol-collapsed");
    this.getMaps().forEach(function(m2) {
      m2.updateSize();
    });
  } else {
    this.element.classList.add("ol-collapsed");
  }
};
ol_control_MapZone.prototype.getCollapsed = function() {
  return this.element.classList.contains("ol-collapsed");
};
ol_control_MapZone.prototype.setVisible = ol_control_MapZone.prototype.setCollapsed;
ol_control_MapZone.prototype.getMaps = function() {
  return this._maps;
};
ol_control_MapZone.prototype.getLength = function() {
  return this._maps.length;
};
ol_control_MapZone.prototype.addZone = function(z2) {
  var view = new View$1({ zoom: 6, center: [0, 0], projection: this._projection });
  var extent2;
  if (z2.map) {
    extent2 = transformExtent(z2.map.getView().calculateExtent(), z2.map.getView().getProjection(), view.getProjection());
  } else {
    extent2 = transformExtent(z2.extent, "EPSG:4326", view.getProjection());
  }
  var div = ol_ext_element.create("DIV", {
    className: "ol-mapzonezone",
    parent: this.element,
    click: function() {
      var index2 = -1;
      this._maps.forEach(function(m2, i2) {
        if (m2.get("zone") === z2) {
          index2 = i2;
        }
      });
      this.dispatchEvent({
        type: "select",
        zone: z2,
        index: index2,
        coordinate: getCenter(extent2),
        extent: extent2
      });
      if (this.get("centerOnClick") !== false) {
        this.getMap().getView().fit(extent2);
      }
      this.setVisible(false);
    }.bind(this)
  });
  var layer;
  if (z2.layer) {
    layer = z2.layer;
  } else if (typeof this._layer === "function") {
    layer = this._layer(z2);
  } else {
    layer = new this._layer.constructor({
      source: this._layer.getSource()
    });
  }
  var map = new Map$3({
    target: div,
    view,
    controls: [],
    interactions: [],
    layers: [layer]
  });
  map.set("zone", z2);
  this._maps.push(map);
  view.fit(extent2);
  ol_ext_element.create("P", {
    html: z2.title,
    parent: div
  });
};
ol_control_MapZone.prototype.removeZone = function(index2) {
  var z2 = this.element.querySelectorAll(".ol-mapzonezone")[index2];
  if (z2) {
    z2.remove();
    this._maps.splice(index2, 1);
  }
};
ol_control_MapZone.zones = {};
ol_control_MapZone.zones.DOM = [{
  "title": "Guadeloupe",
  "extent": [-61.898594315312444, 15.75623038647845, -60.957887532935324, 16.575317670979473]
}, {
  "title": "Guyane",
  "extent": [-54.72525931072715, 2.1603763430019, -51.528236062921344, 5.7984307809552575]
}, {
  "title": "Martinique",
  "extent": [-61.257556528564756, 14.387506317407514, -60.76934912110432, 14.895067461729951]
}, {
  "title": "Mayotte",
  "extent": [44.959844536967815, -13.01674138212816, 45.35328866510648, -12.65521942207829]
}, {
  "title": "La r\xE9union",
  "extent": [55.17059012967656, -21.407680069231688, 55.88195702001797, -20.85560221637526]
}];
ol_control_MapZone.zones.TOM = [{
  "title": "Polyn\xE9sie Fran\xE7aise",
  "extent": [206.23664226630862, -22.189040615809787, 221.85920743981987, -10.835039595040698]
}, {
  "title": "Nouvelle Cal\xE9donie",
  "extent": [163.76420580160925, -22.581641092751838, 167.66984709498706, -19.816411635668445]
}, {
  "title": "St-Pierre et Miquelon",
  "extent": [-56.453698765748676, 46.74449858188555, -56.0980198121544, 47.14669874229787]
}, {
  "title": "Wallis et Futuna",
  "extent": [181.7588623143665, -14.7341169873267, 183.95612353301715, -13.134720799175085]
}, {
  "title": "St-Martin St-Barth\xE9lemy",
  "extent": [-63.1726389501678, 17.806097291313506, -62.7606535945649, 18.13267688837938]
}];
ol_control_MapZone.zones.DOMTOM = [{
  title: "M\xE9tropole",
  extent: [-5.318421740712579, 41.16082274292913, 9.73284186155716, 51.21957336557702]
}].concat(ol_control_MapZone.zones.DOM, ol_control_MapZone.zones.TOM);
const _sfc_main$s = {
  name: "ol-zone-control",
  setup(props, context2) {
    const {
      control
    } = useControl(ol_control_MapZone, props, context2);
    return {
      control
    };
  },
  props: {
    className: {
      type: String
    },
    zones: {
      type: Array
    },
    layer: {
      type: [Object, Function]
    },
    projection: {
      type: String,
      default: "EPSG:3857"
    },
    centerOnClick: {
      type: Boolean,
      default: true
    }
  }
};
function _sfc_render$s(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var ZoneControl = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["render", _sfc_render$s]]);
function install$5(app) {
  if (install$5.installed) {
    return;
  }
  install$5.installed = true;
  app.component(FullScreenControl.name, FullScreenControl);
  app.component(MousePositionControl.name, MousePositionControl);
  app.component(AttributionControl.name, AttributionControl);
  app.component(OverviewMapControl.name, OverviewMapControl);
  app.component(ScaleLineControl.name, ScaleLineControl);
  app.component(ZoomControl.name, ZoomControl);
  app.component(ZoomSliderControl.name, ZoomSliderControl);
  app.component(ZoomToExtentControl.name, ZoomToExtentControl);
  app.component(RotateControl.name, RotateControl);
  app.component(ContextMenuControl.name, ContextMenuControl);
  app.component(SwipeControl.name, SwipeControl);
  app.component(ControlBar.name, ControlBar);
  app.component(ToggleControl.name, ToggleControl);
  app.component(ButtonControl.name, ButtonControl);
  app.component(PrintDialog.name, PrintDialog);
  app.component(VideoRecorderControl.name, VideoRecorderControl);
  app.component(LayerSwitcherControl.name, LayerSwitcherControl);
  app.component(LayerSwitcherImageControl.name, LayerSwitcherImageControl);
  app.component(ZoneControl.name, ZoneControl);
}
var MapControls = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": install$5,
  install: install$5,
  FullScreenControl,
  MousePositionControl,
  AttributionControl,
  OverviewMapControl,
  ScaleLineControl,
  ZoomControl,
  ZoomSliderControl,
  ZoomToExtentControl,
  ContextMenuControl,
  SwipeControl,
  ControlBar,
  ToggleControl,
  ButtonControl,
  PrintDialog,
  VideoRecorderControl,
  LayerSwitcherControl,
  LayerSwitcherImageControl,
  ZoneControl
}, Symbol.toStringTag, { value: "Module" }));
function useGeometry(GeometryType, props) {
  const feature = inject("feature");
  const {
    properties
  } = usePropsAsObjectProperties(props);
  let geometry = computed(() => new GeometryType(...Object.values(properties)));
  watch(properties, () => {
    feature.value.setGeometry(geometry.value);
    feature.value.changed();
  });
  watch(feature, () => {
    feature.value.setGeometry(geometry.value);
  });
  onMounted(() => {
    feature.value.setGeometry(geometry.value);
  });
  onUnmounted(() => {
    feature.value.setGeometry(null);
  });
  return {
    geometry
  };
}
const _sfc_main$r = {
  name: "ol-geom-point",
  setup(props) {
    const {
      geometry
    } = useGeometry(Point$3, props);
    return {
      geometry
    };
  },
  props: {
    coordinates: {
      type: Array
    },
    opt_layout: {
      type: String,
      default: "XY"
    }
  }
};
function _sfc_render$r(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var Point$1 = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["render", _sfc_render$r]]);
const _sfc_main$q = {
  name: "ol-geom-line-string",
  setup(props) {
    const {
      geometry
    } = useGeometry(LineString$1, props);
    return {
      geometry
    };
  },
  props: {
    coordinates: {
      type: Array
    },
    opt_layout: {
      type: String,
      default: "XY"
    }
  }
};
function _sfc_render$q(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var LineString = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["render", _sfc_render$q]]);
const _sfc_main$p = {
  name: "ol-geom-polygon",
  setup(props) {
    const {
      geometry
    } = useGeometry(Polygon$1, props);
    return {
      geometry
    };
  },
  props: {
    coordinates: {
      type: Array
    },
    opt_layout: {
      type: String,
      default: "XY"
    }
  }
};
function _sfc_render$p(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var Polygon = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["render", _sfc_render$p]]);
class MultiPoint$1 extends SimpleGeometry {
  constructor(coordinates2, layout) {
    super();
    if (layout && !Array.isArray(coordinates2[0])) {
      this.setFlatCoordinates(layout, coordinates2);
    } else {
      this.setCoordinates(coordinates2, layout);
    }
  }
  appendPoint(point) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = point.getFlatCoordinates().slice();
    } else {
      extend$3(this.flatCoordinates, point.getFlatCoordinates());
    }
    this.changed();
  }
  clone() {
    const multiPoint = new MultiPoint$1(this.flatCoordinates.slice(), this.layout);
    multiPoint.applyProperties(this);
    return multiPoint;
  }
  closestPointXY(x2, y2, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x2, y2)) {
      return minSquaredDistance;
    }
    const flatCoordinates = this.flatCoordinates;
    const stride = this.stride;
    for (let i2 = 0, ii = flatCoordinates.length; i2 < ii; i2 += stride) {
      const squaredDistance2 = squaredDistance$1(x2, y2, flatCoordinates[i2], flatCoordinates[i2 + 1]);
      if (squaredDistance2 < minSquaredDistance) {
        minSquaredDistance = squaredDistance2;
        for (let j2 = 0; j2 < stride; ++j2) {
          closestPoint[j2] = flatCoordinates[i2 + j2];
        }
        closestPoint.length = stride;
      }
    }
    return minSquaredDistance;
  }
  getCoordinates() {
    return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  }
  getPoint(index2) {
    const n2 = !this.flatCoordinates ? 0 : this.flatCoordinates.length / this.stride;
    if (index2 < 0 || n2 <= index2) {
      return null;
    }
    return new Point$3(this.flatCoordinates.slice(index2 * this.stride, (index2 + 1) * this.stride), this.layout);
  }
  getPoints() {
    const flatCoordinates = this.flatCoordinates;
    const layout = this.layout;
    const stride = this.stride;
    const points = [];
    for (let i2 = 0, ii = flatCoordinates.length; i2 < ii; i2 += stride) {
      const point = new Point$3(flatCoordinates.slice(i2, i2 + stride), layout);
      points.push(point);
    }
    return points;
  }
  getType() {
    return "MultiPoint";
  }
  intersectsExtent(extent2) {
    const flatCoordinates = this.flatCoordinates;
    const stride = this.stride;
    for (let i2 = 0, ii = flatCoordinates.length; i2 < ii; i2 += stride) {
      const x2 = flatCoordinates[i2];
      const y2 = flatCoordinates[i2 + 1];
      if (containsXY(extent2, x2, y2)) {
        return true;
      }
    }
    return false;
  }
  setCoordinates(coordinates2, layout) {
    this.setLayout(layout, coordinates2, 1);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates2, this.stride);
    this.changed();
  }
}
const _sfc_main$o = {
  name: "ol-geom-multi-point",
  setup(props) {
    const {
      geometry
    } = useGeometry(MultiPoint$1, props);
    return {
      geometry
    };
  },
  props: {
    coordinates: {
      type: Array
    },
    opt_layout: {
      type: String,
      default: "XY"
    }
  }
};
function _sfc_render$o(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var MultiPoint = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["render", _sfc_render$o]]);
class MultiLineString$1 extends SimpleGeometry {
  constructor(coordinates2, layout, ends) {
    super();
    this.ends_ = [];
    this.maxDelta_ = -1;
    this.maxDeltaRevision_ = -1;
    if (Array.isArray(coordinates2[0])) {
      this.setCoordinates(coordinates2, layout);
    } else if (layout !== void 0 && ends) {
      this.setFlatCoordinates(layout, coordinates2);
      this.ends_ = ends;
    } else {
      let layout2 = this.getLayout();
      const lineStrings = coordinates2;
      const flatCoordinates = [];
      const ends2 = [];
      for (let i2 = 0, ii = lineStrings.length; i2 < ii; ++i2) {
        const lineString = lineStrings[i2];
        if (i2 === 0) {
          layout2 = lineString.getLayout();
        }
        extend$3(flatCoordinates, lineString.getFlatCoordinates());
        ends2.push(flatCoordinates.length);
      }
      this.setFlatCoordinates(layout2, flatCoordinates);
      this.ends_ = ends2;
    }
  }
  appendLineString(lineString) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = lineString.getFlatCoordinates().slice();
    } else {
      extend$3(this.flatCoordinates, lineString.getFlatCoordinates().slice());
    }
    this.ends_.push(this.flatCoordinates.length);
    this.changed();
  }
  clone() {
    const multiLineString = new MultiLineString$1(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
    multiLineString.applyProperties(this);
    return multiLineString;
  }
  closestPointXY(x2, y2, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x2, y2)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));
      this.maxDeltaRevision_ = this.getRevision();
    }
    return assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, false, x2, y2, closestPoint, minSquaredDistance);
  }
  getCoordinateAtM(m2, extrapolate, interpolate) {
    if (this.layout != "XYM" && this.layout != "XYZM" || this.flatCoordinates.length === 0) {
      return null;
    }
    extrapolate = extrapolate !== void 0 ? extrapolate : false;
    interpolate = interpolate !== void 0 ? interpolate : false;
    return lineStringsCoordinateAtM(this.flatCoordinates, 0, this.ends_, this.stride, m2, extrapolate, interpolate);
  }
  getCoordinates() {
    return inflateCoordinatesArray(this.flatCoordinates, 0, this.ends_, this.stride);
  }
  getEnds() {
    return this.ends_;
  }
  getLineString(index2) {
    if (index2 < 0 || this.ends_.length <= index2) {
      return null;
    }
    return new LineString$1(this.flatCoordinates.slice(index2 === 0 ? 0 : this.ends_[index2 - 1], this.ends_[index2]), this.layout);
  }
  getLineStrings() {
    const flatCoordinates = this.flatCoordinates;
    const ends = this.ends_;
    const layout = this.layout;
    const lineStrings = [];
    let offset2 = 0;
    for (let i2 = 0, ii = ends.length; i2 < ii; ++i2) {
      const end = ends[i2];
      const lineString = new LineString$1(flatCoordinates.slice(offset2, end), layout);
      lineStrings.push(lineString);
      offset2 = end;
    }
    return lineStrings;
  }
  getFlatMidpoints() {
    const midpoints = [];
    const flatCoordinates = this.flatCoordinates;
    let offset2 = 0;
    const ends = this.ends_;
    const stride = this.stride;
    for (let i2 = 0, ii = ends.length; i2 < ii; ++i2) {
      const end = ends[i2];
      const midpoint = interpolatePoint(flatCoordinates, offset2, end, stride, 0.5);
      extend$3(midpoints, midpoint);
      offset2 = end;
    }
    return midpoints;
  }
  getSimplifiedGeometryInternal(squaredTolerance) {
    const simplifiedFlatCoordinates = [];
    const simplifiedEnds = [];
    simplifiedFlatCoordinates.length = douglasPeuckerArray(this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0, simplifiedEnds);
    return new MultiLineString$1(simplifiedFlatCoordinates, "XY", simplifiedEnds);
  }
  getType() {
    return "MultiLineString";
  }
  intersectsExtent(extent2) {
    return intersectsLineStringArray(this.flatCoordinates, 0, this.ends_, this.stride, extent2);
  }
  setCoordinates(coordinates2, layout) {
    this.setLayout(layout, coordinates2, 2);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    const ends = deflateCoordinatesArray(this.flatCoordinates, 0, coordinates2, this.stride, this.ends_);
    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
    this.changed();
  }
}
const _sfc_main$n = {
  name: "ol-geom-multi-line-string",
  setup(props) {
    const {
      geometry
    } = useGeometry(MultiLineString$1, props);
    return {
      geometry
    };
  },
  props: {
    coordinates: {
      type: Array
    },
    opt_layout: {
      type: String,
      default: "XY"
    }
  }
};
function _sfc_render$n(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var MultiLineString = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["render", _sfc_render$n]]);
function linearRingss(flatCoordinates, offset2, endss, stride) {
  const flatCenters = [];
  let extent2 = createEmpty();
  for (let i2 = 0, ii = endss.length; i2 < ii; ++i2) {
    const ends = endss[i2];
    extent2 = createOrUpdateFromFlatCoordinates(flatCoordinates, offset2, ends[0], stride);
    flatCenters.push((extent2[0] + extent2[2]) / 2, (extent2[1] + extent2[3]) / 2);
    offset2 = ends[ends.length - 1];
  }
  return flatCenters;
}
class MultiPolygon$1 extends SimpleGeometry {
  constructor(coordinates2, layout, endss) {
    super();
    this.endss_ = [];
    this.flatInteriorPointsRevision_ = -1;
    this.flatInteriorPoints_ = null;
    this.maxDelta_ = -1;
    this.maxDeltaRevision_ = -1;
    this.orientedRevision_ = -1;
    this.orientedFlatCoordinates_ = null;
    if (!endss && !Array.isArray(coordinates2[0])) {
      let thisLayout = this.getLayout();
      const polygons = coordinates2;
      const flatCoordinates = [];
      const thisEndss = [];
      for (let i2 = 0, ii = polygons.length; i2 < ii; ++i2) {
        const polygon = polygons[i2];
        if (i2 === 0) {
          thisLayout = polygon.getLayout();
        }
        const offset2 = flatCoordinates.length;
        const ends = polygon.getEnds();
        for (let j2 = 0, jj = ends.length; j2 < jj; ++j2) {
          ends[j2] += offset2;
        }
        extend$3(flatCoordinates, polygon.getFlatCoordinates());
        thisEndss.push(ends);
      }
      layout = thisLayout;
      coordinates2 = flatCoordinates;
      endss = thisEndss;
    }
    if (layout !== void 0 && endss) {
      this.setFlatCoordinates(layout, coordinates2);
      this.endss_ = endss;
    } else {
      this.setCoordinates(coordinates2, layout);
    }
  }
  appendPolygon(polygon) {
    let ends;
    if (!this.flatCoordinates) {
      this.flatCoordinates = polygon.getFlatCoordinates().slice();
      ends = polygon.getEnds().slice();
      this.endss_.push();
    } else {
      const offset2 = this.flatCoordinates.length;
      extend$3(this.flatCoordinates, polygon.getFlatCoordinates());
      ends = polygon.getEnds().slice();
      for (let i2 = 0, ii = ends.length; i2 < ii; ++i2) {
        ends[i2] += offset2;
      }
    }
    this.endss_.push(ends);
    this.changed();
  }
  clone() {
    const len = this.endss_.length;
    const newEndss = new Array(len);
    for (let i2 = 0; i2 < len; ++i2) {
      newEndss[i2] = this.endss_[i2].slice();
    }
    const multiPolygon = new MultiPolygon$1(this.flatCoordinates.slice(), this.layout, newEndss);
    multiPolygon.applyProperties(this);
    return multiPolygon;
  }
  closestPointXY(x2, y2, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x2, y2)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(multiArrayMaxSquaredDelta(this.flatCoordinates, 0, this.endss_, this.stride, 0));
      this.maxDeltaRevision_ = this.getRevision();
    }
    return assignClosestMultiArrayPoint(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, true, x2, y2, closestPoint, minSquaredDistance);
  }
  containsXY(x2, y2) {
    return linearRingssContainsXY(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x2, y2);
  }
  getArea() {
    return linearRingss$1(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);
  }
  getCoordinates(right) {
    let flatCoordinates;
    if (right !== void 0) {
      flatCoordinates = this.getOrientedFlatCoordinates().slice();
      orientLinearRingsArray(flatCoordinates, 0, this.endss_, this.stride, right);
    } else {
      flatCoordinates = this.flatCoordinates;
    }
    return inflateMultiCoordinatesArray(flatCoordinates, 0, this.endss_, this.stride);
  }
  getEndss() {
    return this.endss_;
  }
  getFlatInteriorPoints() {
    if (this.flatInteriorPointsRevision_ != this.getRevision()) {
      const flatCenters = linearRingss(this.flatCoordinates, 0, this.endss_, this.stride);
      this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, flatCenters);
      this.flatInteriorPointsRevision_ = this.getRevision();
    }
    return this.flatInteriorPoints_;
  }
  getInteriorPoints() {
    return new MultiPoint$1(this.getFlatInteriorPoints().slice(), "XYM");
  }
  getOrientedFlatCoordinates() {
    if (this.orientedRevision_ != this.getRevision()) {
      const flatCoordinates = this.flatCoordinates;
      if (linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)) {
        this.orientedFlatCoordinates_ = flatCoordinates;
      } else {
        this.orientedFlatCoordinates_ = flatCoordinates.slice();
        this.orientedFlatCoordinates_.length = orientLinearRingsArray(this.orientedFlatCoordinates_, 0, this.endss_, this.stride);
      }
      this.orientedRevision_ = this.getRevision();
    }
    return this.orientedFlatCoordinates_;
  }
  getSimplifiedGeometryInternal(squaredTolerance) {
    const simplifiedFlatCoordinates = [];
    const simplifiedEndss = [];
    simplifiedFlatCoordinates.length = quantizeMultiArray(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEndss);
    return new MultiPolygon$1(simplifiedFlatCoordinates, "XY", simplifiedEndss);
  }
  getPolygon(index2) {
    if (index2 < 0 || this.endss_.length <= index2) {
      return null;
    }
    let offset2;
    if (index2 === 0) {
      offset2 = 0;
    } else {
      const prevEnds = this.endss_[index2 - 1];
      offset2 = prevEnds[prevEnds.length - 1];
    }
    const ends = this.endss_[index2].slice();
    const end = ends[ends.length - 1];
    if (offset2 !== 0) {
      for (let i2 = 0, ii = ends.length; i2 < ii; ++i2) {
        ends[i2] -= offset2;
      }
    }
    return new Polygon$1(this.flatCoordinates.slice(offset2, end), this.layout, ends);
  }
  getPolygons() {
    const layout = this.layout;
    const flatCoordinates = this.flatCoordinates;
    const endss = this.endss_;
    const polygons = [];
    let offset2 = 0;
    for (let i2 = 0, ii = endss.length; i2 < ii; ++i2) {
      const ends = endss[i2].slice();
      const end = ends[ends.length - 1];
      if (offset2 !== 0) {
        for (let j2 = 0, jj = ends.length; j2 < jj; ++j2) {
          ends[j2] -= offset2;
        }
      }
      const polygon = new Polygon$1(flatCoordinates.slice(offset2, end), layout, ends);
      polygons.push(polygon);
      offset2 = end;
    }
    return polygons;
  }
  getType() {
    return "MultiPolygon";
  }
  intersectsExtent(extent2) {
    return intersectsLinearRingMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent2);
  }
  setCoordinates(coordinates2, layout) {
    this.setLayout(layout, coordinates2, 3);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    const endss = deflateMultiCoordinatesArray(this.flatCoordinates, 0, coordinates2, this.stride, this.endss_);
    if (endss.length === 0) {
      this.flatCoordinates.length = 0;
    } else {
      const lastEnds = endss[endss.length - 1];
      this.flatCoordinates.length = lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];
    }
    this.changed();
  }
}
const _sfc_main$m = {
  name: "ol-geom-multi-polygon",
  setup(props) {
    const {
      geometry
    } = useGeometry(MultiPolygon$1, props);
    return {
      geometry
    };
  },
  props: {
    coordinates: {
      type: Array
    },
    opt_layout: {
      type: String,
      default: "XY"
    }
  }
};
function _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var MultiPolygon = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["render", _sfc_render$m]]);
function install$4(app) {
  if (install$4.installed) {
    return;
  }
  install$4.installed = true;
  app.component(Point$1.name, Point$1);
  app.component(LineString.name, LineString);
  app.component(Polygon.name, Polygon);
  app.component(MultiPoint.name, MultiPoint);
  app.component(MultiLineString.name, MultiLineString);
  app.component(MultiPolygon.name, MultiPolygon);
}
var Geometries = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": install$4,
  install: install$4,
  Point: Point$1,
  LineString,
  Polygon,
  MultiPoint,
  MultiLineString,
  MultiPolygon
}, Symbol.toStringTag, { value: "Module" }));
class Circle$1 extends SimpleGeometry {
  constructor(center, radius, layout) {
    super();
    if (layout !== void 0 && radius === void 0) {
      this.setFlatCoordinates(layout, center);
    } else {
      radius = radius ? radius : 0;
      this.setCenterAndRadius(center, radius, layout);
    }
  }
  clone() {
    const circle = new Circle$1(this.flatCoordinates.slice(), void 0, this.layout);
    circle.applyProperties(this);
    return circle;
  }
  closestPointXY(x2, y2, closestPoint, minSquaredDistance) {
    const flatCoordinates = this.flatCoordinates;
    const dx = x2 - flatCoordinates[0];
    const dy = y2 - flatCoordinates[1];
    const squaredDistance2 = dx * dx + dy * dy;
    if (squaredDistance2 < minSquaredDistance) {
      if (squaredDistance2 === 0) {
        for (let i2 = 0; i2 < this.stride; ++i2) {
          closestPoint[i2] = flatCoordinates[i2];
        }
      } else {
        const delta = this.getRadius() / Math.sqrt(squaredDistance2);
        closestPoint[0] = flatCoordinates[0] + delta * dx;
        closestPoint[1] = flatCoordinates[1] + delta * dy;
        for (let i2 = 2; i2 < this.stride; ++i2) {
          closestPoint[i2] = flatCoordinates[i2];
        }
      }
      closestPoint.length = this.stride;
      return squaredDistance2;
    }
    return minSquaredDistance;
  }
  containsXY(x2, y2) {
    const flatCoordinates = this.flatCoordinates;
    const dx = x2 - flatCoordinates[0];
    const dy = y2 - flatCoordinates[1];
    return dx * dx + dy * dy <= this.getRadiusSquared_();
  }
  getCenter() {
    return this.flatCoordinates.slice(0, this.stride);
  }
  computeExtent(extent2) {
    const flatCoordinates = this.flatCoordinates;
    const radius = flatCoordinates[this.stride] - flatCoordinates[0];
    return createOrUpdate$2(flatCoordinates[0] - radius, flatCoordinates[1] - radius, flatCoordinates[0] + radius, flatCoordinates[1] + radius, extent2);
  }
  getRadius() {
    return Math.sqrt(this.getRadiusSquared_());
  }
  getRadiusSquared_() {
    const dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];
    const dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
    return dx * dx + dy * dy;
  }
  getType() {
    return "Circle";
  }
  intersectsExtent(extent2) {
    const circleExtent = this.getExtent();
    if (intersects$2(extent2, circleExtent)) {
      const center = this.getCenter();
      if (extent2[0] <= center[0] && extent2[2] >= center[0]) {
        return true;
      }
      if (extent2[1] <= center[1] && extent2[3] >= center[1]) {
        return true;
      }
      return forEachCorner(extent2, this.intersectsCoordinate.bind(this));
    }
    return false;
  }
  setCenter(center) {
    const stride = this.stride;
    const radius = this.flatCoordinates[stride] - this.flatCoordinates[0];
    const flatCoordinates = center.slice();
    flatCoordinates[stride] = flatCoordinates[0] + radius;
    for (let i2 = 1; i2 < stride; ++i2) {
      flatCoordinates[stride + i2] = center[i2];
    }
    this.setFlatCoordinates(this.layout, flatCoordinates);
    this.changed();
  }
  setCenterAndRadius(center, radius, layout) {
    this.setLayout(layout, center, 0);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    const flatCoordinates = this.flatCoordinates;
    let offset2 = deflateCoordinate(flatCoordinates, 0, center, this.stride);
    flatCoordinates[offset2++] = flatCoordinates[0] + radius;
    for (let i2 = 1, ii = this.stride; i2 < ii; ++i2) {
      flatCoordinates[offset2++] = flatCoordinates[i2];
    }
    flatCoordinates.length = offset2;
    this.changed();
  }
  getCoordinates() {
    return null;
  }
  setCoordinates(coordinates2, layout) {
  }
  setRadius(radius) {
    this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;
    this.changed();
  }
  rotate(angle2, anchor) {
    const center = this.getCenter();
    const stride = this.getStride();
    this.setCenter(rotate(center, 0, center.length, stride, angle2, anchor, center));
    this.changed();
  }
  translate(deltaX, deltaY) {
    const center = this.getCenter();
    const stride = this.getStride();
    this.setCenter(translate(center, 0, center.length, stride, deltaX, deltaY, center));
    this.changed();
  }
}
Circle$1.prototype.transform;
class GeometryCollection extends Geometry {
  constructor(geometries) {
    super();
    this.geometries_ = geometries ? geometries : null;
    this.changeEventsKeys_ = [];
    this.listenGeometriesChange_();
  }
  unlistenGeometriesChange_() {
    this.changeEventsKeys_.forEach(unlistenByKey);
    this.changeEventsKeys_.length = 0;
  }
  listenGeometriesChange_() {
    if (!this.geometries_) {
      return;
    }
    for (let i2 = 0, ii = this.geometries_.length; i2 < ii; ++i2) {
      this.changeEventsKeys_.push(listen(this.geometries_[i2], EventType.CHANGE, this.changed, this));
    }
  }
  clone() {
    const geometryCollection = new GeometryCollection(null);
    geometryCollection.setGeometries(this.geometries_);
    geometryCollection.applyProperties(this);
    return geometryCollection;
  }
  closestPointXY(x2, y2, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x2, y2)) {
      return minSquaredDistance;
    }
    const geometries = this.geometries_;
    for (let i2 = 0, ii = geometries.length; i2 < ii; ++i2) {
      minSquaredDistance = geometries[i2].closestPointXY(x2, y2, closestPoint, minSquaredDistance);
    }
    return minSquaredDistance;
  }
  containsXY(x2, y2) {
    const geometries = this.geometries_;
    for (let i2 = 0, ii = geometries.length; i2 < ii; ++i2) {
      if (geometries[i2].containsXY(x2, y2)) {
        return true;
      }
    }
    return false;
  }
  computeExtent(extent2) {
    createOrUpdateEmpty(extent2);
    const geometries = this.geometries_;
    for (let i2 = 0, ii = geometries.length; i2 < ii; ++i2) {
      extend$2(extent2, geometries[i2].getExtent());
    }
    return extent2;
  }
  getGeometries() {
    return cloneGeometries(this.geometries_);
  }
  getGeometriesArray() {
    return this.geometries_;
  }
  getGeometriesArrayRecursive() {
    let geometriesArray = [];
    const geometries = this.geometries_;
    for (let i2 = 0, ii = geometries.length; i2 < ii; ++i2) {
      if (geometries[i2].getType() === this.getType()) {
        geometriesArray = geometriesArray.concat(geometries[i2].getGeometriesArrayRecursive());
      } else {
        geometriesArray.push(geometries[i2]);
      }
    }
    return geometriesArray;
  }
  getSimplifiedGeometry(squaredTolerance) {
    if (this.simplifiedGeometryRevision !== this.getRevision()) {
      this.simplifiedGeometryMaxMinSquaredTolerance = 0;
      this.simplifiedGeometryRevision = this.getRevision();
    }
    if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance) {
      return this;
    }
    const simplifiedGeometries = [];
    const geometries = this.geometries_;
    let simplified = false;
    for (let i2 = 0, ii = geometries.length; i2 < ii; ++i2) {
      const geometry = geometries[i2];
      const simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);
      simplifiedGeometries.push(simplifiedGeometry);
      if (simplifiedGeometry !== geometry) {
        simplified = true;
      }
    }
    if (simplified) {
      const simplifiedGeometryCollection = new GeometryCollection(null);
      simplifiedGeometryCollection.setGeometriesArray(simplifiedGeometries);
      return simplifiedGeometryCollection;
    }
    this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
    return this;
  }
  getType() {
    return "GeometryCollection";
  }
  intersectsExtent(extent2) {
    const geometries = this.geometries_;
    for (let i2 = 0, ii = geometries.length; i2 < ii; ++i2) {
      if (geometries[i2].intersectsExtent(extent2)) {
        return true;
      }
    }
    return false;
  }
  isEmpty() {
    return this.geometries_.length === 0;
  }
  rotate(angle2, anchor) {
    const geometries = this.geometries_;
    for (let i2 = 0, ii = geometries.length; i2 < ii; ++i2) {
      geometries[i2].rotate(angle2, anchor);
    }
    this.changed();
  }
  scale(sx, sy, anchor) {
    if (!anchor) {
      anchor = getCenter(this.getExtent());
    }
    const geometries = this.geometries_;
    for (let i2 = 0, ii = geometries.length; i2 < ii; ++i2) {
      geometries[i2].scale(sx, sy, anchor);
    }
    this.changed();
  }
  setGeometries(geometries) {
    this.setGeometriesArray(cloneGeometries(geometries));
  }
  setGeometriesArray(geometries) {
    this.unlistenGeometriesChange_();
    this.geometries_ = geometries;
    this.listenGeometriesChange_();
    this.changed();
  }
  applyTransform(transformFn) {
    const geometries = this.geometries_;
    for (let i2 = 0, ii = geometries.length; i2 < ii; ++i2) {
      geometries[i2].applyTransform(transformFn);
    }
    this.changed();
  }
  translate(deltaX, deltaY) {
    const geometries = this.geometries_;
    for (let i2 = 0, ii = geometries.length; i2 < ii; ++i2) {
      geometries[i2].translate(deltaX, deltaY);
    }
    this.changed();
  }
  disposeInternal() {
    this.unlistenGeometriesChange_();
    super.disposeInternal();
  }
}
function cloneGeometries(geometries) {
  const clonedGeometries = [];
  for (let i2 = 0, ii = geometries.length; i2 < ii; ++i2) {
    clonedGeometries.push(geometries[i2].clone());
  }
  return clonedGeometries;
}
const DrawEventType = {
  DRAWSTART: "drawstart",
  DRAWEND: "drawend",
  DRAWABORT: "drawabort"
};
class DrawEvent extends BaseEvent {
  constructor(type, feature) {
    super(type);
    this.feature = feature;
  }
}
function getTraceTargets(coordinate, features) {
  const targets = [];
  for (let i2 = 0; i2 < features.length; ++i2) {
    const feature = features[i2];
    const geometry = feature.getGeometry();
    appendGeometryTraceTargets(coordinate, geometry, targets);
  }
  return targets;
}
function getSquaredDistance(a2, b2) {
  return squaredDistance$1(a2[0], a2[1], b2[0], b2[1]);
}
function getCoordinate(coordinates2, index2) {
  const count = coordinates2.length;
  if (index2 < 0) {
    return coordinates2[index2 + count];
  }
  if (index2 >= count) {
    return coordinates2[index2 - count];
  }
  return coordinates2[index2];
}
function getCumulativeSquaredDistance(coordinates2, startIndex, endIndex) {
  let lowIndex, highIndex;
  if (startIndex < endIndex) {
    lowIndex = startIndex;
    highIndex = endIndex;
  } else {
    lowIndex = endIndex;
    highIndex = startIndex;
  }
  const lowWholeIndex = Math.ceil(lowIndex);
  const highWholeIndex = Math.floor(highIndex);
  if (lowWholeIndex > highWholeIndex) {
    const start2 = interpolateCoordinate(coordinates2, lowIndex);
    const end = interpolateCoordinate(coordinates2, highIndex);
    return getSquaredDistance(start2, end);
  }
  let sd = 0;
  if (lowIndex < lowWholeIndex) {
    const start2 = interpolateCoordinate(coordinates2, lowIndex);
    const end = getCoordinate(coordinates2, lowWholeIndex);
    sd += getSquaredDistance(start2, end);
  }
  if (highWholeIndex < highIndex) {
    const start2 = getCoordinate(coordinates2, highWholeIndex);
    const end = interpolateCoordinate(coordinates2, highIndex);
    sd += getSquaredDistance(start2, end);
  }
  for (let i2 = lowWholeIndex; i2 < highWholeIndex - 1; ++i2) {
    const start2 = getCoordinate(coordinates2, i2);
    const end = getCoordinate(coordinates2, i2 + 1);
    sd += getSquaredDistance(start2, end);
  }
  return sd;
}
function appendGeometryTraceTargets(coordinate, geometry, targets) {
  if (geometry instanceof LineString$1) {
    appendTraceTarget(coordinate, geometry.getCoordinates(), false, targets);
    return;
  }
  if (geometry instanceof MultiLineString$1) {
    const coordinates2 = geometry.getCoordinates();
    for (let i2 = 0, ii = coordinates2.length; i2 < ii; ++i2) {
      appendTraceTarget(coordinate, coordinates2[i2], false, targets);
    }
    return;
  }
  if (geometry instanceof Polygon$1) {
    const coordinates2 = geometry.getCoordinates();
    for (let i2 = 0, ii = coordinates2.length; i2 < ii; ++i2) {
      appendTraceTarget(coordinate, coordinates2[i2], true, targets);
    }
    return;
  }
  if (geometry instanceof MultiPolygon$1) {
    const polys = geometry.getCoordinates();
    for (let i2 = 0, ii = polys.length; i2 < ii; ++i2) {
      const coordinates2 = polys[i2];
      for (let j2 = 0, jj = coordinates2.length; j2 < jj; ++j2) {
        appendTraceTarget(coordinate, coordinates2[j2], true, targets);
      }
    }
    return;
  }
  if (geometry instanceof GeometryCollection) {
    const geometries = geometry.getGeometries();
    for (let i2 = 0; i2 < geometries.length; ++i2) {
      appendGeometryTraceTargets(coordinate, geometries[i2], targets);
    }
    return;
  }
}
const sharedUpdateInfo = { index: -1, endIndex: NaN };
function getTraceTargetUpdate(coordinate, traceState, map, snapTolerance) {
  const x2 = coordinate[0];
  const y2 = coordinate[1];
  let closestTargetDistance = Infinity;
  let newTargetIndex = -1;
  let newEndIndex = NaN;
  for (let targetIndex = 0; targetIndex < traceState.targets.length; ++targetIndex) {
    const target = traceState.targets[targetIndex];
    const coordinates2 = target.coordinates;
    let minSegmentDistance = Infinity;
    let endIndex;
    for (let coordinateIndex = 0; coordinateIndex < coordinates2.length - 1; ++coordinateIndex) {
      const start2 = coordinates2[coordinateIndex];
      const end = coordinates2[coordinateIndex + 1];
      const rel = getPointSegmentRelationship(x2, y2, start2, end);
      if (rel.squaredDistance < minSegmentDistance) {
        minSegmentDistance = rel.squaredDistance;
        endIndex = coordinateIndex + rel.along;
      }
    }
    if (minSegmentDistance < closestTargetDistance) {
      closestTargetDistance = minSegmentDistance;
      if (target.ring && traceState.targetIndex === targetIndex) {
        if (target.endIndex > target.startIndex) {
          if (endIndex < target.startIndex) {
            endIndex += coordinates2.length;
          }
        } else if (target.endIndex < target.startIndex) {
          if (endIndex > target.startIndex) {
            endIndex -= coordinates2.length;
          }
        }
      }
      newEndIndex = endIndex;
      newTargetIndex = targetIndex;
    }
  }
  const newTarget = traceState.targets[newTargetIndex];
  let considerBothDirections = newTarget.ring;
  if (traceState.targetIndex === newTargetIndex && considerBothDirections) {
    const newCoordinate = interpolateCoordinate(newTarget.coordinates, newEndIndex);
    const pixel = map.getPixelFromCoordinate(newCoordinate);
    if (distance$1(pixel, traceState.startPx) > snapTolerance) {
      considerBothDirections = false;
    }
  }
  if (considerBothDirections) {
    const coordinates2 = newTarget.coordinates;
    const count = coordinates2.length;
    const startIndex = newTarget.startIndex;
    const endIndex = newEndIndex;
    if (startIndex < endIndex) {
      const forwardDistance = getCumulativeSquaredDistance(coordinates2, startIndex, endIndex);
      const reverseDistance = getCumulativeSquaredDistance(coordinates2, startIndex, endIndex - count);
      if (reverseDistance < forwardDistance) {
        newEndIndex -= count;
      }
    } else {
      const reverseDistance = getCumulativeSquaredDistance(coordinates2, startIndex, endIndex);
      const forwardDistance = getCumulativeSquaredDistance(coordinates2, startIndex, endIndex + count);
      if (forwardDistance < reverseDistance) {
        newEndIndex += count;
      }
    }
  }
  sharedUpdateInfo.index = newTargetIndex;
  sharedUpdateInfo.endIndex = newEndIndex;
  return sharedUpdateInfo;
}
function appendTraceTarget(coordinate, coordinates2, ring, targets) {
  const x2 = coordinate[0];
  const y2 = coordinate[1];
  for (let i2 = 0, ii = coordinates2.length - 1; i2 < ii; ++i2) {
    const start2 = coordinates2[i2];
    const end = coordinates2[i2 + 1];
    const rel = getPointSegmentRelationship(x2, y2, start2, end);
    if (rel.squaredDistance === 0) {
      const index2 = i2 + rel.along;
      targets.push({
        coordinates: coordinates2,
        ring,
        startIndex: index2,
        endIndex: index2
      });
      return;
    }
  }
}
const sharedRel = { along: 0, squaredDistance: 0 };
function getPointSegmentRelationship(x2, y2, start2, end) {
  const x1 = start2[0];
  const y1 = start2[1];
  const x22 = end[0];
  const y22 = end[1];
  const dx = x22 - x1;
  const dy = y22 - y1;
  let along = 0;
  let px = x1;
  let py = y1;
  if (dx !== 0 || dy !== 0) {
    along = clamp(((x2 - x1) * dx + (y2 - y1) * dy) / (dx * dx + dy * dy), 0, 1);
    px += dx * along;
    py += dy * along;
  }
  sharedRel.along = along;
  sharedRel.squaredDistance = toFixed(squaredDistance$1(x2, y2, px, py), 10);
  return sharedRel;
}
function interpolateCoordinate(coordinates2, index2) {
  const count = coordinates2.length;
  let startIndex = Math.floor(index2);
  const along = index2 - startIndex;
  if (startIndex >= count) {
    startIndex -= count;
  } else if (startIndex < 0) {
    startIndex += count;
  }
  let endIndex = startIndex + 1;
  if (endIndex >= count) {
    endIndex -= count;
  }
  const start2 = coordinates2[startIndex];
  const x0 = start2[0];
  const y0 = start2[1];
  const end = coordinates2[endIndex];
  const dx = end[0] - x0;
  const dy = end[1] - y0;
  return [x0 + dx * along, y0 + dy * along];
}
class Draw extends PointerInteraction {
  constructor(options) {
    const pointerOptions = options;
    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = FALSE;
    }
    super(pointerOptions);
    this.on;
    this.once;
    this.un;
    this.shouldHandle_ = false;
    this.downPx_ = null;
    this.downTimeout_;
    this.lastDragTime_;
    this.pointerType_;
    this.freehand_ = false;
    this.source_ = options.source ? options.source : null;
    this.features_ = options.features ? options.features : null;
    this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;
    this.type_ = options.type;
    this.mode_ = getMode(this.type_);
    this.stopClick_ = !!options.stopClick;
    this.minPoints_ = options.minPoints ? options.minPoints : this.mode_ === "Polygon" ? 3 : 2;
    this.maxPoints_ = this.mode_ === "Circle" ? 2 : options.maxPoints ? options.maxPoints : Infinity;
    this.finishCondition_ = options.finishCondition ? options.finishCondition : TRUE;
    this.geometryLayout_ = options.geometryLayout ? options.geometryLayout : "XY";
    let geometryFunction = options.geometryFunction;
    if (!geometryFunction) {
      const mode2 = this.mode_;
      if (mode2 === "Circle") {
        geometryFunction = function(coordinates2, geometry, projection) {
          const circle = geometry ? geometry : new Circle$1([NaN, NaN]);
          const center = fromUserCoordinate(coordinates2[0]);
          const squaredLength = squaredDistance(center, fromUserCoordinate(coordinates2[coordinates2.length - 1]));
          circle.setCenterAndRadius(center, Math.sqrt(squaredLength), this.geometryLayout_);
          return circle;
        };
      } else {
        let Constructor;
        if (mode2 === "Point") {
          Constructor = Point$3;
        } else if (mode2 === "LineString") {
          Constructor = LineString$1;
        } else if (mode2 === "Polygon") {
          Constructor = Polygon$1;
        }
        geometryFunction = function(coordinates2, geometry, projection) {
          if (geometry) {
            if (mode2 === "Polygon") {
              if (coordinates2[0].length) {
                geometry.setCoordinates([coordinates2[0].concat([coordinates2[0][0]])], this.geometryLayout_);
              } else {
                geometry.setCoordinates([], this.geometryLayout_);
              }
            } else {
              geometry.setCoordinates(coordinates2, this.geometryLayout_);
            }
          } else {
            geometry = new Constructor(coordinates2, this.geometryLayout_);
          }
          return geometry;
        };
      }
    }
    this.geometryFunction_ = geometryFunction;
    this.dragVertexDelay_ = options.dragVertexDelay !== void 0 ? options.dragVertexDelay : 500;
    this.finishCoordinate_ = null;
    this.sketchFeature_ = null;
    this.sketchPoint_ = null;
    this.sketchCoords_ = null;
    this.sketchLine_ = null;
    this.sketchLineCoords_ = null;
    this.squaredClickTolerance_ = options.clickTolerance ? options.clickTolerance * options.clickTolerance : 36;
    this.overlay_ = new VectorLayer$1({
      source: new VectorSource({
        useSpatialIndex: false,
        wrapX: options.wrapX ? options.wrapX : false
      }),
      style: options.style ? options.style : getDefaultStyleFunction$2(),
      updateWhileInteracting: true
    });
    this.geometryName_ = options.geometryName;
    this.condition_ = options.condition ? options.condition : noModifierKeys;
    this.freehandCondition_;
    if (options.freehand) {
      this.freehandCondition_ = always;
    } else {
      this.freehandCondition_ = options.freehandCondition ? options.freehandCondition : shiftKeyOnly;
    }
    this.traceCondition_;
    this.setTrace(options.trace || false);
    this.traceState_ = { active: false };
    this.traceSource_ = options.traceSource || options.source || null;
    this.addChangeListener(InteractionProperty.ACTIVE, this.updateState_);
  }
  setTrace(trace) {
    let condition;
    if (!trace) {
      condition = never;
    } else if (trace === true) {
      condition = always;
    } else {
      condition = trace;
    }
    this.traceCondition_ = condition;
  }
  setMap(map) {
    super.setMap(map);
    this.updateState_();
  }
  getOverlay() {
    return this.overlay_;
  }
  handleEvent(event) {
    if (event.originalEvent.type === EventType.CONTEXTMENU) {
      event.originalEvent.preventDefault();
    }
    this.freehand_ = this.mode_ !== "Point" && this.freehandCondition_(event);
    let move = event.type === MapBrowserEventType.POINTERMOVE;
    let pass = true;
    if (!this.freehand_ && this.lastDragTime_ && event.type === MapBrowserEventType.POINTERDRAG) {
      const now2 = Date.now();
      if (now2 - this.lastDragTime_ >= this.dragVertexDelay_) {
        this.downPx_ = event.pixel;
        this.shouldHandle_ = !this.freehand_;
        move = true;
      } else {
        this.lastDragTime_ = void 0;
      }
      if (this.shouldHandle_ && this.downTimeout_ !== void 0) {
        clearTimeout(this.downTimeout_);
        this.downTimeout_ = void 0;
      }
    }
    if (this.freehand_ && event.type === MapBrowserEventType.POINTERDRAG && this.sketchFeature_ !== null) {
      this.addToDrawing_(event.coordinate);
      pass = false;
    } else if (this.freehand_ && event.type === MapBrowserEventType.POINTERDOWN) {
      pass = false;
    } else if (move && this.getPointerCount() < 2) {
      pass = event.type === MapBrowserEventType.POINTERMOVE;
      if (pass && this.freehand_) {
        this.handlePointerMove_(event);
        if (this.shouldHandle_) {
          event.originalEvent.preventDefault();
        }
      } else if (event.originalEvent.pointerType === "mouse" || event.type === MapBrowserEventType.POINTERDRAG && this.downTimeout_ === void 0) {
        this.handlePointerMove_(event);
      }
    } else if (event.type === MapBrowserEventType.DBLCLICK) {
      pass = false;
    }
    return super.handleEvent(event) && pass;
  }
  handleDownEvent(event) {
    this.shouldHandle_ = !this.freehand_;
    if (this.freehand_) {
      this.downPx_ = event.pixel;
      if (!this.finishCoordinate_) {
        this.startDrawing_(event.coordinate);
      }
      return true;
    }
    if (!this.condition_(event)) {
      this.lastDragTime_ = void 0;
      return false;
    }
    this.lastDragTime_ = Date.now();
    this.downTimeout_ = setTimeout(() => {
      this.handlePointerMove_(new MapBrowserEvent(MapBrowserEventType.POINTERMOVE, event.map, event.originalEvent, false, event.frameState));
    }, this.dragVertexDelay_);
    this.downPx_ = event.pixel;
    return true;
  }
  deactivateTrace_() {
    this.traceState_ = { active: false };
  }
  toggleTraceState_(event) {
    if (!this.traceSource_ || !this.traceCondition_(event)) {
      return;
    }
    if (this.traceState_.active) {
      this.deactivateTrace_();
      return;
    }
    const map = this.getMap();
    const lowerLeft = map.getCoordinateFromPixel([
      event.pixel[0] - this.snapTolerance_,
      event.pixel[1] + this.snapTolerance_
    ]);
    const upperRight = map.getCoordinateFromPixel([
      event.pixel[0] + this.snapTolerance_,
      event.pixel[1] - this.snapTolerance_
    ]);
    const extent2 = boundingExtent([lowerLeft, upperRight]);
    const features = this.traceSource_.getFeaturesInExtent(extent2);
    if (features.length === 0) {
      return;
    }
    const targets = getTraceTargets(event.coordinate, features);
    if (targets.length) {
      this.traceState_ = {
        active: true,
        startPx: event.pixel.slice(),
        targets,
        targetIndex: -1
      };
    }
  }
  addOrRemoveTracedCoordinates_(target, endIndex) {
    const previouslyForward = target.startIndex <= target.endIndex;
    const currentlyForward = target.startIndex <= endIndex;
    if (previouslyForward === currentlyForward) {
      if (previouslyForward && endIndex > target.endIndex || !previouslyForward && endIndex < target.endIndex) {
        this.addTracedCoordinates_(target, target.endIndex, endIndex);
      } else if (previouslyForward && endIndex < target.endIndex || !previouslyForward && endIndex > target.endIndex) {
        this.removeTracedCoordinates_(endIndex, target.endIndex);
      }
    } else {
      this.removeTracedCoordinates_(target.startIndex, target.endIndex);
      this.addTracedCoordinates_(target, target.startIndex, endIndex);
    }
  }
  removeTracedCoordinates_(fromIndex, toIndex) {
    if (fromIndex === toIndex) {
      return;
    }
    let remove = 0;
    if (fromIndex < toIndex) {
      const start2 = Math.ceil(fromIndex);
      let end = Math.floor(toIndex);
      if (end === toIndex) {
        end -= 1;
      }
      remove = end - start2 + 1;
    } else {
      const start2 = Math.floor(fromIndex);
      let end = Math.ceil(toIndex);
      if (end === toIndex) {
        end += 1;
      }
      remove = start2 - end + 1;
    }
    if (remove > 0) {
      this.removeLastPoints_(remove);
    }
  }
  addTracedCoordinates_(target, fromIndex, toIndex) {
    if (fromIndex === toIndex) {
      return;
    }
    const coordinates2 = [];
    if (fromIndex < toIndex) {
      const start2 = Math.ceil(fromIndex);
      let end = Math.floor(toIndex);
      if (end === toIndex) {
        end -= 1;
      }
      for (let i2 = start2; i2 <= end; ++i2) {
        coordinates2.push(getCoordinate(target.coordinates, i2));
      }
    } else {
      const start2 = Math.floor(fromIndex);
      let end = Math.ceil(toIndex);
      if (end === toIndex) {
        end += 1;
      }
      for (let i2 = start2; i2 >= end; --i2) {
        coordinates2.push(getCoordinate(target.coordinates, i2));
      }
    }
    if (coordinates2.length) {
      this.appendCoordinates(coordinates2);
    }
  }
  updateTrace_(event) {
    const traceState = this.traceState_;
    if (!traceState.active) {
      return;
    }
    if (traceState.targetIndex === -1) {
      if (distance$1(traceState.startPx, event.pixel) < this.snapTolerance_) {
        return;
      }
    }
    const updatedTraceTarget = getTraceTargetUpdate(event.coordinate, traceState, this.getMap(), this.snapTolerance_);
    if (traceState.targetIndex !== updatedTraceTarget.index) {
      if (traceState.targetIndex !== -1) {
        const oldTarget = traceState.targets[traceState.targetIndex];
        this.removeTracedCoordinates_(oldTarget.startIndex, oldTarget.endIndex);
      }
      const newTarget = traceState.targets[updatedTraceTarget.index];
      this.addTracedCoordinates_(newTarget, newTarget.startIndex, updatedTraceTarget.endIndex);
    } else {
      const target2 = traceState.targets[traceState.targetIndex];
      this.addOrRemoveTracedCoordinates_(target2, updatedTraceTarget.endIndex);
    }
    traceState.targetIndex = updatedTraceTarget.index;
    const target = traceState.targets[traceState.targetIndex];
    target.endIndex = updatedTraceTarget.endIndex;
    const coordinate = interpolateCoordinate(target.coordinates, target.endIndex);
    const pixel = this.getMap().getPixelFromCoordinate(coordinate);
    event.coordinate = coordinate;
    event.pixel = [Math.round(pixel[0]), Math.round(pixel[1])];
  }
  handleUpEvent(event) {
    let pass = true;
    if (this.getPointerCount() === 0) {
      if (this.downTimeout_) {
        clearTimeout(this.downTimeout_);
        this.downTimeout_ = void 0;
      }
      this.handlePointerMove_(event);
      const tracing = this.traceState_.active;
      this.toggleTraceState_(event);
      if (this.shouldHandle_) {
        const startingToDraw = !this.finishCoordinate_;
        if (startingToDraw) {
          this.startDrawing_(event.coordinate);
        }
        if (!startingToDraw && this.freehand_) {
          this.finishDrawing();
        } else if (!this.freehand_ && (!startingToDraw || this.mode_ === "Point")) {
          if (this.atFinish_(event.pixel, tracing)) {
            if (this.finishCondition_(event)) {
              this.finishDrawing();
            }
          } else {
            this.addToDrawing_(event.coordinate);
          }
        }
        pass = false;
      } else if (this.freehand_) {
        this.abortDrawing();
      }
    }
    if (!pass && this.stopClick_) {
      event.preventDefault();
    }
    return pass;
  }
  handlePointerMove_(event) {
    this.pointerType_ = event.originalEvent.pointerType;
    if (this.downPx_ && (!this.freehand_ && this.shouldHandle_ || this.freehand_ && !this.shouldHandle_)) {
      const downPx = this.downPx_;
      const clickPx = event.pixel;
      const dx = downPx[0] - clickPx[0];
      const dy = downPx[1] - clickPx[1];
      const squaredDistance2 = dx * dx + dy * dy;
      this.shouldHandle_ = this.freehand_ ? squaredDistance2 > this.squaredClickTolerance_ : squaredDistance2 <= this.squaredClickTolerance_;
      if (!this.shouldHandle_) {
        return;
      }
    }
    if (!this.finishCoordinate_) {
      this.createOrUpdateSketchPoint_(event.coordinate.slice());
      return;
    }
    this.updateTrace_(event);
    this.modifyDrawing_(event.coordinate);
  }
  atFinish_(pixel, tracing) {
    let at2 = false;
    if (this.sketchFeature_) {
      let potentiallyDone = false;
      let potentiallyFinishCoordinates = [this.finishCoordinate_];
      const mode2 = this.mode_;
      if (mode2 === "Point") {
        at2 = true;
      } else if (mode2 === "Circle") {
        at2 = this.sketchCoords_.length === 2;
      } else if (mode2 === "LineString") {
        potentiallyDone = !tracing && this.sketchCoords_.length > this.minPoints_;
      } else if (mode2 === "Polygon") {
        const sketchCoords = this.sketchCoords_;
        potentiallyDone = sketchCoords[0].length > this.minPoints_;
        potentiallyFinishCoordinates = [
          sketchCoords[0][0],
          sketchCoords[0][sketchCoords[0].length - 2]
        ];
        if (tracing) {
          potentiallyFinishCoordinates = [sketchCoords[0][0]];
        } else {
          potentiallyFinishCoordinates = [
            sketchCoords[0][0],
            sketchCoords[0][sketchCoords[0].length - 2]
          ];
        }
      }
      if (potentiallyDone) {
        const map = this.getMap();
        for (let i2 = 0, ii = potentiallyFinishCoordinates.length; i2 < ii; i2++) {
          const finishCoordinate = potentiallyFinishCoordinates[i2];
          const finishPixel = map.getPixelFromCoordinate(finishCoordinate);
          const dx = pixel[0] - finishPixel[0];
          const dy = pixel[1] - finishPixel[1];
          const snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;
          at2 = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;
          if (at2) {
            this.finishCoordinate_ = finishCoordinate;
            break;
          }
        }
      }
    }
    return at2;
  }
  createOrUpdateSketchPoint_(coordinates2) {
    if (!this.sketchPoint_) {
      this.sketchPoint_ = new Feature$1(new Point$3(coordinates2));
      this.updateSketchFeatures_();
    } else {
      const sketchPointGeom = this.sketchPoint_.getGeometry();
      sketchPointGeom.setCoordinates(coordinates2);
    }
  }
  createOrUpdateCustomSketchLine_(geometry) {
    if (!this.sketchLine_) {
      this.sketchLine_ = new Feature$1();
    }
    const ring = geometry.getLinearRing(0);
    let sketchLineGeom = this.sketchLine_.getGeometry();
    if (!sketchLineGeom) {
      sketchLineGeom = new LineString$1(ring.getFlatCoordinates(), ring.getLayout());
      this.sketchLine_.setGeometry(sketchLineGeom);
    } else {
      sketchLineGeom.setFlatCoordinates(ring.getLayout(), ring.getFlatCoordinates());
      sketchLineGeom.changed();
    }
  }
  startDrawing_(start2) {
    const projection = this.getMap().getView().getProjection();
    const stride = getStrideForLayout(this.geometryLayout_);
    while (start2.length < stride) {
      start2.push(0);
    }
    this.finishCoordinate_ = start2;
    if (this.mode_ === "Point") {
      this.sketchCoords_ = start2.slice();
    } else if (this.mode_ === "Polygon") {
      this.sketchCoords_ = [[start2.slice(), start2.slice()]];
      this.sketchLineCoords_ = this.sketchCoords_[0];
    } else {
      this.sketchCoords_ = [start2.slice(), start2.slice()];
    }
    if (this.sketchLineCoords_) {
      this.sketchLine_ = new Feature$1(new LineString$1(this.sketchLineCoords_));
    }
    const geometry = this.geometryFunction_(this.sketchCoords_, void 0, projection);
    this.sketchFeature_ = new Feature$1();
    if (this.geometryName_) {
      this.sketchFeature_.setGeometryName(this.geometryName_);
    }
    this.sketchFeature_.setGeometry(geometry);
    this.updateSketchFeatures_();
    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));
  }
  modifyDrawing_(coordinate) {
    const map = this.getMap();
    const geometry = this.sketchFeature_.getGeometry();
    const projection = map.getView().getProjection();
    const stride = getStrideForLayout(this.geometryLayout_);
    let coordinates2, last;
    while (coordinate.length < stride) {
      coordinate.push(0);
    }
    if (this.mode_ === "Point") {
      last = this.sketchCoords_;
    } else if (this.mode_ === "Polygon") {
      coordinates2 = this.sketchCoords_[0];
      last = coordinates2[coordinates2.length - 1];
      if (this.atFinish_(map.getPixelFromCoordinate(coordinate))) {
        coordinate = this.finishCoordinate_.slice();
      }
    } else {
      coordinates2 = this.sketchCoords_;
      last = coordinates2[coordinates2.length - 1];
    }
    last[0] = coordinate[0];
    last[1] = coordinate[1];
    this.geometryFunction_(this.sketchCoords_, geometry, projection);
    if (this.sketchPoint_) {
      const sketchPointGeom = this.sketchPoint_.getGeometry();
      sketchPointGeom.setCoordinates(coordinate);
    }
    if (geometry.getType() === "Polygon" && this.mode_ !== "Polygon") {
      this.createOrUpdateCustomSketchLine_(geometry);
    } else if (this.sketchLineCoords_) {
      const sketchLineGeom = this.sketchLine_.getGeometry();
      sketchLineGeom.setCoordinates(this.sketchLineCoords_);
    }
    this.updateSketchFeatures_();
  }
  addToDrawing_(coordinate) {
    const geometry = this.sketchFeature_.getGeometry();
    const projection = this.getMap().getView().getProjection();
    let done;
    let coordinates2;
    const mode2 = this.mode_;
    if (mode2 === "LineString" || mode2 === "Circle") {
      this.finishCoordinate_ = coordinate.slice();
      coordinates2 = this.sketchCoords_;
      if (coordinates2.length >= this.maxPoints_) {
        if (this.freehand_) {
          coordinates2.pop();
        } else {
          done = true;
        }
      }
      coordinates2.push(coordinate.slice());
      this.geometryFunction_(coordinates2, geometry, projection);
    } else if (mode2 === "Polygon") {
      coordinates2 = this.sketchCoords_[0];
      if (coordinates2.length >= this.maxPoints_) {
        if (this.freehand_) {
          coordinates2.pop();
        } else {
          done = true;
        }
      }
      coordinates2.push(coordinate.slice());
      if (done) {
        this.finishCoordinate_ = coordinates2[0];
      }
      this.geometryFunction_(this.sketchCoords_, geometry, projection);
    }
    this.createOrUpdateSketchPoint_(coordinate.slice());
    this.updateSketchFeatures_();
    if (done) {
      this.finishDrawing();
    }
  }
  removeLastPoints_(n2) {
    if (!this.sketchFeature_) {
      return;
    }
    const geometry = this.sketchFeature_.getGeometry();
    const projection = this.getMap().getView().getProjection();
    const mode2 = this.mode_;
    for (let i2 = 0; i2 < n2; ++i2) {
      let coordinates2;
      if (mode2 === "LineString" || mode2 === "Circle") {
        coordinates2 = this.sketchCoords_;
        coordinates2.splice(-2, 1);
        if (coordinates2.length >= 2) {
          this.finishCoordinate_ = coordinates2[coordinates2.length - 2].slice();
          const finishCoordinate = this.finishCoordinate_.slice();
          coordinates2[coordinates2.length - 1] = finishCoordinate;
          this.createOrUpdateSketchPoint_(finishCoordinate);
        }
        this.geometryFunction_(coordinates2, geometry, projection);
        if (geometry.getType() === "Polygon" && this.sketchLine_) {
          this.createOrUpdateCustomSketchLine_(geometry);
        }
      } else if (mode2 === "Polygon") {
        coordinates2 = this.sketchCoords_[0];
        coordinates2.splice(-2, 1);
        const sketchLineGeom = this.sketchLine_.getGeometry();
        if (coordinates2.length >= 2) {
          const finishCoordinate = coordinates2[coordinates2.length - 2].slice();
          coordinates2[coordinates2.length - 1] = finishCoordinate;
          this.createOrUpdateSketchPoint_(finishCoordinate);
        }
        sketchLineGeom.setCoordinates(coordinates2);
        this.geometryFunction_(this.sketchCoords_, geometry, projection);
      }
      if (coordinates2.length === 1) {
        this.abortDrawing();
        break;
      }
    }
    this.updateSketchFeatures_();
  }
  removeLastPoint() {
    this.removeLastPoints_(1);
  }
  finishDrawing() {
    const sketchFeature = this.abortDrawing_();
    if (!sketchFeature) {
      return;
    }
    let coordinates2 = this.sketchCoords_;
    const geometry = sketchFeature.getGeometry();
    const projection = this.getMap().getView().getProjection();
    if (this.mode_ === "LineString") {
      coordinates2.pop();
      this.geometryFunction_(coordinates2, geometry, projection);
    } else if (this.mode_ === "Polygon") {
      coordinates2[0].pop();
      this.geometryFunction_(coordinates2, geometry, projection);
      coordinates2 = geometry.getCoordinates();
    }
    if (this.type_ === "MultiPoint") {
      sketchFeature.setGeometry(new MultiPoint$1([coordinates2]));
    } else if (this.type_ === "MultiLineString") {
      sketchFeature.setGeometry(new MultiLineString$1([coordinates2]));
    } else if (this.type_ === "MultiPolygon") {
      sketchFeature.setGeometry(new MultiPolygon$1([coordinates2]));
    }
    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature));
    if (this.features_) {
      this.features_.push(sketchFeature);
    }
    if (this.source_) {
      this.source_.addFeature(sketchFeature);
    }
  }
  abortDrawing_() {
    this.finishCoordinate_ = null;
    const sketchFeature = this.sketchFeature_;
    this.sketchFeature_ = null;
    this.sketchPoint_ = null;
    this.sketchLine_ = null;
    this.overlay_.getSource().clear(true);
    this.deactivateTrace_();
    return sketchFeature;
  }
  abortDrawing() {
    const sketchFeature = this.abortDrawing_();
    if (sketchFeature) {
      this.dispatchEvent(new DrawEvent(DrawEventType.DRAWABORT, sketchFeature));
    }
  }
  appendCoordinates(coordinates2) {
    const mode2 = this.mode_;
    const newDrawing = !this.sketchFeature_;
    if (newDrawing) {
      this.startDrawing_(coordinates2[0]);
    }
    let sketchCoords;
    if (mode2 === "LineString" || mode2 === "Circle") {
      sketchCoords = this.sketchCoords_;
    } else if (mode2 === "Polygon") {
      sketchCoords = this.sketchCoords_ && this.sketchCoords_.length ? this.sketchCoords_[0] : [];
    } else {
      return;
    }
    if (newDrawing) {
      sketchCoords.shift();
    }
    sketchCoords.pop();
    for (let i2 = 0; i2 < coordinates2.length; i2++) {
      this.addToDrawing_(coordinates2[i2]);
    }
    const ending = coordinates2[coordinates2.length - 1];
    this.addToDrawing_(ending);
    this.modifyDrawing_(ending);
  }
  extend(feature) {
    const geometry = feature.getGeometry();
    const lineString = geometry;
    this.sketchFeature_ = feature;
    this.sketchCoords_ = lineString.getCoordinates();
    const last = this.sketchCoords_[this.sketchCoords_.length - 1];
    this.finishCoordinate_ = last.slice();
    this.sketchCoords_.push(last.slice());
    this.sketchPoint_ = new Feature$1(new Point$3(last));
    this.updateSketchFeatures_();
    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));
  }
  updateSketchFeatures_() {
    const sketchFeatures = [];
    if (this.sketchFeature_) {
      sketchFeatures.push(this.sketchFeature_);
    }
    if (this.sketchLine_) {
      sketchFeatures.push(this.sketchLine_);
    }
    if (this.sketchPoint_) {
      sketchFeatures.push(this.sketchPoint_);
    }
    const overlaySource = this.overlay_.getSource();
    overlaySource.clear(true);
    overlaySource.addFeatures(sketchFeatures);
  }
  updateState_() {
    const map = this.getMap();
    const active = this.getActive();
    if (!map || !active) {
      this.abortDrawing();
    }
    this.overlay_.setMap(active ? map : null);
  }
}
function getDefaultStyleFunction$2() {
  const styles = createEditingStyle();
  return function(feature, resolution) {
    return styles[feature.getGeometry().getType()];
  };
}
function getMode(type) {
  switch (type) {
    case "Point":
    case "MultiPoint":
      return "Point";
    case "LineString":
    case "MultiLineString":
      return "LineString";
    case "Polygon":
    case "MultiPolygon":
      return "Polygon";
    case "Circle":
      return "Circle";
    default:
      throw new Error("Invalid type: " + type);
  }
}
const CIRCLE_CENTER_INDEX = 0;
const CIRCLE_CIRCUMFERENCE_INDEX = 1;
const tempExtent = [0, 0, 0, 0];
const tempSegment$1 = [];
const ModifyEventType = {
  MODIFYSTART: "modifystart",
  MODIFYEND: "modifyend"
};
class ModifyEvent extends BaseEvent {
  constructor(type, features, mapBrowserEvent) {
    super(type);
    this.features = features;
    this.mapBrowserEvent = mapBrowserEvent;
  }
}
class Modify extends PointerInteraction {
  constructor(options) {
    super(options);
    this.on;
    this.once;
    this.un;
    this.boundHandleFeatureChange_ = this.handleFeatureChange_.bind(this);
    this.condition_ = options.condition ? options.condition : primaryAction;
    this.defaultDeleteCondition_ = function(mapBrowserEvent) {
      return altKeyOnly(mapBrowserEvent) && singleClick(mapBrowserEvent);
    };
    this.deleteCondition_ = options.deleteCondition ? options.deleteCondition : this.defaultDeleteCondition_;
    this.insertVertexCondition_ = options.insertVertexCondition ? options.insertVertexCondition : always;
    this.vertexFeature_ = null;
    this.vertexSegments_ = null;
    this.lastPixel_ = [0, 0];
    this.ignoreNextSingleClick_ = false;
    this.featuresBeingModified_ = null;
    this.rBush_ = new RBush();
    this.pixelTolerance_ = options.pixelTolerance !== void 0 ? options.pixelTolerance : 10;
    this.snappedToVertex_ = false;
    this.changingFeature_ = false;
    this.dragSegments_ = [];
    this.overlay_ = new VectorLayer$1({
      source: new VectorSource({
        useSpatialIndex: false,
        wrapX: !!options.wrapX
      }),
      style: options.style ? options.style : getDefaultStyleFunction$1(),
      updateWhileAnimating: true,
      updateWhileInteracting: true
    });
    this.SEGMENT_WRITERS_ = {
      "Point": this.writePointGeometry_.bind(this),
      "LineString": this.writeLineStringGeometry_.bind(this),
      "LinearRing": this.writeLineStringGeometry_.bind(this),
      "Polygon": this.writePolygonGeometry_.bind(this),
      "MultiPoint": this.writeMultiPointGeometry_.bind(this),
      "MultiLineString": this.writeMultiLineStringGeometry_.bind(this),
      "MultiPolygon": this.writeMultiPolygonGeometry_.bind(this),
      "Circle": this.writeCircleGeometry_.bind(this),
      "GeometryCollection": this.writeGeometryCollectionGeometry_.bind(this)
    };
    this.source_ = null;
    this.hitDetection_ = null;
    let features;
    if (options.features) {
      features = options.features;
    } else if (options.source) {
      this.source_ = options.source;
      features = new Collection(this.source_.getFeatures());
      this.source_.addEventListener(VectorEventType.ADDFEATURE, this.handleSourceAdd_.bind(this));
      this.source_.addEventListener(VectorEventType.REMOVEFEATURE, this.handleSourceRemove_.bind(this));
    }
    if (!features) {
      throw new Error("The modify interaction requires features, a source or a layer");
    }
    if (options.hitDetection) {
      this.hitDetection_ = options.hitDetection;
    }
    this.features_ = features;
    this.features_.forEach(this.addFeature_.bind(this));
    this.features_.addEventListener(CollectionEventType.ADD, this.handleFeatureAdd_.bind(this));
    this.features_.addEventListener(CollectionEventType.REMOVE, this.handleFeatureRemove_.bind(this));
    this.lastPointerEvent_ = null;
    this.delta_ = [0, 0];
    this.snapToPointer_ = options.snapToPointer === void 0 ? !this.hitDetection_ : options.snapToPointer;
  }
  addFeature_(feature) {
    const geometry = feature.getGeometry();
    if (geometry) {
      const writer = this.SEGMENT_WRITERS_[geometry.getType()];
      if (writer) {
        writer(feature, geometry);
      }
    }
    const map = this.getMap();
    if (map && map.isRendered() && this.getActive()) {
      this.handlePointerAtPixel_(this.lastPixel_, map);
    }
    feature.addEventListener(EventType.CHANGE, this.boundHandleFeatureChange_);
  }
  willModifyFeatures_(evt, segments) {
    if (!this.featuresBeingModified_) {
      this.featuresBeingModified_ = new Collection();
      const features = this.featuresBeingModified_.getArray();
      for (let i2 = 0, ii = segments.length; i2 < ii; ++i2) {
        const segment = segments[i2];
        for (let s2 = 0, ss = segment.length; s2 < ss; ++s2) {
          const feature = segment[s2].feature;
          if (feature && !features.includes(feature)) {
            this.featuresBeingModified_.push(feature);
          }
        }
      }
      if (this.featuresBeingModified_.getLength() === 0) {
        this.featuresBeingModified_ = null;
      } else {
        this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYSTART, this.featuresBeingModified_, evt));
      }
    }
  }
  removeFeature_(feature) {
    this.removeFeatureSegmentData_(feature);
    if (this.vertexFeature_ && this.features_.getLength() === 0) {
      this.overlay_.getSource().removeFeature(this.vertexFeature_);
      this.vertexFeature_ = null;
    }
    feature.removeEventListener(EventType.CHANGE, this.boundHandleFeatureChange_);
  }
  removeFeatureSegmentData_(feature) {
    const rBush = this.rBush_;
    const nodesToRemove = [];
    rBush.forEach(function(node2) {
      if (feature === node2.feature) {
        nodesToRemove.push(node2);
      }
    });
    for (let i2 = nodesToRemove.length - 1; i2 >= 0; --i2) {
      const nodeToRemove = nodesToRemove[i2];
      for (let j2 = this.dragSegments_.length - 1; j2 >= 0; --j2) {
        if (this.dragSegments_[j2][0] === nodeToRemove) {
          this.dragSegments_.splice(j2, 1);
        }
      }
      rBush.remove(nodeToRemove);
    }
  }
  setActive(active) {
    if (this.vertexFeature_ && !active) {
      this.overlay_.getSource().removeFeature(this.vertexFeature_);
      this.vertexFeature_ = null;
    }
    super.setActive(active);
  }
  setMap(map) {
    this.overlay_.setMap(map);
    super.setMap(map);
  }
  getOverlay() {
    return this.overlay_;
  }
  handleSourceAdd_(event) {
    if (event.feature) {
      this.features_.push(event.feature);
    }
  }
  handleSourceRemove_(event) {
    if (event.feature) {
      this.features_.remove(event.feature);
    }
  }
  handleFeatureAdd_(evt) {
    this.addFeature_(evt.element);
  }
  handleFeatureChange_(evt) {
    if (!this.changingFeature_) {
      const feature = evt.target;
      this.removeFeature_(feature);
      this.addFeature_(feature);
    }
  }
  handleFeatureRemove_(evt) {
    this.removeFeature_(evt.element);
  }
  writePointGeometry_(feature, geometry) {
    const coordinates2 = geometry.getCoordinates();
    const segmentData = {
      feature,
      geometry,
      segment: [coordinates2, coordinates2]
    };
    this.rBush_.insert(geometry.getExtent(), segmentData);
  }
  writeMultiPointGeometry_(feature, geometry) {
    const points = geometry.getCoordinates();
    for (let i2 = 0, ii = points.length; i2 < ii; ++i2) {
      const coordinates2 = points[i2];
      const segmentData = {
        feature,
        geometry,
        depth: [i2],
        index: i2,
        segment: [coordinates2, coordinates2]
      };
      this.rBush_.insert(geometry.getExtent(), segmentData);
    }
  }
  writeLineStringGeometry_(feature, geometry) {
    const coordinates2 = geometry.getCoordinates();
    for (let i2 = 0, ii = coordinates2.length - 1; i2 < ii; ++i2) {
      const segment = coordinates2.slice(i2, i2 + 2);
      const segmentData = {
        feature,
        geometry,
        index: i2,
        segment
      };
      this.rBush_.insert(boundingExtent(segment), segmentData);
    }
  }
  writeMultiLineStringGeometry_(feature, geometry) {
    const lines = geometry.getCoordinates();
    for (let j2 = 0, jj = lines.length; j2 < jj; ++j2) {
      const coordinates2 = lines[j2];
      for (let i2 = 0, ii = coordinates2.length - 1; i2 < ii; ++i2) {
        const segment = coordinates2.slice(i2, i2 + 2);
        const segmentData = {
          feature,
          geometry,
          depth: [j2],
          index: i2,
          segment
        };
        this.rBush_.insert(boundingExtent(segment), segmentData);
      }
    }
  }
  writePolygonGeometry_(feature, geometry) {
    const rings = geometry.getCoordinates();
    for (let j2 = 0, jj = rings.length; j2 < jj; ++j2) {
      const coordinates2 = rings[j2];
      for (let i2 = 0, ii = coordinates2.length - 1; i2 < ii; ++i2) {
        const segment = coordinates2.slice(i2, i2 + 2);
        const segmentData = {
          feature,
          geometry,
          depth: [j2],
          index: i2,
          segment
        };
        this.rBush_.insert(boundingExtent(segment), segmentData);
      }
    }
  }
  writeMultiPolygonGeometry_(feature, geometry) {
    const polygons = geometry.getCoordinates();
    for (let k2 = 0, kk = polygons.length; k2 < kk; ++k2) {
      const rings = polygons[k2];
      for (let j2 = 0, jj = rings.length; j2 < jj; ++j2) {
        const coordinates2 = rings[j2];
        for (let i2 = 0, ii = coordinates2.length - 1; i2 < ii; ++i2) {
          const segment = coordinates2.slice(i2, i2 + 2);
          const segmentData = {
            feature,
            geometry,
            depth: [j2, k2],
            index: i2,
            segment
          };
          this.rBush_.insert(boundingExtent(segment), segmentData);
        }
      }
    }
  }
  writeCircleGeometry_(feature, geometry) {
    const coordinates2 = geometry.getCenter();
    const centerSegmentData = {
      feature,
      geometry,
      index: CIRCLE_CENTER_INDEX,
      segment: [coordinates2, coordinates2]
    };
    const circumferenceSegmentData = {
      feature,
      geometry,
      index: CIRCLE_CIRCUMFERENCE_INDEX,
      segment: [coordinates2, coordinates2]
    };
    const featureSegments = [centerSegmentData, circumferenceSegmentData];
    centerSegmentData.featureSegments = featureSegments;
    circumferenceSegmentData.featureSegments = featureSegments;
    this.rBush_.insert(createOrUpdateFromCoordinate(coordinates2), centerSegmentData);
    let circleGeometry = geometry;
    this.rBush_.insert(circleGeometry.getExtent(), circumferenceSegmentData);
  }
  writeGeometryCollectionGeometry_(feature, geometry) {
    const geometries = geometry.getGeometriesArray();
    for (let i2 = 0; i2 < geometries.length; ++i2) {
      const geometry2 = geometries[i2];
      const writer = this.SEGMENT_WRITERS_[geometry2.getType()];
      writer(feature, geometry2);
    }
  }
  createOrUpdateVertexFeature_(coordinates2, features, geometries) {
    let vertexFeature = this.vertexFeature_;
    if (!vertexFeature) {
      vertexFeature = new Feature$1(new Point$3(coordinates2));
      this.vertexFeature_ = vertexFeature;
      this.overlay_.getSource().addFeature(vertexFeature);
    } else {
      const geometry = vertexFeature.getGeometry();
      geometry.setCoordinates(coordinates2);
    }
    vertexFeature.set("features", features);
    vertexFeature.set("geometries", geometries);
    return vertexFeature;
  }
  handleEvent(mapBrowserEvent) {
    if (!mapBrowserEvent.originalEvent) {
      return true;
    }
    this.lastPointerEvent_ = mapBrowserEvent;
    let handled;
    if (!mapBrowserEvent.map.getView().getInteracting() && mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE && !this.handlingDownUpSequence) {
      this.handlePointerMove_(mapBrowserEvent);
    }
    if (this.vertexFeature_ && this.deleteCondition_(mapBrowserEvent)) {
      if (mapBrowserEvent.type != MapBrowserEventType.SINGLECLICK || !this.ignoreNextSingleClick_) {
        handled = this.removePoint();
      } else {
        handled = true;
      }
    }
    if (mapBrowserEvent.type == MapBrowserEventType.SINGLECLICK) {
      this.ignoreNextSingleClick_ = false;
    }
    return super.handleEvent(mapBrowserEvent) && !handled;
  }
  handleDragEvent(evt) {
    this.ignoreNextSingleClick_ = false;
    this.willModifyFeatures_(evt, this.dragSegments_);
    const vertex = [
      evt.coordinate[0] + this.delta_[0],
      evt.coordinate[1] + this.delta_[1]
    ];
    const features = [];
    const geometries = [];
    for (let i2 = 0, ii = this.dragSegments_.length; i2 < ii; ++i2) {
      const dragSegment = this.dragSegments_[i2];
      const segmentData = dragSegment[0];
      const feature = segmentData.feature;
      if (!features.includes(feature)) {
        features.push(feature);
      }
      const geometry = segmentData.geometry;
      if (!geometries.includes(geometry)) {
        geometries.push(geometry);
      }
      const depth = segmentData.depth;
      let coordinates2;
      const segment = segmentData.segment;
      const index2 = dragSegment[1];
      while (vertex.length < geometry.getStride()) {
        vertex.push(segment[index2][vertex.length]);
      }
      switch (geometry.getType()) {
        case "Point":
          coordinates2 = vertex;
          segment[0] = vertex;
          segment[1] = vertex;
          break;
        case "MultiPoint":
          coordinates2 = geometry.getCoordinates();
          coordinates2[segmentData.index] = vertex;
          segment[0] = vertex;
          segment[1] = vertex;
          break;
        case "LineString":
          coordinates2 = geometry.getCoordinates();
          coordinates2[segmentData.index + index2] = vertex;
          segment[index2] = vertex;
          break;
        case "MultiLineString":
          coordinates2 = geometry.getCoordinates();
          coordinates2[depth[0]][segmentData.index + index2] = vertex;
          segment[index2] = vertex;
          break;
        case "Polygon":
          coordinates2 = geometry.getCoordinates();
          coordinates2[depth[0]][segmentData.index + index2] = vertex;
          segment[index2] = vertex;
          break;
        case "MultiPolygon":
          coordinates2 = geometry.getCoordinates();
          coordinates2[depth[1]][depth[0]][segmentData.index + index2] = vertex;
          segment[index2] = vertex;
          break;
        case "Circle":
          segment[0] = vertex;
          segment[1] = vertex;
          if (segmentData.index === CIRCLE_CENTER_INDEX) {
            this.changingFeature_ = true;
            geometry.setCenter(vertex);
            this.changingFeature_ = false;
          } else {
            this.changingFeature_ = true;
            evt.map.getView().getProjection();
            let radius = distance$1(fromUserCoordinate(geometry.getCenter()), fromUserCoordinate(vertex));
            geometry.setRadius(radius);
            this.changingFeature_ = false;
          }
          break;
      }
      if (coordinates2) {
        this.setGeometryCoordinates_(geometry, coordinates2);
      }
    }
    this.createOrUpdateVertexFeature_(vertex, features, geometries);
  }
  handleDownEvent(evt) {
    if (!this.condition_(evt)) {
      return false;
    }
    const pixelCoordinate = evt.coordinate;
    this.handlePointerAtPixel_(evt.pixel, evt.map, pixelCoordinate);
    this.dragSegments_.length = 0;
    this.featuresBeingModified_ = null;
    const vertexFeature = this.vertexFeature_;
    if (vertexFeature) {
      evt.map.getView().getProjection();
      const insertVertices = [];
      const vertex = vertexFeature.getGeometry().getCoordinates();
      const vertexExtent = boundingExtent([vertex]);
      const segmentDataMatches = this.rBush_.getInExtent(vertexExtent);
      const componentSegments = {};
      segmentDataMatches.sort(compareIndexes);
      for (let i2 = 0, ii = segmentDataMatches.length; i2 < ii; ++i2) {
        const segmentDataMatch = segmentDataMatches[i2];
        const segment = segmentDataMatch.segment;
        let uid2 = getUid(segmentDataMatch.geometry);
        const depth = segmentDataMatch.depth;
        if (depth) {
          uid2 += "-" + depth.join("-");
        }
        if (!componentSegments[uid2]) {
          componentSegments[uid2] = new Array(2);
        }
        if (segmentDataMatch.geometry.getType() === "Circle" && segmentDataMatch.index === CIRCLE_CIRCUMFERENCE_INDEX) {
          const closestVertex = closestOnSegmentData(pixelCoordinate, segmentDataMatch);
          if (equals$1(closestVertex, vertex) && !componentSegments[uid2][0]) {
            this.dragSegments_.push([segmentDataMatch, 0]);
            componentSegments[uid2][0] = segmentDataMatch;
          }
          continue;
        }
        if (equals$1(segment[0], vertex) && !componentSegments[uid2][0]) {
          this.dragSegments_.push([segmentDataMatch, 0]);
          componentSegments[uid2][0] = segmentDataMatch;
          continue;
        }
        if (equals$1(segment[1], vertex) && !componentSegments[uid2][1]) {
          if (componentSegments[uid2][0] && componentSegments[uid2][0].index === 0) {
            let coordinates2 = segmentDataMatch.geometry.getCoordinates();
            switch (segmentDataMatch.geometry.getType()) {
              case "LineString":
              case "MultiLineString":
                continue;
              case "MultiPolygon":
                coordinates2 = coordinates2[depth[1]];
              case "Polygon":
                if (segmentDataMatch.index !== coordinates2[depth[0]].length - 2) {
                  continue;
                }
                break;
            }
          }
          this.dragSegments_.push([segmentDataMatch, 1]);
          componentSegments[uid2][1] = segmentDataMatch;
          continue;
        }
        if (getUid(segment) in this.vertexSegments_ && !componentSegments[uid2][0] && !componentSegments[uid2][1] && this.insertVertexCondition_(evt)) {
          insertVertices.push(segmentDataMatch);
        }
      }
      if (insertVertices.length) {
        this.willModifyFeatures_(evt, [insertVertices]);
      }
      for (let j2 = insertVertices.length - 1; j2 >= 0; --j2) {
        this.insertVertex_(insertVertices[j2], vertex);
      }
    }
    return !!this.vertexFeature_;
  }
  handleUpEvent(evt) {
    for (let i2 = this.dragSegments_.length - 1; i2 >= 0; --i2) {
      const segmentData = this.dragSegments_[i2][0];
      const geometry = segmentData.geometry;
      if (geometry.getType() === "Circle") {
        const coordinates2 = geometry.getCenter();
        const centerSegmentData = segmentData.featureSegments[0];
        const circumferenceSegmentData = segmentData.featureSegments[1];
        centerSegmentData.segment[0] = coordinates2;
        centerSegmentData.segment[1] = coordinates2;
        circumferenceSegmentData.segment[0] = coordinates2;
        circumferenceSegmentData.segment[1] = coordinates2;
        this.rBush_.update(createOrUpdateFromCoordinate(coordinates2), centerSegmentData);
        let circleGeometry = geometry;
        this.rBush_.update(circleGeometry.getExtent(), circumferenceSegmentData);
      } else {
        this.rBush_.update(boundingExtent(segmentData.segment), segmentData);
      }
    }
    if (this.featuresBeingModified_) {
      this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND, this.featuresBeingModified_, evt));
      this.featuresBeingModified_ = null;
    }
    return false;
  }
  handlePointerMove_(evt) {
    this.lastPixel_ = evt.pixel;
    this.handlePointerAtPixel_(evt.pixel, evt.map, evt.coordinate);
  }
  handlePointerAtPixel_(pixel, map, coordinate) {
    const pixelCoordinate = coordinate || map.getCoordinateFromPixel(pixel);
    map.getView().getProjection();
    const sortByDistance = function(a2, b2) {
      return projectedDistanceToSegmentDataSquared(pixelCoordinate, a2) - projectedDistanceToSegmentDataSquared(pixelCoordinate, b2);
    };
    let nodes;
    let hitPointGeometry;
    if (this.hitDetection_) {
      const layerFilter = typeof this.hitDetection_ === "object" ? (layer) => layer === this.hitDetection_ : void 0;
      map.forEachFeatureAtPixel(pixel, (feature, layer, geometry) => {
        geometry = geometry || feature.getGeometry();
        if (geometry.getType() === "Point" && this.features_.getArray().includes(feature)) {
          hitPointGeometry = geometry;
          const coordinate2 = geometry.getFlatCoordinates().slice(0, 2);
          nodes = [
            {
              feature,
              geometry,
              segment: [coordinate2, coordinate2]
            }
          ];
        }
        return true;
      }, { layerFilter });
    }
    if (!nodes) {
      const viewExtent = fromUserExtent(createOrUpdateFromCoordinate(pixelCoordinate, tempExtent));
      const buffer2 = map.getView().getResolution() * this.pixelTolerance_;
      const box = toUserExtent(buffer$2(viewExtent, buffer2, tempExtent));
      nodes = this.rBush_.getInExtent(box);
    }
    if (nodes && nodes.length > 0) {
      const node2 = nodes.sort(sortByDistance)[0];
      const closestSegment = node2.segment;
      let vertex = closestOnSegmentData(pixelCoordinate, node2);
      const vertexPixel = map.getPixelFromCoordinate(vertex);
      let dist = distance$1(pixel, vertexPixel);
      if (hitPointGeometry || dist <= this.pixelTolerance_) {
        const vertexSegments = {};
        vertexSegments[getUid(closestSegment)] = true;
        if (!this.snapToPointer_) {
          this.delta_[0] = vertex[0] - pixelCoordinate[0];
          this.delta_[1] = vertex[1] - pixelCoordinate[1];
        }
        if (node2.geometry.getType() === "Circle" && node2.index === CIRCLE_CIRCUMFERENCE_INDEX) {
          this.snappedToVertex_ = true;
          this.createOrUpdateVertexFeature_(vertex, [node2.feature], [node2.geometry]);
        } else {
          const pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
          const pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
          const squaredDist1 = squaredDistance(vertexPixel, pixel1);
          const squaredDist2 = squaredDistance(vertexPixel, pixel2);
          dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
          this.snappedToVertex_ = dist <= this.pixelTolerance_;
          if (this.snappedToVertex_) {
            vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
          }
          this.createOrUpdateVertexFeature_(vertex, [node2.feature], [node2.geometry]);
          const geometries = {};
          geometries[getUid(node2.geometry)] = true;
          for (let i2 = 1, ii = nodes.length; i2 < ii; ++i2) {
            const segment = nodes[i2].segment;
            if (equals$1(closestSegment[0], segment[0]) && equals$1(closestSegment[1], segment[1]) || equals$1(closestSegment[0], segment[1]) && equals$1(closestSegment[1], segment[0])) {
              const geometryUid = getUid(nodes[i2].geometry);
              if (!(geometryUid in geometries)) {
                geometries[geometryUid] = true;
                vertexSegments[getUid(segment)] = true;
              }
            } else {
              break;
            }
          }
        }
        this.vertexSegments_ = vertexSegments;
        return;
      }
    }
    if (this.vertexFeature_) {
      this.overlay_.getSource().removeFeature(this.vertexFeature_);
      this.vertexFeature_ = null;
    }
  }
  insertVertex_(segmentData, vertex) {
    const segment = segmentData.segment;
    const feature = segmentData.feature;
    const geometry = segmentData.geometry;
    const depth = segmentData.depth;
    const index2 = segmentData.index;
    let coordinates2;
    while (vertex.length < geometry.getStride()) {
      vertex.push(0);
    }
    switch (geometry.getType()) {
      case "MultiLineString":
        coordinates2 = geometry.getCoordinates();
        coordinates2[depth[0]].splice(index2 + 1, 0, vertex);
        break;
      case "Polygon":
        coordinates2 = geometry.getCoordinates();
        coordinates2[depth[0]].splice(index2 + 1, 0, vertex);
        break;
      case "MultiPolygon":
        coordinates2 = geometry.getCoordinates();
        coordinates2[depth[1]][depth[0]].splice(index2 + 1, 0, vertex);
        break;
      case "LineString":
        coordinates2 = geometry.getCoordinates();
        coordinates2.splice(index2 + 1, 0, vertex);
        break;
      default:
        return;
    }
    this.setGeometryCoordinates_(geometry, coordinates2);
    const rTree = this.rBush_;
    rTree.remove(segmentData);
    this.updateSegmentIndices_(geometry, index2, depth, 1);
    const newSegmentData = {
      segment: [segment[0], vertex],
      feature,
      geometry,
      depth,
      index: index2
    };
    rTree.insert(boundingExtent(newSegmentData.segment), newSegmentData);
    this.dragSegments_.push([newSegmentData, 1]);
    const newSegmentData2 = {
      segment: [vertex, segment[1]],
      feature,
      geometry,
      depth,
      index: index2 + 1
    };
    rTree.insert(boundingExtent(newSegmentData2.segment), newSegmentData2);
    this.dragSegments_.push([newSegmentData2, 0]);
    this.ignoreNextSingleClick_ = true;
  }
  removePoint() {
    if (this.lastPointerEvent_ && this.lastPointerEvent_.type != MapBrowserEventType.POINTERDRAG) {
      const evt = this.lastPointerEvent_;
      this.willModifyFeatures_(evt, this.dragSegments_);
      const removed = this.removeVertex_();
      if (this.featuresBeingModified_) {
        this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND, this.featuresBeingModified_, evt));
      }
      this.featuresBeingModified_ = null;
      return removed;
    }
    return false;
  }
  removeVertex_() {
    const dragSegments = this.dragSegments_;
    const segmentsByFeature = {};
    let deleted = false;
    let component, coordinates2, dragSegment, geometry, i2, index2, left;
    let newIndex, right, segmentData, uid2;
    for (i2 = dragSegments.length - 1; i2 >= 0; --i2) {
      dragSegment = dragSegments[i2];
      segmentData = dragSegment[0];
      uid2 = getUid(segmentData.feature);
      if (segmentData.depth) {
        uid2 += "-" + segmentData.depth.join("-");
      }
      if (!(uid2 in segmentsByFeature)) {
        segmentsByFeature[uid2] = {};
      }
      if (dragSegment[1] === 0) {
        segmentsByFeature[uid2].right = segmentData;
        segmentsByFeature[uid2].index = segmentData.index;
      } else if (dragSegment[1] == 1) {
        segmentsByFeature[uid2].left = segmentData;
        segmentsByFeature[uid2].index = segmentData.index + 1;
      }
    }
    for (uid2 in segmentsByFeature) {
      right = segmentsByFeature[uid2].right;
      left = segmentsByFeature[uid2].left;
      index2 = segmentsByFeature[uid2].index;
      newIndex = index2 - 1;
      if (left !== void 0) {
        segmentData = left;
      } else {
        segmentData = right;
      }
      if (newIndex < 0) {
        newIndex = 0;
      }
      geometry = segmentData.geometry;
      coordinates2 = geometry.getCoordinates();
      component = coordinates2;
      deleted = false;
      switch (geometry.getType()) {
        case "MultiLineString":
          if (coordinates2[segmentData.depth[0]].length > 2) {
            coordinates2[segmentData.depth[0]].splice(index2, 1);
            deleted = true;
          }
          break;
        case "LineString":
          if (coordinates2.length > 2) {
            coordinates2.splice(index2, 1);
            deleted = true;
          }
          break;
        case "MultiPolygon":
          component = component[segmentData.depth[1]];
        case "Polygon":
          component = component[segmentData.depth[0]];
          if (component.length > 4) {
            if (index2 == component.length - 1) {
              index2 = 0;
            }
            component.splice(index2, 1);
            deleted = true;
            if (index2 === 0) {
              component.pop();
              component.push(component[0]);
              newIndex = component.length - 1;
            }
          }
          break;
      }
      if (deleted) {
        this.setGeometryCoordinates_(geometry, coordinates2);
        const segments = [];
        if (left !== void 0) {
          this.rBush_.remove(left);
          segments.push(left.segment[0]);
        }
        if (right !== void 0) {
          this.rBush_.remove(right);
          segments.push(right.segment[1]);
        }
        if (left !== void 0 && right !== void 0) {
          const newSegmentData = {
            depth: segmentData.depth,
            feature: segmentData.feature,
            geometry: segmentData.geometry,
            index: newIndex,
            segment: segments
          };
          this.rBush_.insert(boundingExtent(newSegmentData.segment), newSegmentData);
        }
        this.updateSegmentIndices_(geometry, index2, segmentData.depth, -1);
        if (this.vertexFeature_) {
          this.overlay_.getSource().removeFeature(this.vertexFeature_);
          this.vertexFeature_ = null;
        }
        dragSegments.length = 0;
      }
    }
    return deleted;
  }
  setGeometryCoordinates_(geometry, coordinates2) {
    this.changingFeature_ = true;
    geometry.setCoordinates(coordinates2);
    this.changingFeature_ = false;
  }
  updateSegmentIndices_(geometry, index2, depth, delta) {
    this.rBush_.forEachInExtent(geometry.getExtent(), function(segmentDataMatch) {
      if (segmentDataMatch.geometry === geometry && (depth === void 0 || segmentDataMatch.depth === void 0 || equals$3(segmentDataMatch.depth, depth)) && segmentDataMatch.index > index2) {
        segmentDataMatch.index += delta;
      }
    });
  }
}
function compareIndexes(a2, b2) {
  return a2.index - b2.index;
}
function projectedDistanceToSegmentDataSquared(pointCoordinates, segmentData, projection) {
  const geometry = segmentData.geometry;
  if (geometry.getType() === "Circle") {
    let circleGeometry = geometry;
    if (segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {
      const distanceToCenterSquared = squaredDistance(circleGeometry.getCenter(), fromUserCoordinate(pointCoordinates));
      const distanceToCircumference = Math.sqrt(distanceToCenterSquared) - circleGeometry.getRadius();
      return distanceToCircumference * distanceToCircumference;
    }
  }
  const coordinate = fromUserCoordinate(pointCoordinates);
  tempSegment$1[0] = fromUserCoordinate(segmentData.segment[0]);
  tempSegment$1[1] = fromUserCoordinate(segmentData.segment[1]);
  return squaredDistanceToSegment(coordinate, tempSegment$1);
}
function closestOnSegmentData(pointCoordinates, segmentData, projection) {
  const geometry = segmentData.geometry;
  if (geometry.getType() === "Circle" && segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {
    let circleGeometry = geometry;
    return toUserCoordinate(circleGeometry.getClosestPoint(fromUserCoordinate(pointCoordinates)));
  }
  const coordinate = fromUserCoordinate(pointCoordinates);
  tempSegment$1[0] = fromUserCoordinate(segmentData.segment[0]);
  tempSegment$1[1] = fromUserCoordinate(segmentData.segment[1]);
  return toUserCoordinate(closestOnSegment(coordinate, tempSegment$1));
}
function getDefaultStyleFunction$1() {
  const style2 = createEditingStyle();
  return function(feature, resolution) {
    return style2["Point"];
  };
}
const _sfc_main$l = {
  name: "ol-style",
  setup(props) {
    const styledObj = inject("stylable", null);
    const {
      properties
    } = usePropsAsObjectProperties(props);
    let style2 = computed(() => new Style$1(properties));
    const setStyle = (val) => {
      if (styledObj instanceof Draw || styledObj instanceof Modify) {
        styledObj.getOverlay().setStyle(val);
        styledObj.value.dispatchEvent("styleChanged");
        return;
      }
      try {
        styledObj.value.setStyle(val);
        styledObj.value.changed();
        styledObj.value.dispatchEvent("styleChanged");
      } catch (error) {
        styledObj.value.style_ = val;
        styledObj.value.values_.style = val;
        styledObj.value.changed();
        styledObj.value.dispatchEvent("styleChanged");
      }
    };
    const styleFunc = computed(() => {
      return (feature) => {
        if (properties.overrideStyleFunction != null) {
          properties.overrideStyleFunction(feature, style2.value);
        }
        return style2.value;
      };
    });
    watch(properties, () => {
      if (properties.overrideStyleFunction == null) {
        setStyle(style2.value);
      } else {
        setStyle(styleFunc.value);
      }
    });
    onMounted(() => {
      if (properties.overrideStyleFunction == null) {
        setStyle(style2.value);
      } else {
        setStyle(styleFunc.value);
      }
    });
    onUnmounted(() => {
      setStyle(null);
    });
    provide("style", style2);
    provide("styledObj", styledObj);
    return {
      style: style2
    };
  },
  props: {
    zIndex: {
      type: Number
    },
    overrideStyleFunction: {
      type: Function
    }
  }
};
function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var Style = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["render", _sfc_render$l]]);
const _sfc_main$k = {
  name: "ol-style-circle",
  setup(props) {
    const style2 = inject("style", null);
    const styledObj = inject("styledObj", null);
    const {
      properties
    } = usePropsAsObjectProperties(props);
    const createCircleStyle = (properties2) => {
      return new CircleStyle(__spreadProps(__spreadValues({}, properties2), {
        fill: new Fill$1(),
        stroke: new Stroke$1()
      }));
    };
    let circle = computed(() => createCircleStyle(properties));
    const applyStyle = () => {
      style2.value.setImage(null);
      style2.value.setImage(circle.value);
      styledObj.value.changed();
    };
    watch(properties, () => {
      applyStyle();
    });
    watch(style2, () => {
      applyStyle();
    });
    onMounted(() => {
      style2.value.setImage(circle.value);
    });
    onUnmounted(() => {
      style2.value.setImage(null);
    });
    provide("circle", circle);
    provide("styledObj", styledObj);
  },
  props: {
    radius: {
      type: Number
    },
    scale: {
      type: Number
    }
  }
};
function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var Circle = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["render", _sfc_render$k]]);
const _sfc_main$j = {
  name: "ol-style-stroke",
  setup(props) {
    const style2 = inject("style", null);
    const circle = inject("circle", null);
    const styledObj = inject("styledObj", null);
    const {
      properties
    } = usePropsAsObjectProperties(props);
    if (style2 != null && circle == null) {
      let stroke = new Stroke$1(properties);
      style2.value.setStroke(stroke);
      const applyStroke = () => {
        style2.value.setStroke(null);
        stroke = new Stroke$1(properties);
        style2.value.setStroke(stroke);
      };
      watch(properties, () => {
        applyStroke();
      });
      watch(style2, () => {
        applyStroke();
      });
      onMounted(() => {
        style2.value.setStroke(stroke);
      });
      onUnmounted(() => {
        style2.value.setStroke(null);
      });
    } else if (circle != null) {
      const applyStroketoCircle = (properties2) => {
        circle.value.getStroke().setColor(properties2.color);
        circle.value.getStroke().setLineCap(properties2.lineCap);
        circle.value.getStroke().setLineDash(properties2.lineDash);
        circle.value.getStroke().setLineDashOffset(properties2.lineDashOffset);
        circle.value.getStroke().setLineJoin(properties2.lineJoin);
        circle.value.getStroke().setMiterLimit(properties2.miterLimit);
        circle.value.getStroke().setWidth(properties2.width);
        circle.value.setRadius(circle.value.getRadius());
        try {
          styledObj.value.changed();
        } catch (error) {
          styledObj.changed();
        }
      };
      applyStroketoCircle(properties);
      watch(properties, (newVal) => {
        applyStroketoCircle(newVal);
      });
      watch(circle, () => {
        applyStroketoCircle(properties);
      });
    }
  },
  props: {
    color: {
      type: String
    },
    lineCap: {
      type: String,
      default: "round"
    },
    lineJoin: {
      type: String,
      default: "round"
    },
    lineDash: {
      type: Array
    },
    lineDashOffset: {
      type: Number,
      default: 0
    },
    miterLimit: {
      type: Number,
      default: 10
    },
    width: {
      type: Number,
      default: 1
    }
  }
};
function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var Stroke = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["render", _sfc_render$j]]);
const _sfc_main$i = {
  name: "ol-style-fill",
  setup(props) {
    const style2 = inject("style", null);
    const circle = inject("circle", null);
    const styledObj = inject("styledObj", null);
    const {
      properties
    } = usePropsAsObjectProperties(props);
    if (style2 != null && circle == null) {
      let fill = new Fill$1(properties);
      style2.value.setFill(fill);
      const applyFill = () => {
        style2.value.setFill(null);
        fill = new Fill$1(properties);
        style2.value.setFill(fill);
      };
      watch(properties, () => {
        applyFill();
      });
      watch(style2, () => {
        applyFill();
      });
      onMounted(() => {
        style2.value.setFill(fill);
      });
      onUnmounted(() => {
        style2.value.setFill(null);
      });
    } else if (circle != null) {
      const applyFilltoCircle = (color2) => {
        circle.value.getFill().setColor(color2);
        circle.value.setRadius(circle.value.getRadius());
        try {
          styledObj.value.changed();
        } catch (error) {
          styledObj.changed();
        }
      };
      applyFilltoCircle(properties.color);
      watch(properties, () => {
        applyFilltoCircle(properties.color);
      });
      watch(circle, () => {
        applyFilltoCircle(properties.color);
      });
    }
  },
  props: {
    color: {
      type: String
    }
  }
};
function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var Fill = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["render", _sfc_render$i]]);
const _sfc_main$h = {
  name: "ol-style-icon",
  setup(props) {
    const style2 = inject("style", null);
    const styledObj = inject("styledObj", null);
    const {
      properties
    } = usePropsAsObjectProperties(props);
    let icon = computed(() => {
      let ic = new Icon$1(properties);
      ic.load();
      return ic;
    });
    const applyStyle = () => {
      style2.value.setImage(null);
      style2.value.setImage(icon.value);
      styledObj.value.changed();
    };
    watch(properties, () => {
      applyStyle();
    });
    watch(style2, () => {
      applyStyle();
    });
    onMounted(() => {
      style2.value.setImage(icon.value);
    });
    onUnmounted(() => {
      style2.value.setImage(null);
    });
  },
  props: {
    anchor: {
      type: Array
    },
    anchorOrigin: {
      type: String,
      default: "top-left"
    },
    anchorXUnits: {
      type: String,
      default: "fraction"
    },
    color: {
      type: String
    },
    crossOrigin: {
      type: String
    },
    img: {
      type: [HTMLImageElement, HTMLCanvasElement]
    },
    offset: {
      type: Array,
      default: () => [0, 0]
    },
    displacement: {
      type: Array,
      default: () => [0, 0]
    },
    offsetOrigin: {
      type: String,
      default: "top-left"
    },
    opacity: {
      type: Number,
      default: 1
    },
    scale: {
      type: Number,
      default: 1
    },
    rotateWithView: {
      type: Boolean,
      default: false
    },
    rotation: {
      type: Number,
      default: 0
    },
    size: {
      type: Array
    },
    imgSize: {
      type: Array
    },
    src: {
      type: String
    }
  }
};
function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var Icon = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["render", _sfc_render$h]]);
const _sfc_main$g = {
  name: "ol-style-text",
  setup(props) {
    const style2 = inject("style", null);
    const styledObj = inject("styledObj", null);
    const {
      properties
    } = usePropsAsObjectProperties(props);
    const createText = (properties2) => {
      return new Text$1(__spreadProps(__spreadValues({}, properties2), {
        fill: new Fill$1(),
        stroke: new Stroke$1()
      }));
    };
    let text2 = computed(() => createText(properties));
    const applyStyle = () => {
      style2.value.setText(null);
      style2.value.setText(text2.value);
      styledObj.value.changed();
    };
    watch(properties, () => {
      applyStyle();
    });
    watch(style2, () => {
      applyStyle();
    });
    onMounted(() => {
      style2.value.setText(text2.value);
    });
    onUnmounted(() => {
      style2.value.setText(null);
    });
    provide("style", text2);
    provide("styledObj", styledObj);
  },
  props: {
    font: {
      type: String
    },
    maxAngle: {
      type: Number,
      default: Math.PI / 4
    },
    offsetX: {
      type: Number,
      default: 0
    },
    offsetY: {
      type: Number,
      default: 0
    },
    overflow: {
      type: Boolean,
      default: false
    },
    placement: {
      type: String,
      default: "point"
    },
    scale: {
      type: Number
    },
    rotateWithView: {
      type: Boolean,
      default: false
    },
    rotation: {
      type: Number,
      default: 0
    },
    text: {
      type: String
    },
    textAlign: {
      type: String
    },
    textBaseline: {
      type: String,
      default: "middle"
    },
    padding: {
      type: Array,
      default: () => [0, 0, 0, 0]
    }
  }
};
function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var Text = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["render", _sfc_render$g]]);
var ol_coordinate_dist2d = function(p12, p22) {
  var dx = p12[0] - p22[0];
  var dy = p12[1] - p22[1];
  return Math.sqrt(dx * dx + dy * dy);
};
var ol_coordinate_equal = function(p12, p22) {
  return p12[0] == p22[0] && p12[1] == p22[1];
};
var ol_extent_intersection;
(function() {
  function splitX(pts, x2) {
    var pt2;
    for (let i2 = pts.length - 1; i2 > 0; i2--) {
      if (pts[i2][0] > x2 && pts[i2 - 1][0] < x2 || pts[i2][0] < x2 && pts[i2 - 1][0] > x2) {
        pt2 = [x2, (x2 - pts[i2][0]) / (pts[i2 - 1][0] - pts[i2][0]) * (pts[i2 - 1][1] - pts[i2][1]) + pts[i2][1]];
        pts.splice(i2, 0, pt2);
      }
    }
  }
  function splitY(pts, y2) {
    var pt2;
    for (let i2 = pts.length - 1; i2 > 0; i2--) {
      if (pts[i2][1] > y2 && pts[i2 - 1][1] < y2 || pts[i2][1] < y2 && pts[i2 - 1][1] > y2) {
        pt2 = [(y2 - pts[i2][1]) / (pts[i2 - 1][1] - pts[i2][1]) * (pts[i2 - 1][0] - pts[i2][0]) + pts[i2][0], y2];
        pts.splice(i2, 0, pt2);
      }
    }
  }
  ol_extent_intersection = function(extent2, polygon) {
    var poly2 = polygon.getType() === "Polygon";
    if (!poly2 && polygon.getType() !== "MultiPolygon")
      return null;
    var geom2 = polygon.getCoordinates();
    if (poly2)
      geom2 = [geom2];
    geom2.forEach(function(g2) {
      g2.forEach(function(c2) {
        splitX(c2, extent2[0]);
        splitX(c2, extent2[2]);
        splitY(c2, extent2[1]);
        splitY(c2, extent2[3]);
      });
    });
    geom2.forEach(function(g2) {
      g2.forEach(function(c2) {
        c2.forEach(function(p5) {
          if (p5[0] < extent2[0])
            p5[0] = extent2[0];
          else if (p5[0] > extent2[2])
            p5[0] = extent2[2];
          if (p5[1] < extent2[1])
            p5[1] = extent2[1];
          else if (p5[1] > extent2[3])
            p5[1] = extent2[3];
        });
      });
    });
    if (poly2) {
      return new Polygon$1(geom2[0]);
    } else {
      return new MultiPolygon$1(geom2);
    }
  };
})();
var ol_coordinate_sampleAt = function(p12, p22, d2, start2) {
  var pts = [];
  if (start2 !== false)
    pts.push(p12);
  var dl = ol_coordinate_dist2d(p12, p22);
  if (dl) {
    var nb = Math.round(dl / d2);
    if (nb > 1) {
      var dx = (p22[0] - p12[0]) / nb;
      var dy = (p22[1] - p12[1]) / nb;
      for (var i2 = 1; i2 < nb; i2++) {
        pts.push([p12[0] + dx * i2, p12[1] + dy * i2]);
      }
    }
  }
  pts.push(p22);
  return pts;
};
LineString$1.prototype.sampleAt = function(d2) {
  var line = this.getCoordinates();
  var result = [];
  for (var i2 = 1; i2 < line.length; i2++) {
    result = result.concat(ol_coordinate_sampleAt(line[i2 - 1], line[i2], d2, i2 === 1));
  }
  return new LineString$1(result);
};
MultiLineString$1.prototype.sampleAt = function(d2) {
  var lines = this.getCoordinates();
  var result = [];
  lines.forEach(function(p5) {
    var l2 = [];
    for (var i2 = 1; i2 < p5.length; i2++) {
      l2 = l2.concat(ol_coordinate_sampleAt(p5[i2 - 1], p5[i2], d2, i2 === 1));
    }
    result.push(l2);
  });
  return new MultiLineString$1(result);
};
Polygon$1.prototype.sampleAt = function(res) {
  var poly2 = this.getCoordinates();
  var result = [];
  poly2.forEach(function(p5) {
    var l2 = [];
    for (var i2 = 1; i2 < p5.length; i2++) {
      l2 = l2.concat(ol_coordinate_sampleAt(p5[i2 - 1], p5[i2], res, i2 === 1));
    }
    result.push(l2);
  });
  return new Polygon$1(result);
};
MultiPolygon$1.prototype.sampleAt = function(res) {
  var mpoly = this.getCoordinates();
  var result = [];
  mpoly.forEach(function(poly2) {
    var a2 = [];
    result.push(a2);
    poly2.forEach(function(p5) {
      var l2 = [];
      for (var i2 = 1; i2 < p5.length; i2++) {
        l2 = l2.concat(ol_coordinate_sampleAt(p5[i2 - 1], p5[i2], res, i2 === 1));
      }
      a2.push(l2);
    });
  });
  return new MultiPolygon$1(result);
};
Circle$1.prototype.intersection = function(geom2, resolution) {
  if (geom2.sampleAt) {
    var ext = buffer$2(this.getCenter().concat(this.getCenter()), this.getRadius());
    geom2 = ol_extent_intersection(ext, geom2);
    geom2 = geom2.simplify(resolution);
    var c2 = this.getCenter();
    var r2 = this.getRadius();
    var g2 = geom2.sampleAt(resolution).getCoordinates();
    switch (geom2.getType()) {
      case "Polygon":
        g2 = [g2];
      case "MultiPolygon": {
        var hasout = false;
        var result = [];
        g2.forEach(function(poly2) {
          var a2 = [];
          result.push(a2);
          poly2.forEach(function(ring) {
            var l2 = [];
            a2.push(l2);
            ring.forEach(function(p5) {
              var d2 = ol_coordinate_dist2d(c2, p5);
              if (d2 > r2) {
                hasout = true;
                l2.push([
                  c2[0] + r2 / d2 * (p5[0] - c2[0]),
                  c2[1] + r2 / d2 * (p5[1] - c2[1])
                ]);
              } else {
                l2.push(p5);
              }
            });
          });
        });
        if (!hasout)
          return geom2;
        if (geom2.getType() === "Polygon") {
          return new Polygon$1(result[0]);
        } else {
          return new MultiPolygon$1(result);
        }
      }
    }
  } else {
    console.warn("[ol/geom/Circle~intersection] Unsupported geometry type: " + geom2.getType());
  }
  return geom2;
};
LineString$1.prototype.splitAt = function(pt2, tol) {
  var i2;
  if (!pt2)
    return [this];
  if (!tol)
    tol = 1e-10;
  if (pt2.length && pt2[0].length) {
    var result = [this];
    for (i2 = 0; i2 < pt2.length; i2++) {
      var r2 = [];
      for (var k2 = 0; k2 < result.length; k2++) {
        var ri = result[k2].splitAt(pt2[i2], tol);
        r2 = r2.concat(ri);
      }
      result = r2;
    }
    return result;
  }
  if (ol_coordinate_equal(pt2, this.getFirstCoordinate()) || ol_coordinate_equal(pt2, this.getLastCoordinate())) {
    return [this];
  }
  var c0 = this.getCoordinates();
  var ci = [c0[0]];
  var c2 = [];
  for (i2 = 0; i2 < c0.length - 1; i2++) {
    if (ol_coordinate_equal(c0[i2], c0[i2 + 1]))
      continue;
    if (ol_coordinate_equal(pt2, c0[i2 + 1])) {
      ci.push(c0[i2 + 1]);
      c2.push(new LineString$1(ci));
      ci = [];
    } else if (!ol_coordinate_equal(pt2, c0[i2])) {
      var d1, d2, split2 = false;
      if (c0[i2][0] == c0[i2 + 1][0]) {
        d1 = (c0[i2][1] - pt2[1]) / (c0[i2][1] - c0[i2 + 1][1]);
        split2 = c0[i2][0] == pt2[0] && (0 < d1 && d1 <= 1);
      } else if (c0[i2][1] == c0[i2 + 1][1]) {
        d1 = (c0[i2][0] - pt2[0]) / (c0[i2][0] - c0[i2 + 1][0]);
        split2 = c0[i2][1] == pt2[1] && (0 < d1 && d1 <= 1);
      } else {
        d1 = (c0[i2][0] - pt2[0]) / (c0[i2][0] - c0[i2 + 1][0]);
        d2 = (c0[i2][1] - pt2[1]) / (c0[i2][1] - c0[i2 + 1][1]);
        split2 = Math.abs(d1 - d2) <= tol && 0 < d1 && d1 <= 1;
      }
      if (split2) {
        ci.push(pt2);
        c2.push(new LineString$1(ci));
        ci = [pt2];
      }
    }
    ci.push(c0[i2 + 1]);
  }
  if (ci.length > 1)
    c2.push(new LineString$1(ci));
  if (c2.length)
    return c2;
  else
    return [this];
};
var ol_style_FlowLine = function(options) {
  if (!options)
    options = {};
  Style$1.call(this, {
    renderer: this._render.bind(this),
    stroke: options.stroke,
    text: options.text,
    zIndex: options.zIndex,
    geometry: options.geometry
  });
  this._visible = options.visible !== false;
  if (typeof options.width === "function") {
    this._widthFn = options.width;
  } else {
    this.setWidth(options.width);
  }
  this.setWidth2(options.width2);
  if (typeof options.color === "function") {
    this._colorFn = options.color;
  } else {
    this.setColor(options.color);
  }
  this.setColor2(options.color2);
  this.setLineCap(options.lineCap);
  this.setArrow(options.arrow);
  this.setArrowSize(options.arrowSize);
  this.setArrowColor(options.arrowColor);
  this._offset = [0, 0];
  this.setOffset(options.offset0, 0);
  this.setOffset(options.offset1, 1);
  this._noOverlap = options.noOverlap;
};
ol_ext_inherits(ol_style_FlowLine, Style$1);
ol_style_FlowLine.prototype.setWidth = function(width) {
  this._width = width || 0;
};
ol_style_FlowLine.prototype.setWidth2 = function(width) {
  this._width2 = width;
};
ol_style_FlowLine.prototype.getOffset = function(where) {
  return this._offset[where];
};
ol_style_FlowLine.prototype.setOffset = function(width, where) {
  width = Math.max(0, parseFloat(width));
  switch (where) {
    case 0: {
      this._offset[0] = width;
      break;
    }
    case 1: {
      this._offset[1] = width;
      break;
    }
  }
};
ol_style_FlowLine.prototype.setLineCap = function(cap) {
  this._lineCap = cap === "round" ? "round" : "butt";
};
ol_style_FlowLine.prototype.getWidth = function(feature, step) {
  if (this._widthFn)
    return this._widthFn(feature, step);
  var w2 = typeof this._width2 === "number" ? this._width2 : this._width;
  return this._width + (w2 - this._width) * step;
};
ol_style_FlowLine.prototype.setColor = function(color2) {
  try {
    this._color = asArray(color2);
  } catch (e2) {
    this._color = [0, 0, 0, 1];
  }
};
ol_style_FlowLine.prototype.setColor2 = function(color2) {
  try {
    this._color2 = asArray(color2);
  } catch (e2) {
    this._color2 = null;
  }
};
ol_style_FlowLine.prototype.setArrowColor = function(color2) {
  try {
    this._acolor = asString$1(color2);
  } catch (e2) {
    this._acolor = null;
  }
};
ol_style_FlowLine.prototype.getColor = function(feature, step) {
  if (this._colorFn)
    return asString$1(this._colorFn(feature, step));
  var color2 = this._color;
  var color22 = this._color2 || this._color;
  return "rgba(" + +Math.round(color2[0] + (color22[0] - color2[0]) * step) + "," + Math.round(color2[1] + (color22[1] - color2[1]) * step) + "," + Math.round(color2[2] + (color22[2] - color2[2]) * step) + "," + (color2[3] + (color22[3] - color2[3]) * step) + ")";
};
ol_style_FlowLine.prototype.getArrow = function() {
  return this._arrow;
};
ol_style_FlowLine.prototype.setArrow = function(n2) {
  this._arrow = parseInt(n2);
  if (this._arrow < -1 || this._arrow > 2)
    this._arrow = 0;
};
ol_style_FlowLine.prototype.getArrowSize = function() {
  return this._arrowSize || [16, 16];
};
ol_style_FlowLine.prototype.setArrowSize = function(size) {
  if (Array.isArray(size))
    this._arrowSize = size;
  else if (typeof size === "number")
    this._arrowSize = [size, size];
};
ol_style_FlowLine.prototype.drawArrow = function(ctx, p0, p12, width, ratio) {
  var asize = this.getArrowSize()[0] * ratio;
  var l2 = ol_coordinate_dist2d(p0, p12);
  var dx = (p0[0] - p12[0]) / l2;
  var dy = (p0[1] - p12[1]) / l2;
  width = Math.max(this.getArrowSize()[1] / 2, width / 2) * ratio;
  ctx.beginPath();
  ctx.moveTo(p0[0], p0[1]);
  ctx.lineTo(p0[0] - asize * dx + width * dy, p0[1] - asize * dy - width * dx);
  ctx.lineTo(p0[0] - asize * dx - width * dy, p0[1] - asize * dy + width * dx);
  ctx.lineTo(p0[0], p0[1]);
  ctx.fill();
};
ol_style_FlowLine.prototype._render = function(geom2, e2) {
  if (e2.geometry.getType() === "LineString") {
    var i2, g2, p5, ctx = e2.context;
    if (!this._visible) {
      var a2 = e2.pixelRatio / e2.resolution;
      var cos = Math.cos(e2.rotation);
      var sin = Math.sin(e2.rotation);
      g2 = e2.geometry.getCoordinates();
      var dx = geom2[0][0] - g2[0][0] * a2 * cos - g2[0][1] * a2 * sin;
      var dy = geom2[0][1] - g2[0][0] * a2 * sin + g2[0][1] * a2 * cos;
      geom2 = [];
      for (i2 = 0; p5 = g2[i2]; i2++) {
        geom2[i2] = [
          dx + p5[0] * a2 * cos + p5[1] * a2 * sin,
          dy + p5[0] * a2 * sin - p5[1] * a2 * cos,
          p5[2]
        ];
      }
    }
    var asize = this.getArrowSize()[0] * e2.pixelRatio;
    ctx.save();
    if (this.getOffset(0))
      this._splitAsize(geom2, this.getOffset(0) * e2.pixelRatio);
    if (this.getOffset(1))
      this._splitAsize(geom2, this.getOffset(1) * e2.pixelRatio, true);
    if (geom2.length > 1 && (this.getArrow() === -1 || this.getArrow() === 2)) {
      p5 = this._splitAsize(geom2, asize);
      if (this._acolor)
        ctx.fillStyle = this._acolor;
      else
        ctx.fillStyle = this.getColor(e2.feature, 0);
      this.drawArrow(ctx, p5[0], p5[1], this.getWidth(e2.feature, 0), e2.pixelRatio);
    }
    if (geom2.length > 1 && this.getArrow() > 0) {
      p5 = this._splitAsize(geom2, asize, true);
      if (this._acolor)
        ctx.fillStyle = this._acolor;
      else
        ctx.fillStyle = this.getColor(e2.feature, 1);
      this.drawArrow(ctx, p5[0], p5[1], this.getWidth(e2.feature, 1), e2.pixelRatio);
    }
    var geoms = this._splitInto(geom2, 255, 2);
    var k2 = 0;
    var nb = geoms.length;
    ctx.lineJoin = "round";
    ctx.lineCap = this._lineCap || "butt";
    if (geoms.length > 1) {
      for (k2 = 0; k2 < geoms.length; k2++) {
        var step = k2 / nb;
        g2 = geoms[k2];
        ctx.lineWidth = this.getWidth(e2.feature, step) * e2.pixelRatio;
        ctx.strokeStyle = this.getColor(e2.feature, step);
        ctx.beginPath();
        ctx.moveTo(g2[0][0], g2[0][1]);
        for (i2 = 1; p5 = g2[i2]; i2++) {
          ctx.lineTo(p5[0], p5[1]);
        }
        ctx.stroke();
      }
    }
    ctx.restore();
  }
};
ol_style_FlowLine.prototype._splitAsize = function(geom2, asize, end) {
  var p5, p12, p0;
  var dl, d2 = 0;
  if (end)
    p0 = geom2.pop();
  else
    p0 = geom2.shift();
  p5 = p0;
  while (geom2.length) {
    if (end)
      p12 = geom2.pop();
    else
      p12 = geom2.shift();
    dl = ol_coordinate_dist2d(p5, p12);
    if (d2 + dl > asize) {
      p5 = [p5[0] + (p12[0] - p5[0]) * (asize - d2) / dl, p5[1] + (p12[1] - p5[1]) * (asize - d2) / dl];
      dl = ol_coordinate_dist2d(p5, p0);
      if (end) {
        geom2.push(p12);
        geom2.push(p5);
        geom2.push([p5[0] + (p0[0] - p5[0]) / dl, p5[1] + (p0[1] - p5[1]) / dl]);
      } else {
        geom2.unshift(p12);
        geom2.unshift(p5);
        geom2.unshift([p5[0] + (p0[0] - p5[0]) / dl, p5[1] + (p0[1] - p5[1]) / dl]);
      }
      break;
    }
    d2 += dl;
    p5 = p12;
  }
  return [p0, p5];
};
ol_style_FlowLine.prototype._splitInto = function(geom2, nb, min2) {
  var i2, p5;
  var dt2 = this._noOverlap ? 1 : 0.9;
  var geoms = [];
  var dl, l2 = 0;
  for (i2 = 1; p5 = geom2[i2]; i2++) {
    l2 += ol_coordinate_dist2d(geom2[i2 - 1], p5);
  }
  var length = Math.max(min2 || 2, l2 / (nb || 255));
  var p0 = geom2[0];
  l2 = 0;
  var g2 = [p0];
  i2 = 1;
  p5 = geom2[1];
  while (i2 < geom2.length) {
    var dx = p5[0] - p0[0];
    var dy = p5[1] - p0[1];
    dl = Math.sqrt(dx * dx + dy * dy);
    if (l2 + dl > length) {
      var d2 = (length - l2) / dl;
      g2.push([
        p0[0] + dx * d2,
        p0[1] + dy * d2
      ]);
      geoms.push(g2);
      p0 = [
        p0[0] + dx * d2 * dt2,
        p0[1] + dy * d2 * dt2
      ];
      g2 = [p0];
      l2 = 0;
    } else {
      l2 += dl;
      p0 = p5;
      g2.push(p0);
      i2++;
      p5 = geom2[i2];
    }
  }
  geoms.push(g2);
  return geoms;
};
const _sfc_main$f = {
  name: "ol-style-flowline",
  setup(props) {
    const styledObj = inject("stylable", null);
    const {
      properties
    } = usePropsAsObjectProperties(props);
    let style2 = computed(() => new ol_style_FlowLine(properties));
    const setStyle = (val) => {
      if (styledObj instanceof Draw || styledObj instanceof Modify) {
        styledObj.getOverlay().setStyle(val);
        styledObj.value.dispatchEvent("styleChanged");
        return;
      }
      try {
        styledObj.value.setStyle(val);
        styledObj.value.changed();
        styledObj.value.dispatchEvent("styleChanged");
      } catch (error) {
        styledObj.value.style_ = val;
        styledObj.value.values_.style = val;
        styledObj.value.changed();
        styledObj.value.dispatchEvent("styleChanged");
      }
    };
    const styleFunc = computed(() => {
      return (feature) => {
        if (properties.overrideStyleFunction != null) {
          properties.overrideStyleFunction(feature, style2.value);
        }
        return style2.value;
      };
    });
    watch(properties, () => {
      if (properties.overrideStyleFunction == null) {
        setStyle(style2.value);
      } else {
        setStyle(styleFunc.value);
      }
    });
    onMounted(() => {
      if (properties.overrideStyleFunction == null) {
        setStyle(style2.value);
      } else {
        setStyle(styleFunc.value);
      }
    });
    onUnmounted(() => {
      setStyle(null);
    });
    return {
      style: style2
    };
  },
  props: {
    color: {
      type: [String, Function]
    },
    color2: {
      type: String
    },
    width: {
      type: [Number, Function]
    },
    width2: {
      type: Number
    },
    arrow: {
      type: Number
    },
    arrowColor: {
      type: String
    }
  }
};
function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var FlowLine = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", _sfc_render$f]]);
function install$3(app) {
  if (install$3.installed) {
    return;
  }
  install$3.installed = true;
  app.component(Style.name, Style);
  app.component(Circle.name, Circle);
  app.component(Stroke.name, Stroke);
  app.component(Fill.name, Fill);
  app.component(Icon.name, Icon);
  app.component(Text.name, Text);
  app.component(FlowLine.name, FlowLine);
}
var Styles = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": install$3,
  install: install$3,
  Style,
  Stroke,
  Fill,
  Icon,
  Text,
  FlowLine,
  Circle
}, Symbol.toStringTag, { value: "Module" }));
const SelectEventType = {
  SELECT: "select"
};
class SelectEvent extends BaseEvent {
  constructor(type, selected, deselected, mapBrowserEvent) {
    super(type);
    this.selected = selected;
    this.deselected = deselected;
    this.mapBrowserEvent = mapBrowserEvent;
  }
}
const originalFeatureStyles = {};
class Select extends Interaction {
  constructor(options) {
    super();
    this.on;
    this.once;
    this.un;
    options = options ? options : {};
    this.boundAddFeature_ = this.addFeature_.bind(this);
    this.boundRemoveFeature_ = this.removeFeature_.bind(this);
    this.condition_ = options.condition ? options.condition : singleClick;
    this.addCondition_ = options.addCondition ? options.addCondition : never;
    this.removeCondition_ = options.removeCondition ? options.removeCondition : never;
    this.toggleCondition_ = options.toggleCondition ? options.toggleCondition : shiftKeyOnly;
    this.multi_ = options.multi ? options.multi : false;
    this.filter_ = options.filter ? options.filter : TRUE;
    this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;
    this.style_ = options.style !== void 0 ? options.style : getDefaultStyleFunction();
    this.features_ = options.features || new Collection();
    let layerFilter;
    if (options.layers) {
      if (typeof options.layers === "function") {
        layerFilter = options.layers;
      } else {
        const layers = options.layers;
        layerFilter = function(layer) {
          return layers.includes(layer);
        };
      }
    } else {
      layerFilter = TRUE;
    }
    this.layerFilter_ = layerFilter;
    this.featureLayerAssociation_ = {};
  }
  addFeatureLayerAssociation_(feature, layer) {
    this.featureLayerAssociation_[getUid(feature)] = layer;
  }
  getFeatures() {
    return this.features_;
  }
  getHitTolerance() {
    return this.hitTolerance_;
  }
  getLayer(feature) {
    return this.featureLayerAssociation_[getUid(feature)];
  }
  setHitTolerance(hitTolerance) {
    this.hitTolerance_ = hitTolerance;
  }
  setMap(map) {
    const currentMap = this.getMap();
    if (currentMap && this.style_) {
      this.features_.forEach(this.restorePreviousStyle_.bind(this));
    }
    super.setMap(map);
    if (map) {
      this.features_.addEventListener(CollectionEventType.ADD, this.boundAddFeature_);
      this.features_.addEventListener(CollectionEventType.REMOVE, this.boundRemoveFeature_);
      if (this.style_) {
        this.features_.forEach(this.applySelectedStyle_.bind(this));
      }
    } else {
      this.features_.removeEventListener(CollectionEventType.ADD, this.boundAddFeature_);
      this.features_.removeEventListener(CollectionEventType.REMOVE, this.boundRemoveFeature_);
    }
  }
  addFeature_(evt) {
    const feature = evt.element;
    if (this.style_) {
      this.applySelectedStyle_(feature);
    }
    if (!this.getLayer(feature)) {
      const layer = this.getMap().getAllLayers().find(function(layer2) {
        if (layer2 instanceof VectorLayer$1 && layer2.getSource() && layer2.getSource().hasFeature(feature)) {
          return layer2;
        }
      });
      if (layer) {
        this.addFeatureLayerAssociation_(feature, layer);
      }
    }
  }
  removeFeature_(evt) {
    if (this.style_) {
      this.restorePreviousStyle_(evt.element);
    }
  }
  getStyle() {
    return this.style_;
  }
  applySelectedStyle_(feature) {
    const key = getUid(feature);
    if (!(key in originalFeatureStyles)) {
      originalFeatureStyles[key] = feature.getStyle();
    }
    feature.setStyle(this.style_);
  }
  restorePreviousStyle_(feature) {
    const interactions = this.getMap().getInteractions().getArray();
    for (let i2 = interactions.length - 1; i2 >= 0; --i2) {
      const interaction = interactions[i2];
      if (interaction !== this && interaction instanceof Select && interaction.getStyle() && interaction.getFeatures().getArray().lastIndexOf(feature) !== -1) {
        feature.setStyle(interaction.getStyle());
        return;
      }
    }
    const key = getUid(feature);
    feature.setStyle(originalFeatureStyles[key]);
    delete originalFeatureStyles[key];
  }
  removeFeatureLayerAssociation_(feature) {
    delete this.featureLayerAssociation_[getUid(feature)];
  }
  handleEvent(mapBrowserEvent) {
    if (!this.condition_(mapBrowserEvent)) {
      return true;
    }
    const add2 = this.addCondition_(mapBrowserEvent);
    const remove = this.removeCondition_(mapBrowserEvent);
    const toggle2 = this.toggleCondition_(mapBrowserEvent);
    const set2 = !add2 && !remove && !toggle2;
    const map = mapBrowserEvent.map;
    const features = this.getFeatures();
    const deselected = [];
    const selected = [];
    if (set2) {
      clear$1(this.featureLayerAssociation_);
      map.forEachFeatureAtPixel(mapBrowserEvent.pixel, (feature, layer) => {
        if (!(feature instanceof Feature$1) || !this.filter_(feature, layer)) {
          return;
        }
        this.addFeatureLayerAssociation_(feature, layer);
        selected.push(feature);
        return !this.multi_;
      }, {
        layerFilter: this.layerFilter_,
        hitTolerance: this.hitTolerance_
      });
      for (let i2 = features.getLength() - 1; i2 >= 0; --i2) {
        const feature = features.item(i2);
        const index2 = selected.indexOf(feature);
        if (index2 > -1) {
          selected.splice(index2, 1);
        } else {
          features.remove(feature);
          deselected.push(feature);
        }
      }
      if (selected.length !== 0) {
        features.extend(selected);
      }
    } else {
      map.forEachFeatureAtPixel(mapBrowserEvent.pixel, (feature, layer) => {
        if (!(feature instanceof Feature$1) || !this.filter_(feature, layer)) {
          return;
        }
        if ((add2 || toggle2) && !features.getArray().includes(feature)) {
          this.addFeatureLayerAssociation_(feature, layer);
          selected.push(feature);
        } else if ((remove || toggle2) && features.getArray().includes(feature)) {
          deselected.push(feature);
          this.removeFeatureLayerAssociation_(feature);
        }
        return !this.multi_;
      }, {
        layerFilter: this.layerFilter_,
        hitTolerance: this.hitTolerance_
      });
      for (let j2 = deselected.length - 1; j2 >= 0; --j2) {
        features.remove(deselected[j2]);
      }
      features.extend(selected);
    }
    if (selected.length > 0 || deselected.length > 0) {
      this.dispatchEvent(new SelectEvent(SelectEventType.SELECT, selected, deselected, mapBrowserEvent));
    }
    return true;
  }
}
function getDefaultStyleFunction() {
  const styles = createEditingStyle();
  extend$3(styles["Polygon"], styles["LineString"]);
  extend$3(styles["GeometryCollection"], styles["LineString"]);
  return function(feature) {
    if (!feature.getGeometry()) {
      return null;
    }
    return styles[feature.getGeometry().getType()];
  };
}
const _sfc_main$e = {
  name: "ol-interaction-select",
  emits: ["select"],
  setup(props, {
    emit
  }) {
    const map = inject("map");
    const {
      properties
    } = usePropsAsObjectProperties(props);
    let select = computed(() => {
      let s2 = new Select(__spreadProps(__spreadValues({}, properties), {
        style: new Style$1()
      }));
      s2.on("select", (event) => {
        emit("select", event);
      });
      return s2;
    });
    watch(select, (newVal, oldVal) => {
      map.removeInteraction(oldVal);
      map.addInteraction(newVal);
      map.changed();
    });
    onMounted(() => {
      map.addInteraction(select.value);
    });
    onUnmounted(() => {
      map.removeInteraction(select.value);
    });
    provide("stylable", select);
    return {
      select
    };
  },
  props: {
    multi: {
      type: Boolean,
      default: false
    },
    condition: {
      type: Function
    },
    filter: {
      type: Function
    },
    features: {
      type: [Collection, Object]
    }
  }
};
function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}
var SelectInteraction = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render$e]]);
var ol_interaction_SelectCluster = function(options) {
  options = options || {};
  this.pointRadius = options.pointRadius || 12;
  this.circleMaxObjects = options.circleMaxObjects || 10;
  this.maxObjects = options.maxObjects || 60;
  this.spiral = options.spiral !== false;
  this.animate = options.animate;
  this.animationDuration = options.animationDuration || 500;
  this.selectCluster_ = options.selectCluster !== false;
  this._autoClose = options.autoClose !== false;
  var overlay = this.overlayLayer_ = new VectorLayer$1({
    source: new VectorSource({
      features: new Collection(),
      wrapX: options.wrapX,
      useSpatialIndex: true
    }),
    name: "Cluster overlay",
    updateWhileAnimating: true,
    updateWhileInteracting: true,
    displayInLayerSwitcher: false,
    style: options.featureStyle
  });
  if (options.layers) {
    if (typeof options.layers == "function") {
      var fnLayers = options.layers;
      options.layers = function(layer) {
        return layer === overlay || fnLayers(layer);
      };
    } else if (options.layers.push) {
      options.layers.push(this.overlayLayer_);
    }
  }
  if (options.filter) {
    var fnFilter = options.filter;
    options.filter = function(f2, l2) {
      if (!l2 && f2.get("selectclusterlink"))
        return false;
      else
        return fnFilter(f2, l2);
    };
  } else
    options.filter = function(f2, l2) {
      if (!l2 && f2.get("selectclusterlink"))
        return false;
      else
        return true;
    };
  this.filter_ = options.filter;
  if (!this._autoClose && !options.toggleCondition) {
    options.toggleCondition = singleClick;
  }
  Select.call(this, options);
  this.on("select", this.selectCluster.bind(this));
};
ol_ext_inherits(ol_interaction_SelectCluster, Select);
ol_interaction_SelectCluster.prototype.setMap = function(map) {
  if (this.getMap()) {
    this.getMap().removeLayer(this.overlayLayer_);
  }
  if (this._listener)
    unByKey(this._listener);
  this._listener = null;
  Select.prototype.setMap.call(this, map);
  this.overlayLayer_.setMap(map);
  if (map && map.getView()) {
    this._listener = map.getView().on("change:resolution", this.clear.bind(this));
  }
};
ol_interaction_SelectCluster.prototype.clear = function() {
  this.getFeatures().clear();
  this.overlayLayer_.getSource().clear();
};
ol_interaction_SelectCluster.prototype.getLayer = function() {
  return this.overlayLayer_;
};
ol_interaction_SelectCluster.prototype.selectCluster = function(e2) {
  if (e2 instanceof Feature$1) {
    e2 = { selected: [e2] };
  }
  if (!e2.selected.length) {
    if (this._autoClose) {
      this.clear();
    } else {
      const deselectedFeatures = e2.deselected;
      deselectedFeatures.forEach((deselectedFeature) => {
        const selectClusterFeatures = deselectedFeature.get("selectcluserfeatures");
        selectClusterFeatures.forEach((selectClusterFeature) => {
          this.overlayLayer_.getSource().removeFeature(selectClusterFeature);
        });
      });
    }
    return;
  }
  var feature = e2.selected[0];
  if (feature.get("selectclusterfeature"))
    return;
  var source = this.overlayLayer_.getSource();
  if (this._autoClose) {
    source.clear();
  }
  var cluster = feature.get("features");
  if (!cluster || cluster.length == 1)
    return;
  if (!this.selectCluster_)
    this.getFeatures().clear();
  var center = feature.getGeometry().getCoordinates();
  var pix = this.getMap().getView().getResolution();
  var r2, a2, i2, max2;
  var p5, cf, lk;
  var features = [];
  if (!this.spiral || cluster.length <= this.circleMaxObjects) {
    max2 = Math.min(cluster.length, this.circleMaxObjects);
    r2 = pix * this.pointRadius * (0.5 + max2 / 4);
    for (i2 = 0; i2 < max2; i2++) {
      a2 = 2 * Math.PI * i2 / max2;
      if (max2 == 2 || max2 == 4)
        a2 += Math.PI / 4;
      p5 = [center[0] + r2 * Math.sin(a2), center[1] + r2 * Math.cos(a2)];
      cf = new Feature$1({ "selectclusterfeature": true, "features": [cluster[i2]], geometry: new Point$3(p5) });
      cf.setStyle(cluster[i2].getStyle());
      features.push(cf);
      lk = new Feature$1({ "selectclusterlink": true, geometry: new LineString$1([center, p5]) });
      features.push(lk);
    }
  } else {
    a2 = 0;
    var d2 = 2 * this.pointRadius;
    max2 = Math.min(this.maxObjects, cluster.length);
    for (i2 = 0; i2 < max2; i2++) {
      r2 = d2 / 2 + d2 * a2 / (2 * Math.PI);
      a2 = a2 + (d2 + 0.1) / r2;
      var dx = pix * r2 * Math.sin(a2);
      var dy = pix * r2 * Math.cos(a2);
      p5 = [center[0] + dx, center[1] + dy];
      cf = new Feature$1({ "selectclusterfeature": true, "features": [cluster[i2]], geometry: new Point$3(p5) });
      cf.setStyle(cluster[i2].getStyle());
      features.push(cf);
      lk = new Feature$1({ "selectclusterlink": true, geometry: new LineString$1([center, p5]) });
      features.push(lk);
    }
  }
  feature.set("selectcluserfeatures", features);
  if (this.animate) {
    this.animateCluster_(center, features);
  } else {
    source.addFeatures(features);
  }
};
ol_interaction_SelectCluster.prototype.animateCluster_ = function(center, features) {
  if (this.listenerKey_) {
    unByKey(this.listenerKey_);
  }
  if (!features.length)
    return;
  var style2 = this.overlayLayer_.getStyle();
  var stylefn = typeof style2 == "function" ? style2 : style2.length ? function() {
    return style2;
  } : function() {
    return [style2];
  };
  var duration2 = this.animationDuration || 500;
  var start2 = new Date().getTime();
  function animate(event) {
    var vectorContext = event.vectorContext || getVectorContext(event);
    var ratio = event.frameState.pixelRatio;
    var res = this.getMap().getView().getResolution();
    var e2 = easeOut((event.frameState.time - start2) / duration2);
    for (var i2 = 0, feature2; feature2 = features[i2]; i2++)
      if (feature2.get("features")) {
        var pt2 = feature2.getGeometry().getCoordinates();
        pt2[0] = center[0] + e2 * (pt2[0] - center[0]);
        pt2[1] = center[1] + e2 * (pt2[1] - center[1]);
        var geo = new Point$3(pt2);
        var st2 = stylefn(feature2, res);
        for (var s2 = 0; s2 < st2.length; s2++) {
          var sc;
          var imgs = Map$3.prototype.getFeaturesAtPixel ? false : st2[s2].getImage();
          if (imgs) {
            sc = imgs.getScale();
            imgs.setScale(ratio);
          }
          if (vectorContext.setStyle) {
            vectorContext.setStyle(st2[s2]);
            vectorContext.drawGeometry(geo);
          } else {
            vectorContext.setImageStyle(imgs);
            vectorContext.drawPointGeometry(geo);
          }
          if (imgs)
            imgs.setScale(sc);
        }
      }
    if (e2 > 1) {
      unByKey(this.listenerKey_);
      this.overlayLayer_.getSource().addFeatures(features);
      this.overlayLayer_.changed();
      return;
    }
    event.frameState.animate = true;
  }
  this.listenerKey_ = this.overlayLayer_.on(["postcompose", "postrender"], animate.bind(this));
  var feature = new Feature$1(new Point$3(this.getMap().getView().getCenter()));
  feature.setStyle(new Style$1({ image: new CircleStyle({}) }));
  this.overlayLayer_.getSource().addFeature(feature);
};
ol_interaction_SelectCluster.prototype.getClusterExtent = function(feature) {
  if (!feature.get("features"))
    return null;
  var extent2 = createEmpty();
  feature.get("features").forEach(function(f2) {
    extent2 = extend$2(extent2, f2.getGeometry().getExtent());
  });
  if (extent2[0] === extent2[2] && extent2[1] === extent2[3])
    return null;
  return extent2;
};
const _sfc_main$d = {
  name: "ol-interaction-clusterselect",
  emits: ["select"],
  setup(props, {
    emit
  }) {
    const map = inject("map");
    const {
      properties
    } = usePropsAsObjectProperties(props);
    let select = computed(() => {
      let s2 = new ol_interaction_SelectCluster(__spreadProps(__spreadValues({}, properties), {
        style: new Style$1()
      }));
      s2.on("select", (event) => {
        emit("select", event);
      });
      return s2;
    });
    watch(select, (newVal, oldVal) => {
      map.removeInteraction(oldVal);
      map.addInteraction(newVal);
      map.changed();
    });
    onMounted(() => {
      map.addInteraction(select.value);
    });
    onUnmounted(() => {
      map.removeInteraction(select.value);
    });
    provide("stylable", select);
  },
  props: {
    multi: {
      type: Boolean,
      default: false
    },
    condition: {
      type: Function
    },
    filter: {
      type: Function
    },
    pointRadius: {
      type: Number,
      default: 7
    },
    animate: {
      type: Boolean,
      default: true
    },
    featureStyle: {
      type: Function
    },
    style: {
      type: Function
    }
  }
};
function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}
var ClusterSelectInteraction = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$d]]);
const _sfc_main$c = {
  name: "ol-interaction-draw",
  emits: ["drawstart", "drawend"],
  setup(props, {
    emit
  }) {
    const map = inject("map");
    const source = inject("vectorSource");
    const {
      type,
      clickTolerance,
      dragVertexDelay,
      snapTolerance,
      stopClick,
      maxPoints,
      minPoints,
      finishCondition,
      geometryFunction,
      geometryName,
      condition,
      freehand,
      freehandCondition,
      wrapX: wrapX2
    } = toRefs(props);
    let createDraw = () => {
      let draw2 = new Draw({
        source: source.value,
        type: type.value,
        clickTolerance: clickTolerance.value,
        dragVertexDelay: dragVertexDelay.value,
        snapTolerance: snapTolerance.value,
        stopClick: stopClick.value,
        maxPoints: maxPoints.value,
        minPoints: minPoints.value,
        finishCondition: finishCondition.value,
        geometryFunction: geometryFunction.value,
        geometryName: geometryName.value,
        condition: condition.value,
        freehand: freehand.value,
        freehandCondition: freehandCondition.value,
        wrapX: wrapX2.value
      });
      draw2.on("drawstart", (event) => {
        emit("drawstart", event);
      });
      draw2.on("drawend", (event) => {
        emit("drawend", event);
      });
      return draw2;
    };
    let draw = createDraw();
    watch([
      type,
      clickTolerance,
      dragVertexDelay,
      snapTolerance,
      stopClick,
      maxPoints,
      minPoints,
      finishCondition,
      geometryFunction,
      geometryName,
      condition,
      freehand,
      freehandCondition,
      wrapX2
    ], () => {
      map.removeInteraction(draw);
      draw = createDraw();
      map.addInteraction(draw);
      draw.changed();
      map.changed();
    });
    onMounted(() => {
      map.addInteraction(draw);
    });
    onUnmounted(() => {
      map.removeInteraction(draw);
    });
    provide("stylable", draw);
  },
  props: {
    type: {
      type: String,
      required: true
    },
    clickTolerance: {
      type: Number,
      default: 6
    },
    dragVertexDelay: {
      type: Number,
      default: 500
    },
    snapTolerance: {
      type: Number,
      default: 12
    },
    stopClick: {
      type: Boolean,
      default: false
    },
    maxPoints: {
      type: Number
    },
    minPoints: {
      type: Number
    },
    finishCondition: {
      type: Function
    },
    geometryFunction: {
      type: Function
    },
    geometryName: {
      type: String
    },
    condition: {
      type: Function
    },
    freehand: {
      type: Boolean,
      default: false
    },
    freehandCondition: {
      type: Function
    },
    wrapX: {
      type: Boolean,
      default: false
    }
  }
};
function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}
var DrawInteraction = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$c]]);
function getFeatureFromEvent(evt) {
  if (evt.feature) {
    return evt.feature;
  } else if (evt.element) {
    return evt.element;
  }
}
const tempSegment = [];
class Snap extends PointerInteraction {
  constructor(options) {
    options = options ? options : {};
    const pointerOptions = options;
    if (!pointerOptions.handleDownEvent) {
      pointerOptions.handleDownEvent = TRUE;
    }
    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = FALSE;
    }
    super(pointerOptions);
    this.source_ = options.source ? options.source : null;
    this.vertex_ = options.vertex !== void 0 ? options.vertex : true;
    this.edge_ = options.edge !== void 0 ? options.edge : true;
    this.features_ = options.features ? options.features : null;
    this.featuresListenerKeys_ = [];
    this.featureChangeListenerKeys_ = {};
    this.indexedFeaturesExtents_ = {};
    this.pendingFeatures_ = {};
    this.pixelTolerance_ = options.pixelTolerance !== void 0 ? options.pixelTolerance : 10;
    this.rBush_ = new RBush();
    this.GEOMETRY_SEGMENTERS_ = {
      "Point": this.segmentPointGeometry_.bind(this),
      "LineString": this.segmentLineStringGeometry_.bind(this),
      "LinearRing": this.segmentLineStringGeometry_.bind(this),
      "Polygon": this.segmentPolygonGeometry_.bind(this),
      "MultiPoint": this.segmentMultiPointGeometry_.bind(this),
      "MultiLineString": this.segmentMultiLineStringGeometry_.bind(this),
      "MultiPolygon": this.segmentMultiPolygonGeometry_.bind(this),
      "GeometryCollection": this.segmentGeometryCollectionGeometry_.bind(this),
      "Circle": this.segmentCircleGeometry_.bind(this)
    };
  }
  addFeature(feature, register2) {
    register2 = register2 !== void 0 ? register2 : true;
    const feature_uid = getUid(feature);
    const geometry = feature.getGeometry();
    if (geometry) {
      const segmenter = this.GEOMETRY_SEGMENTERS_[geometry.getType()];
      if (segmenter) {
        this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(createEmpty());
        const segments = [];
        segmenter(segments, geometry);
        if (segments.length === 1) {
          this.rBush_.insert(boundingExtent(segments[0]), {
            feature,
            segment: segments[0]
          });
        } else if (segments.length > 1) {
          const extents = segments.map((s2) => boundingExtent(s2));
          const segmentsData = segments.map((segment) => ({
            feature,
            segment
          }));
          this.rBush_.load(extents, segmentsData);
        }
      }
    }
    if (register2) {
      this.featureChangeListenerKeys_[feature_uid] = listen(feature, EventType.CHANGE, this.handleFeatureChange_, this);
    }
  }
  forEachFeatureAdd_(feature) {
    this.addFeature(feature);
  }
  forEachFeatureRemove_(feature) {
    this.removeFeature(feature);
  }
  getFeatures_() {
    let features;
    if (this.features_) {
      features = this.features_;
    } else if (this.source_) {
      features = this.source_.getFeatures();
    }
    return features;
  }
  handleEvent(evt) {
    const result = this.snapTo(evt.pixel, evt.coordinate, evt.map);
    if (result) {
      evt.coordinate = result.vertex.slice(0, 2);
      evt.pixel = result.vertexPixel;
    }
    return super.handleEvent(evt);
  }
  handleFeatureAdd_(evt) {
    const feature = getFeatureFromEvent(evt);
    this.addFeature(feature);
  }
  handleFeatureRemove_(evt) {
    const feature = getFeatureFromEvent(evt);
    this.removeFeature(feature);
  }
  handleFeatureChange_(evt) {
    const feature = evt.target;
    if (this.handlingDownUpSequence) {
      const uid2 = getUid(feature);
      if (!(uid2 in this.pendingFeatures_)) {
        this.pendingFeatures_[uid2] = feature;
      }
    } else {
      this.updateFeature_(feature);
    }
  }
  handleUpEvent(evt) {
    const featuresToUpdate = Object.values(this.pendingFeatures_);
    if (featuresToUpdate.length) {
      featuresToUpdate.forEach(this.updateFeature_.bind(this));
      this.pendingFeatures_ = {};
    }
    return false;
  }
  removeFeature(feature, unlisten) {
    const unregister = unlisten !== void 0 ? unlisten : true;
    const feature_uid = getUid(feature);
    const extent2 = this.indexedFeaturesExtents_[feature_uid];
    if (extent2) {
      const rBush = this.rBush_;
      const nodesToRemove = [];
      rBush.forEachInExtent(extent2, function(node2) {
        if (feature === node2.feature) {
          nodesToRemove.push(node2);
        }
      });
      for (let i2 = nodesToRemove.length - 1; i2 >= 0; --i2) {
        rBush.remove(nodesToRemove[i2]);
      }
    }
    if (unregister) {
      unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);
      delete this.featureChangeListenerKeys_[feature_uid];
    }
  }
  setMap(map) {
    const currentMap = this.getMap();
    const keys3 = this.featuresListenerKeys_;
    const features = this.getFeatures_();
    if (currentMap) {
      keys3.forEach(unlistenByKey);
      keys3.length = 0;
      features.forEach(this.forEachFeatureRemove_.bind(this));
    }
    super.setMap(map);
    if (map) {
      if (this.features_) {
        keys3.push(listen(this.features_, CollectionEventType.ADD, this.handleFeatureAdd_, this), listen(this.features_, CollectionEventType.REMOVE, this.handleFeatureRemove_, this));
      } else if (this.source_) {
        keys3.push(listen(this.source_, VectorEventType.ADDFEATURE, this.handleFeatureAdd_, this), listen(this.source_, VectorEventType.REMOVEFEATURE, this.handleFeatureRemove_, this));
      }
      features.forEach(this.forEachFeatureAdd_.bind(this));
    }
  }
  snapTo(pixel, pixelCoordinate, map) {
    const lowerLeft = map.getCoordinateFromPixel([
      pixel[0] - this.pixelTolerance_,
      pixel[1] + this.pixelTolerance_
    ]);
    const upperRight = map.getCoordinateFromPixel([
      pixel[0] + this.pixelTolerance_,
      pixel[1] - this.pixelTolerance_
    ]);
    const box = boundingExtent([lowerLeft, upperRight]);
    const segments = this.rBush_.getInExtent(box);
    const segmentsLength = segments.length;
    if (segmentsLength === 0) {
      return null;
    }
    map.getView().getProjection();
    const projectedCoordinate = fromUserCoordinate(pixelCoordinate);
    let closestVertex;
    let minSquaredDistance = Infinity;
    const squaredPixelTolerance = this.pixelTolerance_ * this.pixelTolerance_;
    const getResult = () => {
      if (closestVertex) {
        const vertexPixel = map.getPixelFromCoordinate(closestVertex);
        const squaredPixelDistance = squaredDistance(pixel, vertexPixel);
        if (squaredPixelDistance <= squaredPixelTolerance) {
          return {
            vertex: closestVertex,
            vertexPixel: [
              Math.round(vertexPixel[0]),
              Math.round(vertexPixel[1])
            ]
          };
        }
      }
      return null;
    };
    if (this.vertex_) {
      for (let i2 = 0; i2 < segmentsLength; ++i2) {
        const segmentData = segments[i2];
        if (segmentData.feature.getGeometry().getType() !== "Circle") {
          segmentData.segment.forEach((vertex) => {
            const tempVertexCoord = fromUserCoordinate(vertex);
            const delta = squaredDistance(projectedCoordinate, tempVertexCoord);
            if (delta < minSquaredDistance) {
              closestVertex = vertex;
              minSquaredDistance = delta;
            }
          });
        }
      }
      const result = getResult();
      if (result) {
        return result;
      }
    }
    if (this.edge_) {
      for (let i2 = 0; i2 < segmentsLength; ++i2) {
        let vertex = null;
        const segmentData = segments[i2];
        if (segmentData.feature.getGeometry().getType() === "Circle") {
          let circleGeometry = segmentData.feature.getGeometry();
          vertex = toUserCoordinate(closestOnCircle(projectedCoordinate, circleGeometry));
        } else {
          const [segmentStart, segmentEnd] = segmentData.segment;
          if (segmentEnd) {
            tempSegment[0] = fromUserCoordinate(segmentStart);
            tempSegment[1] = fromUserCoordinate(segmentEnd);
            vertex = closestOnSegment(projectedCoordinate, tempSegment);
          }
        }
        if (vertex) {
          const delta = squaredDistance(projectedCoordinate, vertex);
          if (delta < minSquaredDistance) {
            closestVertex = vertex;
            minSquaredDistance = delta;
          }
        }
      }
      const result = getResult();
      if (result) {
        return result;
      }
    }
    return null;
  }
  updateFeature_(feature) {
    this.removeFeature(feature, false);
    this.addFeature(feature, false);
  }
  segmentCircleGeometry_(segments, geometry) {
    this.getMap().getView().getProjection();
    let circleGeometry = geometry;
    const polygon = fromCircle(circleGeometry);
    const coordinates2 = polygon.getCoordinates()[0];
    for (let i2 = 0, ii = coordinates2.length - 1; i2 < ii; ++i2) {
      segments.push(coordinates2.slice(i2, i2 + 2));
    }
  }
  segmentGeometryCollectionGeometry_(segments, geometry) {
    const geometries = geometry.getGeometriesArray();
    for (let i2 = 0; i2 < geometries.length; ++i2) {
      const segmenter = this.GEOMETRY_SEGMENTERS_[geometries[i2].getType()];
      if (segmenter) {
        segmenter(segments, geometries[i2]);
      }
    }
  }
  segmentLineStringGeometry_(segments, geometry) {
    const coordinates2 = geometry.getCoordinates();
    for (let i2 = 0, ii = coordinates2.length - 1; i2 < ii; ++i2) {
      segments.push(coordinates2.slice(i2, i2 + 2));
    }
  }
  segmentMultiLineStringGeometry_(segments, geometry) {
    const lines = geometry.getCoordinates();
    for (let j2 = 0, jj = lines.length; j2 < jj; ++j2) {
      const coordinates2 = lines[j2];
      for (let i2 = 0, ii = coordinates2.length - 1; i2 < ii; ++i2) {
        segments.push(coordinates2.slice(i2, i2 + 2));
      }
    }
  }
  segmentMultiPointGeometry_(segments, geometry) {
    geometry.getCoordinates().forEach((point) => {
      segments.push([point]);
    });
  }
  segmentMultiPolygonGeometry_(segments, geometry) {
    const polygons = geometry.getCoordinates();
    for (let k2 = 0, kk = polygons.length; k2 < kk; ++k2) {
      const rings = polygons[k2];
      for (let j2 = 0, jj = rings.length; j2 < jj; ++j2) {
        const coordinates2 = rings[j2];
        for (let i2 = 0, ii = coordinates2.length - 1; i2 < ii; ++i2) {
          segments.push(coordinates2.slice(i2, i2 + 2));
        }
      }
    }
  }
  segmentPointGeometry_(segments, geometry) {
    segments.push([geometry.getCoordinates()]);
  }
  segmentPolygonGeometry_(segments, geometry) {
    const rings = geometry.getCoordinates();
    for (let j2 = 0, jj = rings.length; j2 < jj; ++j2) {
      const coordinates2 = rings[j2];
      for (let i2 = 0, ii = coordinates2.length - 1; i2 < ii; ++i2) {
        segments.push(coordinates2.slice(i2, i2 + 2));
      }
    }
  }
}
const _sfc_main$b = {
  name: "ol-interaction-snap",
  setup(props) {
    const map = inject("map");
    const source = inject("vectorSource");
    const {
      properties
    } = usePropsAsObjectProperties(props);
    let createSnap = () => {
      let s2 = new Snap(__spreadProps(__spreadValues({}, properties), {
        source: source.value
      }));
      return s2;
    };
    let snap2 = createSnap();
    watch(properties, () => {
      map.removeInteraction(snap2);
      snap2 = createSnap();
      map.addInteraction(snap2);
      map.changed();
    });
    onMounted(() => {
      map.addInteraction(snap2);
    });
    onUnmounted(() => {
      map.removeInteraction(snap2);
    });
  },
  props: {
    vertex: {
      type: Boolean,
      default: true
    },
    edge: {
      type: Boolean,
      default: true
    },
    pixelTolerance: {
      type: Number,
      default: 10
    }
  }
};
function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}
var SnapInteraction = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$b]]);
const _sfc_main$a = {
  name: "ol-interaction-modify",
  emits: ["modifystart", "modifyend"],
  setup(props, {
    emit
  }) {
    const map = inject("map");
    const source = inject("vectorSource");
    const {
      features,
      condition,
      deleteCondition,
      insertVertexCondition,
      pixelTolerance,
      wrapX: wrapX2,
      hitDetection
    } = toRefs(props);
    let createModify = () => {
      let modify2 = new Modify({
        source: source.value,
        features: features.value,
        condition: condition.value,
        deleteCondition: deleteCondition.value,
        insertVertexCondition: insertVertexCondition.value,
        pixelTolerance: pixelTolerance.value,
        wrapX: wrapX2.value,
        hitDetection: hitDetection.value
      });
      modify2.on("modifystart", (event) => {
        emit("modifystart", event);
      });
      modify2.on("modifyend", (event) => {
        emit("modifyend", event);
      });
      return modify2;
    };
    let modify = createModify();
    watch([
      condition,
      deleteCondition,
      insertVertexCondition,
      pixelTolerance,
      wrapX2,
      hitDetection
    ], () => {
      map.removeInteraction(modify);
      modify = createModify();
      map.addInteraction(modify);
      modify.changed();
      map.changed();
    });
    onMounted(() => {
      map.addInteraction(modify);
    });
    onUnmounted(() => {
      map.removeInteraction(modify);
    });
    provide("stylable", modify);
  },
  props: {
    condition: {
      type: Function
    },
    deleteCondition: {
      type: Function
    },
    insertVertexCondition: {
      type: Function
    },
    pixelTolerance: {
      type: Number,
      default: 10
    },
    wrapX: {
      type: Boolean,
      default: false
    },
    hitDetection: {
      type: Boolean
    },
    features: {
      type: [Collection, Object]
    }
  }
};
function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}
var ModifyInteraction = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$a]]);
var ol_interaction_Transform = function(options) {
  if (!options)
    options = {};
  var self2 = this;
  this.selection_ = new Collection();
  this.handles_ = new Collection();
  this.overlayLayer_ = new VectorLayer$1({
    source: new VectorSource({
      features: this.handles_,
      useSpatialIndex: false,
      wrapX: false
    }),
    name: "Transform overlay",
    displayInLayerSwitcher: false,
    style: function(feature) {
      return self2.style[(feature.get("handle") || "default") + (feature.get("constraint") || "") + (feature.get("option") || "")];
    }
  });
  PointerInteraction.call(this, {
    handleDownEvent: this.handleDownEvent_,
    handleDragEvent: this.handleDragEvent_,
    handleMoveEvent: this.handleMoveEvent_,
    handleUpEvent: this.handleUpEvent_
  });
  this.features_ = options.features;
  if (typeof options.filter === "function")
    this._filter = options.filter;
  this.layers_ = options.layers ? options.layers instanceof Array ? options.layers : [options.layers] : null;
  this._handleEvent = options.condition || function() {
    return true;
  };
  this.addFn_ = options.addCondition || function() {
    return false;
  };
  this.set("translateFeature", options.translateFeature !== false);
  this.set("translate", options.translate !== false);
  this.set("translateBBox", options.translateBBox === true);
  this.set("stretch", options.stretch !== false);
  this.set("scale", options.scale !== false);
  this.set("rotate", options.rotate !== false);
  this.set("keepAspectRatio", options.keepAspectRatio || function(e2) {
    return e2.originalEvent.shiftKey;
  });
  this.set("modifyCenter", options.modifyCenter || function(e2) {
    return e2.originalEvent.metaKey || e2.originalEvent.ctrlKey;
  });
  this.set("noFlip", options.noFlip || false);
  this.set("selection", options.selection !== false);
  this.set("hitTolerance", options.hitTolerance || 0);
  this.set("enableRotatedTransform", options.enableRotatedTransform || false);
  this.set("keepRectangle", options.keepRectangle || false);
  this.on("propertychange", function() {
    this.drawSketch_();
  });
  this.setDefaultStyle();
};
ol_ext_inherits(ol_interaction_Transform, PointerInteraction);
ol_interaction_Transform.prototype.Cursors = {
  "default": "auto",
  "select": "pointer",
  "translate": "move",
  "rotate": "move",
  "rotate0": "move",
  "scale": "nesw-resize",
  "scale1": "nwse-resize",
  "scale2": "nesw-resize",
  "scale3": "nwse-resize",
  "scalev": "ew-resize",
  "scaleh1": "ns-resize",
  "scalev2": "ew-resize",
  "scaleh3": "ns-resize"
};
ol_interaction_Transform.prototype.setMap = function(map) {
  var oldMap = this.getMap();
  if (oldMap) {
    var targetElement = oldMap.getTargetElement();
    oldMap.removeLayer(this.overlayLayer_);
    if (this.previousCursor_ && targetElement) {
      targetElement.style.cursor = this.previousCursor_;
    }
    this.previousCursor_ = void 0;
  }
  PointerInteraction.prototype.setMap.call(this, map);
  this.overlayLayer_.setMap(map);
  if (map === null) {
    this.select(null);
  }
  if (map !== null) {
    this.isTouch = /touch/.test(map.getViewport().className);
    this.setDefaultStyle();
  }
};
ol_interaction_Transform.prototype.setActive = function(b2) {
  this.select(null);
  this.overlayLayer_.setVisible(b2);
  PointerInteraction.prototype.setActive.call(this, b2);
};
ol_interaction_Transform.prototype.setDefaultStyle = function(options) {
  options = options || {};
  var stroke = options.pointStroke || new Stroke$1({ color: [255, 0, 0, 1], width: 1 });
  var strokedash = options.stroke || new Stroke$1({ color: [255, 0, 0, 1], width: 1, lineDash: [4, 4] });
  var fill0 = options.fill || new Fill$1({ color: [255, 0, 0, 0.01] });
  var fill = options.pointFill || new Fill$1({ color: [255, 255, 255, 0.8] });
  var circle = new RegularShape({
    fill,
    stroke,
    radius: this.isTouch ? 12 : 6,
    displacement: this.isTouch ? [24, -24] : [12, -12],
    points: 15
  });
  if (!circle.setDisplacement)
    circle.getAnchor()[0] = this.isTouch ? -10 : -5;
  var bigpt = new RegularShape({
    fill,
    stroke,
    radius: this.isTouch ? 16 : 8,
    points: 4,
    angle: Math.PI / 4
  });
  var smallpt = new RegularShape({
    fill,
    stroke,
    radius: this.isTouch ? 12 : 6,
    points: 4,
    angle: Math.PI / 4
  });
  function createStyle(img, stroke2, fill2) {
    return [new Style$1({ image: img, stroke: stroke2, fill: fill2 })];
  }
  this.style = {
    "default": createStyle(bigpt, strokedash, fill0),
    "translate": createStyle(bigpt, stroke, fill),
    "rotate": createStyle(circle, stroke, fill),
    "rotate0": createStyle(bigpt, stroke, fill),
    "scale": createStyle(bigpt, stroke, fill),
    "scale1": createStyle(bigpt, stroke, fill),
    "scale2": createStyle(bigpt, stroke, fill),
    "scale3": createStyle(bigpt, stroke, fill),
    "scalev": createStyle(smallpt, stroke, fill),
    "scaleh1": createStyle(smallpt, stroke, fill),
    "scalev2": createStyle(smallpt, stroke, fill),
    "scaleh3": createStyle(smallpt, stroke, fill)
  };
  this.drawSketch_();
};
ol_interaction_Transform.prototype.setStyle = function(style2, olstyle) {
  if (!olstyle)
    return;
  if (olstyle instanceof Array)
    this.style[style2] = olstyle;
  else
    this.style[style2] = [olstyle];
  for (var i2 = 0; i2 < this.style[style2].length; i2++) {
    var im = this.style[style2][i2].getImage();
    if (im) {
      if (style2 == "rotate") {
        im.getAnchor()[0] = -5;
      }
      if (this.isTouch)
        im.setScale(1.8);
    }
    var tx = this.style[style2][i2].getText();
    if (tx) {
      if (style2 == "rotate")
        tx.setOffsetX(this.isTouch ? 14 : 7);
      if (this.isTouch)
        tx.setScale(1.8);
    }
  }
  this.drawSketch_();
};
ol_interaction_Transform.prototype.getFeatureAtPixel_ = function(pixel) {
  var self2 = this;
  return this.getMap().forEachFeatureAtPixel(pixel, function(feature, layer) {
    var found = false;
    if (!layer) {
      if (feature === self2.bbox_) {
        if (self2.get("translateBBox")) {
          return { feature, handle: "translate", constraint: "", option: "" };
        } else {
          return false;
        }
      }
      self2.handles_.forEach(function(f2) {
        if (f2 === feature)
          found = true;
      });
      if (found)
        return { feature, handle: feature.get("handle"), constraint: feature.get("constraint"), option: feature.get("option") };
    }
    if (!self2.get("selection")) {
      if (self2.selection_.getArray().some(function(f2) {
        return feature === f2;
      })) {
        return { feature };
      }
      return null;
    }
    if (self2._filter) {
      if (self2._filter(feature, layer))
        return { feature };
      else
        return null;
    } else if (self2.layers_) {
      for (var i2 = 0; i2 < self2.layers_.length; i2++) {
        if (self2.layers_[i2] === layer)
          return { feature };
      }
      return null;
    } else if (self2.features_) {
      self2.features_.forEach(function(f2) {
        if (f2 === feature)
          found = true;
      });
      if (found)
        return { feature };
      else
        return null;
    } else
      return { feature };
  }, { hitTolerance: this.get("hitTolerance") }) || {};
};
ol_interaction_Transform.prototype.getGeometryRotateToZero_ = function(f2, clone2) {
  var origGeom = f2.getGeometry();
  var viewRotation = this.getMap().getView().getRotation();
  if (viewRotation === 0 || !this.get("enableRotatedTransform")) {
    return clone2 ? origGeom.clone() : origGeom;
  }
  var rotGeom = origGeom.clone();
  rotGeom.rotate(viewRotation * -1, this.getMap().getView().getCenter());
  return rotGeom;
};
ol_interaction_Transform.prototype._isRectangle = function(geom2) {
  if (this.get("keepRectangle") && geom2.getType() === "Polygon") {
    var coords = geom2.getCoordinates()[0];
    return coords.length === 5;
  }
  return false;
};
ol_interaction_Transform.prototype.drawSketch_ = function(center) {
  var i2, f2, geom2;
  var keepRectangle = this.selection_.item(0) && this._isRectangle(this.selection_.item(0).getGeometry());
  this.overlayLayer_.getSource().clear();
  if (!this.selection_.getLength())
    return;
  var viewRotation = this.getMap().getView().getRotation();
  var ext = this.getGeometryRotateToZero_(this.selection_.item(0)).getExtent();
  var coords;
  if (keepRectangle) {
    coords = this.getGeometryRotateToZero_(this.selection_.item(0)).getCoordinates()[0].slice(0, 4);
    coords.unshift(coords[3]);
  }
  ext = buffer$2(ext, 0);
  this.selection_.forEach(function(f3) {
    var extendExt = this.getGeometryRotateToZero_(f3).getExtent();
    extend$2(ext, extendExt);
  }.bind(this));
  if (center === true) {
    if (!this.ispt_) {
      this.overlayLayer_.getSource().addFeature(new Feature$1({ geometry: new Point$3(this.center_), handle: "rotate0" }));
      geom2 = fromExtent(ext);
      if (this.get("enableRotatedTransform") && viewRotation !== 0) {
        geom2.rotate(viewRotation, this.getMap().getView().getCenter());
      }
      f2 = this.bbox_ = new Feature$1(geom2);
      this.overlayLayer_.getSource().addFeature(f2);
    }
  } else {
    if (this.ispt_) {
      var p5 = this.getMap().getPixelFromCoordinate([ext[0], ext[1]]);
      if (p5) {
        ext = boundingExtent([
          this.getMap().getCoordinateFromPixel([p5[0] - 10, p5[1] - 10]),
          this.getMap().getCoordinateFromPixel([p5[0] + 10, p5[1] + 10])
        ]);
      }
    }
    geom2 = keepRectangle ? new Polygon$1([coords]) : fromExtent(ext);
    if (this.get("enableRotatedTransform") && viewRotation !== 0) {
      geom2.rotate(viewRotation, this.getMap().getView().getCenter());
    }
    f2 = this.bbox_ = new Feature$1(geom2);
    var features = [];
    var g2 = geom2.getCoordinates()[0];
    if (!this.ispt_) {
      features.push(f2);
      if (!this.iscircle_ && this.get("stretch") && this.get("scale"))
        for (i2 = 0; i2 < g2.length - 1; i2++) {
          f2 = new Feature$1({ geometry: new Point$3([(g2[i2][0] + g2[i2 + 1][0]) / 2, (g2[i2][1] + g2[i2 + 1][1]) / 2]), handle: "scale", constraint: i2 % 2 ? "h" : "v", option: i2 });
          features.push(f2);
        }
      if (this.get("scale"))
        for (i2 = 0; i2 < g2.length - 1; i2++) {
          f2 = new Feature$1({ geometry: new Point$3(g2[i2]), handle: "scale", option: i2 });
          features.push(f2);
        }
      if (this.get("translate") && !this.get("translateFeature")) {
        f2 = new Feature$1({ geometry: new Point$3([(g2[0][0] + g2[2][0]) / 2, (g2[0][1] + g2[2][1]) / 2]), handle: "translate" });
        features.push(f2);
      }
    }
    if (!this.iscircle_ && this.get("rotate")) {
      f2 = new Feature$1({ geometry: new Point$3(g2[3]), handle: "rotate" });
      features.push(f2);
    }
    this.overlayLayer_.getSource().addFeatures(features);
  }
};
ol_interaction_Transform.prototype.select = function(feature, add2) {
  if (!feature) {
    this.selection_.clear();
    this.drawSketch_();
    return;
  }
  if (!feature.getGeometry || !feature.getGeometry())
    return;
  if (add2) {
    this.selection_.push(feature);
  } else {
    var index2 = this.selection_.getArray().indexOf(feature);
    this.selection_.removeAt(index2);
  }
  this.ispt_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == "Point" : false;
  this.iscircle_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == "Circle" : false;
  this.drawSketch_();
  this.watchFeatures_();
  this.dispatchEvent({ type: "select", feature, features: this.selection_ });
};
ol_interaction_Transform.prototype.setSelection = function(features) {
  this.selection_.clear();
  features.forEach(function(feature) {
    this.selection_.push(feature);
  }.bind(this));
  this.ispt_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == "Point" : false;
  this.iscircle_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == "Circle" : false;
  this.drawSketch_();
  this.watchFeatures_();
  this.dispatchEvent({ type: "select", features: this.selection_ });
};
ol_interaction_Transform.prototype.watchFeatures_ = function() {
  if (this._featureListeners) {
    this._featureListeners.forEach(function(l2) {
      unByKey(l2);
    });
  }
  this._featureListeners = [];
  this.selection_.forEach(function(f2) {
    this._featureListeners.push(f2.on("change", function() {
      if (!this.isUpdating_) {
        this.drawSketch_();
      }
    }.bind(this)));
  }.bind(this));
};
ol_interaction_Transform.prototype.handleDownEvent_ = function(evt) {
  if (!this._handleEvent(evt, this.selection_))
    return;
  var sel = this.getFeatureAtPixel_(evt.pixel);
  var feature = sel.feature;
  if (this.selection_.getLength() && this.selection_.getArray().indexOf(feature) >= 0 && (this.ispt_ && this.get("translate") || this.get("translateFeature"))) {
    sel.handle = "translate";
  }
  if (sel.handle) {
    this.mode_ = sel.handle;
    this.opt_ = sel.option;
    this.constraint_ = sel.constraint;
    var viewRotation = this.getMap().getView().getRotation();
    this.coordinate_ = evt.coordinate;
    this.pixel_ = evt.pixel;
    this.geoms_ = [];
    this.rotatedGeoms_ = [];
    var extent2 = createEmpty();
    var rotExtent = createEmpty();
    for (var i2 = 0, f2; f2 = this.selection_.item(i2); i2++) {
      this.geoms_.push(f2.getGeometry().clone());
      extent2 = extend$2(extent2, f2.getGeometry().getExtent());
      if (this.get("enableRotatedTransform") && viewRotation !== 0) {
        var rotGeom = this.getGeometryRotateToZero_(f2, true);
        this.rotatedGeoms_.push(rotGeom);
        rotExtent = extend$2(rotExtent, rotGeom.getExtent());
      }
    }
    this.extent_ = fromExtent(extent2).getCoordinates()[0];
    if (this.get("enableRotatedTransform") && viewRotation !== 0) {
      this.rotatedExtent_ = fromExtent(rotExtent).getCoordinates()[0];
    }
    if (this.mode_ === "rotate") {
      this.center_ = this.getCenter() || getCenter(extent2);
      var element = evt.map.getTargetElement();
      element.style.cursor = this.Cursors.rotate0;
      this.previousCursor_ = element.style.cursor;
    } else {
      this.center_ = getCenter(extent2);
    }
    this.angle_ = Math.atan2(this.center_[1] - evt.coordinate[1], this.center_[0] - evt.coordinate[0]);
    this.dispatchEvent({
      type: this.mode_ + "start",
      feature: this.selection_.item(0),
      features: this.selection_,
      pixel: evt.pixel,
      coordinate: evt.coordinate
    });
    return true;
  } else if (this.get("selection")) {
    if (feature) {
      if (!this.addFn_(evt))
        this.selection_.clear();
      var index2 = this.selection_.getArray().indexOf(feature);
      if (index2 < 0)
        this.selection_.push(feature);
      else
        this.selection_.removeAt(index2);
    } else {
      this.selection_.clear();
    }
    this.ispt_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == "Point" : false;
    this.iscircle_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == "Circle" : false;
    this.drawSketch_();
    this.watchFeatures_();
    this.dispatchEvent({ type: "select", feature, features: this.selection_, pixel: evt.pixel, coordinate: evt.coordinate });
    return false;
  }
};
ol_interaction_Transform.prototype.getFeatures = function() {
  return this.selection_;
};
ol_interaction_Transform.prototype.getCenter = function() {
  return this.get("center");
};
ol_interaction_Transform.prototype.setCenter = function(c2) {
  return this.set("center", c2);
};
function projectVectorOnVector(displacement_vector, base) {
  var k2 = (displacement_vector[0] * base[0] + displacement_vector[1] * base[1]) / (base[0] * base[0] + base[1] * base[1]);
  return [base[0] * k2, base[1] * k2];
}
function countVector(start2, end) {
  return [end[0] - start2[0], end[1] - start2[1]];
}
function movePoint(point, displacementVector) {
  return [point[0] + displacementVector[0], point[1] + displacementVector[1]];
}
ol_interaction_Transform.prototype.handleDragEvent_ = function(evt) {
  if (!this._handleEvent(evt, this.features_))
    return;
  var viewRotation = this.getMap().getView().getRotation();
  var i2, j2, f2, geometry;
  var pt0 = [this.coordinate_[0], this.coordinate_[1]];
  var pt2 = [evt.coordinate[0], evt.coordinate[1]];
  this.isUpdating_ = true;
  switch (this.mode_) {
    case "rotate": {
      var a2 = Math.atan2(this.center_[1] - pt2[1], this.center_[0] - pt2[0]);
      if (!this.ispt) {
        for (i2 = 0, f2; f2 = this.selection_.item(i2); i2++) {
          geometry = this.geoms_[i2].clone();
          geometry.rotate(a2 - this.angle_, this.center_);
          if (geometry.getType() == "Circle")
            geometry.setCenterAndRadius(geometry.getCenter(), geometry.getRadius());
          f2.setGeometry(geometry);
        }
      }
      this.drawSketch_(true);
      this.dispatchEvent({
        type: "rotating",
        feature: this.selection_.item(0),
        features: this.selection_,
        angle: a2 - this.angle_,
        pixel: evt.pixel,
        coordinate: evt.coordinate
      });
      break;
    }
    case "translate": {
      var deltaX = pt2[0] - pt0[0];
      var deltaY = pt2[1] - pt0[1];
      for (i2 = 0, f2; f2 = this.selection_.item(i2); i2++) {
        f2.getGeometry().translate(deltaX, deltaY);
      }
      this.handles_.forEach(function(f3) {
        f3.getGeometry().translate(deltaX, deltaY);
      });
      this.coordinate_ = evt.coordinate;
      this.dispatchEvent({
        type: "translating",
        feature: this.selection_.item(0),
        features: this.selection_,
        delta: [deltaX, deltaY],
        pixel: evt.pixel,
        coordinate: evt.coordinate
      });
      break;
    }
    case "scale": {
      var center = this.center_;
      if (this.get("modifyCenter")(evt)) {
        var extentCoordinates = this.extent_;
        if (this.get("enableRotatedTransform") && viewRotation !== 0) {
          extentCoordinates = this.rotatedExtent_;
        }
        center = extentCoordinates[(Number(this.opt_) + 2) % 4];
      }
      var keepRectangle = this.geoms_.length == 1 && this._isRectangle(this.geoms_[0]);
      var stretch = this.constraint_;
      var opt = this.opt_;
      var downCoordinate = this.coordinate_;
      var dragCoordinate = evt.coordinate;
      if (this.get("enableRotatedTransform") && viewRotation !== 0) {
        var downPoint = new Point$3(this.coordinate_);
        downPoint.rotate(viewRotation * -1, center);
        downCoordinate = downPoint.getCoordinates();
        var dragPoint = new Point$3(evt.coordinate);
        dragPoint.rotate(viewRotation * -1, center);
        dragCoordinate = dragPoint.getCoordinates();
      }
      var scx = (dragCoordinate[0] - center[0]) / (downCoordinate[0] - center[0]);
      var scy = (dragCoordinate[1] - center[1]) / (downCoordinate[1] - center[1]);
      var displacementVector = [dragCoordinate[0] - downCoordinate[0], dragCoordinate[1] - downCoordinate[1]];
      if (this.get("enableRotatedTransform") && viewRotation !== 0) {
        var centerPoint = new Point$3(center);
        centerPoint.rotate(viewRotation * -1, this.getMap().getView().getCenter());
        center = centerPoint.getCoordinates();
      }
      if (this.get("noFlip")) {
        if (scx < 0)
          scx = -scx;
        if (scy < 0)
          scy = -scy;
      }
      if (this.constraint_) {
        if (this.constraint_ == "h")
          scx = 1;
        else
          scy = 1;
      } else {
        if (this.get("keepAspectRatio")(evt)) {
          scx = scy = Math.min(scx, scy);
        }
      }
      for (i2 = 0, f2; f2 = this.selection_.item(i2); i2++) {
        geometry = viewRotation === 0 || !this.get("enableRotatedTransform") ? this.geoms_[i2].clone() : this.rotatedGeoms_[i2].clone();
        geometry.applyTransform(function(g1, g2, dim) {
          if (dim < 2)
            return g2;
          if (!keepRectangle) {
            for (j2 = 0; j2 < g1.length; j2 += dim) {
              if (scx != 1)
                g2[j2] = center[0] + (g1[j2] - center[0]) * scx;
              if (scy != 1)
                g2[j2 + 1] = center[1] + (g1[j2 + 1] - center[1]) * scy;
            }
          } else {
            var pointArray = [[6], [0, 8], [2], [4]];
            var pointA = [g1[0], g1[1]];
            var pointB = [g1[2], g1[3]];
            var pointC = [g1[4], g1[5]];
            var pointD = [g1[6], g1[7]];
            var pointA1 = [g1[8], g1[9]];
            if (stretch) {
              var base = opt % 2 === 0 ? countVector(pointA, pointB) : countVector(pointD, pointA);
              var projectedVector = projectVectorOnVector(displacementVector, base);
              var nextIndex = opt + 1 < pointArray.length ? opt + 1 : 0;
              var coordsToChange = [...pointArray[opt], ...pointArray[nextIndex]];
              for (j2 = 0; j2 < g1.length; j2 += dim) {
                g2[j2] = coordsToChange.includes(j2) ? g1[j2] + projectedVector[0] : g1[j2];
                g2[j2 + 1] = coordsToChange.includes(j2) ? g1[j2 + 1] + projectedVector[1] : g1[j2 + 1];
              }
            } else {
              var projectedLeft, projectedRight;
              switch (opt) {
                case 0:
                  displacementVector = countVector(pointD, dragCoordinate);
                  projectedLeft = projectVectorOnVector(displacementVector, countVector(pointC, pointD));
                  projectedRight = projectVectorOnVector(displacementVector, countVector(pointA, pointD));
                  [g2[0], g2[1]] = movePoint(pointA, projectedLeft);
                  [g2[4], g2[5]] = movePoint(pointC, projectedRight);
                  [g2[6], g2[7]] = movePoint(pointD, displacementVector);
                  [g2[8], g2[9]] = movePoint(pointA1, projectedLeft);
                  break;
                case 1:
                  displacementVector = countVector(pointA, dragCoordinate);
                  projectedLeft = projectVectorOnVector(displacementVector, countVector(pointD, pointA));
                  projectedRight = projectVectorOnVector(displacementVector, countVector(pointB, pointA));
                  [g2[0], g2[1]] = movePoint(pointA, displacementVector);
                  [g2[2], g2[3]] = movePoint(pointB, projectedLeft);
                  [g2[6], g2[7]] = movePoint(pointD, projectedRight);
                  [g2[8], g2[9]] = movePoint(pointA1, displacementVector);
                  break;
                case 2:
                  displacementVector = countVector(pointB, dragCoordinate);
                  projectedLeft = projectVectorOnVector(displacementVector, countVector(pointA, pointB));
                  projectedRight = projectVectorOnVector(displacementVector, countVector(pointC, pointB));
                  [g2[0], g2[1]] = movePoint(pointA, projectedRight);
                  [g2[2], g2[3]] = movePoint(pointB, displacementVector);
                  [g2[4], g2[5]] = movePoint(pointC, projectedLeft);
                  [g2[8], g2[9]] = movePoint(pointA1, projectedRight);
                  break;
                case 3:
                  displacementVector = countVector(pointC, dragCoordinate);
                  projectedLeft = projectVectorOnVector(displacementVector, countVector(pointB, pointC));
                  projectedRight = projectVectorOnVector(displacementVector, countVector(pointD, pointC));
                  [g2[2], g2[3]] = movePoint(pointB, projectedRight);
                  [g2[4], g2[5]] = movePoint(pointC, displacementVector);
                  [g2[6], g2[7]] = movePoint(pointD, projectedLeft);
                  break;
              }
            }
          }
          if (geometry.getType() == "Circle")
            geometry.setCenterAndRadius(geometry.getCenter(), geometry.getRadius());
          return g2;
        });
        if (this.get("enableRotatedTransform") && viewRotation !== 0) {
          geometry.rotate(viewRotation, this.getMap().getView().getCenter());
        }
        f2.setGeometry(geometry);
      }
      this.drawSketch_();
      this.dispatchEvent({
        type: "scaling",
        feature: this.selection_.item(0),
        features: this.selection_,
        scale: [scx, scy],
        pixel: evt.pixel,
        coordinate: evt.coordinate
      });
      break;
    }
  }
  this.isUpdating_ = false;
};
ol_interaction_Transform.prototype.handleMoveEvent_ = function(evt) {
  if (!this._handleEvent(evt, this.features_))
    return;
  if (!this.mode_) {
    var sel = this.getFeatureAtPixel_(evt.pixel);
    var element = evt.map.getTargetElement();
    if (sel.feature) {
      var c2 = sel.handle ? this.Cursors[(sel.handle || "default") + (sel.constraint || "") + (sel.option || "")] : this.Cursors.select;
      if (this.previousCursor_ === void 0) {
        this.previousCursor_ = element.style.cursor;
      }
      element.style.cursor = c2;
    } else {
      if (this.previousCursor_ !== void 0)
        element.style.cursor = this.previousCursor_;
      this.previousCursor_ = void 0;
    }
  }
};
ol_interaction_Transform.prototype.handleUpEvent_ = function(evt) {
  if (this.mode_ === "rotate") {
    var element = evt.map.getTargetElement();
    element.style.cursor = this.Cursors.default;
    this.previousCursor_ = void 0;
  }
  this.dispatchEvent({
    type: this.mode_ + "end",
    feature: this.selection_.item(0),
    features: this.selection_,
    oldgeom: this.geoms_[0],
    oldgeoms: this.geoms_
  });
  this.drawSketch_();
  this.mode_ = null;
  return false;
};
ol_interaction_Transform.prototype.getFeatures = function() {
  return this.selection_;
};
const _sfc_main$9 = {
  name: "ol-interaction-transform",
  setup(props) {
    const map = inject("map");
    const {
      properties
    } = usePropsAsObjectProperties(props);
    let transform2 = computed(() => {
      let interaction = new ol_interaction_Transform(__spreadValues({}, properties));
      return interaction;
    });
    watch(transform2, (newVal, oldVal) => {
      map.removeInteraction(oldVal);
      map.addInteraction(newVal);
      map.changed();
    });
    onMounted(() => {
      map.addInteraction(transform2.value);
    });
    onUnmounted(() => {
      map.removeInteraction(transform2.value);
    });
    provide("stylable", transform2);
  },
  props: {
    enableRotatedTransform: {
      type: Boolean,
      default: false
    },
    condition: {
      type: Function
    },
    addCondition: {
      type: Function
    },
    filter: {
      type: Function
    },
    layers: {
      type: Array
    },
    hitTolerance: {
      type: Number,
      default: 2
    },
    translateFeature: {
      type: Boolean,
      default: true
    },
    scale: {
      type: Boolean,
      default: true
    },
    rotate: {
      type: Boolean,
      default: true
    },
    keepAspectRatio: {
      type: Boolean,
      default: false
    },
    translate: {
      type: Boolean,
      default: true
    },
    stretch: {
      type: Boolean,
      default: true
    }
  }
};
function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}
var TransformInteraction = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$9]]);
class DragRotateAndZoom extends PointerInteraction {
  constructor(options) {
    options = options ? options : {};
    super(options);
    this.condition_ = options.condition ? options.condition : shiftKeyOnly;
    this.lastAngle_ = void 0;
    this.lastMagnitude_ = void 0;
    this.lastScaleDelta_ = 0;
    this.duration_ = options.duration !== void 0 ? options.duration : 400;
  }
  handleDragEvent(mapBrowserEvent) {
    if (!mouseOnly(mapBrowserEvent)) {
      return;
    }
    const map = mapBrowserEvent.map;
    const size = map.getSize();
    const offset2 = mapBrowserEvent.pixel;
    const deltaX = offset2[0] - size[0] / 2;
    const deltaY = size[1] / 2 - offset2[1];
    const theta = Math.atan2(deltaY, deltaX);
    const magnitude = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    const view = map.getView();
    if (this.lastAngle_ !== void 0) {
      const angleDelta = this.lastAngle_ - theta;
      view.adjustRotationInternal(angleDelta);
    }
    this.lastAngle_ = theta;
    if (this.lastMagnitude_ !== void 0) {
      view.adjustResolutionInternal(this.lastMagnitude_ / magnitude);
    }
    if (this.lastMagnitude_ !== void 0) {
      this.lastScaleDelta_ = this.lastMagnitude_ / magnitude;
    }
    this.lastMagnitude_ = magnitude;
  }
  handleUpEvent(mapBrowserEvent) {
    if (!mouseOnly(mapBrowserEvent)) {
      return true;
    }
    const map = mapBrowserEvent.map;
    const view = map.getView();
    const direction2 = this.lastScaleDelta_ > 1 ? 1 : -1;
    view.endInteraction(this.duration_, direction2);
    this.lastScaleDelta_ = 0;
    return false;
  }
  handleDownEvent(mapBrowserEvent) {
    if (!mouseOnly(mapBrowserEvent)) {
      return false;
    }
    if (this.condition_(mapBrowserEvent)) {
      mapBrowserEvent.map.getView().beginInteraction();
      this.lastAngle_ = void 0;
      this.lastMagnitude_ = void 0;
      return true;
    }
    return false;
  }
}
const _sfc_main$8 = {
  name: "ol-interaction-dragrotatezoom",
  setup(props) {
    const map = inject("map");
    const {
      properties
    } = usePropsAsObjectProperties(props);
    let dragrotatezoom = computed(() => {
      let s2 = new DragRotateAndZoom(__spreadValues({}, properties));
      return s2;
    });
    watch(dragrotatezoom, (newVal, oldVal) => {
      map.removeInteraction(oldVal);
      map.addInteraction(newVal);
      map.changed();
    });
    onMounted(() => {
      map.addInteraction(dragrotatezoom.value);
    });
    onUnmounted(() => {
      map.removeInteraction(dragrotatezoom.value);
    });
  },
  props: {
    condition: {
      type: Function
    },
    duration: {
      type: Number,
      default: 400
    }
  }
};
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}
var DragRotateAndZoomInteraction = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$8]]);
function install$2(app) {
  if (install$2.installed) {
    return;
  }
  install$2.installed = true;
  app.component(SelectInteraction.name, SelectInteraction);
  app.component(ClusterSelectInteraction.name, ClusterSelectInteraction);
  app.component(DrawInteraction.name, DrawInteraction);
  app.component(SnapInteraction.name, SnapInteraction);
  app.component(ModifyInteraction.name, ModifyInteraction);
  app.component(TransformInteraction.name, TransformInteraction);
  app.component(DragRotateAndZoomInteraction.name, DragRotateAndZoomInteraction);
}
var Interactions = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": install$2,
  install: install$2,
  SelectInteraction,
  ClusterSelectInteraction,
  DrawInteraction,
  SnapInteraction,
  ModifyInteraction,
  TransformInteraction,
  DragRotateAndZoomInteraction
}, Symbol.toStringTag, { value: "Module" }));
const _sfc_main$7 = {
  setup() {
    const map = inject("map");
    const vectorLayer = inject("vectorLayer");
    return {
      map,
      vectorLayer
    };
  },
  props: {
    duration: {
      type: Number,
      default: 1e3
    },
    revers: {
      type: Boolean,
      default: false
    },
    repeat: {
      type: Number,
      default: 0
    },
    fade: {
      type: Function
    },
    easing: {
      type: Function,
      default: easeOut
    }
  }
};
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}
var FeatureAnimation = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$7]]);
var ol_featureAnimation = function(options) {
  options = options || {};
  this.duration_ = typeof options.duration == "number" ? options.duration >= 0 ? options.duration : 0 : 1e3;
  this.fade_ = typeof options.fade == "function" ? options.fade : null;
  this.repeat_ = Number(options.repeat);
  var easing = typeof options.easing == "function" ? options.easing : linear;
  if (options.revers)
    this.easing_ = function(t3) {
      return 1 - easing(t3);
    };
  else
    this.easing_ = easing;
  this.hiddenStyle = options.hiddenStyle;
  BaseObject.call(this);
};
ol_ext_inherits(ol_featureAnimation, BaseObject);
ol_featureAnimation.hiddenStyle = new Style$1({
  image: new CircleStyle({}),
  stroke: new Stroke$1({
    color: "transparent"
  })
});
ol_featureAnimation.prototype.drawGeom_ = function(e2, geom2, shadow) {
  if (this.fade_) {
    e2.context.globalAlpha = this.fade_(1 - e2.elapsed);
  }
  var style2 = e2.style;
  for (var i2 = 0; i2 < style2.length; i2++) {
    try {
      var vectorContext = e2.vectorContext || getVectorContext(e2);
      var s2 = ol_ext_getVectorContextStyle(e2, style2[i2]);
      vectorContext.setStyle(s2);
      if (s2.getZIndex() < 0)
        vectorContext.drawGeometry(shadow || geom2);
      else
        vectorContext.drawGeometry(geom2);
    } catch (e3) {
    }
  }
};
ol_featureAnimation.prototype.animate = function() {
  return false;
};
Map$3.prototype.animateFeature = function(feature, fanim) {
  var layer = this._featureAnimationLayer;
  if (!layer) {
    layer = this._featureAnimationLayer = new VectorLayer$1({ source: new VectorSource() });
    layer.setMap(this);
  }
  layer.getSource().addFeature(feature);
  var listener2 = fanim.on("animationend", function(e2) {
    if (e2.feature === feature) {
      layer.getSource().removeFeature(feature);
      unByKey(listener2);
    }
  });
  layer.animateFeature(feature, fanim);
};
BaseLayer$1.prototype.animateFeature = function(feature, fanim, useFilter) {
  var self2 = this;
  var listenerKey;
  var style2 = feature.getStyle();
  var flashStyle = style2 || (this.getStyleFunction ? this.getStyleFunction()(feature) : null);
  if (!flashStyle)
    flashStyle = [];
  if (!(flashStyle instanceof Array))
    flashStyle = [flashStyle];
  var event = {
    vectorContext: null,
    frameState: null,
    start: 0,
    time: 0,
    elapsed: 0,
    extent: false,
    feature,
    geom: feature.getGeometry(),
    typeGeom: feature.getGeometry().getType(),
    bbox: feature.getGeometry().getExtent(),
    coord: getCenter(feature.getGeometry().getExtent()),
    style: flashStyle
  };
  if (!(fanim instanceof Array))
    fanim = [fanim];
  for (var i2 = fanim.length - 1; i2 >= 0; i2--) {
    if (fanim[i2].duration_ === 0)
      fanim.splice(i2, 1);
  }
  var nb = 0, step = 0;
  var filters = useFilter && this.getFilters ? this.getFilters() : [];
  function animate(e2) {
    event.type = e2.type;
    try {
      event.vectorContext = e2.vectorContext || getVectorContext(e2);
    } catch (e3) {
    }
    event.frameState = e2.frameState;
    event.inversePixelTransform = e2.inversePixelTransform;
    if (!event.extent) {
      event.extent = e2.frameState.extent;
      event.start = e2.frameState.time;
      event.context = e2.context;
    }
    event.time = e2.frameState.time - event.start;
    event.elapsed = event.time / fanim[step].duration_;
    if (event.elapsed > 1)
      event.elapsed = 1;
    e2.context.save();
    filters.forEach(function(f2) {
      if (f2.get("active"))
        f2.precompose(e2);
    });
    if (this.getOpacity) {
      e2.context.globalAlpha = this.getOpacity();
    }
    if (!fanim[step].animate(event)) {
      nb++;
      if (nb < fanim[step].repeat_) {
        event.extent = false;
      } else if (step < fanim.length - 1) {
        fanim[step].dispatchEvent({ type: "animationend", feature });
        step++;
        nb = 0;
        event.extent = false;
      } else {
        stop();
      }
    } else {
      var animEvent = {
        type: "animating",
        step,
        start: event.start,
        time: event.time,
        elapsed: event.elapsed,
        rotation: event.rotation || 0,
        geom: event.geom,
        coordinate: event.coord,
        feature
      };
      fanim[step].dispatchEvent(animEvent);
      self2.dispatchEvent(animEvent);
    }
    filters.forEach(function(f2) {
      if (f2.get("active"))
        f2.postcompose(e2);
    });
    e2.context.restore();
    e2.frameState.animate = true;
  }
  function stop(options) {
    unByKey(listenerKey);
    listenerKey = null;
    feature.setStyle(style2);
    var event2 = { type: "animationend", feature };
    if (options) {
      for (var i3 in options)
        if (options.hasOwnProperty(i3)) {
          event2[i3] = options[i3];
        }
    }
    fanim[step].dispatchEvent(event2);
    self2.dispatchEvent(event2);
  }
  function start2(options) {
    if (fanim.length && !listenerKey) {
      listenerKey = self2.on(["postcompose", "postrender"], animate.bind(self2));
      if (self2.renderSync) {
        try {
          self2.renderSync();
        } catch (e2) {
        }
      } else {
        self2.changed();
      }
      feature.setStyle(fanim[step].hiddenStyle || ol_featureAnimation.hiddenStyle);
      var event2 = { type: "animationstart", feature };
      if (options) {
        for (var i3 in options)
          if (options.hasOwnProperty(i3)) {
            event2[i3] = options[i3];
          }
      }
      fanim[step].dispatchEvent(event2);
      self2.dispatchEvent(event2);
    }
  }
  start2();
  return {
    start: start2,
    stop,
    isPlaying: function() {
      return !!listenerKey;
    }
  };
};
var ol_featureAnimation_Drop = function(options) {
  options = options || {};
  this.speed_ = options.speed || 0;
  ol_featureAnimation.call(this, options);
  this.side_ = options.side || "top";
};
ol_ext_inherits(ol_featureAnimation_Drop, ol_featureAnimation);
ol_featureAnimation_Drop.prototype.animate = function(e2) {
  if (!e2.time) {
    var angle2 = e2.frameState.viewState.rotation;
    var s2 = e2.frameState.size[1] * e2.frameState.viewState.resolution;
    if (this.side_ != "top")
      s2 *= -1;
    this.dx = -Math.sin(angle2) * s2;
    this.dy = Math.cos(angle2) * s2;
    if (this.speed_) {
      this.duration_ = s2 / this.speed_ / e2.frameState.viewState.resolution;
    }
  }
  var flashGeom = e2.geom.clone();
  flashGeom.translate(this.dx * (1 - this.easing_(e2.elapsed)), this.dy * (1 - this.easing_(e2.elapsed)));
  this.drawGeom_(e2, flashGeom, e2.geom);
  return e2.time <= this.duration_;
};
function useAnimation(AnimationType, props) {
  const {
    map,
    vectorLayer
  } = FeatureAnimation.setup();
  const {
    properties
  } = usePropsAsObjectProperties(props);
  const animation = computed(() => {
    let anim = new AnimationType(__spreadValues({}, properties));
    return anim;
  });
  provide("animation", animation);
  return {
    map,
    vectorLayer,
    animation,
    properties
  };
}
const _sfc_main$6 = {
  name: "ol-animation-drop",
  extends: FeatureAnimation,
  setup(props) {
    const {
      map,
      vectorLayer,
      properties
    } = useAnimation(ol_featureAnimation_Drop, props);
    return {
      map,
      vectorLayer,
      properties
    };
  },
  props: {
    side: {
      type: Number,
      default: 0
    },
    speed: {
      type: Number,
      default: 0
    }
  }
};
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}
var DropAnimation = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$6]]);
var ol_featureAnimation_Shake = function(options) {
  options = options || {};
  ol_featureAnimation.call(this, options);
  this.amplitude_ = options.amplitude || 40;
  this.bounce_ = -Math.PI * (options.bounce || 6);
  this.horizontal_ = options.horizontal;
};
ol_ext_inherits(ol_featureAnimation_Shake, ol_featureAnimation);
ol_featureAnimation_Shake.prototype.animate = function(e2) {
  var flashGeom = e2.geom.clone();
  var shadow = e2.geom.clone();
  var t3 = this.easing_(e2.elapsed);
  t3 = Math.sin(this.bounce_ * t3) * this.amplitude_ * (1 - t3) * e2.frameState.viewState.resolution;
  if (this.horizontal_) {
    flashGeom.translate(t3, 0);
    shadow.translate(t3, 0);
  } else
    flashGeom.translate(0, t3);
  this.drawGeom_(e2, flashGeom, shadow);
  return e2.time <= this.duration_;
};
const _sfc_main$5 = {
  name: "ol-animation-shake",
  extends: FeatureAnimation,
  setup(props) {
    const {
      map,
      vectorLayer,
      properties,
      animation
    } = useAnimation(ol_featureAnimation_Shake, props);
    return {
      map,
      vectorLayer,
      properties,
      animation
    };
  },
  props: {
    bounce: {
      type: Number,
      default: 6
    },
    amplitude: {
      type: Number,
      default: 40
    },
    horizontal: {
      type: Boolean,
      default: false
    }
  }
};
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}
var ShakeAnimation = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5]]);
var ol_featureAnimation_Zoom = function(options) {
  options = options || {};
  ol_featureAnimation.call(this, options);
  this.set("zoomout", options.zoomOut);
};
ol_ext_inherits(ol_featureAnimation_Zoom, ol_featureAnimation);
var ol_featureAnimation_ZoomOut = function(options) {
  options = options || {};
  options.zoomOut = true;
  ol_featureAnimation_Zoom.call(this, options);
};
ol_ext_inherits(ol_featureAnimation_ZoomOut, ol_featureAnimation_Zoom);
ol_featureAnimation_Zoom.prototype.animate = function(e2) {
  var fac = this.easing_(e2.elapsed);
  if (fac) {
    if (this.get("zoomout"))
      fac = 1 / fac;
    var style2 = e2.style;
    var i2, imgs, sc = [];
    for (i2 = 0; i2 < style2.length; i2++) {
      imgs = style2[i2].getImage();
      if (imgs) {
        sc[i2] = imgs.getScale();
        if (e2.type === "postrender")
          imgs.setScale(sc[i2] * fac / e2.frameState.pixelRatio);
        else
          imgs.setScale(sc[i2] * fac);
      }
    }
    this.drawGeom_(e2, e2.geom);
    for (i2 = 0; i2 < style2.length; i2++) {
      imgs = style2[i2].getImage();
      if (imgs)
        imgs.setScale(sc[i2]);
    }
  }
  return e2.time <= this.duration_;
};
const _sfc_main$4 = {
  name: "ol-animation-zoom",
  extends: FeatureAnimation,
  setup(props) {
    const {
      map,
      vectorLayer,
      properties
    } = useAnimation(ol_featureAnimation_Zoom, props);
    return {
      map,
      vectorLayer,
      properties
    };
  },
  props: {
    zoomOut: {
      type: Boolean,
      default: false
    }
  }
};
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}
var ZoomAnimation = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4]]);
var ol_featureAnimation_Teleport = function(options) {
  ol_featureAnimation.call(this, options);
};
ol_ext_inherits(ol_featureAnimation_Teleport, ol_featureAnimation);
ol_featureAnimation_Teleport.prototype.animate = function(e2) {
  var sc = this.easing_(e2.elapsed);
  if (sc) {
    e2.context.save();
    var ratio = e2.frameState.pixelRatio;
    e2.context.globalAlpha = sc;
    e2.context.scale(sc, 1 / sc);
    var m2 = e2.frameState.coordinateToPixelTransform;
    var dx = (1 / sc - 1) * ratio * (m2[0] * e2.coord[0] + m2[1] * e2.coord[1] + m2[4]);
    var dy = (sc - 1) * ratio * (m2[2] * e2.coord[0] + m2[3] * e2.coord[1] + m2[5]);
    e2.context.translate(dx, dy);
    this.drawGeom_(e2, e2.geom);
    e2.context.restore();
  }
  return e2.time <= this.duration_;
};
const _sfc_main$3 = {
  name: "ol-animation-teleport",
  extends: FeatureAnimation,
  setup(props) {
    const {
      map,
      vectorLayer,
      properties
    } = useAnimation(ol_featureAnimation_Teleport, props);
    return {
      map,
      vectorLayer,
      properties
    };
  },
  props: {}
};
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}
var TeleportAnimation = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3]]);
var ol_featureAnimation_Fade = function(options) {
  options = options || {};
  this.speed_ = options.speed || 0;
  ol_featureAnimation.call(this, options);
};
ol_ext_inherits(ol_featureAnimation_Fade, ol_featureAnimation);
ol_featureAnimation_Fade.prototype.animate = function(e2) {
  e2.context.globalAlpha = this.easing_(e2.elapsed);
  this.drawGeom_(e2, e2.geom);
  return e2.time <= this.duration_;
};
const _sfc_main$2 = {
  name: "ol-animation-fade",
  extends: FeatureAnimation,
  setup(props) {
    const {
      map,
      vectorLayer,
      properties
    } = useAnimation(ol_featureAnimation_Fade, props);
    return {
      map,
      vectorLayer,
      properties
    };
  }
};
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}
var FadeAnimation = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2]]);
var ol_featureAnimation_Slide = function(options) {
  options = options || {};
  this.speed_ = options.speed || 0;
  ol_featureAnimation.call(this, options);
  this.side_ = options.side || "left";
};
ol_ext_inherits(ol_featureAnimation_Slide, ol_featureAnimation);
ol_featureAnimation_Slide.prototype.animate = function(e2) {
  if (!e2.time) {
    if (this.side_ == "left")
      this.dx = e2.extent[0] - e2.bbox[2];
    else
      this.dx = e2.extent[2] - e2.bbox[0];
    if (this.speed_)
      this.duration_ = Math.abs(this.dx) / this.speed_ / e2.frameState.viewState.resolution;
  }
  var flashGeom = e2.geom.clone();
  flashGeom.translate(this.dx * (1 - this.easing_(e2.elapsed)), 0);
  this.drawGeom_(e2, flashGeom);
  return e2.time <= this.duration_;
};
const _sfc_main$1 = {
  name: "ol-animation-slide",
  extends: FeatureAnimation,
  setup(props) {
    const {
      map,
      vectorLayer,
      properties
    } = useAnimation(ol_featureAnimation_Slide, props);
    return {
      map,
      vectorLayer,
      properties
    };
  },
  props: {
    speed: {
      type: Number,
      default: 0
    }
  }
};
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}
var SlideAnimation = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
var ol_featureAnimation_Path = function(options) {
  options = options || {};
  ol_featureAnimation.call(this, options);
  this.speed_ = options.speed || 0;
  this.path_ = options.path;
  switch (options.rotate) {
    case true:
    case 0:
      this.rotate_ = 0;
      break;
    default:
      this.rotate_ = options.rotate || false;
      break;
  }
  if (this.path_ && this.path_.getGeometry)
    this.path_ = this.path_.getGeometry();
  if (this.path_ && this.path_.getLineString)
    this.path_ = this.path_.getLineString();
  if (this.path_.getLength) {
    this.dist_ = this.path_.getLength();
    if (this.path_ && this.path_.getCoordinates)
      this.path_ = this.path_.getCoordinates();
  } else {
    this.dist_ = 0;
  }
  if (this.speed_ > 0)
    this.duration_ = this.dist_ / this.speed_;
};
ol_ext_inherits(ol_featureAnimation_Path, ol_featureAnimation);
ol_featureAnimation_Path.prototype.animate = function(e2) {
  if (!e2.time) {
    if (!this.dist_)
      return false;
  }
  var dmax = this.dist_ * this.easing_(e2.elapsed);
  var p0, p5, s2, dx, dy, dl, d2 = 0;
  p5 = this.path_[0];
  for (var i2 = 1; i2 < this.path_.length; i2++) {
    p0 = p5;
    p5 = this.path_[i2];
    dx = p5[0] - p0[0];
    dy = p5[1] - p0[1];
    dl = Math.sqrt(dx * dx + dy * dy);
    if (dl && d2 + dl >= dmax) {
      s2 = (dmax - d2) / dl;
      p5 = [p0[0] + (p5[0] - p0[0]) * s2, p0[1] + (p5[1] - p0[1]) * s2];
      break;
    }
    d2 += dl;
  }
  var style2 = e2.style;
  e2.rotation = Math.PI / 2 + Math.atan2(p0[1] - p5[1], p0[0] - p5[0]);
  if (this.rotate_ !== false) {
    var st2 = [];
    var angle2 = this.rotate_ - e2.rotation + e2.frameState.viewState.rotation;
    e2.rotation = Math.PI / 2 + Math.atan2(p0[1] - p5[1], p0[0] - p5[0]);
    for (var k2 = 0; s2 = e2.style[k2]; k2++) {
      if (s2.getImage()) {
        s2.getImage().setRotation(angle2);
      }
      st2.push(s2);
    }
    e2.style = st2;
  }
  e2.geom.setCoordinates(p5);
  this.drawGeom_(e2, e2.geom);
  e2.style = style2;
  return e2.time <= this.duration_;
};
const _sfc_main = {
  name: "ol-animation-path",
  extends: FeatureAnimation,
  setup(props) {
    const {
      map,
      vectorLayer,
      properties
    } = useAnimation(ol_featureAnimation_Path, props);
    return {
      map,
      vectorLayer,
      properties
    };
  },
  props: {
    rotate: {
      type: Boolean,
      default: false
    },
    speed: {
      type: Number,
      default: 0
    },
    path: {
      type: Object
    }
  }
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}
var PathAnimation = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
function install$1(app) {
  if (install$1.installed) {
    return;
  }
  install$1.installed = true;
  app.component(FeatureAnimation.name, FeatureAnimation);
  app.component(DropAnimation.name, DropAnimation);
  app.component(ShakeAnimation.name, ShakeAnimation);
  app.component(ZoomAnimation.name, ZoomAnimation);
  app.component(TeleportAnimation.name, TeleportAnimation);
  app.component(FadeAnimation.name, FadeAnimation);
  app.component(SlideAnimation.name, SlideAnimation);
  app.component(PathAnimation.name, PathAnimation);
}
var Animations = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": install$1,
  install: install$1,
  FeatureAnimation,
  DropAnimation,
  ShakeAnimation,
  ZoomAnimation,
  TeleportAnimation,
  FadeAnimation,
  PathAnimation,
  SlideAnimation
}, Symbol.toStringTag, { value: "Module" }));
var ol$1 = "";
var olExt = "";
var olContextmenu = "";
var style = "";
var geom = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Circle: Circle$1,
  Geometry,
  GeometryCollection,
  LinearRing,
  LineString: LineString$1,
  MultiLineString: MultiLineString$1,
  MultiPoint: MultiPoint$1,
  MultiPolygon: MultiPolygon$1,
  Point: Point$3,
  Polygon: Polygon$1,
  SimpleGeometry
}, Symbol.toStringTag, { value: "Module" }));
class FeatureFormat {
  constructor() {
    this.dataProjection = void 0;
    this.defaultFeatureProjection = void 0;
    this.supportedMediaTypes = null;
  }
  getReadOptions(source, options) {
    if (options) {
      let dataProjection = options.dataProjection ? get$4(options.dataProjection) : this.readProjection(source);
      if (options.extent && dataProjection && dataProjection.getUnits() === "tile-pixels") {
        dataProjection = get$4(dataProjection);
        dataProjection.setWorldExtent(options.extent);
      }
      options = {
        dataProjection,
        featureProjection: options.featureProjection
      };
    }
    return this.adaptOptions(options);
  }
  adaptOptions(options) {
    return Object.assign({
      dataProjection: this.dataProjection,
      featureProjection: this.defaultFeatureProjection
    }, options);
  }
  getType() {
    return abstract();
  }
  readFeature(source, options) {
    return abstract();
  }
  readFeatures(source, options) {
    return abstract();
  }
  readGeometry(source, options) {
    return abstract();
  }
  readProjection(source) {
    return abstract();
  }
  writeFeature(feature, options) {
    return abstract();
  }
  writeFeatures(features, options) {
    return abstract();
  }
  writeGeometry(geometry, options) {
    return abstract();
  }
}
function transformGeometryWithOptions(geometry, write, options) {
  const featureProjection = options ? get$4(options.featureProjection) : null;
  const dataProjection = options ? get$4(options.dataProjection) : null;
  let transformed;
  if (featureProjection && dataProjection && !equivalent(featureProjection, dataProjection)) {
    transformed = (write ? geometry.clone() : geometry).transform(write ? featureProjection : dataProjection, write ? dataProjection : featureProjection);
  } else {
    transformed = geometry;
  }
  if (write && options && options.decimals !== void 0) {
    const power = Math.pow(10, options.decimals);
    const transform2 = function(coordinates2) {
      for (let i2 = 0, ii = coordinates2.length; i2 < ii; ++i2) {
        coordinates2[i2] = Math.round(coordinates2[i2] * power) / power;
      }
      return coordinates2;
    };
    if (transformed === geometry) {
      transformed = geometry.clone();
    }
    transformed.applyTransform(transform2);
  }
  return transformed;
}
function transformExtentWithOptions(extent2, options) {
  const featureProjection = options ? get$4(options.featureProjection) : null;
  const dataProjection = options ? get$4(options.dataProjection) : null;
  if (featureProjection && dataProjection && !equivalent(featureProjection, dataProjection)) {
    return transformExtent(extent2, dataProjection, featureProjection);
  }
  return extent2;
}
class JSONFeature extends FeatureFormat {
  constructor() {
    super();
  }
  getType() {
    return "json";
  }
  readFeature(source, options) {
    return this.readFeatureFromObject(getObject(source), this.getReadOptions(source, options));
  }
  readFeatures(source, options) {
    return this.readFeaturesFromObject(getObject(source), this.getReadOptions(source, options));
  }
  readFeatureFromObject(object, options) {
    return abstract();
  }
  readFeaturesFromObject(object, options) {
    return abstract();
  }
  readGeometry(source, options) {
    return this.readGeometryFromObject(getObject(source), this.getReadOptions(source, options));
  }
  readGeometryFromObject(object, options) {
    return abstract();
  }
  readProjection(source) {
    return this.readProjectionFromObject(getObject(source));
  }
  readProjectionFromObject(object) {
    return abstract();
  }
  writeFeature(feature, options) {
    return JSON.stringify(this.writeFeatureObject(feature, options));
  }
  writeFeatureObject(feature, options) {
    return abstract();
  }
  writeFeatures(features, options) {
    return JSON.stringify(this.writeFeaturesObject(features, options));
  }
  writeFeaturesObject(features, options) {
    return abstract();
  }
  writeGeometry(geometry, options) {
    return JSON.stringify(this.writeGeometryObject(geometry, options));
  }
  writeGeometryObject(geometry, options) {
    return abstract();
  }
}
function getObject(source) {
  if (typeof source === "string") {
    const object = JSON.parse(source);
    return object ? object : null;
  } else if (source !== null) {
    return source;
  }
  return null;
}
const GEOMETRY_READERS$1 = {
  Point: readPointGeometry$2,
  LineString: readLineStringGeometry$2,
  Polygon: readPolygonGeometry$2,
  MultiPoint: readMultiPointGeometry$2,
  MultiLineString: readMultiLineStringGeometry$2,
  MultiPolygon: readMultiPolygonGeometry$2
};
const GEOMETRY_WRITERS = {
  Point: writePointGeometry$1,
  LineString: writeLineStringGeometry$1,
  Polygon: writePolygonGeometry$1,
  MultiPoint: writeMultiPointGeometry$1,
  MultiLineString: writeMultiLineStringGeometry$1,
  MultiPolygon: writeMultiPolygonGeometry$1
};
class EsriJSON extends JSONFeature {
  constructor(options) {
    options = options ? options : {};
    super();
    this.geometryName_ = options.geometryName;
  }
  readFeatureFromObject(object, options, idField) {
    const esriJSONFeature = object;
    const geometry = readGeometry$1(esriJSONFeature.geometry, options);
    const feature = new Feature$1();
    if (this.geometryName_) {
      feature.setGeometryName(this.geometryName_);
    }
    feature.setGeometry(geometry);
    if (esriJSONFeature.attributes) {
      feature.setProperties(esriJSONFeature.attributes, true);
      const id = esriJSONFeature.attributes[idField];
      if (id !== void 0) {
        feature.setId(id);
      }
    }
    return feature;
  }
  readFeaturesFromObject(object, options) {
    options = options ? options : {};
    if (object["features"]) {
      const esriJSONFeatureSet = object;
      const features = [];
      const esriJSONFeatures = esriJSONFeatureSet.features;
      for (let i2 = 0, ii = esriJSONFeatures.length; i2 < ii; ++i2) {
        features.push(this.readFeatureFromObject(esriJSONFeatures[i2], options, object.objectIdFieldName));
      }
      return features;
    }
    return [this.readFeatureFromObject(object, options)];
  }
  readGeometryFromObject(object, options) {
    return readGeometry$1(object, options);
  }
  readProjectionFromObject(object) {
    if (object["spatialReference"] && object["spatialReference"]["wkid"] !== void 0) {
      const spatialReference = object["spatialReference"];
      const crs = spatialReference.wkid;
      return get$4("EPSG:" + crs);
    }
    return null;
  }
  writeGeometryObject(geometry, options) {
    return writeGeometry$1(geometry, this.adaptOptions(options));
  }
  writeFeatureObject(feature, options) {
    options = this.adaptOptions(options);
    const object = {};
    if (!feature.hasProperties()) {
      object["attributes"] = {};
      return object;
    }
    const properties = feature.getProperties();
    const geometry = feature.getGeometry();
    if (geometry) {
      object["geometry"] = writeGeometry$1(geometry, options);
      const projection = options && (options.dataProjection || options.featureProjection);
      if (projection) {
        object["geometry"]["spatialReference"] = {
          wkid: Number(get$4(projection).getCode().split(":").pop())
        };
      }
      delete properties[feature.getGeometryName()];
    }
    if (!isEmpty$1(properties)) {
      object["attributes"] = properties;
    } else {
      object["attributes"] = {};
    }
    return object;
  }
  writeFeaturesObject(features, options) {
    options = this.adaptOptions(options);
    const objects = [];
    for (let i2 = 0, ii = features.length; i2 < ii; ++i2) {
      objects.push(this.writeFeatureObject(features[i2], options));
    }
    return {
      "features": objects
    };
  }
}
function readGeometry$1(object, options) {
  if (!object) {
    return null;
  }
  let type;
  if (typeof object["x"] === "number" && typeof object["y"] === "number") {
    type = "Point";
  } else if (object["points"]) {
    type = "MultiPoint";
  } else if (object["paths"]) {
    const esriJSONPolyline = object;
    if (esriJSONPolyline.paths.length === 1) {
      type = "LineString";
    } else {
      type = "MultiLineString";
    }
  } else if (object["rings"]) {
    const esriJSONPolygon = object;
    const layout = getGeometryLayout(esriJSONPolygon);
    const rings = convertRings(esriJSONPolygon.rings, layout);
    if (rings.length === 1) {
      type = "Polygon";
      object = Object.assign({}, object, { ["rings"]: rings[0] });
    } else {
      type = "MultiPolygon";
      object = Object.assign({}, object, { ["rings"]: rings });
    }
  }
  const geometryReader = GEOMETRY_READERS$1[type];
  return transformGeometryWithOptions(geometryReader(object), false, options);
}
function convertRings(rings, layout) {
  const flatRing = [];
  const outerRings = [];
  const holes = [];
  let i2, ii;
  for (i2 = 0, ii = rings.length; i2 < ii; ++i2) {
    flatRing.length = 0;
    deflateCoordinates(flatRing, 0, rings[i2], layout.length);
    const clockwise = linearRingIsClockwise(flatRing, 0, flatRing.length, layout.length);
    if (clockwise) {
      outerRings.push([rings[i2]]);
    } else {
      holes.push(rings[i2]);
    }
  }
  while (holes.length) {
    const hole = holes.shift();
    let matched = false;
    for (i2 = outerRings.length - 1; i2 >= 0; i2--) {
      const outerRing = outerRings[i2][0];
      const containsHole = containsExtent(new LinearRing(outerRing).getExtent(), new LinearRing(hole).getExtent());
      if (containsHole) {
        outerRings[i2].push(hole);
        matched = true;
        break;
      }
    }
    if (!matched) {
      outerRings.push([hole.reverse()]);
    }
  }
  return outerRings;
}
function readPointGeometry$2(object) {
  let point;
  if (object.m !== void 0 && object.z !== void 0) {
    point = new Point$3([object.x, object.y, object.z, object.m], "XYZM");
  } else if (object.z !== void 0) {
    point = new Point$3([object.x, object.y, object.z], "XYZ");
  } else if (object.m !== void 0) {
    point = new Point$3([object.x, object.y, object.m], "XYM");
  } else {
    point = new Point$3([object.x, object.y]);
  }
  return point;
}
function readLineStringGeometry$2(object) {
  const layout = getGeometryLayout(object);
  return new LineString$1(object.paths[0], layout);
}
function readMultiLineStringGeometry$2(object) {
  const layout = getGeometryLayout(object);
  return new MultiLineString$1(object.paths, layout);
}
function getGeometryLayout(object) {
  let layout = "XY";
  if (object.hasZ === true && object.hasM === true) {
    layout = "XYZM";
  } else if (object.hasZ === true) {
    layout = "XYZ";
  } else if (object.hasM === true) {
    layout = "XYM";
  }
  return layout;
}
function readMultiPointGeometry$2(object) {
  const layout = getGeometryLayout(object);
  return new MultiPoint$1(object.points, layout);
}
function readMultiPolygonGeometry$2(object) {
  const layout = getGeometryLayout(object);
  return new MultiPolygon$1(object.rings, layout);
}
function readPolygonGeometry$2(object) {
  const layout = getGeometryLayout(object);
  return new Polygon$1(object.rings, layout);
}
function writePointGeometry$1(geometry, options) {
  const coordinates2 = geometry.getCoordinates();
  let esriJSON;
  const layout = geometry.getLayout();
  if (layout === "XYZ") {
    esriJSON = {
      x: coordinates2[0],
      y: coordinates2[1],
      z: coordinates2[2]
    };
  } else if (layout === "XYM") {
    esriJSON = {
      x: coordinates2[0],
      y: coordinates2[1],
      m: coordinates2[2]
    };
  } else if (layout === "XYZM") {
    esriJSON = {
      x: coordinates2[0],
      y: coordinates2[1],
      z: coordinates2[2],
      m: coordinates2[3]
    };
  } else if (layout === "XY") {
    esriJSON = {
      x: coordinates2[0],
      y: coordinates2[1]
    };
  } else {
    assert(false, 34);
  }
  return esriJSON;
}
function getHasZM(geometry) {
  const layout = geometry.getLayout();
  return {
    hasZ: layout === "XYZ" || layout === "XYZM",
    hasM: layout === "XYM" || layout === "XYZM"
  };
}
function writeLineStringGeometry$1(lineString, options) {
  const hasZM = getHasZM(lineString);
  return {
    hasZ: hasZM.hasZ,
    hasM: hasZM.hasM,
    paths: [
      lineString.getCoordinates()
    ]
  };
}
function writePolygonGeometry$1(polygon, options) {
  const hasZM = getHasZM(polygon);
  return {
    hasZ: hasZM.hasZ,
    hasM: hasZM.hasM,
    rings: polygon.getCoordinates(false)
  };
}
function writeMultiLineStringGeometry$1(multiLineString, options) {
  const hasZM = getHasZM(multiLineString);
  return {
    hasZ: hasZM.hasZ,
    hasM: hasZM.hasM,
    paths: multiLineString.getCoordinates()
  };
}
function writeMultiPointGeometry$1(multiPoint, options) {
  const hasZM = getHasZM(multiPoint);
  return {
    hasZ: hasZM.hasZ,
    hasM: hasZM.hasM,
    points: multiPoint.getCoordinates()
  };
}
function writeMultiPolygonGeometry$1(geometry, options) {
  const hasZM = getHasZM(geometry);
  const coordinates2 = geometry.getCoordinates(false);
  const output = [];
  for (let i2 = 0; i2 < coordinates2.length; i2++) {
    for (let x2 = coordinates2[i2].length - 1; x2 >= 0; x2--) {
      output.push(coordinates2[i2][x2]);
    }
  }
  return {
    hasZ: hasZM.hasZ,
    hasM: hasZM.hasM,
    rings: output
  };
}
function writeGeometry$1(geometry, options) {
  const geometryWriter = GEOMETRY_WRITERS[geometry.getType()];
  return geometryWriter(transformGeometryWithOptions(geometry, true, options), options);
}
class GeoJSON extends JSONFeature {
  constructor(options) {
    options = options ? options : {};
    super();
    this.dataProjection = get$4(options.dataProjection ? options.dataProjection : "EPSG:4326");
    if (options.featureProjection) {
      this.defaultFeatureProjection = get$4(options.featureProjection);
    }
    this.geometryName_ = options.geometryName;
    this.extractGeometryName_ = options.extractGeometryName;
    this.supportedMediaTypes = [
      "application/geo+json",
      "application/vnd.geo+json"
    ];
  }
  readFeatureFromObject(object, options) {
    let geoJSONFeature = null;
    if (object["type"] === "Feature") {
      geoJSONFeature = object;
    } else {
      geoJSONFeature = {
        "type": "Feature",
        "geometry": object,
        "properties": null
      };
    }
    const geometry = readGeometry(geoJSONFeature["geometry"], options);
    const feature = new Feature$1();
    if (this.geometryName_) {
      feature.setGeometryName(this.geometryName_);
    } else if (this.extractGeometryName_ && "geometry_name" in geoJSONFeature !== void 0) {
      feature.setGeometryName(geoJSONFeature["geometry_name"]);
    }
    feature.setGeometry(geometry);
    if ("id" in geoJSONFeature) {
      feature.setId(geoJSONFeature["id"]);
    }
    if (geoJSONFeature["properties"]) {
      feature.setProperties(geoJSONFeature["properties"], true);
    }
    return feature;
  }
  readFeaturesFromObject(object, options) {
    const geoJSONObject = object;
    let features = null;
    if (geoJSONObject["type"] === "FeatureCollection") {
      const geoJSONFeatureCollection = object;
      features = [];
      const geoJSONFeatures = geoJSONFeatureCollection["features"];
      for (let i2 = 0, ii = geoJSONFeatures.length; i2 < ii; ++i2) {
        features.push(this.readFeatureFromObject(geoJSONFeatures[i2], options));
      }
    } else {
      features = [this.readFeatureFromObject(object, options)];
    }
    return features;
  }
  readGeometryFromObject(object, options) {
    return readGeometry(object, options);
  }
  readProjectionFromObject(object) {
    const crs = object["crs"];
    let projection;
    if (crs) {
      if (crs["type"] == "name") {
        projection = get$4(crs["properties"]["name"]);
      } else if (crs["type"] === "EPSG") {
        projection = get$4("EPSG:" + crs["properties"]["code"]);
      } else {
        assert(false, 36);
      }
    } else {
      projection = this.dataProjection;
    }
    return projection;
  }
  writeFeatureObject(feature, options) {
    options = this.adaptOptions(options);
    const object = {
      "type": "Feature",
      geometry: null,
      properties: null
    };
    const id = feature.getId();
    if (id !== void 0) {
      object.id = id;
    }
    if (!feature.hasProperties()) {
      return object;
    }
    const properties = feature.getProperties();
    const geometry = feature.getGeometry();
    if (geometry) {
      object.geometry = writeGeometry(geometry, options);
      delete properties[feature.getGeometryName()];
    }
    if (!isEmpty$1(properties)) {
      object.properties = properties;
    }
    return object;
  }
  writeFeaturesObject(features, options) {
    options = this.adaptOptions(options);
    const objects = [];
    for (let i2 = 0, ii = features.length; i2 < ii; ++i2) {
      objects.push(this.writeFeatureObject(features[i2], options));
    }
    return {
      type: "FeatureCollection",
      features: objects
    };
  }
  writeGeometryObject(geometry, options) {
    return writeGeometry(geometry, this.adaptOptions(options));
  }
}
function readGeometry(object, options) {
  if (!object) {
    return null;
  }
  let geometry;
  switch (object["type"]) {
    case "Point": {
      geometry = readPointGeometry$1(object);
      break;
    }
    case "LineString": {
      geometry = readLineStringGeometry$1(object);
      break;
    }
    case "Polygon": {
      geometry = readPolygonGeometry$1(object);
      break;
    }
    case "MultiPoint": {
      geometry = readMultiPointGeometry$1(object);
      break;
    }
    case "MultiLineString": {
      geometry = readMultiLineStringGeometry$1(object);
      break;
    }
    case "MultiPolygon": {
      geometry = readMultiPolygonGeometry$1(object);
      break;
    }
    case "GeometryCollection": {
      geometry = readGeometryCollectionGeometry(object);
      break;
    }
    default: {
      throw new Error("Unsupported GeoJSON type: " + object["type"]);
    }
  }
  return transformGeometryWithOptions(geometry, false, options);
}
function readGeometryCollectionGeometry(object, options) {
  const geometries = object["geometries"].map(function(geometry) {
    return readGeometry(geometry, options);
  });
  return new GeometryCollection(geometries);
}
function readPointGeometry$1(object) {
  return new Point$3(object["coordinates"]);
}
function readLineStringGeometry$1(object) {
  return new LineString$1(object["coordinates"]);
}
function readMultiLineStringGeometry$1(object) {
  return new MultiLineString$1(object["coordinates"]);
}
function readMultiPointGeometry$1(object) {
  return new MultiPoint$1(object["coordinates"]);
}
function readMultiPolygonGeometry$1(object) {
  return new MultiPolygon$1(object["coordinates"]);
}
function readPolygonGeometry$1(object) {
  return new Polygon$1(object["coordinates"]);
}
function writeGeometry(geometry, options) {
  geometry = transformGeometryWithOptions(geometry, true, options);
  const type = geometry.getType();
  let geoJSON;
  switch (type) {
    case "Point": {
      geoJSON = writePointGeometry(geometry);
      break;
    }
    case "LineString": {
      geoJSON = writeLineStringGeometry(geometry);
      break;
    }
    case "Polygon": {
      geoJSON = writePolygonGeometry(geometry, options);
      break;
    }
    case "MultiPoint": {
      geoJSON = writeMultiPointGeometry(geometry);
      break;
    }
    case "MultiLineString": {
      geoJSON = writeMultiLineStringGeometry(geometry);
      break;
    }
    case "MultiPolygon": {
      geoJSON = writeMultiPolygonGeometry(geometry, options);
      break;
    }
    case "GeometryCollection": {
      geoJSON = writeGeometryCollectionGeometry(geometry, options);
      break;
    }
    case "Circle": {
      geoJSON = {
        type: "GeometryCollection",
        geometries: []
      };
      break;
    }
    default: {
      throw new Error("Unsupported geometry type: " + type);
    }
  }
  return geoJSON;
}
function writeGeometryCollectionGeometry(geometry, options) {
  options = Object.assign({}, options);
  delete options.featureProjection;
  const geometries = geometry.getGeometriesArray().map(function(geometry2) {
    return writeGeometry(geometry2, options);
  });
  return {
    type: "GeometryCollection",
    geometries
  };
}
function writeLineStringGeometry(geometry, options) {
  return {
    type: "LineString",
    coordinates: geometry.getCoordinates()
  };
}
function writeMultiLineStringGeometry(geometry, options) {
  return {
    type: "MultiLineString",
    coordinates: geometry.getCoordinates()
  };
}
function writeMultiPointGeometry(geometry, options) {
  return {
    type: "MultiPoint",
    coordinates: geometry.getCoordinates()
  };
}
function writeMultiPolygonGeometry(geometry, options) {
  let right;
  if (options) {
    right = options.rightHanded;
  }
  return {
    type: "MultiPolygon",
    coordinates: geometry.getCoordinates(right)
  };
}
function writePointGeometry(geometry, options) {
  return {
    type: "Point",
    coordinates: geometry.getCoordinates()
  };
}
function writePolygonGeometry(geometry, options) {
  let right;
  if (options) {
    right = options.rightHanded;
  }
  return {
    type: "Polygon",
    coordinates: geometry.getCoordinates(right)
  };
}
const XML_SCHEMA_INSTANCE_URI = "http://www.w3.org/2001/XMLSchema-instance";
function createElementNS(namespaceURI, qualifiedName) {
  return getDocument().createElementNS(namespaceURI, qualifiedName);
}
function getAllTextContent(node2, normalizeWhitespace) {
  return getAllTextContent_(node2, normalizeWhitespace, []).join("");
}
function getAllTextContent_(node2, normalizeWhitespace, accumulator) {
  if (node2.nodeType == Node.CDATA_SECTION_NODE || node2.nodeType == Node.TEXT_NODE) {
    if (normalizeWhitespace) {
      accumulator.push(String(node2.nodeValue).replace(/(\r\n|\r|\n)/g, ""));
    } else {
      accumulator.push(node2.nodeValue);
    }
  } else {
    let n2;
    for (n2 = node2.firstChild; n2; n2 = n2.nextSibling) {
      getAllTextContent_(n2, normalizeWhitespace, accumulator);
    }
  }
  return accumulator;
}
function isDocument(object) {
  return "documentElement" in object;
}
function getAttributeNS(node2, namespaceURI, name) {
  return node2.getAttributeNS(namespaceURI, name) || "";
}
function parse$1(xml2) {
  return new DOMParser().parseFromString(xml2, "application/xml");
}
function makeArrayExtender(valueReader, thisArg) {
  return function(node2, objectStack) {
    const value = valueReader.call(thisArg !== void 0 ? thisArg : this, node2, objectStack);
    if (value !== void 0) {
      const array = objectStack[objectStack.length - 1];
      extend$3(array, value);
    }
  };
}
function makeArrayPusher(valueReader, thisArg) {
  return function(node2, objectStack) {
    const value = valueReader.call(thisArg !== void 0 ? thisArg : this, node2, objectStack);
    if (value !== void 0) {
      const array = objectStack[objectStack.length - 1];
      array.push(value);
    }
  };
}
function makeReplacer(valueReader, thisArg) {
  return function(node2, objectStack) {
    const value = valueReader.call(thisArg !== void 0 ? thisArg : this, node2, objectStack);
    if (value !== void 0) {
      objectStack[objectStack.length - 1] = value;
    }
  };
}
function makeObjectPropertyPusher(valueReader, property, thisArg) {
  return function(node2, objectStack) {
    const value = valueReader.call(thisArg !== void 0 ? thisArg : this, node2, objectStack);
    if (value !== void 0) {
      const object = objectStack[objectStack.length - 1];
      const name = property !== void 0 ? property : node2.localName;
      let array;
      if (name in object) {
        array = object[name];
      } else {
        array = [];
        object[name] = array;
      }
      array.push(value);
    }
  };
}
function makeObjectPropertySetter(valueReader, property, thisArg) {
  return function(node2, objectStack) {
    const value = valueReader.call(thisArg !== void 0 ? thisArg : this, node2, objectStack);
    if (value !== void 0) {
      const object = objectStack[objectStack.length - 1];
      const name = property !== void 0 ? property : node2.localName;
      object[name] = value;
    }
  };
}
function makeChildAppender(nodeWriter, thisArg) {
  return function(node2, value, objectStack) {
    nodeWriter.call(thisArg !== void 0 ? thisArg : this, node2, value, objectStack);
    const parent = objectStack[objectStack.length - 1];
    const parentNode = parent.node;
    parentNode.appendChild(node2);
  };
}
function makeArraySerializer(nodeWriter, thisArg) {
  let serializersNS, nodeFactory;
  return function(node2, value, objectStack) {
    if (serializersNS === void 0) {
      serializersNS = {};
      const serializers = {};
      serializers[node2.localName] = nodeWriter;
      serializersNS[node2.namespaceURI] = serializers;
      nodeFactory = makeSimpleNodeFactory(node2.localName);
    }
    serialize(serializersNS, nodeFactory, value, objectStack);
  };
}
function makeSimpleNodeFactory(fixedNodeName, fixedNamespaceURI) {
  return function(value, objectStack, newNodeName) {
    const context2 = objectStack[objectStack.length - 1];
    const node2 = context2.node;
    let nodeName = fixedNodeName;
    if (nodeName === void 0) {
      nodeName = newNodeName;
    }
    const namespaceURI = fixedNamespaceURI !== void 0 ? fixedNamespaceURI : node2.namespaceURI;
    return createElementNS(namespaceURI, nodeName);
  };
}
const OBJECT_PROPERTY_NODE_FACTORY = makeSimpleNodeFactory();
function makeSequence(object, orderedKeys) {
  const length = orderedKeys.length;
  const sequence = new Array(length);
  for (let i2 = 0; i2 < length; ++i2) {
    sequence[i2] = object[orderedKeys[i2]];
  }
  return sequence;
}
function makeStructureNS(namespaceURIs, structure, structureNS) {
  structureNS = structureNS !== void 0 ? structureNS : {};
  let i2, ii;
  for (i2 = 0, ii = namespaceURIs.length; i2 < ii; ++i2) {
    structureNS[namespaceURIs[i2]] = structure;
  }
  return structureNS;
}
function parseNode(parsersNS, node2, objectStack, thisArg) {
  let n2;
  for (n2 = node2.firstElementChild; n2; n2 = n2.nextElementSibling) {
    const parsers = parsersNS[n2.namespaceURI];
    if (parsers !== void 0) {
      const parser = parsers[n2.localName];
      if (parser !== void 0) {
        parser.call(thisArg, n2, objectStack);
      }
    }
  }
}
function pushParseAndPop(object, parsersNS, node2, objectStack, thisArg) {
  objectStack.push(object);
  parseNode(parsersNS, node2, objectStack, thisArg);
  return objectStack.pop();
}
function serialize(serializersNS, nodeFactory, values3, objectStack, keys3, thisArg) {
  const length = (keys3 !== void 0 ? keys3 : values3).length;
  let value, node2;
  for (let i2 = 0; i2 < length; ++i2) {
    value = values3[i2];
    if (value !== void 0) {
      node2 = nodeFactory.call(thisArg !== void 0 ? thisArg : this, value, objectStack, keys3 !== void 0 ? keys3[i2] : void 0);
      if (node2 !== void 0) {
        serializersNS[node2.namespaceURI][node2.localName].call(thisArg, node2, value, objectStack);
      }
    }
  }
}
function pushSerializeAndPop(object, serializersNS, nodeFactory, values3, objectStack, keys3, thisArg) {
  objectStack.push(object);
  serialize(serializersNS, nodeFactory, values3, objectStack, keys3, thisArg);
  return objectStack.pop();
}
let xmlSerializer_ = void 0;
function getXMLSerializer() {
  if (xmlSerializer_ === void 0 && typeof XMLSerializer !== "undefined") {
    xmlSerializer_ = new XMLSerializer();
  }
  return xmlSerializer_;
}
let document_ = void 0;
function getDocument() {
  if (document_ === void 0 && typeof document !== "undefined") {
    document_ = document.implementation.createDocument("", "", null);
  }
  return document_;
}
class XMLFeature extends FeatureFormat {
  constructor() {
    super();
    this.xmlSerializer_ = getXMLSerializer();
  }
  getType() {
    return "xml";
  }
  readFeature(source, options) {
    if (!source) {
      return null;
    } else if (typeof source === "string") {
      const doc = parse$1(source);
      return this.readFeatureFromDocument(doc, options);
    } else if (isDocument(source)) {
      return this.readFeatureFromDocument(source, options);
    }
    return this.readFeatureFromNode(source, options);
  }
  readFeatureFromDocument(doc, options) {
    const features = this.readFeaturesFromDocument(doc, options);
    if (features.length > 0) {
      return features[0];
    }
    return null;
  }
  readFeatureFromNode(node2, options) {
    return null;
  }
  readFeatures(source, options) {
    if (!source) {
      return [];
    } else if (typeof source === "string") {
      const doc = parse$1(source);
      return this.readFeaturesFromDocument(doc, options);
    } else if (isDocument(source)) {
      return this.readFeaturesFromDocument(source, options);
    }
    return this.readFeaturesFromNode(source, options);
  }
  readFeaturesFromDocument(doc, options) {
    const features = [];
    for (let n2 = doc.firstChild; n2; n2 = n2.nextSibling) {
      if (n2.nodeType == Node.ELEMENT_NODE) {
        extend$3(features, this.readFeaturesFromNode(n2, options));
      }
    }
    return features;
  }
  readFeaturesFromNode(node2, options) {
    return abstract();
  }
  readGeometry(source, options) {
    if (!source) {
      return null;
    } else if (typeof source === "string") {
      const doc = parse$1(source);
      return this.readGeometryFromDocument(doc, options);
    } else if (isDocument(source)) {
      return this.readGeometryFromDocument(source, options);
    }
    return this.readGeometryFromNode(source, options);
  }
  readGeometryFromDocument(doc, options) {
    return null;
  }
  readGeometryFromNode(node2, options) {
    return null;
  }
  readProjection(source) {
    if (!source) {
      return null;
    } else if (typeof source === "string") {
      const doc = parse$1(source);
      return this.readProjectionFromDocument(doc);
    } else if (isDocument(source)) {
      return this.readProjectionFromDocument(source);
    }
    return this.readProjectionFromNode(source);
  }
  readProjectionFromDocument(doc) {
    return this.dataProjection;
  }
  readProjectionFromNode(node2) {
    return this.dataProjection;
  }
  writeFeature(feature, options) {
    const node2 = this.writeFeatureNode(feature, options);
    return this.xmlSerializer_.serializeToString(node2);
  }
  writeFeatureNode(feature, options) {
    return null;
  }
  writeFeatures(features, options) {
    const node2 = this.writeFeaturesNode(features, options);
    return this.xmlSerializer_.serializeToString(node2);
  }
  writeFeaturesNode(features, options) {
    return null;
  }
  writeGeometry(geometry, options) {
    const node2 = this.writeGeometryNode(geometry, options);
    return this.xmlSerializer_.serializeToString(node2);
  }
  writeGeometryNode(geometry, options) {
    return null;
  }
}
const GMLNS = "http://www.opengis.net/gml";
const ONLY_WHITESPACE_RE = /^\s*$/;
class GMLBase extends XMLFeature {
  constructor(options) {
    super();
    options = options ? options : {};
    this.featureType = options.featureType;
    this.featureNS = options.featureNS;
    this.srsName = options.srsName;
    this.schemaLocation = "";
    this.FEATURE_COLLECTION_PARSERS = {};
    this.FEATURE_COLLECTION_PARSERS[this.namespace] = {
      "featureMember": makeArrayPusher(this.readFeaturesInternal),
      "featureMembers": makeReplacer(this.readFeaturesInternal)
    };
    this.supportedMediaTypes = ["application/gml+xml"];
  }
  readFeaturesInternal(node2, objectStack) {
    const localName = node2.localName;
    let features = null;
    if (localName == "FeatureCollection") {
      features = pushParseAndPop([], this.FEATURE_COLLECTION_PARSERS, node2, objectStack, this);
    } else if (localName == "featureMembers" || localName == "featureMember" || localName == "member") {
      const context2 = objectStack[0];
      let featureType = context2["featureType"];
      let featureNS = context2["featureNS"];
      const prefix = "p";
      const defaultPrefix = "p0";
      if (!featureType && node2.childNodes) {
        featureType = [], featureNS = {};
        for (let i2 = 0, ii = node2.childNodes.length; i2 < ii; ++i2) {
          const child = node2.childNodes[i2];
          if (child.nodeType === 1) {
            const ft2 = child.nodeName.split(":").pop();
            if (!featureType.includes(ft2)) {
              let key = "";
              let count = 0;
              const uri = child.namespaceURI;
              for (const candidate in featureNS) {
                if (featureNS[candidate] === uri) {
                  key = candidate;
                  break;
                }
                ++count;
              }
              if (!key) {
                key = prefix + count;
                featureNS[key] = uri;
              }
              featureType.push(key + ":" + ft2);
            }
          }
        }
        if (localName != "featureMember") {
          context2["featureType"] = featureType;
          context2["featureNS"] = featureNS;
        }
      }
      if (typeof featureNS === "string") {
        const ns = featureNS;
        featureNS = {};
        featureNS[defaultPrefix] = ns;
      }
      const parsersNS = {};
      const featureTypes = Array.isArray(featureType) ? featureType : [featureType];
      for (const p5 in featureNS) {
        const parsers = {};
        for (let i2 = 0, ii = featureTypes.length; i2 < ii; ++i2) {
          const featurePrefix = featureTypes[i2].includes(":") ? featureTypes[i2].split(":")[0] : defaultPrefix;
          if (featurePrefix === p5) {
            parsers[featureTypes[i2].split(":").pop()] = localName == "featureMembers" ? makeArrayPusher(this.readFeatureElement, this) : makeReplacer(this.readFeatureElement, this);
          }
        }
        parsersNS[featureNS[p5]] = parsers;
      }
      if (localName == "featureMember" || localName == "member") {
        features = pushParseAndPop(void 0, parsersNS, node2, objectStack);
      } else {
        features = pushParseAndPop([], parsersNS, node2, objectStack);
      }
    }
    if (features === null) {
      features = [];
    }
    return features;
  }
  readGeometryOrExtent(node2, objectStack) {
    const context2 = objectStack[0];
    context2["srsName"] = node2.firstElementChild.getAttribute("srsName");
    context2["srsDimension"] = node2.firstElementChild.getAttribute("srsDimension");
    return pushParseAndPop(null, this.GEOMETRY_PARSERS, node2, objectStack, this);
  }
  readExtentElement(node2, objectStack) {
    const context2 = objectStack[0];
    const extent2 = this.readGeometryOrExtent(node2, objectStack);
    return extent2 ? transformExtentWithOptions(extent2, context2) : void 0;
  }
  readGeometryElement(node2, objectStack) {
    const context2 = objectStack[0];
    const geometry = this.readGeometryOrExtent(node2, objectStack);
    return geometry ? transformGeometryWithOptions(geometry, false, context2) : void 0;
  }
  readFeatureElementInternal(node2, objectStack, asFeature) {
    let geometryName;
    const values3 = {};
    for (let n2 = node2.firstElementChild; n2; n2 = n2.nextElementSibling) {
      let value;
      const localName = n2.localName;
      if (n2.childNodes.length === 0 || n2.childNodes.length === 1 && (n2.firstChild.nodeType === 3 || n2.firstChild.nodeType === 4)) {
        value = getAllTextContent(n2, false);
        if (ONLY_WHITESPACE_RE.test(value)) {
          value = void 0;
        }
      } else {
        if (asFeature) {
          value = localName === "boundedBy" ? this.readExtentElement(n2, objectStack) : this.readGeometryElement(n2, objectStack);
        }
        if (!value) {
          value = this.readFeatureElementInternal(n2, objectStack, false);
        } else if (localName !== "boundedBy") {
          geometryName = localName;
        }
      }
      const len = n2.attributes.length;
      if (len > 0) {
        value = { _content_: value };
        for (let i2 = 0; i2 < len; i2++) {
          const attName = n2.attributes[i2].name;
          value[attName] = n2.attributes[i2].value;
        }
      }
      if (values3[localName]) {
        if (!(values3[localName] instanceof Array)) {
          values3[localName] = [values3[localName]];
        }
        values3[localName].push(value);
      } else {
        values3[localName] = value;
      }
    }
    if (!asFeature) {
      return values3;
    }
    const feature = new Feature$1(values3);
    if (geometryName) {
      feature.setGeometryName(geometryName);
    }
    const fid = node2.getAttribute("fid") || getAttributeNS(node2, this.namespace, "id");
    if (fid) {
      feature.setId(fid);
    }
    return feature;
  }
  readFeatureElement(node2, objectStack) {
    return this.readFeatureElementInternal(node2, objectStack, true);
  }
  readPoint(node2, objectStack) {
    const flatCoordinates = this.readFlatCoordinatesFromNode(node2, objectStack);
    if (flatCoordinates) {
      return new Point$3(flatCoordinates, "XYZ");
    }
  }
  readMultiPoint(node2, objectStack) {
    const coordinates2 = pushParseAndPop([], this.MULTIPOINT_PARSERS, node2, objectStack, this);
    if (coordinates2) {
      return new MultiPoint$1(coordinates2);
    }
    return void 0;
  }
  readMultiLineString(node2, objectStack) {
    const lineStrings = pushParseAndPop([], this.MULTILINESTRING_PARSERS, node2, objectStack, this);
    if (lineStrings) {
      return new MultiLineString$1(lineStrings);
    }
  }
  readMultiPolygon(node2, objectStack) {
    const polygons = pushParseAndPop([], this.MULTIPOLYGON_PARSERS, node2, objectStack, this);
    if (polygons) {
      return new MultiPolygon$1(polygons);
    }
  }
  pointMemberParser(node2, objectStack) {
    parseNode(this.POINTMEMBER_PARSERS, node2, objectStack, this);
  }
  lineStringMemberParser(node2, objectStack) {
    parseNode(this.LINESTRINGMEMBER_PARSERS, node2, objectStack, this);
  }
  polygonMemberParser(node2, objectStack) {
    parseNode(this.POLYGONMEMBER_PARSERS, node2, objectStack, this);
  }
  readLineString(node2, objectStack) {
    const flatCoordinates = this.readFlatCoordinatesFromNode(node2, objectStack);
    if (flatCoordinates) {
      const lineString = new LineString$1(flatCoordinates, "XYZ");
      return lineString;
    }
    return void 0;
  }
  readFlatLinearRing(node2, objectStack) {
    const ring = pushParseAndPop(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS, node2, objectStack, this);
    if (ring) {
      return ring;
    }
    return void 0;
  }
  readLinearRing(node2, objectStack) {
    const flatCoordinates = this.readFlatCoordinatesFromNode(node2, objectStack);
    if (flatCoordinates) {
      return new LinearRing(flatCoordinates, "XYZ");
    }
  }
  readPolygon(node2, objectStack) {
    const flatLinearRings = pushParseAndPop([null], this.FLAT_LINEAR_RINGS_PARSERS, node2, objectStack, this);
    if (flatLinearRings && flatLinearRings[0]) {
      const flatCoordinates = flatLinearRings[0];
      const ends = [flatCoordinates.length];
      let i2, ii;
      for (i2 = 1, ii = flatLinearRings.length; i2 < ii; ++i2) {
        extend$3(flatCoordinates, flatLinearRings[i2]);
        ends.push(flatCoordinates.length);
      }
      return new Polygon$1(flatCoordinates, "XYZ", ends);
    }
    return void 0;
  }
  readFlatCoordinatesFromNode(node2, objectStack) {
    return pushParseAndPop(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS, node2, objectStack, this);
  }
  readGeometryFromNode(node2, options) {
    const geometry = this.readGeometryElement(node2, [
      this.getReadOptions(node2, options ? options : {})
    ]);
    return geometry ? geometry : null;
  }
  readFeaturesFromNode(node2, options) {
    const internalOptions = {
      featureType: this.featureType,
      featureNS: this.featureNS
    };
    if (internalOptions) {
      Object.assign(internalOptions, this.getReadOptions(node2, options));
    }
    const features = this.readFeaturesInternal(node2, [internalOptions]);
    return features || [];
  }
  readProjectionFromNode(node2) {
    return get$4(this.srsName ? this.srsName : node2.firstElementChild.getAttribute("srsName"));
  }
}
GMLBase.prototype.namespace = GMLNS;
GMLBase.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  "http://www.opengis.net/gml": {}
};
GMLBase.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  "http://www.opengis.net/gml": {}
};
GMLBase.prototype.GEOMETRY_PARSERS = {
  "http://www.opengis.net/gml": {}
};
GMLBase.prototype.MULTIPOINT_PARSERS = {
  "http://www.opengis.net/gml": {
    "pointMember": makeArrayPusher(GMLBase.prototype.pointMemberParser),
    "pointMembers": makeArrayPusher(GMLBase.prototype.pointMemberParser)
  }
};
GMLBase.prototype.MULTILINESTRING_PARSERS = {
  "http://www.opengis.net/gml": {
    "lineStringMember": makeArrayPusher(GMLBase.prototype.lineStringMemberParser),
    "lineStringMembers": makeArrayPusher(GMLBase.prototype.lineStringMemberParser)
  }
};
GMLBase.prototype.MULTIPOLYGON_PARSERS = {
  "http://www.opengis.net/gml": {
    "polygonMember": makeArrayPusher(GMLBase.prototype.polygonMemberParser),
    "polygonMembers": makeArrayPusher(GMLBase.prototype.polygonMemberParser)
  }
};
GMLBase.prototype.POINTMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    "Point": makeArrayPusher(GMLBase.prototype.readFlatCoordinatesFromNode)
  }
};
GMLBase.prototype.LINESTRINGMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    "LineString": makeArrayPusher(GMLBase.prototype.readLineString)
  }
};
GMLBase.prototype.POLYGONMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    "Polygon": makeArrayPusher(GMLBase.prototype.readPolygon)
  }
};
GMLBase.prototype.RING_PARSERS = {
  "http://www.opengis.net/gml": {
    "LinearRing": makeReplacer(GMLBase.prototype.readFlatLinearRing)
  }
};
function readBoolean(node2) {
  const s2 = getAllTextContent(node2, false);
  return readBooleanString(s2);
}
function readBooleanString(string) {
  const m2 = /^\s*(true|1)|(false|0)\s*$/.exec(string);
  if (m2) {
    return m2[1] !== void 0 || false;
  }
  return void 0;
}
function readDateTime(node2) {
  const s2 = getAllTextContent(node2, false);
  const dateTime = Date.parse(s2);
  return isNaN(dateTime) ? void 0 : dateTime / 1e3;
}
function readDecimal(node2) {
  const s2 = getAllTextContent(node2, false);
  return readDecimalString(s2);
}
function readDecimalString(string) {
  const m2 = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*$/i.exec(string);
  if (m2) {
    return parseFloat(m2[1]);
  }
  return void 0;
}
function readPositiveInteger(node2) {
  const s2 = getAllTextContent(node2, false);
  return readNonNegativeIntegerString(s2);
}
function readNonNegativeIntegerString(string) {
  const m2 = /^\s*(\d+)\s*$/.exec(string);
  if (m2) {
    return parseInt(m2[1], 10);
  }
  return void 0;
}
function readString(node2) {
  return getAllTextContent(node2, false).trim();
}
function writeBooleanTextNode(node2, bool) {
  writeStringTextNode(node2, bool ? "1" : "0");
}
function writeCDATASection(node2, string) {
  node2.appendChild(getDocument().createCDATASection(string));
}
function writeDateTimeTextNode(node2, dateTime) {
  const date = new Date(dateTime * 1e3);
  const string = date.getUTCFullYear() + "-" + padNumber(date.getUTCMonth() + 1, 2) + "-" + padNumber(date.getUTCDate(), 2) + "T" + padNumber(date.getUTCHours(), 2) + ":" + padNumber(date.getUTCMinutes(), 2) + ":" + padNumber(date.getUTCSeconds(), 2) + "Z";
  node2.appendChild(getDocument().createTextNode(string));
}
function writeDecimalTextNode(node2, decimal) {
  const string = decimal.toPrecision();
  node2.appendChild(getDocument().createTextNode(string));
}
function writeNonNegativeIntegerTextNode(node2, nonNegativeInteger) {
  const string = nonNegativeInteger.toString();
  node2.appendChild(getDocument().createTextNode(string));
}
function writeStringTextNode(node2, string) {
  node2.appendChild(getDocument().createTextNode(string));
}
const schemaLocation$1 = GMLNS + " http://schemas.opengis.net/gml/2.1.2/feature.xsd";
const MULTIGEOMETRY_TO_MEMBER_NODENAME$1 = {
  "MultiLineString": "lineStringMember",
  "MultiCurve": "curveMember",
  "MultiPolygon": "polygonMember",
  "MultiSurface": "surfaceMember"
};
class GML2 extends GMLBase {
  constructor(options) {
    options = options ? options : {};
    super(options);
    this.FEATURE_COLLECTION_PARSERS[GMLNS]["featureMember"] = makeArrayPusher(this.readFeaturesInternal);
    this.schemaLocation = options.schemaLocation ? options.schemaLocation : schemaLocation$1;
  }
  readFlatCoordinates(node2, objectStack) {
    const s2 = getAllTextContent(node2, false).replace(/^\s*|\s*$/g, "");
    const context2 = objectStack[0];
    const containerSrs = context2["srsName"];
    let axisOrientation = "enu";
    if (containerSrs) {
      const proj = get$4(containerSrs);
      if (proj) {
        axisOrientation = proj.getAxisOrientation();
      }
    }
    const coordsGroups = s2.trim().split(/\s+/);
    const flatCoordinates = [];
    for (let i2 = 0, ii = coordsGroups.length; i2 < ii; i2++) {
      const coords = coordsGroups[i2].split(/,+/);
      const x2 = parseFloat(coords[0]);
      const y2 = parseFloat(coords[1]);
      const z2 = coords.length === 3 ? parseFloat(coords[2]) : 0;
      if (axisOrientation.substr(0, 2) === "en") {
        flatCoordinates.push(x2, y2, z2);
      } else {
        flatCoordinates.push(y2, x2, z2);
      }
    }
    return flatCoordinates;
  }
  readBox(node2, objectStack) {
    const flatCoordinates = pushParseAndPop([null], this.BOX_PARSERS_, node2, objectStack, this);
    return createOrUpdate$2(flatCoordinates[1][0], flatCoordinates[1][1], flatCoordinates[1][3], flatCoordinates[1][4]);
  }
  innerBoundaryIsParser(node2, objectStack) {
    const flatLinearRing = pushParseAndPop(void 0, this.RING_PARSERS, node2, objectStack, this);
    if (flatLinearRing) {
      const flatLinearRings = objectStack[objectStack.length - 1];
      flatLinearRings.push(flatLinearRing);
    }
  }
  outerBoundaryIsParser(node2, objectStack) {
    const flatLinearRing = pushParseAndPop(void 0, this.RING_PARSERS, node2, objectStack, this);
    if (flatLinearRing) {
      const flatLinearRings = objectStack[objectStack.length - 1];
      flatLinearRings[0] = flatLinearRing;
    }
  }
  GEOMETRY_NODE_FACTORY_(value, objectStack, nodeName) {
    const context2 = objectStack[objectStack.length - 1];
    const multiSurface = context2["multiSurface"];
    const surface = context2["surface"];
    const multiCurve = context2["multiCurve"];
    if (!Array.isArray(value)) {
      nodeName = value.getType();
      if (nodeName === "MultiPolygon" && multiSurface === true) {
        nodeName = "MultiSurface";
      } else if (nodeName === "Polygon" && surface === true) {
        nodeName = "Surface";
      } else if (nodeName === "MultiLineString" && multiCurve === true) {
        nodeName = "MultiCurve";
      }
    } else {
      nodeName = "Envelope";
    }
    return createElementNS("http://www.opengis.net/gml", nodeName);
  }
  writeFeatureElement(node2, feature, objectStack) {
    const fid = feature.getId();
    if (fid) {
      node2.setAttribute("fid", fid);
    }
    const context2 = objectStack[objectStack.length - 1];
    const featureNS = context2["featureNS"];
    const geometryName = feature.getGeometryName();
    if (!context2.serializers) {
      context2.serializers = {};
      context2.serializers[featureNS] = {};
    }
    const keys3 = [];
    const values3 = [];
    if (feature.hasProperties()) {
      const properties = feature.getProperties();
      for (const key in properties) {
        const value = properties[key];
        if (value !== null) {
          keys3.push(key);
          values3.push(value);
          if (key == geometryName || typeof value.getSimplifiedGeometry === "function") {
            if (!(key in context2.serializers[featureNS])) {
              context2.serializers[featureNS][key] = makeChildAppender(this.writeGeometryElement, this);
            }
          } else {
            if (!(key in context2.serializers[featureNS])) {
              context2.serializers[featureNS][key] = makeChildAppender(writeStringTextNode);
            }
          }
        }
      }
    }
    const item = Object.assign({}, context2);
    item.node = node2;
    pushSerializeAndPop(item, context2.serializers, makeSimpleNodeFactory(void 0, featureNS), values3, objectStack, keys3);
  }
  writeCurveOrLineString(node2, geometry, objectStack) {
    const context2 = objectStack[objectStack.length - 1];
    const srsName = context2["srsName"];
    if (node2.nodeName !== "LineStringSegment" && srsName) {
      node2.setAttribute("srsName", srsName);
    }
    if (node2.nodeName === "LineString" || node2.nodeName === "LineStringSegment") {
      const coordinates2 = this.createCoordinatesNode_(node2.namespaceURI);
      node2.appendChild(coordinates2);
      this.writeCoordinates_(coordinates2, geometry, objectStack);
    } else if (node2.nodeName === "Curve") {
      const segments = createElementNS(node2.namespaceURI, "segments");
      node2.appendChild(segments);
      this.writeCurveSegments_(segments, geometry, objectStack);
    }
  }
  writeLineStringOrCurveMember(node2, line, objectStack) {
    const child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);
    if (child) {
      node2.appendChild(child);
      this.writeCurveOrLineString(child, line, objectStack);
    }
  }
  writeMultiCurveOrLineString(node2, geometry, objectStack) {
    const context2 = objectStack[objectStack.length - 1];
    const hasZ = context2["hasZ"];
    const srsName = context2["srsName"];
    const curve = context2["curve"];
    if (srsName) {
      node2.setAttribute("srsName", srsName);
    }
    const lines = geometry.getLineStrings();
    pushSerializeAndPop({ node: node2, hasZ, srsName, curve }, this.LINESTRINGORCURVEMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, lines, objectStack, void 0, this);
  }
  writeGeometryElement(node2, geometry, objectStack) {
    const context2 = objectStack[objectStack.length - 1];
    const item = Object.assign({}, context2);
    item["node"] = node2;
    let value;
    if (Array.isArray(geometry)) {
      value = transformExtentWithOptions(geometry, context2);
    } else {
      value = transformGeometryWithOptions(geometry, true, context2);
    }
    pushSerializeAndPop(item, this.GEOMETRY_SERIALIZERS, this.GEOMETRY_NODE_FACTORY_, [value], objectStack, void 0, this);
  }
  createCoordinatesNode_(namespaceURI) {
    const coordinates2 = createElementNS(namespaceURI, "coordinates");
    coordinates2.setAttribute("decimal", ".");
    coordinates2.setAttribute("cs", ",");
    coordinates2.setAttribute("ts", " ");
    return coordinates2;
  }
  writeCoordinates_(node2, value, objectStack) {
    const context2 = objectStack[objectStack.length - 1];
    const hasZ = context2["hasZ"];
    const srsName = context2["srsName"];
    const points = value.getCoordinates();
    const len = points.length;
    const parts = new Array(len);
    for (let i2 = 0; i2 < len; ++i2) {
      const point = points[i2];
      parts[i2] = this.getCoords_(point, srsName, hasZ);
    }
    writeStringTextNode(node2, parts.join(" "));
  }
  writeCurveSegments_(node2, line, objectStack) {
    const child = createElementNS(node2.namespaceURI, "LineStringSegment");
    node2.appendChild(child);
    this.writeCurveOrLineString(child, line, objectStack);
  }
  writeSurfaceOrPolygon(node2, geometry, objectStack) {
    const context2 = objectStack[objectStack.length - 1];
    const hasZ = context2["hasZ"];
    const srsName = context2["srsName"];
    if (node2.nodeName !== "PolygonPatch" && srsName) {
      node2.setAttribute("srsName", srsName);
    }
    if (node2.nodeName === "Polygon" || node2.nodeName === "PolygonPatch") {
      const rings = geometry.getLinearRings();
      pushSerializeAndPop({ node: node2, hasZ, srsName }, this.RING_SERIALIZERS, this.RING_NODE_FACTORY_, rings, objectStack, void 0, this);
    } else if (node2.nodeName === "Surface") {
      const patches = createElementNS(node2.namespaceURI, "patches");
      node2.appendChild(patches);
      this.writeSurfacePatches_(patches, geometry, objectStack);
    }
  }
  RING_NODE_FACTORY_(value, objectStack, nodeName) {
    const context2 = objectStack[objectStack.length - 1];
    const parentNode = context2.node;
    const exteriorWritten = context2["exteriorWritten"];
    if (exteriorWritten === void 0) {
      context2["exteriorWritten"] = true;
    }
    return createElementNS(parentNode.namespaceURI, exteriorWritten !== void 0 ? "innerBoundaryIs" : "outerBoundaryIs");
  }
  writeSurfacePatches_(node2, polygon, objectStack) {
    const child = createElementNS(node2.namespaceURI, "PolygonPatch");
    node2.appendChild(child);
    this.writeSurfaceOrPolygon(child, polygon, objectStack);
  }
  writeRing(node2, ring, objectStack) {
    const linearRing2 = createElementNS(node2.namespaceURI, "LinearRing");
    node2.appendChild(linearRing2);
    this.writeLinearRing(linearRing2, ring, objectStack);
  }
  getCoords_(point, srsName, hasZ) {
    let axisOrientation = "enu";
    if (srsName) {
      axisOrientation = get$4(srsName).getAxisOrientation();
    }
    let coords = axisOrientation.substr(0, 2) === "en" ? point[0] + "," + point[1] : point[1] + "," + point[0];
    if (hasZ) {
      const z2 = point[2] || 0;
      coords += "," + z2;
    }
    return coords;
  }
  writePoint(node2, geometry, objectStack) {
    const context2 = objectStack[objectStack.length - 1];
    const hasZ = context2["hasZ"];
    const srsName = context2["srsName"];
    if (srsName) {
      node2.setAttribute("srsName", srsName);
    }
    const coordinates2 = this.createCoordinatesNode_(node2.namespaceURI);
    node2.appendChild(coordinates2);
    const point = geometry.getCoordinates();
    const coord = this.getCoords_(point, srsName, hasZ);
    writeStringTextNode(coordinates2, coord);
  }
  writeMultiPoint(node2, geometry, objectStack) {
    const context2 = objectStack[objectStack.length - 1];
    const hasZ = context2["hasZ"];
    const srsName = context2["srsName"];
    if (srsName) {
      node2.setAttribute("srsName", srsName);
    }
    const points = geometry.getPoints();
    pushSerializeAndPop({ node: node2, hasZ, srsName }, this.POINTMEMBER_SERIALIZERS, makeSimpleNodeFactory("pointMember"), points, objectStack, void 0, this);
  }
  writePointMember(node2, point, objectStack) {
    const child = createElementNS(node2.namespaceURI, "Point");
    node2.appendChild(child);
    this.writePoint(child, point, objectStack);
  }
  writeLinearRing(node2, geometry, objectStack) {
    const context2 = objectStack[objectStack.length - 1];
    const srsName = context2["srsName"];
    if (srsName) {
      node2.setAttribute("srsName", srsName);
    }
    const coordinates2 = this.createCoordinatesNode_(node2.namespaceURI);
    node2.appendChild(coordinates2);
    this.writeCoordinates_(coordinates2, geometry, objectStack);
  }
  writeMultiSurfaceOrPolygon(node2, geometry, objectStack) {
    const context2 = objectStack[objectStack.length - 1];
    const hasZ = context2["hasZ"];
    const srsName = context2["srsName"];
    const surface = context2["surface"];
    if (srsName) {
      node2.setAttribute("srsName", srsName);
    }
    const polygons = geometry.getPolygons();
    pushSerializeAndPop({ node: node2, hasZ, srsName, surface }, this.SURFACEORPOLYGONMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, polygons, objectStack, void 0, this);
  }
  writeSurfaceOrPolygonMember(node2, polygon, objectStack) {
    const child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);
    if (child) {
      node2.appendChild(child);
      this.writeSurfaceOrPolygon(child, polygon, objectStack);
    }
  }
  writeEnvelope(node2, extent2, objectStack) {
    const context2 = objectStack[objectStack.length - 1];
    const srsName = context2["srsName"];
    if (srsName) {
      node2.setAttribute("srsName", srsName);
    }
    const keys3 = ["lowerCorner", "upperCorner"];
    const values3 = [extent2[0] + " " + extent2[1], extent2[2] + " " + extent2[3]];
    pushSerializeAndPop({ node: node2 }, this.ENVELOPE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values3, objectStack, keys3, this);
  }
  MULTIGEOMETRY_MEMBER_NODE_FACTORY_(value, objectStack, nodeName) {
    const parentNode = objectStack[objectStack.length - 1].node;
    return createElementNS("http://www.opengis.net/gml", MULTIGEOMETRY_TO_MEMBER_NODENAME$1[parentNode.nodeName]);
  }
}
GML2.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  "http://www.opengis.net/gml": {
    "coordinates": makeReplacer(GML2.prototype.readFlatCoordinates)
  }
};
GML2.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  "http://www.opengis.net/gml": {
    "innerBoundaryIs": GML2.prototype.innerBoundaryIsParser,
    "outerBoundaryIs": GML2.prototype.outerBoundaryIsParser
  }
};
GML2.prototype.BOX_PARSERS_ = {
  "http://www.opengis.net/gml": {
    "coordinates": makeArrayPusher(GML2.prototype.readFlatCoordinates)
  }
};
GML2.prototype.GEOMETRY_PARSERS = {
  "http://www.opengis.net/gml": {
    "Point": makeReplacer(GMLBase.prototype.readPoint),
    "MultiPoint": makeReplacer(GMLBase.prototype.readMultiPoint),
    "LineString": makeReplacer(GMLBase.prototype.readLineString),
    "MultiLineString": makeReplacer(GMLBase.prototype.readMultiLineString),
    "LinearRing": makeReplacer(GMLBase.prototype.readLinearRing),
    "Polygon": makeReplacer(GMLBase.prototype.readPolygon),
    "MultiPolygon": makeReplacer(GMLBase.prototype.readMultiPolygon),
    "Box": makeReplacer(GML2.prototype.readBox)
  }
};
GML2.prototype.GEOMETRY_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "Curve": makeChildAppender(GML2.prototype.writeCurveOrLineString),
    "MultiCurve": makeChildAppender(GML2.prototype.writeMultiCurveOrLineString),
    "Point": makeChildAppender(GML2.prototype.writePoint),
    "MultiPoint": makeChildAppender(GML2.prototype.writeMultiPoint),
    "LineString": makeChildAppender(GML2.prototype.writeCurveOrLineString),
    "MultiLineString": makeChildAppender(GML2.prototype.writeMultiCurveOrLineString),
    "LinearRing": makeChildAppender(GML2.prototype.writeLinearRing),
    "Polygon": makeChildAppender(GML2.prototype.writeSurfaceOrPolygon),
    "MultiPolygon": makeChildAppender(GML2.prototype.writeMultiSurfaceOrPolygon),
    "Surface": makeChildAppender(GML2.prototype.writeSurfaceOrPolygon),
    "MultiSurface": makeChildAppender(GML2.prototype.writeMultiSurfaceOrPolygon),
    "Envelope": makeChildAppender(GML2.prototype.writeEnvelope)
  }
};
GML2.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "lineStringMember": makeChildAppender(GML2.prototype.writeLineStringOrCurveMember),
    "curveMember": makeChildAppender(GML2.prototype.writeLineStringOrCurveMember)
  }
};
GML2.prototype.RING_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "outerBoundaryIs": makeChildAppender(GML2.prototype.writeRing),
    "innerBoundaryIs": makeChildAppender(GML2.prototype.writeRing)
  }
};
GML2.prototype.POINTMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "pointMember": makeChildAppender(GML2.prototype.writePointMember)
  }
};
GML2.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "surfaceMember": makeChildAppender(GML2.prototype.writeSurfaceOrPolygonMember),
    "polygonMember": makeChildAppender(GML2.prototype.writeSurfaceOrPolygonMember)
  }
};
GML2.prototype.ENVELOPE_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "lowerCorner": makeChildAppender(writeStringTextNode),
    "upperCorner": makeChildAppender(writeStringTextNode)
  }
};
const schemaLocation = GMLNS + " http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/1.0.0/gmlsf.xsd";
const MULTIGEOMETRY_TO_MEMBER_NODENAME = {
  "MultiLineString": "lineStringMember",
  "MultiCurve": "curveMember",
  "MultiPolygon": "polygonMember",
  "MultiSurface": "surfaceMember"
};
class GML3 extends GMLBase {
  constructor(options) {
    options = options ? options : {};
    super(options);
    this.surface_ = options.surface !== void 0 ? options.surface : false;
    this.curve_ = options.curve !== void 0 ? options.curve : false;
    this.multiCurve_ = options.multiCurve !== void 0 ? options.multiCurve : true;
    this.multiSurface_ = options.multiSurface !== void 0 ? options.multiSurface : true;
    this.schemaLocation = options.schemaLocation ? options.schemaLocation : schemaLocation;
    this.hasZ = options.hasZ !== void 0 ? options.hasZ : false;
  }
  readMultiCurve(node2, objectStack) {
    const lineStrings = pushParseAndPop([], this.MULTICURVE_PARSERS, node2, objectStack, this);
    if (lineStrings) {
      const multiLineString = new MultiLineString$1(lineStrings);
      return multiLineString;
    }
    return void 0;
  }
  readFlatCurveRing(node2, objectStack) {
    const lineStrings = pushParseAndPop([], this.MULTICURVE_PARSERS, node2, objectStack, this);
    const flatCoordinates = [];
    for (let i2 = 0, ii = lineStrings.length; i2 < ii; ++i2) {
      extend$3(flatCoordinates, lineStrings[i2].getFlatCoordinates());
    }
    return flatCoordinates;
  }
  readMultiSurface(node2, objectStack) {
    const polygons = pushParseAndPop([], this.MULTISURFACE_PARSERS, node2, objectStack, this);
    if (polygons) {
      return new MultiPolygon$1(polygons);
    }
  }
  curveMemberParser(node2, objectStack) {
    parseNode(this.CURVEMEMBER_PARSERS, node2, objectStack, this);
  }
  surfaceMemberParser(node2, objectStack) {
    parseNode(this.SURFACEMEMBER_PARSERS, node2, objectStack, this);
  }
  readPatch(node2, objectStack) {
    return pushParseAndPop([null], this.PATCHES_PARSERS, node2, objectStack, this);
  }
  readSegment(node2, objectStack) {
    return pushParseAndPop([], this.SEGMENTS_PARSERS, node2, objectStack, this);
  }
  readPolygonPatch(node2, objectStack) {
    return pushParseAndPop([null], this.FLAT_LINEAR_RINGS_PARSERS, node2, objectStack, this);
  }
  readLineStringSegment(node2, objectStack) {
    return pushParseAndPop([null], this.GEOMETRY_FLAT_COORDINATES_PARSERS, node2, objectStack, this);
  }
  interiorParser(node2, objectStack) {
    const flatLinearRing = pushParseAndPop(void 0, this.RING_PARSERS, node2, objectStack, this);
    if (flatLinearRing) {
      const flatLinearRings = objectStack[objectStack.length - 1];
      flatLinearRings.push(flatLinearRing);
    }
  }
  exteriorParser(node2, objectStack) {
    const flatLinearRing = pushParseAndPop(void 0, this.RING_PARSERS, node2, objectStack, this);
    if (flatLinearRing) {
      const flatLinearRings = objectStack[objectStack.length - 1];
      flatLinearRings[0] = flatLinearRing;
    }
  }
  readSurface(node2, objectStack) {
    const flatLinearRings = pushParseAndPop([null], this.SURFACE_PARSERS, node2, objectStack, this);
    if (flatLinearRings && flatLinearRings[0]) {
      const flatCoordinates = flatLinearRings[0];
      const ends = [flatCoordinates.length];
      let i2, ii;
      for (i2 = 1, ii = flatLinearRings.length; i2 < ii; ++i2) {
        extend$3(flatCoordinates, flatLinearRings[i2]);
        ends.push(flatCoordinates.length);
      }
      return new Polygon$1(flatCoordinates, "XYZ", ends);
    }
    return void 0;
  }
  readCurve(node2, objectStack) {
    const flatCoordinates = pushParseAndPop([null], this.CURVE_PARSERS, node2, objectStack, this);
    if (flatCoordinates) {
      const lineString = new LineString$1(flatCoordinates, "XYZ");
      return lineString;
    }
    return void 0;
  }
  readEnvelope(node2, objectStack) {
    const flatCoordinates = pushParseAndPop([null], this.ENVELOPE_PARSERS, node2, objectStack, this);
    return createOrUpdate$2(flatCoordinates[1][0], flatCoordinates[1][1], flatCoordinates[2][0], flatCoordinates[2][1]);
  }
  readFlatPos(node2, objectStack) {
    let s2 = getAllTextContent(node2, false);
    const re2 = /^\s*([+\-]?\d*\.?\d+(?:[eE][+\-]?\d+)?)\s*/;
    const flatCoordinates = [];
    let m2;
    while (m2 = re2.exec(s2)) {
      flatCoordinates.push(parseFloat(m2[1]));
      s2 = s2.substr(m2[0].length);
    }
    if (s2 !== "") {
      return void 0;
    }
    const context2 = objectStack[0];
    const containerSrs = context2["srsName"];
    let axisOrientation = "enu";
    if (containerSrs) {
      const proj = get$4(containerSrs);
      axisOrientation = proj.getAxisOrientation();
    }
    if (axisOrientation === "neu") {
      let i2, ii;
      for (i2 = 0, ii = flatCoordinates.length; i2 < ii; i2 += 3) {
        const y2 = flatCoordinates[i2];
        const x2 = flatCoordinates[i2 + 1];
        flatCoordinates[i2] = x2;
        flatCoordinates[i2 + 1] = y2;
      }
    }
    const len = flatCoordinates.length;
    if (len == 2) {
      flatCoordinates.push(0);
    }
    if (len === 0) {
      return void 0;
    }
    return flatCoordinates;
  }
  readFlatPosList(node2, objectStack) {
    const s2 = getAllTextContent(node2, false).replace(/^\s*|\s*$/g, "");
    const context2 = objectStack[0];
    const containerSrs = context2["srsName"];
    const contextDimension = context2["srsDimension"];
    let axisOrientation = "enu";
    if (containerSrs) {
      const proj = get$4(containerSrs);
      axisOrientation = proj.getAxisOrientation();
    }
    const coords = s2.split(/\s+/);
    let dim = 2;
    if (node2.getAttribute("srsDimension")) {
      dim = readNonNegativeIntegerString(node2.getAttribute("srsDimension"));
    } else if (node2.getAttribute("dimension")) {
      dim = readNonNegativeIntegerString(node2.getAttribute("dimension"));
    } else if (node2.parentNode.getAttribute("srsDimension")) {
      dim = readNonNegativeIntegerString(node2.parentNode.getAttribute("srsDimension"));
    } else if (contextDimension) {
      dim = readNonNegativeIntegerString(contextDimension);
    }
    let x2, y2, z2;
    const flatCoordinates = [];
    for (let i2 = 0, ii = coords.length; i2 < ii; i2 += dim) {
      x2 = parseFloat(coords[i2]);
      y2 = parseFloat(coords[i2 + 1]);
      z2 = dim === 3 ? parseFloat(coords[i2 + 2]) : 0;
      if (axisOrientation.substr(0, 2) === "en") {
        flatCoordinates.push(x2, y2, z2);
      } else {
        flatCoordinates.push(y2, x2, z2);
      }
    }
    return flatCoordinates;
  }
  writePos_(node2, value, objectStack) {
    const context2 = objectStack[objectStack.length - 1];
    const hasZ = context2["hasZ"];
    const srsDimension = hasZ ? "3" : "2";
    node2.setAttribute("srsDimension", srsDimension);
    const srsName = context2["srsName"];
    let axisOrientation = "enu";
    if (srsName) {
      axisOrientation = get$4(srsName).getAxisOrientation();
    }
    const point = value.getCoordinates();
    let coords;
    if (axisOrientation.substr(0, 2) === "en") {
      coords = point[0] + " " + point[1];
    } else {
      coords = point[1] + " " + point[0];
    }
    if (hasZ) {
      const z2 = point[2] || 0;
      coords += " " + z2;
    }
    writeStringTextNode(node2, coords);
  }
  getCoords_(point, srsName, hasZ) {
    let axisOrientation = "enu";
    if (srsName) {
      axisOrientation = get$4(srsName).getAxisOrientation();
    }
    let coords = axisOrientation.substr(0, 2) === "en" ? point[0] + " " + point[1] : point[1] + " " + point[0];
    if (hasZ) {
      const z2 = point[2] || 0;
      coords += " " + z2;
    }
    return coords;
  }
  writePosList_(node2, value, objectStack) {
    const context2 = objectStack[objectStack.length - 1];
    const hasZ = context2["hasZ"];
    const srsDimension = hasZ ? "3" : "2";
    node2.setAttribute("srsDimension", srsDimension);
    const srsName = context2["srsName"];
    const points = value.getCoordinates();
    const len = points.length;
    const parts = new Array(len);
    let point;
    for (let i2 = 0; i2 < len; ++i2) {
      point = points[i2];
      parts[i2] = this.getCoords_(point, srsName, hasZ);
    }
    writeStringTextNode(node2, parts.join(" "));
  }
  writePoint(node2, geometry, objectStack) {
    const context2 = objectStack[objectStack.length - 1];
    const srsName = context2["srsName"];
    if (srsName) {
      node2.setAttribute("srsName", srsName);
    }
    const pos = createElementNS(node2.namespaceURI, "pos");
    node2.appendChild(pos);
    this.writePos_(pos, geometry, objectStack);
  }
  writeEnvelope(node2, extent2, objectStack) {
    const context2 = objectStack[objectStack.length - 1];
    const srsName = context2["srsName"];
    if (srsName) {
      node2.setAttribute("srsName", srsName);
    }
    const keys3 = ["lowerCorner", "upperCorner"];
    const values3 = [extent2[0] + " " + extent2[1], extent2[2] + " " + extent2[3]];
    pushSerializeAndPop({ node: node2 }, this.ENVELOPE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values3, objectStack, keys3, this);
  }
  writeLinearRing(node2, geometry, objectStack) {
    const context2 = objectStack[objectStack.length - 1];
    const srsName = context2["srsName"];
    if (srsName) {
      node2.setAttribute("srsName", srsName);
    }
    const posList = createElementNS(node2.namespaceURI, "posList");
    node2.appendChild(posList);
    this.writePosList_(posList, geometry, objectStack);
  }
  RING_NODE_FACTORY_(value, objectStack, nodeName) {
    const context2 = objectStack[objectStack.length - 1];
    const parentNode = context2.node;
    const exteriorWritten = context2["exteriorWritten"];
    if (exteriorWritten === void 0) {
      context2["exteriorWritten"] = true;
    }
    return createElementNS(parentNode.namespaceURI, exteriorWritten !== void 0 ? "interior" : "exterior");
  }
  writeSurfaceOrPolygon(node2, geometry, objectStack) {
    const context2 = objectStack[objectStack.length - 1];
    const hasZ = context2["hasZ"];
    const srsName = context2["srsName"];
    if (node2.nodeName !== "PolygonPatch" && srsName) {
      node2.setAttribute("srsName", srsName);
    }
    if (node2.nodeName === "Polygon" || node2.nodeName === "PolygonPatch") {
      const rings = geometry.getLinearRings();
      pushSerializeAndPop({ node: node2, hasZ, srsName }, this.RING_SERIALIZERS, this.RING_NODE_FACTORY_, rings, objectStack, void 0, this);
    } else if (node2.nodeName === "Surface") {
      const patches = createElementNS(node2.namespaceURI, "patches");
      node2.appendChild(patches);
      this.writeSurfacePatches_(patches, geometry, objectStack);
    }
  }
  writeCurveOrLineString(node2, geometry, objectStack) {
    const context2 = objectStack[objectStack.length - 1];
    const srsName = context2["srsName"];
    if (node2.nodeName !== "LineStringSegment" && srsName) {
      node2.setAttribute("srsName", srsName);
    }
    if (node2.nodeName === "LineString" || node2.nodeName === "LineStringSegment") {
      const posList = createElementNS(node2.namespaceURI, "posList");
      node2.appendChild(posList);
      this.writePosList_(posList, geometry, objectStack);
    } else if (node2.nodeName === "Curve") {
      const segments = createElementNS(node2.namespaceURI, "segments");
      node2.appendChild(segments);
      this.writeCurveSegments_(segments, geometry, objectStack);
    }
  }
  writeMultiSurfaceOrPolygon(node2, geometry, objectStack) {
    const context2 = objectStack[objectStack.length - 1];
    const hasZ = context2["hasZ"];
    const srsName = context2["srsName"];
    const surface = context2["surface"];
    if (srsName) {
      node2.setAttribute("srsName", srsName);
    }
    const polygons = geometry.getPolygons();
    pushSerializeAndPop({ node: node2, hasZ, srsName, surface }, this.SURFACEORPOLYGONMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, polygons, objectStack, void 0, this);
  }
  writeMultiPoint(node2, geometry, objectStack) {
    const context2 = objectStack[objectStack.length - 1];
    const srsName = context2["srsName"];
    const hasZ = context2["hasZ"];
    if (srsName) {
      node2.setAttribute("srsName", srsName);
    }
    const points = geometry.getPoints();
    pushSerializeAndPop({ node: node2, hasZ, srsName }, this.POINTMEMBER_SERIALIZERS, makeSimpleNodeFactory("pointMember"), points, objectStack, void 0, this);
  }
  writeMultiCurveOrLineString(node2, geometry, objectStack) {
    const context2 = objectStack[objectStack.length - 1];
    const hasZ = context2["hasZ"];
    const srsName = context2["srsName"];
    const curve = context2["curve"];
    if (srsName) {
      node2.setAttribute("srsName", srsName);
    }
    const lines = geometry.getLineStrings();
    pushSerializeAndPop({ node: node2, hasZ, srsName, curve }, this.LINESTRINGORCURVEMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, lines, objectStack, void 0, this);
  }
  writeRing(node2, ring, objectStack) {
    const linearRing2 = createElementNS(node2.namespaceURI, "LinearRing");
    node2.appendChild(linearRing2);
    this.writeLinearRing(linearRing2, ring, objectStack);
  }
  writeSurfaceOrPolygonMember(node2, polygon, objectStack) {
    const child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);
    if (child) {
      node2.appendChild(child);
      this.writeSurfaceOrPolygon(child, polygon, objectStack);
    }
  }
  writePointMember(node2, point, objectStack) {
    const child = createElementNS(node2.namespaceURI, "Point");
    node2.appendChild(child);
    this.writePoint(child, point, objectStack);
  }
  writeLineStringOrCurveMember(node2, line, objectStack) {
    const child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);
    if (child) {
      node2.appendChild(child);
      this.writeCurveOrLineString(child, line, objectStack);
    }
  }
  writeSurfacePatches_(node2, polygon, objectStack) {
    const child = createElementNS(node2.namespaceURI, "PolygonPatch");
    node2.appendChild(child);
    this.writeSurfaceOrPolygon(child, polygon, objectStack);
  }
  writeCurveSegments_(node2, line, objectStack) {
    const child = createElementNS(node2.namespaceURI, "LineStringSegment");
    node2.appendChild(child);
    this.writeCurveOrLineString(child, line, objectStack);
  }
  writeGeometryElement(node2, geometry, objectStack) {
    const context2 = objectStack[objectStack.length - 1];
    const item = Object.assign({}, context2);
    item["node"] = node2;
    let value;
    if (Array.isArray(geometry)) {
      value = transformExtentWithOptions(geometry, context2);
    } else {
      value = transformGeometryWithOptions(geometry, true, context2);
    }
    pushSerializeAndPop(item, this.GEOMETRY_SERIALIZERS, this.GEOMETRY_NODE_FACTORY_, [value], objectStack, void 0, this);
  }
  writeFeatureElement(node2, feature, objectStack) {
    const fid = feature.getId();
    if (fid) {
      node2.setAttribute("fid", fid);
    }
    const context2 = objectStack[objectStack.length - 1];
    const featureNS = context2["featureNS"];
    const geometryName = feature.getGeometryName();
    if (!context2.serializers) {
      context2.serializers = {};
      context2.serializers[featureNS] = {};
    }
    const keys3 = [];
    const values3 = [];
    if (feature.hasProperties()) {
      const properties = feature.getProperties();
      for (const key in properties) {
        const value = properties[key];
        if (value !== null) {
          keys3.push(key);
          values3.push(value);
          if (key == geometryName || typeof value.getSimplifiedGeometry === "function") {
            if (!(key in context2.serializers[featureNS])) {
              context2.serializers[featureNS][key] = makeChildAppender(this.writeGeometryElement, this);
            }
          } else {
            if (!(key in context2.serializers[featureNS])) {
              context2.serializers[featureNS][key] = makeChildAppender(writeStringTextNode);
            }
          }
        }
      }
    }
    const item = Object.assign({}, context2);
    item.node = node2;
    pushSerializeAndPop(item, context2.serializers, makeSimpleNodeFactory(void 0, featureNS), values3, objectStack, keys3);
  }
  writeFeatureMembers_(node2, features, objectStack) {
    const context2 = objectStack[objectStack.length - 1];
    const featureType = context2["featureType"];
    const featureNS = context2["featureNS"];
    const serializers = {};
    serializers[featureNS] = {};
    serializers[featureNS][featureType] = makeChildAppender(this.writeFeatureElement, this);
    const item = Object.assign({}, context2);
    item.node = node2;
    pushSerializeAndPop(item, serializers, makeSimpleNodeFactory(featureType, featureNS), features, objectStack);
  }
  MULTIGEOMETRY_MEMBER_NODE_FACTORY_(value, objectStack, nodeName) {
    const parentNode = objectStack[objectStack.length - 1].node;
    return createElementNS(this.namespace, MULTIGEOMETRY_TO_MEMBER_NODENAME[parentNode.nodeName]);
  }
  GEOMETRY_NODE_FACTORY_(value, objectStack, nodeName) {
    const context2 = objectStack[objectStack.length - 1];
    const multiSurface = context2["multiSurface"];
    const surface = context2["surface"];
    const curve = context2["curve"];
    const multiCurve = context2["multiCurve"];
    if (!Array.isArray(value)) {
      nodeName = value.getType();
      if (nodeName === "MultiPolygon" && multiSurface === true) {
        nodeName = "MultiSurface";
      } else if (nodeName === "Polygon" && surface === true) {
        nodeName = "Surface";
      } else if (nodeName === "LineString" && curve === true) {
        nodeName = "Curve";
      } else if (nodeName === "MultiLineString" && multiCurve === true) {
        nodeName = "MultiCurve";
      }
    } else {
      nodeName = "Envelope";
    }
    return createElementNS(this.namespace, nodeName);
  }
  writeGeometryNode(geometry, options) {
    options = this.adaptOptions(options);
    const geom2 = createElementNS(this.namespace, "geom");
    const context2 = {
      node: geom2,
      hasZ: this.hasZ,
      srsName: this.srsName,
      curve: this.curve_,
      surface: this.surface_,
      multiSurface: this.multiSurface_,
      multiCurve: this.multiCurve_
    };
    if (options) {
      Object.assign(context2, options);
    }
    this.writeGeometryElement(geom2, geometry, [context2]);
    return geom2;
  }
  writeFeaturesNode(features, options) {
    options = this.adaptOptions(options);
    const node2 = createElementNS(this.namespace, "featureMembers");
    node2.setAttributeNS(XML_SCHEMA_INSTANCE_URI, "xsi:schemaLocation", this.schemaLocation);
    const context2 = {
      srsName: this.srsName,
      hasZ: this.hasZ,
      curve: this.curve_,
      surface: this.surface_,
      multiSurface: this.multiSurface_,
      multiCurve: this.multiCurve_,
      featureNS: this.featureNS,
      featureType: this.featureType
    };
    if (options) {
      Object.assign(context2, options);
    }
    this.writeFeatureMembers_(node2, features, [context2]);
    return node2;
  }
}
GML3.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  "http://www.opengis.net/gml": {
    "pos": makeReplacer(GML3.prototype.readFlatPos),
    "posList": makeReplacer(GML3.prototype.readFlatPosList),
    "coordinates": makeReplacer(GML2.prototype.readFlatCoordinates)
  }
};
GML3.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  "http://www.opengis.net/gml": {
    "interior": GML3.prototype.interiorParser,
    "exterior": GML3.prototype.exteriorParser
  }
};
GML3.prototype.GEOMETRY_PARSERS = {
  "http://www.opengis.net/gml": {
    "Point": makeReplacer(GMLBase.prototype.readPoint),
    "MultiPoint": makeReplacer(GMLBase.prototype.readMultiPoint),
    "LineString": makeReplacer(GMLBase.prototype.readLineString),
    "MultiLineString": makeReplacer(GMLBase.prototype.readMultiLineString),
    "LinearRing": makeReplacer(GMLBase.prototype.readLinearRing),
    "Polygon": makeReplacer(GMLBase.prototype.readPolygon),
    "MultiPolygon": makeReplacer(GMLBase.prototype.readMultiPolygon),
    "Surface": makeReplacer(GML3.prototype.readSurface),
    "MultiSurface": makeReplacer(GML3.prototype.readMultiSurface),
    "Curve": makeReplacer(GML3.prototype.readCurve),
    "MultiCurve": makeReplacer(GML3.prototype.readMultiCurve),
    "Envelope": makeReplacer(GML3.prototype.readEnvelope)
  }
};
GML3.prototype.MULTICURVE_PARSERS = {
  "http://www.opengis.net/gml": {
    "curveMember": makeArrayPusher(GML3.prototype.curveMemberParser),
    "curveMembers": makeArrayPusher(GML3.prototype.curveMemberParser)
  }
};
GML3.prototype.MULTISURFACE_PARSERS = {
  "http://www.opengis.net/gml": {
    "surfaceMember": makeArrayPusher(GML3.prototype.surfaceMemberParser),
    "surfaceMembers": makeArrayPusher(GML3.prototype.surfaceMemberParser)
  }
};
GML3.prototype.CURVEMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    "LineString": makeArrayPusher(GMLBase.prototype.readLineString),
    "Curve": makeArrayPusher(GML3.prototype.readCurve)
  }
};
GML3.prototype.SURFACEMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    "Polygon": makeArrayPusher(GMLBase.prototype.readPolygon),
    "Surface": makeArrayPusher(GML3.prototype.readSurface)
  }
};
GML3.prototype.SURFACE_PARSERS = {
  "http://www.opengis.net/gml": {
    "patches": makeReplacer(GML3.prototype.readPatch)
  }
};
GML3.prototype.CURVE_PARSERS = {
  "http://www.opengis.net/gml": {
    "segments": makeReplacer(GML3.prototype.readSegment)
  }
};
GML3.prototype.ENVELOPE_PARSERS = {
  "http://www.opengis.net/gml": {
    "lowerCorner": makeArrayPusher(GML3.prototype.readFlatPosList),
    "upperCorner": makeArrayPusher(GML3.prototype.readFlatPosList)
  }
};
GML3.prototype.PATCHES_PARSERS = {
  "http://www.opengis.net/gml": {
    "PolygonPatch": makeReplacer(GML3.prototype.readPolygonPatch)
  }
};
GML3.prototype.SEGMENTS_PARSERS = {
  "http://www.opengis.net/gml": {
    "LineStringSegment": makeArrayExtender(GML3.prototype.readLineStringSegment)
  }
};
GMLBase.prototype.RING_PARSERS = {
  "http://www.opengis.net/gml": {
    "LinearRing": makeReplacer(GMLBase.prototype.readFlatLinearRing),
    "Ring": makeReplacer(GML3.prototype.readFlatCurveRing)
  }
};
GML3.prototype.writeFeatures;
GML3.prototype.RING_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "exterior": makeChildAppender(GML3.prototype.writeRing),
    "interior": makeChildAppender(GML3.prototype.writeRing)
  }
};
GML3.prototype.ENVELOPE_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "lowerCorner": makeChildAppender(writeStringTextNode),
    "upperCorner": makeChildAppender(writeStringTextNode)
  }
};
GML3.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "surfaceMember": makeChildAppender(GML3.prototype.writeSurfaceOrPolygonMember),
    "polygonMember": makeChildAppender(GML3.prototype.writeSurfaceOrPolygonMember)
  }
};
GML3.prototype.POINTMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "pointMember": makeChildAppender(GML3.prototype.writePointMember)
  }
};
GML3.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "lineStringMember": makeChildAppender(GML3.prototype.writeLineStringOrCurveMember),
    "curveMember": makeChildAppender(GML3.prototype.writeLineStringOrCurveMember)
  }
};
GML3.prototype.GEOMETRY_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "Curve": makeChildAppender(GML3.prototype.writeCurveOrLineString),
    "MultiCurve": makeChildAppender(GML3.prototype.writeMultiCurveOrLineString),
    "Point": makeChildAppender(GML3.prototype.writePoint),
    "MultiPoint": makeChildAppender(GML3.prototype.writeMultiPoint),
    "LineString": makeChildAppender(GML3.prototype.writeCurveOrLineString),
    "MultiLineString": makeChildAppender(GML3.prototype.writeMultiCurveOrLineString),
    "LinearRing": makeChildAppender(GML3.prototype.writeLinearRing),
    "Polygon": makeChildAppender(GML3.prototype.writeSurfaceOrPolygon),
    "MultiPolygon": makeChildAppender(GML3.prototype.writeMultiSurfaceOrPolygon),
    "Surface": makeChildAppender(GML3.prototype.writeSurfaceOrPolygon),
    "MultiSurface": makeChildAppender(GML3.prototype.writeMultiSurfaceOrPolygon),
    "Envelope": makeChildAppender(GML3.prototype.writeEnvelope)
  }
};
const GML = GML3;
GML.prototype.writeFeatures;
GML.prototype.writeFeaturesNode;
const NAMESPACE_URIS$4 = [
  null,
  "http://www.topografix.com/GPX/1/0",
  "http://www.topografix.com/GPX/1/1"
];
const SCHEMA_LOCATION$1 = "http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd";
const FEATURE_READER = {
  "rte": readRte,
  "trk": readTrk,
  "wpt": readWpt
};
const GPX_PARSERS = makeStructureNS(NAMESPACE_URIS$4, {
  "rte": makeArrayPusher(readRte),
  "trk": makeArrayPusher(readTrk),
  "wpt": makeArrayPusher(readWpt)
});
const LINK_PARSERS$1 = makeStructureNS(NAMESPACE_URIS$4, {
  "text": makeObjectPropertySetter(readString, "linkText"),
  "type": makeObjectPropertySetter(readString, "linkType")
});
const GPX_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$4, {
  "rte": makeChildAppender(writeRte),
  "trk": makeChildAppender(writeTrk),
  "wpt": makeChildAppender(writeWpt)
});
class GPX extends XMLFeature {
  constructor(options) {
    super();
    options = options ? options : {};
    this.dataProjection = get$4("EPSG:4326");
    this.readExtensions_ = options.readExtensions;
  }
  handleReadExtensions_(features) {
    if (!features) {
      features = [];
    }
    for (let i2 = 0, ii = features.length; i2 < ii; ++i2) {
      const feature = features[i2];
      if (this.readExtensions_) {
        const extensionsNode = feature.get("extensionsNode_") || null;
        this.readExtensions_(feature, extensionsNode);
      }
      feature.set("extensionsNode_", void 0);
    }
  }
  readFeatureFromNode(node2, options) {
    if (!NAMESPACE_URIS$4.includes(node2.namespaceURI)) {
      return null;
    }
    const featureReader = FEATURE_READER[node2.localName];
    if (!featureReader) {
      return null;
    }
    const feature = featureReader(node2, [this.getReadOptions(node2, options)]);
    if (!feature) {
      return null;
    }
    this.handleReadExtensions_([feature]);
    return feature;
  }
  readFeaturesFromNode(node2, options) {
    if (!NAMESPACE_URIS$4.includes(node2.namespaceURI)) {
      return [];
    }
    if (node2.localName == "gpx") {
      const features = pushParseAndPop([], GPX_PARSERS, node2, [
        this.getReadOptions(node2, options)
      ]);
      if (features) {
        this.handleReadExtensions_(features);
        return features;
      }
      return [];
    }
    return [];
  }
  writeFeaturesNode(features, options) {
    options = this.adaptOptions(options);
    const gpx = createElementNS("http://www.topografix.com/GPX/1/1", "gpx");
    const xmlnsUri = "http://www.w3.org/2000/xmlns/";
    gpx.setAttributeNS(xmlnsUri, "xmlns:xsi", XML_SCHEMA_INSTANCE_URI);
    gpx.setAttributeNS(XML_SCHEMA_INSTANCE_URI, "xsi:schemaLocation", SCHEMA_LOCATION$1);
    gpx.setAttribute("version", "1.1");
    gpx.setAttribute("creator", "OpenLayers");
    pushSerializeAndPop({ node: gpx }, GPX_SERIALIZERS, GPX_NODE_FACTORY, features, [options]);
    return gpx;
  }
}
const RTE_PARSERS = makeStructureNS(NAMESPACE_URIS$4, {
  "name": makeObjectPropertySetter(readString),
  "cmt": makeObjectPropertySetter(readString),
  "desc": makeObjectPropertySetter(readString),
  "src": makeObjectPropertySetter(readString),
  "link": parseLink,
  "number": makeObjectPropertySetter(readPositiveInteger),
  "extensions": parseExtensions,
  "type": makeObjectPropertySetter(readString),
  "rtept": parseRtePt
});
const RTEPT_PARSERS = makeStructureNS(NAMESPACE_URIS$4, {
  "ele": makeObjectPropertySetter(readDecimal),
  "time": makeObjectPropertySetter(readDateTime)
});
const TRK_PARSERS = makeStructureNS(NAMESPACE_URIS$4, {
  "name": makeObjectPropertySetter(readString),
  "cmt": makeObjectPropertySetter(readString),
  "desc": makeObjectPropertySetter(readString),
  "src": makeObjectPropertySetter(readString),
  "link": parseLink,
  "number": makeObjectPropertySetter(readPositiveInteger),
  "type": makeObjectPropertySetter(readString),
  "extensions": parseExtensions,
  "trkseg": parseTrkSeg
});
const TRKSEG_PARSERS = makeStructureNS(NAMESPACE_URIS$4, {
  "trkpt": parseTrkPt
});
const TRKPT_PARSERS = makeStructureNS(NAMESPACE_URIS$4, {
  "ele": makeObjectPropertySetter(readDecimal),
  "time": makeObjectPropertySetter(readDateTime)
});
const WPT_PARSERS = makeStructureNS(NAMESPACE_URIS$4, {
  "ele": makeObjectPropertySetter(readDecimal),
  "time": makeObjectPropertySetter(readDateTime),
  "magvar": makeObjectPropertySetter(readDecimal),
  "geoidheight": makeObjectPropertySetter(readDecimal),
  "name": makeObjectPropertySetter(readString),
  "cmt": makeObjectPropertySetter(readString),
  "desc": makeObjectPropertySetter(readString),
  "src": makeObjectPropertySetter(readString),
  "link": parseLink,
  "sym": makeObjectPropertySetter(readString),
  "type": makeObjectPropertySetter(readString),
  "fix": makeObjectPropertySetter(readString),
  "sat": makeObjectPropertySetter(readPositiveInteger),
  "hdop": makeObjectPropertySetter(readDecimal),
  "vdop": makeObjectPropertySetter(readDecimal),
  "pdop": makeObjectPropertySetter(readDecimal),
  "ageofdgpsdata": makeObjectPropertySetter(readDecimal),
  "dgpsid": makeObjectPropertySetter(readPositiveInteger),
  "extensions": parseExtensions
});
const LINK_SEQUENCE = ["text", "type"];
const LINK_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$4, {
  "text": makeChildAppender(writeStringTextNode),
  "type": makeChildAppender(writeStringTextNode)
});
const RTE_SEQUENCE = makeStructureNS(NAMESPACE_URIS$4, [
  "name",
  "cmt",
  "desc",
  "src",
  "link",
  "number",
  "type",
  "rtept"
]);
const RTE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$4, {
  "name": makeChildAppender(writeStringTextNode),
  "cmt": makeChildAppender(writeStringTextNode),
  "desc": makeChildAppender(writeStringTextNode),
  "src": makeChildAppender(writeStringTextNode),
  "link": makeChildAppender(writeLink),
  "number": makeChildAppender(writeNonNegativeIntegerTextNode),
  "type": makeChildAppender(writeStringTextNode),
  "rtept": makeArraySerializer(makeChildAppender(writeWptType))
});
const RTEPT_TYPE_SEQUENCE = makeStructureNS(NAMESPACE_URIS$4, ["ele", "time"]);
const TRK_SEQUENCE = makeStructureNS(NAMESPACE_URIS$4, [
  "name",
  "cmt",
  "desc",
  "src",
  "link",
  "number",
  "type",
  "trkseg"
]);
const TRK_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$4, {
  "name": makeChildAppender(writeStringTextNode),
  "cmt": makeChildAppender(writeStringTextNode),
  "desc": makeChildAppender(writeStringTextNode),
  "src": makeChildAppender(writeStringTextNode),
  "link": makeChildAppender(writeLink),
  "number": makeChildAppender(writeNonNegativeIntegerTextNode),
  "type": makeChildAppender(writeStringTextNode),
  "trkseg": makeArraySerializer(makeChildAppender(writeTrkSeg))
});
const TRKSEG_NODE_FACTORY = makeSimpleNodeFactory("trkpt");
const TRKSEG_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$4, {
  "trkpt": makeChildAppender(writeWptType)
});
const WPT_TYPE_SEQUENCE = makeStructureNS(NAMESPACE_URIS$4, [
  "ele",
  "time",
  "magvar",
  "geoidheight",
  "name",
  "cmt",
  "desc",
  "src",
  "link",
  "sym",
  "type",
  "fix",
  "sat",
  "hdop",
  "vdop",
  "pdop",
  "ageofdgpsdata",
  "dgpsid"
]);
const WPT_TYPE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$4, {
  "ele": makeChildAppender(writeDecimalTextNode),
  "time": makeChildAppender(writeDateTimeTextNode),
  "magvar": makeChildAppender(writeDecimalTextNode),
  "geoidheight": makeChildAppender(writeDecimalTextNode),
  "name": makeChildAppender(writeStringTextNode),
  "cmt": makeChildAppender(writeStringTextNode),
  "desc": makeChildAppender(writeStringTextNode),
  "src": makeChildAppender(writeStringTextNode),
  "link": makeChildAppender(writeLink),
  "sym": makeChildAppender(writeStringTextNode),
  "type": makeChildAppender(writeStringTextNode),
  "fix": makeChildAppender(writeStringTextNode),
  "sat": makeChildAppender(writeNonNegativeIntegerTextNode),
  "hdop": makeChildAppender(writeDecimalTextNode),
  "vdop": makeChildAppender(writeDecimalTextNode),
  "pdop": makeChildAppender(writeDecimalTextNode),
  "ageofdgpsdata": makeChildAppender(writeDecimalTextNode),
  "dgpsid": makeChildAppender(writeNonNegativeIntegerTextNode)
});
const GEOMETRY_TYPE_TO_NODENAME$1 = {
  "Point": "wpt",
  "LineString": "rte",
  "MultiLineString": "trk"
};
function GPX_NODE_FACTORY(value, objectStack, nodeName) {
  const geometry = value.getGeometry();
  if (geometry) {
    const nodeName2 = GEOMETRY_TYPE_TO_NODENAME$1[geometry.getType()];
    if (nodeName2) {
      const parentNode = objectStack[objectStack.length - 1].node;
      return createElementNS(parentNode.namespaceURI, nodeName2);
    }
  }
}
function appendCoordinate(flatCoordinates, layoutOptions, node2, values3) {
  flatCoordinates.push(parseFloat(node2.getAttribute("lon")), parseFloat(node2.getAttribute("lat")));
  if ("ele" in values3) {
    flatCoordinates.push(values3["ele"]);
    delete values3["ele"];
    layoutOptions.hasZ = true;
  } else {
    flatCoordinates.push(0);
  }
  if ("time" in values3) {
    flatCoordinates.push(values3["time"]);
    delete values3["time"];
    layoutOptions.hasM = true;
  } else {
    flatCoordinates.push(0);
  }
  return flatCoordinates;
}
function applyLayoutOptions(layoutOptions, flatCoordinates, ends) {
  let layout = "XY";
  let stride = 2;
  if (layoutOptions.hasZ && layoutOptions.hasM) {
    layout = "XYZM";
    stride = 4;
  } else if (layoutOptions.hasZ) {
    layout = "XYZ";
    stride = 3;
  } else if (layoutOptions.hasM) {
    layout = "XYM";
    stride = 3;
  }
  if (stride !== 4) {
    for (let i2 = 0, ii = flatCoordinates.length / 4; i2 < ii; i2++) {
      flatCoordinates[i2 * stride] = flatCoordinates[i2 * 4];
      flatCoordinates[i2 * stride + 1] = flatCoordinates[i2 * 4 + 1];
      if (layoutOptions.hasZ) {
        flatCoordinates[i2 * stride + 2] = flatCoordinates[i2 * 4 + 2];
      }
      if (layoutOptions.hasM) {
        flatCoordinates[i2 * stride + 2] = flatCoordinates[i2 * 4 + 3];
      }
    }
    flatCoordinates.length = flatCoordinates.length / 4 * stride;
    if (ends) {
      for (let i2 = 0, ii = ends.length; i2 < ii; i2++) {
        ends[i2] = ends[i2] / 4 * stride;
      }
    }
  }
  return layout;
}
function parseLink(node2, objectStack) {
  const values3 = objectStack[objectStack.length - 1];
  const href = node2.getAttribute("href");
  if (href !== null) {
    values3["link"] = href;
  }
  parseNode(LINK_PARSERS$1, node2, objectStack);
}
function parseExtensions(node2, objectStack) {
  const values3 = objectStack[objectStack.length - 1];
  values3["extensionsNode_"] = node2;
}
function parseRtePt(node2, objectStack) {
  const values3 = pushParseAndPop({}, RTEPT_PARSERS, node2, objectStack);
  if (values3) {
    const rteValues = objectStack[objectStack.length - 1];
    const flatCoordinates = rteValues["flatCoordinates"];
    const layoutOptions = rteValues["layoutOptions"];
    appendCoordinate(flatCoordinates, layoutOptions, node2, values3);
  }
}
function parseTrkPt(node2, objectStack) {
  const values3 = pushParseAndPop({}, TRKPT_PARSERS, node2, objectStack);
  if (values3) {
    const trkValues = objectStack[objectStack.length - 1];
    const flatCoordinates = trkValues["flatCoordinates"];
    const layoutOptions = trkValues["layoutOptions"];
    appendCoordinate(flatCoordinates, layoutOptions, node2, values3);
  }
}
function parseTrkSeg(node2, objectStack) {
  const values3 = objectStack[objectStack.length - 1];
  parseNode(TRKSEG_PARSERS, node2, objectStack);
  const flatCoordinates = values3["flatCoordinates"];
  const ends = values3["ends"];
  ends.push(flatCoordinates.length);
}
function readRte(node2, objectStack) {
  const options = objectStack[0];
  const values3 = pushParseAndPop({
    "flatCoordinates": [],
    "layoutOptions": {}
  }, RTE_PARSERS, node2, objectStack);
  if (!values3) {
    return void 0;
  }
  const flatCoordinates = values3["flatCoordinates"];
  delete values3["flatCoordinates"];
  const layoutOptions = values3["layoutOptions"];
  delete values3["layoutOptions"];
  const layout = applyLayoutOptions(layoutOptions, flatCoordinates);
  const geometry = new LineString$1(flatCoordinates, layout);
  transformGeometryWithOptions(geometry, false, options);
  const feature = new Feature$1(geometry);
  feature.setProperties(values3, true);
  return feature;
}
function readTrk(node2, objectStack) {
  const options = objectStack[0];
  const values3 = pushParseAndPop({
    "flatCoordinates": [],
    "ends": [],
    "layoutOptions": {}
  }, TRK_PARSERS, node2, objectStack);
  if (!values3) {
    return void 0;
  }
  const flatCoordinates = values3["flatCoordinates"];
  delete values3["flatCoordinates"];
  const ends = values3["ends"];
  delete values3["ends"];
  const layoutOptions = values3["layoutOptions"];
  delete values3["layoutOptions"];
  const layout = applyLayoutOptions(layoutOptions, flatCoordinates, ends);
  const geometry = new MultiLineString$1(flatCoordinates, layout, ends);
  transformGeometryWithOptions(geometry, false, options);
  const feature = new Feature$1(geometry);
  feature.setProperties(values3, true);
  return feature;
}
function readWpt(node2, objectStack) {
  const options = objectStack[0];
  const values3 = pushParseAndPop({}, WPT_PARSERS, node2, objectStack);
  if (!values3) {
    return void 0;
  }
  const layoutOptions = {};
  const coordinates2 = appendCoordinate([], layoutOptions, node2, values3);
  const layout = applyLayoutOptions(layoutOptions, coordinates2);
  const geometry = new Point$3(coordinates2, layout);
  transformGeometryWithOptions(geometry, false, options);
  const feature = new Feature$1(geometry);
  feature.setProperties(values3, true);
  return feature;
}
function writeLink(node2, value, objectStack) {
  node2.setAttribute("href", value);
  const context2 = objectStack[objectStack.length - 1];
  const properties = context2["properties"];
  const link = [properties["linkText"], properties["linkType"]];
  pushSerializeAndPop({ node: node2 }, LINK_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, link, objectStack, LINK_SEQUENCE);
}
function writeWptType(node2, coordinate, objectStack) {
  const context2 = objectStack[objectStack.length - 1];
  const parentNode = context2.node;
  const namespaceURI = parentNode.namespaceURI;
  const properties = context2["properties"];
  node2.setAttributeNS(null, "lat", String(coordinate[1]));
  node2.setAttributeNS(null, "lon", String(coordinate[0]));
  const geometryLayout = context2["geometryLayout"];
  switch (geometryLayout) {
    case "XYZM":
      if (coordinate[3] !== 0) {
        properties["time"] = coordinate[3];
      }
    case "XYZ":
      if (coordinate[2] !== 0) {
        properties["ele"] = coordinate[2];
      }
      break;
    case "XYM":
      if (coordinate[2] !== 0) {
        properties["time"] = coordinate[2];
      }
      break;
  }
  const orderedKeys = node2.nodeName == "rtept" ? RTEPT_TYPE_SEQUENCE[namespaceURI] : WPT_TYPE_SEQUENCE[namespaceURI];
  const values3 = makeSequence(properties, orderedKeys);
  pushSerializeAndPop({ node: node2, "properties": properties }, WPT_TYPE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values3, objectStack, orderedKeys);
}
function writeRte(node2, feature, objectStack) {
  const options = objectStack[0];
  const properties = feature.getProperties();
  const context2 = { node: node2 };
  context2["properties"] = properties;
  const geometry = feature.getGeometry();
  if (geometry.getType() == "LineString") {
    const lineString = transformGeometryWithOptions(geometry, true, options);
    context2["geometryLayout"] = lineString.getLayout();
    properties["rtept"] = lineString.getCoordinates();
  }
  const parentNode = objectStack[objectStack.length - 1].node;
  const orderedKeys = RTE_SEQUENCE[parentNode.namespaceURI];
  const values3 = makeSequence(properties, orderedKeys);
  pushSerializeAndPop(context2, RTE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values3, objectStack, orderedKeys);
}
function writeTrk(node2, feature, objectStack) {
  const options = objectStack[0];
  const properties = feature.getProperties();
  const context2 = { node: node2 };
  context2["properties"] = properties;
  const geometry = feature.getGeometry();
  if (geometry.getType() == "MultiLineString") {
    const multiLineString = transformGeometryWithOptions(geometry, true, options);
    properties["trkseg"] = multiLineString.getLineStrings();
  }
  const parentNode = objectStack[objectStack.length - 1].node;
  const orderedKeys = TRK_SEQUENCE[parentNode.namespaceURI];
  const values3 = makeSequence(properties, orderedKeys);
  pushSerializeAndPop(context2, TRK_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values3, objectStack, orderedKeys);
}
function writeTrkSeg(node2, lineString, objectStack) {
  const context2 = { node: node2 };
  context2["geometryLayout"] = lineString.getLayout();
  context2["properties"] = {};
  pushSerializeAndPop(context2, TRKSEG_SERIALIZERS, TRKSEG_NODE_FACTORY, lineString.getCoordinates(), objectStack);
}
function writeWpt(node2, feature, objectStack) {
  const options = objectStack[0];
  const context2 = objectStack[objectStack.length - 1];
  context2["properties"] = feature.getProperties();
  const geometry = feature.getGeometry();
  if (geometry.getType() == "Point") {
    const point = transformGeometryWithOptions(geometry, true, options);
    context2["geometryLayout"] = point.getLayout();
    writeWptType(node2, point.getCoordinates(), objectStack);
  }
}
class TextFeature extends FeatureFormat {
  constructor() {
    super();
  }
  getType() {
    return "text";
  }
  readFeature(source, options) {
    return this.readFeatureFromText(getText(source), this.adaptOptions(options));
  }
  readFeatureFromText(text2, options) {
    return abstract();
  }
  readFeatures(source, options) {
    return this.readFeaturesFromText(getText(source), this.adaptOptions(options));
  }
  readFeaturesFromText(text2, options) {
    return abstract();
  }
  readGeometry(source, options) {
    return this.readGeometryFromText(getText(source), this.adaptOptions(options));
  }
  readGeometryFromText(text2, options) {
    return abstract();
  }
  readProjection(source) {
    return this.readProjectionFromText(getText(source));
  }
  readProjectionFromText(text2) {
    return this.dataProjection;
  }
  writeFeature(feature, options) {
    return this.writeFeatureText(feature, this.adaptOptions(options));
  }
  writeFeatureText(feature, options) {
    return abstract();
  }
  writeFeatures(features, options) {
    return this.writeFeaturesText(features, this.adaptOptions(options));
  }
  writeFeaturesText(features, options) {
    return abstract();
  }
  writeGeometry(geometry, options) {
    return this.writeGeometryText(geometry, this.adaptOptions(options));
  }
  writeGeometryText(geometry, options) {
    return abstract();
  }
}
function getText(source) {
  if (typeof source === "string") {
    return source;
  }
  return "";
}
const B_RECORD_RE = /^B(\d{2})(\d{2})(\d{2})(\d{2})(\d{5})([NS])(\d{3})(\d{5})([EW])([AV])(\d{5})(\d{5})/;
const H_RECORD_RE = /^H.([A-Z]{3}).*?:(.*)/;
const HFDTE_RECORD_RE = /^HFDTE(\d{2})(\d{2})(\d{2})/;
const NEWLINE_RE = /\r\n|\r|\n/;
class IGC extends TextFeature {
  constructor(options) {
    super();
    options = options ? options : {};
    this.dataProjection = get$4("EPSG:4326");
    this.altitudeMode_ = options.altitudeMode ? options.altitudeMode : "none";
  }
  readFeatureFromText(text2, options) {
    const altitudeMode = this.altitudeMode_;
    const lines = text2.split(NEWLINE_RE);
    const properties = {};
    const flatCoordinates = [];
    let year = 2e3;
    let month = 0;
    let day = 1;
    let lastDateTime = -1;
    let i2, ii;
    for (i2 = 0, ii = lines.length; i2 < ii; ++i2) {
      const line = lines[i2];
      let m2;
      if (line.charAt(0) == "B") {
        m2 = B_RECORD_RE.exec(line);
        if (m2) {
          const hour = parseInt(m2[1], 10);
          const minute = parseInt(m2[2], 10);
          const second = parseInt(m2[3], 10);
          let y2 = parseInt(m2[4], 10) + parseInt(m2[5], 10) / 6e4;
          if (m2[6] == "S") {
            y2 = -y2;
          }
          let x2 = parseInt(m2[7], 10) + parseInt(m2[8], 10) / 6e4;
          if (m2[9] == "W") {
            x2 = -x2;
          }
          flatCoordinates.push(x2, y2);
          if (altitudeMode != "none") {
            let z2;
            if (altitudeMode == "gps") {
              z2 = parseInt(m2[11], 10);
            } else if (altitudeMode == "barometric") {
              z2 = parseInt(m2[12], 10);
            } else {
              z2 = 0;
            }
            flatCoordinates.push(z2);
          }
          let dateTime = Date.UTC(year, month, day, hour, minute, second);
          if (dateTime < lastDateTime) {
            dateTime = Date.UTC(year, month, day + 1, hour, minute, second);
          }
          flatCoordinates.push(dateTime / 1e3);
          lastDateTime = dateTime;
        }
      } else if (line.charAt(0) == "H") {
        m2 = HFDTE_RECORD_RE.exec(line);
        if (m2) {
          day = parseInt(m2[1], 10);
          month = parseInt(m2[2], 10) - 1;
          year = 2e3 + parseInt(m2[3], 10);
        } else {
          m2 = H_RECORD_RE.exec(line);
          if (m2) {
            properties[m2[1]] = m2[2].trim();
          }
        }
      }
    }
    if (flatCoordinates.length === 0) {
      return null;
    }
    const layout = altitudeMode == "none" ? "XYM" : "XYZM";
    const lineString = new LineString$1(flatCoordinates, layout);
    const feature = new Feature$1(transformGeometryWithOptions(lineString, false, options));
    feature.setProperties(properties, true);
    return feature;
  }
  readFeaturesFromText(text2, options) {
    const feature = this.readFeatureFromText(text2, options);
    if (feature) {
      return [feature];
    }
    return [];
  }
}
const GX_NAMESPACE_URIS = ["http://www.google.com/kml/ext/2.2"];
const NAMESPACE_URIS$3 = [
  null,
  "http://earth.google.com/kml/2.0",
  "http://earth.google.com/kml/2.1",
  "http://earth.google.com/kml/2.2",
  "http://www.opengis.net/kml/2.2"
];
const SCHEMA_LOCATION = "http://www.opengis.net/kml/2.2 https://developers.google.com/kml/schema/kml22gx.xsd";
const ICON_ANCHOR_UNITS_MAP = {
  "fraction": "fraction",
  "pixels": "pixels",
  "insetPixels": "pixels"
};
const PLACEMARK_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "ExtendedData": extendedDataParser,
  "Region": regionParser,
  "MultiGeometry": makeObjectPropertySetter(readMultiGeometry, "geometry"),
  "LineString": makeObjectPropertySetter(readLineString, "geometry"),
  "LinearRing": makeObjectPropertySetter(readLinearRing, "geometry"),
  "Point": makeObjectPropertySetter(readPoint, "geometry"),
  "Polygon": makeObjectPropertySetter(readPolygon, "geometry"),
  "Style": makeObjectPropertySetter(readStyle$2),
  "StyleMap": placemarkStyleMapParser,
  "address": makeObjectPropertySetter(readString),
  "description": makeObjectPropertySetter(readString),
  "name": makeObjectPropertySetter(readString),
  "open": makeObjectPropertySetter(readBoolean),
  "phoneNumber": makeObjectPropertySetter(readString),
  "styleUrl": makeObjectPropertySetter(readStyleURL),
  "visibility": makeObjectPropertySetter(readBoolean)
}, makeStructureNS(GX_NAMESPACE_URIS, {
  "MultiTrack": makeObjectPropertySetter(readGxMultiTrack, "geometry"),
  "Track": makeObjectPropertySetter(readGxTrack, "geometry")
}));
const NETWORK_LINK_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "ExtendedData": extendedDataParser,
  "Region": regionParser,
  "Link": linkParser,
  "address": makeObjectPropertySetter(readString),
  "description": makeObjectPropertySetter(readString),
  "name": makeObjectPropertySetter(readString),
  "open": makeObjectPropertySetter(readBoolean),
  "phoneNumber": makeObjectPropertySetter(readString),
  "visibility": makeObjectPropertySetter(readBoolean)
});
const LINK_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "href": makeObjectPropertySetter(readURI)
});
const REGION_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "LatLonAltBox": latLonAltBoxParser,
  "Lod": lodParser
});
const KML_SEQUENCE = makeStructureNS(NAMESPACE_URIS$3, ["Document", "Placemark"]);
const KML_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {
  "Document": makeChildAppender(writeDocument),
  "Placemark": makeChildAppender(writePlacemark)
});
let DEFAULT_COLOR;
let DEFAULT_FILL_STYLE = null;
let DEFAULT_IMAGE_STYLE_ANCHOR;
let DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;
let DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;
let DEFAULT_IMAGE_STYLE_SIZE;
let DEFAULT_IMAGE_STYLE_SRC;
let DEFAULT_IMAGE_STYLE = null;
let DEFAULT_NO_IMAGE_STYLE;
let DEFAULT_STROKE_STYLE = null;
let DEFAULT_TEXT_STROKE_STYLE;
let DEFAULT_TEXT_STYLE = null;
let DEFAULT_STYLE = null;
let DEFAULT_STYLE_ARRAY = null;
function scaleForSize(size) {
  return 32 / Math.min(size[0], size[1]);
}
function createStyleDefaults() {
  DEFAULT_COLOR = [255, 255, 255, 1];
  DEFAULT_FILL_STYLE = new Fill$1({
    color: DEFAULT_COLOR
  });
  DEFAULT_IMAGE_STYLE_ANCHOR = [20, 2];
  DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS = "pixels";
  DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS = "pixels";
  DEFAULT_IMAGE_STYLE_SIZE = [64, 64];
  DEFAULT_IMAGE_STYLE_SRC = "https://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png";
  DEFAULT_IMAGE_STYLE = new Icon$1({
    anchor: DEFAULT_IMAGE_STYLE_ANCHOR,
    anchorOrigin: "bottom-left",
    anchorXUnits: DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS,
    anchorYUnits: DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS,
    crossOrigin: "anonymous",
    rotation: 0,
    scale: scaleForSize(DEFAULT_IMAGE_STYLE_SIZE),
    size: DEFAULT_IMAGE_STYLE_SIZE,
    src: DEFAULT_IMAGE_STYLE_SRC
  });
  DEFAULT_NO_IMAGE_STYLE = "NO_IMAGE";
  DEFAULT_STROKE_STYLE = new Stroke$1({
    color: DEFAULT_COLOR,
    width: 1
  });
  DEFAULT_TEXT_STROKE_STYLE = new Stroke$1({
    color: [51, 51, 51, 1],
    width: 2
  });
  DEFAULT_TEXT_STYLE = new Text$1({
    font: "bold 16px Helvetica",
    fill: DEFAULT_FILL_STYLE,
    stroke: DEFAULT_TEXT_STROKE_STYLE,
    scale: 0.8
  });
  DEFAULT_STYLE = new Style$1({
    fill: DEFAULT_FILL_STYLE,
    image: DEFAULT_IMAGE_STYLE,
    text: DEFAULT_TEXT_STYLE,
    stroke: DEFAULT_STROKE_STYLE,
    zIndex: 0
  });
  DEFAULT_STYLE_ARRAY = [DEFAULT_STYLE];
}
let TEXTAREA;
function defaultIconUrlFunction(href) {
  return href;
}
class KML extends XMLFeature {
  constructor(options) {
    super();
    options = options ? options : {};
    if (!DEFAULT_STYLE_ARRAY) {
      createStyleDefaults();
    }
    this.dataProjection = get$4("EPSG:4326");
    this.defaultStyle_ = options.defaultStyle ? options.defaultStyle : DEFAULT_STYLE_ARRAY;
    this.extractStyles_ = options.extractStyles !== void 0 ? options.extractStyles : true;
    this.writeStyles_ = options.writeStyles !== void 0 ? options.writeStyles : true;
    this.sharedStyles_ = {};
    this.showPointNames_ = options.showPointNames !== void 0 ? options.showPointNames : true;
    this.crossOrigin_ = options.crossOrigin !== void 0 ? options.crossOrigin : "anonymous";
    this.iconUrlFunction_ = options.iconUrlFunction ? options.iconUrlFunction : defaultIconUrlFunction;
    this.supportedMediaTypes = ["application/vnd.google-earth.kml+xml"];
  }
  readDocumentOrFolder_(node2, objectStack) {
    const parsersNS = makeStructureNS(NAMESPACE_URIS$3, {
      "Document": makeArrayExtender(this.readDocumentOrFolder_, this),
      "Folder": makeArrayExtender(this.readDocumentOrFolder_, this),
      "Placemark": makeArrayPusher(this.readPlacemark_, this),
      "Style": this.readSharedStyle_.bind(this),
      "StyleMap": this.readSharedStyleMap_.bind(this)
    });
    const features = pushParseAndPop([], parsersNS, node2, objectStack, this);
    if (features) {
      return features;
    }
    return void 0;
  }
  readPlacemark_(node2, objectStack) {
    const object = pushParseAndPop({ "geometry": null }, PLACEMARK_PARSERS, node2, objectStack, this);
    if (!object) {
      return void 0;
    }
    const feature = new Feature$1();
    const id = node2.getAttribute("id");
    if (id !== null) {
      feature.setId(id);
    }
    const options = objectStack[0];
    const geometry = object["geometry"];
    if (geometry) {
      transformGeometryWithOptions(geometry, false, options);
    }
    feature.setGeometry(geometry);
    delete object["geometry"];
    if (this.extractStyles_) {
      const style2 = object["Style"];
      const styleUrl = object["styleUrl"];
      const styleFunction = createFeatureStyleFunction(style2, styleUrl, this.defaultStyle_, this.sharedStyles_, this.showPointNames_);
      feature.setStyle(styleFunction);
    }
    delete object["Style"];
    feature.setProperties(object, true);
    return feature;
  }
  readSharedStyle_(node2, objectStack) {
    const id = node2.getAttribute("id");
    if (id !== null) {
      const style2 = readStyle$2.call(this, node2, objectStack);
      if (style2) {
        let styleUri;
        let baseURI = node2.baseURI;
        if (!baseURI || baseURI == "about:blank") {
          baseURI = window.location.href;
        }
        if (baseURI) {
          const url = new URL("#" + id, baseURI);
          styleUri = url.href;
        } else {
          styleUri = "#" + id;
        }
        this.sharedStyles_[styleUri] = style2;
      }
    }
  }
  readSharedStyleMap_(node2, objectStack) {
    const id = node2.getAttribute("id");
    if (id === null) {
      return;
    }
    const styleMapValue = readStyleMapValue.call(this, node2, objectStack);
    if (!styleMapValue) {
      return;
    }
    let styleUri;
    let baseURI = node2.baseURI;
    if (!baseURI || baseURI == "about:blank") {
      baseURI = window.location.href;
    }
    if (baseURI) {
      const url = new URL("#" + id, baseURI);
      styleUri = url.href;
    } else {
      styleUri = "#" + id;
    }
    this.sharedStyles_[styleUri] = styleMapValue;
  }
  readFeatureFromNode(node2, options) {
    if (!NAMESPACE_URIS$3.includes(node2.namespaceURI)) {
      return null;
    }
    const feature = this.readPlacemark_(node2, [
      this.getReadOptions(node2, options)
    ]);
    if (feature) {
      return feature;
    }
    return null;
  }
  readFeaturesFromNode(node2, options) {
    if (!NAMESPACE_URIS$3.includes(node2.namespaceURI)) {
      return [];
    }
    let features;
    const localName = node2.localName;
    if (localName == "Document" || localName == "Folder") {
      features = this.readDocumentOrFolder_(node2, [
        this.getReadOptions(node2, options)
      ]);
      if (features) {
        return features;
      }
      return [];
    } else if (localName == "Placemark") {
      const feature = this.readPlacemark_(node2, [
        this.getReadOptions(node2, options)
      ]);
      if (feature) {
        return [feature];
      }
      return [];
    } else if (localName == "kml") {
      features = [];
      for (let n2 = node2.firstElementChild; n2; n2 = n2.nextElementSibling) {
        const fs2 = this.readFeaturesFromNode(n2, options);
        if (fs2) {
          extend$3(features, fs2);
        }
      }
      return features;
    }
    return [];
  }
  readName(source) {
    if (!source) {
      return void 0;
    } else if (typeof source === "string") {
      const doc = parse$1(source);
      return this.readNameFromDocument(doc);
    } else if (isDocument(source)) {
      return this.readNameFromDocument(source);
    }
    return this.readNameFromNode(source);
  }
  readNameFromDocument(doc) {
    for (let n2 = doc.firstChild; n2; n2 = n2.nextSibling) {
      if (n2.nodeType == Node.ELEMENT_NODE) {
        const name = this.readNameFromNode(n2);
        if (name) {
          return name;
        }
      }
    }
    return void 0;
  }
  readNameFromNode(node2) {
    for (let n2 = node2.firstElementChild; n2; n2 = n2.nextElementSibling) {
      if (NAMESPACE_URIS$3.includes(n2.namespaceURI) && n2.localName == "name") {
        return readString(n2);
      }
    }
    for (let n2 = node2.firstElementChild; n2; n2 = n2.nextElementSibling) {
      const localName = n2.localName;
      if (NAMESPACE_URIS$3.includes(n2.namespaceURI) && (localName == "Document" || localName == "Folder" || localName == "Placemark" || localName == "kml")) {
        const name = this.readNameFromNode(n2);
        if (name) {
          return name;
        }
      }
    }
    return void 0;
  }
  readNetworkLinks(source) {
    const networkLinks = [];
    if (typeof source === "string") {
      const doc = parse$1(source);
      extend$3(networkLinks, this.readNetworkLinksFromDocument(doc));
    } else if (isDocument(source)) {
      extend$3(networkLinks, this.readNetworkLinksFromDocument(source));
    } else {
      extend$3(networkLinks, this.readNetworkLinksFromNode(source));
    }
    return networkLinks;
  }
  readNetworkLinksFromDocument(doc) {
    const networkLinks = [];
    for (let n2 = doc.firstChild; n2; n2 = n2.nextSibling) {
      if (n2.nodeType == Node.ELEMENT_NODE) {
        extend$3(networkLinks, this.readNetworkLinksFromNode(n2));
      }
    }
    return networkLinks;
  }
  readNetworkLinksFromNode(node2) {
    const networkLinks = [];
    for (let n2 = node2.firstElementChild; n2; n2 = n2.nextElementSibling) {
      if (NAMESPACE_URIS$3.includes(n2.namespaceURI) && n2.localName == "NetworkLink") {
        const obj = pushParseAndPop({}, NETWORK_LINK_PARSERS, n2, []);
        networkLinks.push(obj);
      }
    }
    for (let n2 = node2.firstElementChild; n2; n2 = n2.nextElementSibling) {
      const localName = n2.localName;
      if (NAMESPACE_URIS$3.includes(n2.namespaceURI) && (localName == "Document" || localName == "Folder" || localName == "kml")) {
        extend$3(networkLinks, this.readNetworkLinksFromNode(n2));
      }
    }
    return networkLinks;
  }
  readRegion(source) {
    const regions = [];
    if (typeof source === "string") {
      const doc = parse$1(source);
      extend$3(regions, this.readRegionFromDocument(doc));
    } else if (isDocument(source)) {
      extend$3(regions, this.readRegionFromDocument(source));
    } else {
      extend$3(regions, this.readRegionFromNode(source));
    }
    return regions;
  }
  readRegionFromDocument(doc) {
    const regions = [];
    for (let n2 = doc.firstChild; n2; n2 = n2.nextSibling) {
      if (n2.nodeType == Node.ELEMENT_NODE) {
        extend$3(regions, this.readRegionFromNode(n2));
      }
    }
    return regions;
  }
  readRegionFromNode(node2) {
    const regions = [];
    for (let n2 = node2.firstElementChild; n2; n2 = n2.nextElementSibling) {
      if (NAMESPACE_URIS$3.includes(n2.namespaceURI) && n2.localName == "Region") {
        const obj = pushParseAndPop({}, REGION_PARSERS, n2, []);
        regions.push(obj);
      }
    }
    for (let n2 = node2.firstElementChild; n2; n2 = n2.nextElementSibling) {
      const localName = n2.localName;
      if (NAMESPACE_URIS$3.includes(n2.namespaceURI) && (localName == "Document" || localName == "Folder" || localName == "kml")) {
        extend$3(regions, this.readRegionFromNode(n2));
      }
    }
    return regions;
  }
  writeFeaturesNode(features, options) {
    options = this.adaptOptions(options);
    const kml = createElementNS(NAMESPACE_URIS$3[4], "kml");
    const xmlnsUri = "http://www.w3.org/2000/xmlns/";
    kml.setAttributeNS(xmlnsUri, "xmlns:gx", GX_NAMESPACE_URIS[0]);
    kml.setAttributeNS(xmlnsUri, "xmlns:xsi", XML_SCHEMA_INSTANCE_URI);
    kml.setAttributeNS(XML_SCHEMA_INSTANCE_URI, "xsi:schemaLocation", SCHEMA_LOCATION);
    const context2 = {
      node: kml
    };
    const properties = {};
    if (features.length > 1) {
      properties["Document"] = features;
    } else if (features.length == 1) {
      properties["Placemark"] = features[0];
    }
    const orderedKeys = KML_SEQUENCE[kml.namespaceURI];
    const values3 = makeSequence(properties, orderedKeys);
    pushSerializeAndPop(context2, KML_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values3, [options], orderedKeys, this);
    return kml;
  }
}
function createNameStyleFunction(foundStyle, name) {
  const textOffset = [0, 0];
  let textAlign2 = "start";
  const imageStyle = foundStyle.getImage();
  if (imageStyle) {
    const imageSize = imageStyle.getSize();
    if (imageSize && imageSize.length == 2) {
      const imageScale = imageStyle.getScaleArray();
      const anchor = imageStyle.getAnchor();
      textOffset[0] = imageScale[0] * (imageSize[0] - anchor[0]);
      textOffset[1] = imageScale[1] * (imageSize[1] / 2 - anchor[1]);
      textAlign2 = "left";
    }
  }
  let textStyle = foundStyle.getText();
  if (textStyle) {
    textStyle = textStyle.clone();
    textStyle.setFont(textStyle.getFont() || DEFAULT_TEXT_STYLE.getFont());
    textStyle.setScale(textStyle.getScale() || DEFAULT_TEXT_STYLE.getScale());
    textStyle.setFill(textStyle.getFill() || DEFAULT_TEXT_STYLE.getFill());
    textStyle.setStroke(textStyle.getStroke() || DEFAULT_TEXT_STROKE_STYLE);
  } else {
    textStyle = DEFAULT_TEXT_STYLE.clone();
  }
  textStyle.setText(name);
  textStyle.setOffsetX(textOffset[0]);
  textStyle.setOffsetY(textOffset[1]);
  textStyle.setTextAlign(textAlign2);
  const nameStyle = new Style$1({
    image: imageStyle,
    text: textStyle
  });
  return nameStyle;
}
function createFeatureStyleFunction(style2, styleUrl, defaultStyle, sharedStyles, showPointNames) {
  return function(feature, resolution) {
    let drawName = showPointNames;
    let name = "";
    let multiGeometryPoints = [];
    if (drawName) {
      const geometry = feature.getGeometry();
      if (geometry) {
        if (geometry instanceof GeometryCollection) {
          multiGeometryPoints = geometry.getGeometriesArrayRecursive().filter(function(geometry2) {
            const type = geometry2.getType();
            return type === "Point" || type === "MultiPoint";
          });
          drawName = multiGeometryPoints.length > 0;
        } else {
          const type = geometry.getType();
          drawName = type === "Point" || type === "MultiPoint";
        }
      }
    }
    if (drawName) {
      name = feature.get("name");
      drawName = drawName && !!name;
      if (drawName && /&[^&]+;/.test(name)) {
        if (!TEXTAREA) {
          TEXTAREA = document.createElement("textarea");
        }
        TEXTAREA.innerHTML = name;
        name = TEXTAREA.value;
      }
    }
    let featureStyle = defaultStyle;
    if (style2) {
      featureStyle = style2;
    } else if (styleUrl) {
      featureStyle = findStyle(styleUrl, defaultStyle, sharedStyles);
    }
    if (drawName) {
      const nameStyle = createNameStyleFunction(featureStyle[0], name);
      if (multiGeometryPoints.length > 0) {
        nameStyle.setGeometry(new GeometryCollection(multiGeometryPoints));
        const baseStyle = new Style$1({
          geometry: featureStyle[0].getGeometry(),
          image: null,
          fill: featureStyle[0].getFill(),
          stroke: featureStyle[0].getStroke(),
          text: null
        });
        return [nameStyle, baseStyle].concat(featureStyle.slice(1));
      }
      return nameStyle;
    }
    return featureStyle;
  };
}
function findStyle(styleValue, defaultStyle, sharedStyles) {
  if (Array.isArray(styleValue)) {
    return styleValue;
  } else if (typeof styleValue === "string") {
    return findStyle(sharedStyles[styleValue], defaultStyle, sharedStyles);
  }
  return defaultStyle;
}
function readColor(node2) {
  const s2 = getAllTextContent(node2, false);
  const m2 = /^\s*#?\s*([0-9A-Fa-f]{8})\s*$/.exec(s2);
  if (m2) {
    const hexColor = m2[1];
    return [
      parseInt(hexColor.substr(6, 2), 16),
      parseInt(hexColor.substr(4, 2), 16),
      parseInt(hexColor.substr(2, 2), 16),
      parseInt(hexColor.substr(0, 2), 16) / 255
    ];
  }
  return void 0;
}
function readFlatCoordinates(node2) {
  let s2 = getAllTextContent(node2, false);
  const flatCoordinates = [];
  s2 = s2.replace(/\s*,\s*/g, ",");
  const re2 = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?),([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s+|,|$)(?:([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s+|$))?\s*/i;
  let m2;
  while (m2 = re2.exec(s2)) {
    const x2 = parseFloat(m2[1]);
    const y2 = parseFloat(m2[2]);
    const z2 = m2[3] ? parseFloat(m2[3]) : 0;
    flatCoordinates.push(x2, y2, z2);
    s2 = s2.substr(m2[0].length);
  }
  if (s2 !== "") {
    return void 0;
  }
  return flatCoordinates;
}
function readURI(node2) {
  const s2 = getAllTextContent(node2, false).trim();
  let baseURI = node2.baseURI;
  if (!baseURI || baseURI == "about:blank") {
    baseURI = window.location.href;
  }
  if (baseURI) {
    const url = new URL(s2, baseURI);
    return url.href;
  }
  return s2;
}
function readStyleURL(node2) {
  const s2 = getAllTextContent(node2, false).trim().replace(/^(?!.*#)/, "#");
  let baseURI = node2.baseURI;
  if (!baseURI || baseURI == "about:blank") {
    baseURI = window.location.href;
  }
  if (baseURI) {
    const url = new URL(s2, baseURI);
    return url.href;
  }
  return s2;
}
function readVec2(node2) {
  const xunits = node2.getAttribute("xunits");
  const yunits = node2.getAttribute("yunits");
  let origin;
  if (xunits !== "insetPixels") {
    if (yunits !== "insetPixels") {
      origin = "bottom-left";
    } else {
      origin = "top-left";
    }
  } else {
    if (yunits !== "insetPixels") {
      origin = "bottom-right";
    } else {
      origin = "top-right";
    }
  }
  return {
    x: parseFloat(node2.getAttribute("x")),
    xunits: ICON_ANCHOR_UNITS_MAP[xunits],
    y: parseFloat(node2.getAttribute("y")),
    yunits: ICON_ANCHOR_UNITS_MAP[yunits],
    origin
  };
}
function readScale(node2) {
  return readDecimal(node2);
}
const STYLE_MAP_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "Pair": pairDataParser
});
function readStyleMapValue(node2, objectStack) {
  return pushParseAndPop(void 0, STYLE_MAP_PARSERS, node2, objectStack, this);
}
const ICON_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "Icon": makeObjectPropertySetter(readIcon),
  "color": makeObjectPropertySetter(readColor),
  "heading": makeObjectPropertySetter(readDecimal),
  "hotSpot": makeObjectPropertySetter(readVec2),
  "scale": makeObjectPropertySetter(readScale)
});
function iconStyleParser(node2, objectStack) {
  const object = pushParseAndPop({}, ICON_STYLE_PARSERS, node2, objectStack);
  if (!object) {
    return;
  }
  const styleObject = objectStack[objectStack.length - 1];
  const IconObject = "Icon" in object ? object["Icon"] : {};
  const drawIcon = !("Icon" in object) || Object.keys(IconObject).length > 0;
  let src;
  const href = IconObject["href"];
  if (href) {
    src = href;
  } else if (drawIcon) {
    src = DEFAULT_IMAGE_STYLE_SRC;
  }
  let anchor, anchorXUnits, anchorYUnits;
  let anchorOrigin = "bottom-left";
  const hotSpot = object["hotSpot"];
  if (hotSpot) {
    anchor = [hotSpot.x, hotSpot.y];
    anchorXUnits = hotSpot.xunits;
    anchorYUnits = hotSpot.yunits;
    anchorOrigin = hotSpot.origin;
  } else if (/^https?:\/\/maps\.(?:google|gstatic)\.com\//.test(src)) {
    if (src.includes("pushpin")) {
      anchor = DEFAULT_IMAGE_STYLE_ANCHOR;
      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;
      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;
    } else if (src.includes("arrow-reverse")) {
      anchor = [54, 42];
      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;
      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;
    } else if (src.includes("paddle")) {
      anchor = [32, 1];
      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;
      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;
    }
  }
  let offset2;
  const x2 = IconObject["x"];
  const y2 = IconObject["y"];
  if (x2 !== void 0 && y2 !== void 0) {
    offset2 = [x2, y2];
  }
  let size;
  const w2 = IconObject["w"];
  const h2 = IconObject["h"];
  if (w2 !== void 0 && h2 !== void 0) {
    size = [w2, h2];
  }
  let rotation;
  const heading = object["heading"];
  if (heading !== void 0) {
    rotation = toRadians(heading);
  }
  const scale2 = object["scale"];
  const color2 = object["color"];
  if (drawIcon) {
    if (src == DEFAULT_IMAGE_STYLE_SRC) {
      size = DEFAULT_IMAGE_STYLE_SIZE;
    }
    const imageStyle = new Icon$1({
      anchor,
      anchorOrigin,
      anchorXUnits,
      anchorYUnits,
      crossOrigin: this.crossOrigin_,
      offset: offset2,
      offsetOrigin: "bottom-left",
      rotation,
      scale: scale2,
      size,
      src: this.iconUrlFunction_(src),
      color: color2
    });
    const imageScale = imageStyle.getScaleArray()[0];
    const imageSize = imageStyle.getSize();
    if (imageSize === null) {
      const imageState = imageStyle.getImageState();
      if (imageState === ImageState.IDLE || imageState === ImageState.LOADING) {
        const listener2 = function() {
          const imageState2 = imageStyle.getImageState();
          if (!(imageState2 === ImageState.IDLE || imageState2 === ImageState.LOADING)) {
            const imageSize2 = imageStyle.getSize();
            if (imageSize2 && imageSize2.length == 2) {
              const resizeScale = scaleForSize(imageSize2);
              imageStyle.setScale(imageScale * resizeScale);
            }
            imageStyle.unlistenImageChange(listener2);
          }
        };
        imageStyle.listenImageChange(listener2);
        if (imageState === ImageState.IDLE) {
          imageStyle.load();
        }
      }
    } else if (imageSize.length == 2) {
      const resizeScale = scaleForSize(imageSize);
      imageStyle.setScale(imageScale * resizeScale);
    }
    styleObject["imageStyle"] = imageStyle;
  } else {
    styleObject["imageStyle"] = DEFAULT_NO_IMAGE_STYLE;
  }
}
const LABEL_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "color": makeObjectPropertySetter(readColor),
  "scale": makeObjectPropertySetter(readScale)
});
function labelStyleParser(node2, objectStack) {
  const object = pushParseAndPop({}, LABEL_STYLE_PARSERS, node2, objectStack);
  if (!object) {
    return;
  }
  const styleObject = objectStack[objectStack.length - 1];
  const textStyle = new Text$1({
    fill: new Fill$1({
      color: "color" in object ? object["color"] : DEFAULT_COLOR
    }),
    scale: object["scale"]
  });
  styleObject["textStyle"] = textStyle;
}
const LINE_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "color": makeObjectPropertySetter(readColor),
  "width": makeObjectPropertySetter(readDecimal)
});
function lineStyleParser(node2, objectStack) {
  const object = pushParseAndPop({}, LINE_STYLE_PARSERS, node2, objectStack);
  if (!object) {
    return;
  }
  const styleObject = objectStack[objectStack.length - 1];
  const strokeStyle = new Stroke$1({
    color: "color" in object ? object["color"] : DEFAULT_COLOR,
    width: "width" in object ? object["width"] : 1
  });
  styleObject["strokeStyle"] = strokeStyle;
}
const POLY_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "color": makeObjectPropertySetter(readColor),
  "fill": makeObjectPropertySetter(readBoolean),
  "outline": makeObjectPropertySetter(readBoolean)
});
function polyStyleParser(node2, objectStack) {
  const object = pushParseAndPop({}, POLY_STYLE_PARSERS, node2, objectStack);
  if (!object) {
    return;
  }
  const styleObject = objectStack[objectStack.length - 1];
  const fillStyle = new Fill$1({
    color: "color" in object ? object["color"] : DEFAULT_COLOR
  });
  styleObject["fillStyle"] = fillStyle;
  const fill = object["fill"];
  if (fill !== void 0) {
    styleObject["fill"] = fill;
  }
  const outline = object["outline"];
  if (outline !== void 0) {
    styleObject["outline"] = outline;
  }
}
const FLAT_LINEAR_RING_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "coordinates": makeReplacer(readFlatCoordinates)
});
function readFlatLinearRing(node2, objectStack) {
  return pushParseAndPop(null, FLAT_LINEAR_RING_PARSERS, node2, objectStack);
}
function gxCoordParser(node2, objectStack) {
  const gxTrackObject = objectStack[objectStack.length - 1];
  const coordinates2 = gxTrackObject.coordinates;
  const s2 = getAllTextContent(node2, false);
  const re2 = /^\s*([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s*$/i;
  const m2 = re2.exec(s2);
  if (m2) {
    const x2 = parseFloat(m2[1]);
    const y2 = parseFloat(m2[2]);
    const z2 = parseFloat(m2[3]);
    coordinates2.push([x2, y2, z2]);
  } else {
    coordinates2.push([]);
  }
}
const GX_MULTITRACK_GEOMETRY_PARSERS = makeStructureNS(GX_NAMESPACE_URIS, {
  "Track": makeArrayPusher(readGxTrack)
});
function readGxMultiTrack(node2, objectStack) {
  const lineStrings = pushParseAndPop([], GX_MULTITRACK_GEOMETRY_PARSERS, node2, objectStack);
  if (!lineStrings) {
    return void 0;
  }
  return new MultiLineString$1(lineStrings);
}
const GX_TRACK_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "when": whenParser
}, makeStructureNS(GX_NAMESPACE_URIS, {
  "coord": gxCoordParser
}));
function readGxTrack(node2, objectStack) {
  const gxTrackObject = pushParseAndPop({
    coordinates: [],
    whens: []
  }, GX_TRACK_PARSERS, node2, objectStack);
  if (!gxTrackObject) {
    return void 0;
  }
  const flatCoordinates = [];
  const coordinates2 = gxTrackObject.coordinates;
  const whens = gxTrackObject.whens;
  for (let i2 = 0, ii = Math.min(coordinates2.length, whens.length); i2 < ii; ++i2) {
    if (coordinates2[i2].length == 3) {
      flatCoordinates.push(coordinates2[i2][0], coordinates2[i2][1], coordinates2[i2][2], whens[i2]);
    }
  }
  return new LineString$1(flatCoordinates, "XYZM");
}
const ICON_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "href": makeObjectPropertySetter(readURI)
}, makeStructureNS(GX_NAMESPACE_URIS, {
  "x": makeObjectPropertySetter(readDecimal),
  "y": makeObjectPropertySetter(readDecimal),
  "w": makeObjectPropertySetter(readDecimal),
  "h": makeObjectPropertySetter(readDecimal)
}));
function readIcon(node2, objectStack) {
  const iconObject = pushParseAndPop({}, ICON_PARSERS, node2, objectStack);
  if (iconObject) {
    return iconObject;
  }
  return null;
}
const GEOMETRY_FLAT_COORDINATES_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "coordinates": makeReplacer(readFlatCoordinates)
});
function readFlatCoordinatesFromNode(node2, objectStack) {
  return pushParseAndPop(null, GEOMETRY_FLAT_COORDINATES_PARSERS, node2, objectStack);
}
const EXTRUDE_AND_ALTITUDE_MODE_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "extrude": makeObjectPropertySetter(readBoolean),
  "tessellate": makeObjectPropertySetter(readBoolean),
  "altitudeMode": makeObjectPropertySetter(readString)
});
function readLineString(node2, objectStack) {
  const properties = pushParseAndPop({}, EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node2, objectStack);
  const flatCoordinates = readFlatCoordinatesFromNode(node2, objectStack);
  if (flatCoordinates) {
    const lineString = new LineString$1(flatCoordinates, "XYZ");
    lineString.setProperties(properties, true);
    return lineString;
  }
  return void 0;
}
function readLinearRing(node2, objectStack) {
  const properties = pushParseAndPop({}, EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node2, objectStack);
  const flatCoordinates = readFlatCoordinatesFromNode(node2, objectStack);
  if (flatCoordinates) {
    const polygon = new Polygon$1(flatCoordinates, "XYZ", [
      flatCoordinates.length
    ]);
    polygon.setProperties(properties, true);
    return polygon;
  }
  return void 0;
}
const MULTI_GEOMETRY_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "LineString": makeArrayPusher(readLineString),
  "LinearRing": makeArrayPusher(readLinearRing),
  "MultiGeometry": makeArrayPusher(readMultiGeometry),
  "Point": makeArrayPusher(readPoint),
  "Polygon": makeArrayPusher(readPolygon)
});
function readMultiGeometry(node2, objectStack) {
  const geometries = pushParseAndPop([], MULTI_GEOMETRY_PARSERS, node2, objectStack);
  if (!geometries) {
    return null;
  }
  if (geometries.length === 0) {
    return new GeometryCollection(geometries);
  }
  let multiGeometry;
  let homogeneous = true;
  const type = geometries[0].getType();
  let geometry;
  for (let i2 = 1, ii = geometries.length; i2 < ii; ++i2) {
    geometry = geometries[i2];
    if (geometry.getType() != type) {
      homogeneous = false;
      break;
    }
  }
  if (homogeneous) {
    let layout;
    let flatCoordinates;
    if (type == "Point") {
      const point = geometries[0];
      layout = point.getLayout();
      flatCoordinates = point.getFlatCoordinates();
      for (let i2 = 1, ii = geometries.length; i2 < ii; ++i2) {
        geometry = geometries[i2];
        extend$3(flatCoordinates, geometry.getFlatCoordinates());
      }
      multiGeometry = new MultiPoint$1(flatCoordinates, layout);
      setCommonGeometryProperties(multiGeometry, geometries);
    } else if (type == "LineString") {
      multiGeometry = new MultiLineString$1(geometries);
      setCommonGeometryProperties(multiGeometry, geometries);
    } else if (type == "Polygon") {
      multiGeometry = new MultiPolygon$1(geometries);
      setCommonGeometryProperties(multiGeometry, geometries);
    } else if (type == "GeometryCollection") {
      multiGeometry = new GeometryCollection(geometries);
    } else {
      assert(false, 37);
    }
  } else {
    multiGeometry = new GeometryCollection(geometries);
  }
  return multiGeometry;
}
function readPoint(node2, objectStack) {
  const properties = pushParseAndPop({}, EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node2, objectStack);
  const flatCoordinates = readFlatCoordinatesFromNode(node2, objectStack);
  if (flatCoordinates) {
    const point = new Point$3(flatCoordinates, "XYZ");
    point.setProperties(properties, true);
    return point;
  }
  return void 0;
}
const FLAT_LINEAR_RINGS_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "innerBoundaryIs": innerBoundaryIsParser,
  "outerBoundaryIs": outerBoundaryIsParser
});
function readPolygon(node2, objectStack) {
  const properties = pushParseAndPop({}, EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node2, objectStack);
  const flatLinearRings = pushParseAndPop([null], FLAT_LINEAR_RINGS_PARSERS, node2, objectStack);
  if (flatLinearRings && flatLinearRings[0]) {
    const flatCoordinates = flatLinearRings[0];
    const ends = [flatCoordinates.length];
    for (let i2 = 1, ii = flatLinearRings.length; i2 < ii; ++i2) {
      extend$3(flatCoordinates, flatLinearRings[i2]);
      ends.push(flatCoordinates.length);
    }
    const polygon = new Polygon$1(flatCoordinates, "XYZ", ends);
    polygon.setProperties(properties, true);
    return polygon;
  }
  return void 0;
}
const STYLE_PARSERS$2 = makeStructureNS(NAMESPACE_URIS$3, {
  "IconStyle": iconStyleParser,
  "LabelStyle": labelStyleParser,
  "LineStyle": lineStyleParser,
  "PolyStyle": polyStyleParser
});
function readStyle$2(node2, objectStack) {
  const styleObject = pushParseAndPop({}, STYLE_PARSERS$2, node2, objectStack, this);
  if (!styleObject) {
    return null;
  }
  let fillStyle = "fillStyle" in styleObject ? styleObject["fillStyle"] : DEFAULT_FILL_STYLE;
  const fill = styleObject["fill"];
  if (fill !== void 0 && !fill) {
    fillStyle = null;
  }
  let imageStyle;
  if ("imageStyle" in styleObject) {
    if (styleObject["imageStyle"] != DEFAULT_NO_IMAGE_STYLE) {
      imageStyle = styleObject["imageStyle"];
    }
  } else {
    imageStyle = DEFAULT_IMAGE_STYLE;
  }
  const textStyle = "textStyle" in styleObject ? styleObject["textStyle"] : DEFAULT_TEXT_STYLE;
  const strokeStyle = "strokeStyle" in styleObject ? styleObject["strokeStyle"] : DEFAULT_STROKE_STYLE;
  const outline = styleObject["outline"];
  if (outline !== void 0 && !outline) {
    return [
      new Style$1({
        geometry: function(feature) {
          const geometry = feature.getGeometry();
          const type = geometry.getType();
          if (type === "GeometryCollection") {
            const collection = geometry;
            return new GeometryCollection(collection.getGeometriesArrayRecursive().filter(function(geometry2) {
              const type2 = geometry2.getType();
              return type2 !== "Polygon" && type2 !== "MultiPolygon";
            }));
          } else if (type !== "Polygon" && type !== "MultiPolygon") {
            return geometry;
          }
        },
        fill: fillStyle,
        image: imageStyle,
        stroke: strokeStyle,
        text: textStyle,
        zIndex: void 0
      }),
      new Style$1({
        geometry: function(feature) {
          const geometry = feature.getGeometry();
          const type = geometry.getType();
          if (type === "GeometryCollection") {
            const collection = geometry;
            return new GeometryCollection(collection.getGeometriesArrayRecursive().filter(function(geometry2) {
              const type2 = geometry2.getType();
              return type2 === "Polygon" || type2 === "MultiPolygon";
            }));
          } else if (type === "Polygon" || type === "MultiPolygon") {
            return geometry;
          }
        },
        fill: fillStyle,
        stroke: null,
        zIndex: void 0
      })
    ];
  }
  return [
    new Style$1({
      fill: fillStyle,
      image: imageStyle,
      stroke: strokeStyle,
      text: textStyle,
      zIndex: void 0
    })
  ];
}
function setCommonGeometryProperties(multiGeometry, geometries) {
  const ii = geometries.length;
  const extrudes = new Array(geometries.length);
  const tessellates = new Array(geometries.length);
  const altitudeModes = new Array(geometries.length);
  let hasExtrude, hasTessellate, hasAltitudeMode;
  hasExtrude = false;
  hasTessellate = false;
  hasAltitudeMode = false;
  for (let i2 = 0; i2 < ii; ++i2) {
    const geometry = geometries[i2];
    extrudes[i2] = geometry.get("extrude");
    tessellates[i2] = geometry.get("tessellate");
    altitudeModes[i2] = geometry.get("altitudeMode");
    hasExtrude = hasExtrude || extrudes[i2] !== void 0;
    hasTessellate = hasTessellate || tessellates[i2] !== void 0;
    hasAltitudeMode = hasAltitudeMode || altitudeModes[i2];
  }
  if (hasExtrude) {
    multiGeometry.set("extrude", extrudes);
  }
  if (hasTessellate) {
    multiGeometry.set("tessellate", tessellates);
  }
  if (hasAltitudeMode) {
    multiGeometry.set("altitudeMode", altitudeModes);
  }
}
const DATA_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "displayName": makeObjectPropertySetter(readString),
  "value": makeObjectPropertySetter(readString)
});
function dataParser(node2, objectStack) {
  const name = node2.getAttribute("name");
  parseNode(DATA_PARSERS, node2, objectStack);
  const featureObject = objectStack[objectStack.length - 1];
  if (name && featureObject.displayName) {
    featureObject[name] = {
      value: featureObject.value,
      displayName: featureObject.displayName,
      toString: function() {
        return featureObject.value;
      }
    };
  } else if (name !== null) {
    featureObject[name] = featureObject.value;
  } else if (featureObject.displayName !== null) {
    featureObject[featureObject.displayName] = featureObject.value;
  }
  delete featureObject["value"];
}
const EXTENDED_DATA_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "Data": dataParser,
  "SchemaData": schemaDataParser
});
function extendedDataParser(node2, objectStack) {
  parseNode(EXTENDED_DATA_PARSERS, node2, objectStack);
}
function regionParser(node2, objectStack) {
  parseNode(REGION_PARSERS, node2, objectStack);
}
const PAIR_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "Style": makeObjectPropertySetter(readStyle$2),
  "key": makeObjectPropertySetter(readString),
  "styleUrl": makeObjectPropertySetter(readStyleURL)
});
function pairDataParser(node2, objectStack) {
  const pairObject = pushParseAndPop({}, PAIR_PARSERS, node2, objectStack, this);
  if (!pairObject) {
    return;
  }
  const key = pairObject["key"];
  if (key && key == "normal") {
    const styleUrl = pairObject["styleUrl"];
    if (styleUrl) {
      objectStack[objectStack.length - 1] = styleUrl;
    }
    const style2 = pairObject["Style"];
    if (style2) {
      objectStack[objectStack.length - 1] = style2;
    }
  }
}
function placemarkStyleMapParser(node2, objectStack) {
  const styleMapValue = readStyleMapValue.call(this, node2, objectStack);
  if (!styleMapValue) {
    return;
  }
  const placemarkObject = objectStack[objectStack.length - 1];
  if (Array.isArray(styleMapValue)) {
    placemarkObject["Style"] = styleMapValue;
  } else if (typeof styleMapValue === "string") {
    placemarkObject["styleUrl"] = styleMapValue;
  } else {
    assert(false, 38);
  }
}
const SCHEMA_DATA_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "SimpleData": simpleDataParser
});
function schemaDataParser(node2, objectStack) {
  parseNode(SCHEMA_DATA_PARSERS, node2, objectStack);
}
function simpleDataParser(node2, objectStack) {
  const name = node2.getAttribute("name");
  if (name !== null) {
    const data2 = readString(node2);
    const featureObject = objectStack[objectStack.length - 1];
    featureObject[name] = data2;
  }
}
const LAT_LON_ALT_BOX_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "altitudeMode": makeObjectPropertySetter(readString),
  "minAltitude": makeObjectPropertySetter(readDecimal),
  "maxAltitude": makeObjectPropertySetter(readDecimal),
  "north": makeObjectPropertySetter(readDecimal),
  "south": makeObjectPropertySetter(readDecimal),
  "east": makeObjectPropertySetter(readDecimal),
  "west": makeObjectPropertySetter(readDecimal)
});
function latLonAltBoxParser(node2, objectStack) {
  const object = pushParseAndPop({}, LAT_LON_ALT_BOX_PARSERS, node2, objectStack);
  if (!object) {
    return;
  }
  const regionObject = objectStack[objectStack.length - 1];
  const extent2 = [
    parseFloat(object["west"]),
    parseFloat(object["south"]),
    parseFloat(object["east"]),
    parseFloat(object["north"])
  ];
  regionObject["extent"] = extent2;
  regionObject["altitudeMode"] = object["altitudeMode"];
  regionObject["minAltitude"] = parseFloat(object["minAltitude"]);
  regionObject["maxAltitude"] = parseFloat(object["maxAltitude"]);
}
const LOD_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "minLodPixels": makeObjectPropertySetter(readDecimal),
  "maxLodPixels": makeObjectPropertySetter(readDecimal),
  "minFadeExtent": makeObjectPropertySetter(readDecimal),
  "maxFadeExtent": makeObjectPropertySetter(readDecimal)
});
function lodParser(node2, objectStack) {
  const object = pushParseAndPop({}, LOD_PARSERS, node2, objectStack);
  if (!object) {
    return;
  }
  const lodObject = objectStack[objectStack.length - 1];
  lodObject["minLodPixels"] = parseFloat(object["minLodPixels"]);
  lodObject["maxLodPixels"] = parseFloat(object["maxLodPixels"]);
  lodObject["minFadeExtent"] = parseFloat(object["minFadeExtent"]);
  lodObject["maxFadeExtent"] = parseFloat(object["maxFadeExtent"]);
}
const INNER_BOUNDARY_IS_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "LinearRing": makeArrayPusher(readFlatLinearRing)
});
function innerBoundaryIsParser(node2, objectStack) {
  const innerBoundaryFlatLinearRings = pushParseAndPop([], INNER_BOUNDARY_IS_PARSERS, node2, objectStack);
  if (innerBoundaryFlatLinearRings.length > 0) {
    const flatLinearRings = objectStack[objectStack.length - 1];
    flatLinearRings.push(...innerBoundaryFlatLinearRings);
  }
}
const OUTER_BOUNDARY_IS_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "LinearRing": makeReplacer(readFlatLinearRing)
});
function outerBoundaryIsParser(node2, objectStack) {
  const flatLinearRing = pushParseAndPop(void 0, OUTER_BOUNDARY_IS_PARSERS, node2, objectStack);
  if (flatLinearRing) {
    const flatLinearRings = objectStack[objectStack.length - 1];
    flatLinearRings[0] = flatLinearRing;
  }
}
function linkParser(node2, objectStack) {
  parseNode(LINK_PARSERS, node2, objectStack);
}
function whenParser(node2, objectStack) {
  const gxTrackObject = objectStack[objectStack.length - 1];
  const whens = gxTrackObject.whens;
  const s2 = getAllTextContent(node2, false);
  const when = Date.parse(s2);
  whens.push(isNaN(when) ? 0 : when);
}
function writeColorTextNode(node2, color2) {
  const rgba = asArray(color2);
  const opacity2 = rgba.length == 4 ? rgba[3] : 1;
  const abgr = [opacity2 * 255, rgba[2], rgba[1], rgba[0]];
  for (let i2 = 0; i2 < 4; ++i2) {
    const hex = Math.floor(abgr[i2]).toString(16);
    abgr[i2] = hex.length == 1 ? "0" + hex : hex;
  }
  writeStringTextNode(node2, abgr.join(""));
}
function writeCoordinatesTextNode(node2, coordinates2, objectStack) {
  const context2 = objectStack[objectStack.length - 1];
  const layout = context2["layout"];
  const stride = context2["stride"];
  let dimension;
  if (layout == "XY" || layout == "XYM") {
    dimension = 2;
  } else if (layout == "XYZ" || layout == "XYZM") {
    dimension = 3;
  } else {
    assert(false, 34);
  }
  const ii = coordinates2.length;
  let text2 = "";
  if (ii > 0) {
    text2 += coordinates2[0];
    for (let d2 = 1; d2 < dimension; ++d2) {
      text2 += "," + coordinates2[d2];
    }
    for (let i2 = stride; i2 < ii; i2 += stride) {
      text2 += " " + coordinates2[i2];
      for (let d2 = 1; d2 < dimension; ++d2) {
        text2 += "," + coordinates2[i2 + d2];
      }
    }
  }
  writeStringTextNode(node2, text2);
}
const EXTENDEDDATA_NODE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {
  "Data": makeChildAppender(writeDataNode),
  "value": makeChildAppender(writeDataNodeValue),
  "displayName": makeChildAppender(writeDataNodeName)
});
function writeDataNode(node2, pair, objectStack) {
  node2.setAttribute("name", pair.name);
  const context2 = { node: node2 };
  const value = pair.value;
  if (typeof value == "object") {
    if (value !== null && value.displayName) {
      pushSerializeAndPop(context2, EXTENDEDDATA_NODE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, [value.displayName], objectStack, ["displayName"]);
    }
    if (value !== null && value.value) {
      pushSerializeAndPop(context2, EXTENDEDDATA_NODE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, [value.value], objectStack, ["value"]);
    }
  } else {
    pushSerializeAndPop(context2, EXTENDEDDATA_NODE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, [value], objectStack, ["value"]);
  }
}
function writeDataNodeName(node2, name) {
  writeCDATASection(node2, name);
}
function writeDataNodeValue(node2, value) {
  writeStringTextNode(node2, value);
}
const DOCUMENT_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {
  "Placemark": makeChildAppender(writePlacemark)
});
const DOCUMENT_NODE_FACTORY = function(value, objectStack, nodeName) {
  const parentNode = objectStack[objectStack.length - 1].node;
  return createElementNS(parentNode.namespaceURI, "Placemark");
};
function writeDocument(node2, features, objectStack) {
  const context2 = { node: node2 };
  pushSerializeAndPop(context2, DOCUMENT_SERIALIZERS, DOCUMENT_NODE_FACTORY, features, objectStack, void 0, this);
}
const DATA_NODE_FACTORY = makeSimpleNodeFactory("Data");
function writeExtendedData(node2, namesAndValues, objectStack) {
  const context2 = { node: node2 };
  const names2 = namesAndValues.names;
  const values3 = namesAndValues.values;
  const length = names2.length;
  for (let i2 = 0; i2 < length; i2++) {
    pushSerializeAndPop(context2, EXTENDEDDATA_NODE_SERIALIZERS, DATA_NODE_FACTORY, [{ name: names2[i2], value: values3[i2] }], objectStack);
  }
}
const ICON_SEQUENCE = makeStructureNS(NAMESPACE_URIS$3, ["href"], makeStructureNS(GX_NAMESPACE_URIS, ["x", "y", "w", "h"]));
const ICON_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {
  "href": makeChildAppender(writeStringTextNode)
}, makeStructureNS(GX_NAMESPACE_URIS, {
  "x": makeChildAppender(writeDecimalTextNode),
  "y": makeChildAppender(writeDecimalTextNode),
  "w": makeChildAppender(writeDecimalTextNode),
  "h": makeChildAppender(writeDecimalTextNode)
}));
const GX_NODE_FACTORY = function(value, objectStack, nodeName) {
  return createElementNS(GX_NAMESPACE_URIS[0], "gx:" + nodeName);
};
function writeIcon(node2, icon, objectStack) {
  const context2 = { node: node2 };
  const parentNode = objectStack[objectStack.length - 1].node;
  let orderedKeys = ICON_SEQUENCE[parentNode.namespaceURI];
  let values3 = makeSequence(icon, orderedKeys);
  pushSerializeAndPop(context2, ICON_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values3, objectStack, orderedKeys);
  orderedKeys = ICON_SEQUENCE[GX_NAMESPACE_URIS[0]];
  values3 = makeSequence(icon, orderedKeys);
  pushSerializeAndPop(context2, ICON_SERIALIZERS, GX_NODE_FACTORY, values3, objectStack, orderedKeys);
}
const ICON_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS$3, [
  "scale",
  "heading",
  "Icon",
  "color",
  "hotSpot"
]);
const ICON_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {
  "Icon": makeChildAppender(writeIcon),
  "color": makeChildAppender(writeColorTextNode),
  "heading": makeChildAppender(writeDecimalTextNode),
  "hotSpot": makeChildAppender(writeVec2),
  "scale": makeChildAppender(writeScaleTextNode)
});
function writeIconStyle(node2, style2, objectStack) {
  const context2 = { node: node2 };
  const properties = {};
  const src = style2.getSrc();
  const size = style2.getSize();
  const iconImageSize = style2.getImageSize();
  const iconProperties = {
    "href": src
  };
  if (size) {
    iconProperties["w"] = size[0];
    iconProperties["h"] = size[1];
    const anchor = style2.getAnchor();
    const origin = style2.getOrigin();
    if (origin && iconImageSize && origin[0] !== 0 && origin[1] !== size[1]) {
      iconProperties["x"] = origin[0];
      iconProperties["y"] = iconImageSize[1] - (origin[1] + size[1]);
    }
    if (anchor && (anchor[0] !== size[0] / 2 || anchor[1] !== size[1] / 2)) {
      const hotSpot = {
        x: anchor[0],
        xunits: "pixels",
        y: size[1] - anchor[1],
        yunits: "pixels"
      };
      properties["hotSpot"] = hotSpot;
    }
  }
  properties["Icon"] = iconProperties;
  let scale2 = style2.getScaleArray()[0];
  let imageSize = size;
  if (imageSize === null) {
    imageSize = DEFAULT_IMAGE_STYLE_SIZE;
  }
  if (imageSize.length == 2) {
    const resizeScale = scaleForSize(imageSize);
    scale2 = scale2 / resizeScale;
  }
  if (scale2 !== 1) {
    properties["scale"] = scale2;
  }
  const rotation = style2.getRotation();
  if (rotation !== 0) {
    properties["heading"] = rotation;
  }
  const color2 = style2.getColor();
  if (color2) {
    properties["color"] = color2;
  }
  const parentNode = objectStack[objectStack.length - 1].node;
  const orderedKeys = ICON_STYLE_SEQUENCE[parentNode.namespaceURI];
  const values3 = makeSequence(properties, orderedKeys);
  pushSerializeAndPop(context2, ICON_STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values3, objectStack, orderedKeys);
}
const LABEL_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS$3, [
  "color",
  "scale"
]);
const LABEL_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {
  "color": makeChildAppender(writeColorTextNode),
  "scale": makeChildAppender(writeScaleTextNode)
});
function writeLabelStyle(node2, style2, objectStack) {
  const context2 = { node: node2 };
  const properties = {};
  const fill = style2.getFill();
  if (fill) {
    properties["color"] = fill.getColor();
  }
  const scale2 = style2.getScale();
  if (scale2 && scale2 !== 1) {
    properties["scale"] = scale2;
  }
  const parentNode = objectStack[objectStack.length - 1].node;
  const orderedKeys = LABEL_STYLE_SEQUENCE[parentNode.namespaceURI];
  const values3 = makeSequence(properties, orderedKeys);
  pushSerializeAndPop(context2, LABEL_STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values3, objectStack, orderedKeys);
}
const LINE_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS$3, ["color", "width"]);
const LINE_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {
  "color": makeChildAppender(writeColorTextNode),
  "width": makeChildAppender(writeDecimalTextNode)
});
function writeLineStyle(node2, style2, objectStack) {
  const context2 = { node: node2 };
  const properties = {
    "color": style2.getColor(),
    "width": Number(style2.getWidth()) || 1
  };
  const parentNode = objectStack[objectStack.length - 1].node;
  const orderedKeys = LINE_STYLE_SEQUENCE[parentNode.namespaceURI];
  const values3 = makeSequence(properties, orderedKeys);
  pushSerializeAndPop(context2, LINE_STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values3, objectStack, orderedKeys);
}
const GEOMETRY_TYPE_TO_NODENAME = {
  "Point": "Point",
  "LineString": "LineString",
  "LinearRing": "LinearRing",
  "Polygon": "Polygon",
  "MultiPoint": "MultiGeometry",
  "MultiLineString": "MultiGeometry",
  "MultiPolygon": "MultiGeometry",
  "GeometryCollection": "MultiGeometry"
};
const GEOMETRY_NODE_FACTORY = function(value, objectStack, nodeName) {
  if (value) {
    const parentNode = objectStack[objectStack.length - 1].node;
    return createElementNS(parentNode.namespaceURI, GEOMETRY_TYPE_TO_NODENAME[value.getType()]);
  }
};
const POINT_NODE_FACTORY = makeSimpleNodeFactory("Point");
const LINE_STRING_NODE_FACTORY = makeSimpleNodeFactory("LineString");
const LINEAR_RING_NODE_FACTORY = makeSimpleNodeFactory("LinearRing");
const POLYGON_NODE_FACTORY = makeSimpleNodeFactory("Polygon");
const MULTI_GEOMETRY_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {
  "LineString": makeChildAppender(writePrimitiveGeometry),
  "Point": makeChildAppender(writePrimitiveGeometry),
  "Polygon": makeChildAppender(writePolygon),
  "GeometryCollection": makeChildAppender(writeMultiGeometry)
});
function writeMultiGeometry(node2, geometry, objectStack) {
  const context2 = { node: node2 };
  const type = geometry.getType();
  let geometries = [];
  let factory;
  if (type === "GeometryCollection") {
    geometry.getGeometriesArrayRecursive().forEach(function(geometry2) {
      const type2 = geometry2.getType();
      if (type2 === "MultiPoint") {
        geometries = geometries.concat(geometry2.getPoints());
      } else if (type2 === "MultiLineString") {
        geometries = geometries.concat(geometry2.getLineStrings());
      } else if (type2 === "MultiPolygon") {
        geometries = geometries.concat(geometry2.getPolygons());
      } else if (type2 === "Point" || type2 === "LineString" || type2 === "Polygon") {
        geometries.push(geometry2);
      } else {
        assert(false, 39);
      }
    });
    factory = GEOMETRY_NODE_FACTORY;
  } else if (type === "MultiPoint") {
    geometries = geometry.getPoints();
    factory = POINT_NODE_FACTORY;
  } else if (type === "MultiLineString") {
    geometries = geometry.getLineStrings();
    factory = LINE_STRING_NODE_FACTORY;
  } else if (type === "MultiPolygon") {
    geometries = geometry.getPolygons();
    factory = POLYGON_NODE_FACTORY;
  } else {
    assert(false, 39);
  }
  pushSerializeAndPop(context2, MULTI_GEOMETRY_SERIALIZERS, factory, geometries, objectStack);
}
const BOUNDARY_IS_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {
  "LinearRing": makeChildAppender(writePrimitiveGeometry)
});
function writeBoundaryIs(node2, linearRing2, objectStack) {
  const context2 = { node: node2 };
  pushSerializeAndPop(context2, BOUNDARY_IS_SERIALIZERS, LINEAR_RING_NODE_FACTORY, [linearRing2], objectStack);
}
const PLACEMARK_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {
  "ExtendedData": makeChildAppender(writeExtendedData),
  "MultiGeometry": makeChildAppender(writeMultiGeometry),
  "LineString": makeChildAppender(writePrimitiveGeometry),
  "LinearRing": makeChildAppender(writePrimitiveGeometry),
  "Point": makeChildAppender(writePrimitiveGeometry),
  "Polygon": makeChildAppender(writePolygon),
  "Style": makeChildAppender(writeStyle),
  "address": makeChildAppender(writeStringTextNode),
  "description": makeChildAppender(writeStringTextNode),
  "name": makeChildAppender(writeStringTextNode),
  "open": makeChildAppender(writeBooleanTextNode),
  "phoneNumber": makeChildAppender(writeStringTextNode),
  "styleUrl": makeChildAppender(writeStringTextNode),
  "visibility": makeChildAppender(writeBooleanTextNode)
});
const PLACEMARK_SEQUENCE = makeStructureNS(NAMESPACE_URIS$3, [
  "name",
  "open",
  "visibility",
  "address",
  "phoneNumber",
  "description",
  "styleUrl",
  "Style"
]);
const EXTENDEDDATA_NODE_FACTORY = makeSimpleNodeFactory("ExtendedData");
function writePlacemark(node2, feature, objectStack) {
  const context2 = { node: node2 };
  if (feature.getId()) {
    node2.setAttribute("id", feature.getId());
  }
  const properties = feature.getProperties();
  const filter = {
    "address": 1,
    "description": 1,
    "name": 1,
    "open": 1,
    "phoneNumber": 1,
    "styleUrl": 1,
    "visibility": 1
  };
  filter[feature.getGeometryName()] = 1;
  const keys3 = Object.keys(properties || {}).sort().filter(function(v2) {
    return !filter[v2];
  });
  const styleFunction = feature.getStyleFunction();
  if (styleFunction) {
    const styles = styleFunction(feature, 0);
    if (styles) {
      const styleArray = Array.isArray(styles) ? styles : [styles];
      let pointStyles = styleArray;
      if (feature.getGeometry()) {
        pointStyles = styleArray.filter(function(style2) {
          const geometry2 = style2.getGeometryFunction()(feature);
          if (geometry2) {
            const type = geometry2.getType();
            if (type === "GeometryCollection") {
              return geometry2.getGeometriesArrayRecursive().filter(function(geometry3) {
                const type2 = geometry3.getType();
                return type2 === "Point" || type2 === "MultiPoint";
              }).length;
            }
            return type === "Point" || type === "MultiPoint";
          }
        });
      }
      if (this.writeStyles_) {
        let lineStyles = styleArray;
        let polyStyles = styleArray;
        if (feature.getGeometry()) {
          lineStyles = styleArray.filter(function(style2) {
            const geometry2 = style2.getGeometryFunction()(feature);
            if (geometry2) {
              const type = geometry2.getType();
              if (type === "GeometryCollection") {
                return geometry2.getGeometriesArrayRecursive().filter(function(geometry3) {
                  const type2 = geometry3.getType();
                  return type2 === "LineString" || type2 === "MultiLineString";
                }).length;
              }
              return type === "LineString" || type === "MultiLineString";
            }
          });
          polyStyles = styleArray.filter(function(style2) {
            const geometry2 = style2.getGeometryFunction()(feature);
            if (geometry2) {
              const type = geometry2.getType();
              if (type === "GeometryCollection") {
                return geometry2.getGeometriesArrayRecursive().filter(function(geometry3) {
                  const type2 = geometry3.getType();
                  return type2 === "Polygon" || type2 === "MultiPolygon";
                }).length;
              }
              return type === "Polygon" || type === "MultiPolygon";
            }
          });
        }
        properties["Style"] = {
          pointStyles,
          lineStyles,
          polyStyles
        };
      }
      if (pointStyles.length && properties["name"] === void 0) {
        const textStyle = pointStyles[0].getText();
        if (textStyle) {
          properties["name"] = textStyle.getText();
        }
      }
    }
  }
  const parentNode = objectStack[objectStack.length - 1].node;
  const orderedKeys = PLACEMARK_SEQUENCE[parentNode.namespaceURI];
  const values3 = makeSequence(properties, orderedKeys);
  pushSerializeAndPop(context2, PLACEMARK_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values3, objectStack, orderedKeys);
  if (keys3.length > 0) {
    const sequence = makeSequence(properties, keys3);
    const namesAndValues = { names: keys3, values: sequence };
    pushSerializeAndPop(context2, PLACEMARK_SERIALIZERS, EXTENDEDDATA_NODE_FACTORY, [namesAndValues], objectStack);
  }
  const options = objectStack[0];
  let geometry = feature.getGeometry();
  if (geometry) {
    geometry = transformGeometryWithOptions(geometry, true, options);
  }
  pushSerializeAndPop(context2, PLACEMARK_SERIALIZERS, GEOMETRY_NODE_FACTORY, [geometry], objectStack);
}
const PRIMITIVE_GEOMETRY_SEQUENCE = makeStructureNS(NAMESPACE_URIS$3, [
  "extrude",
  "tessellate",
  "altitudeMode",
  "coordinates"
]);
const PRIMITIVE_GEOMETRY_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {
  "extrude": makeChildAppender(writeBooleanTextNode),
  "tessellate": makeChildAppender(writeBooleanTextNode),
  "altitudeMode": makeChildAppender(writeStringTextNode),
  "coordinates": makeChildAppender(writeCoordinatesTextNode)
});
function writePrimitiveGeometry(node2, geometry, objectStack) {
  const flatCoordinates = geometry.getFlatCoordinates();
  const context2 = { node: node2 };
  context2["layout"] = geometry.getLayout();
  context2["stride"] = geometry.getStride();
  const properties = geometry.getProperties();
  properties.coordinates = flatCoordinates;
  const parentNode = objectStack[objectStack.length - 1].node;
  const orderedKeys = PRIMITIVE_GEOMETRY_SEQUENCE[parentNode.namespaceURI];
  const values3 = makeSequence(properties, orderedKeys);
  pushSerializeAndPop(context2, PRIMITIVE_GEOMETRY_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values3, objectStack, orderedKeys);
}
const POLY_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS$3, [
  "color",
  "fill",
  "outline"
]);
const POLYGON_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {
  "outerBoundaryIs": makeChildAppender(writeBoundaryIs),
  "innerBoundaryIs": makeChildAppender(writeBoundaryIs)
});
const INNER_BOUNDARY_NODE_FACTORY = makeSimpleNodeFactory("innerBoundaryIs");
const OUTER_BOUNDARY_NODE_FACTORY = makeSimpleNodeFactory("outerBoundaryIs");
function writePolygon(node2, polygon, objectStack) {
  const linearRings2 = polygon.getLinearRings();
  const outerRing = linearRings2.shift();
  const context2 = { node: node2 };
  pushSerializeAndPop(context2, POLYGON_SERIALIZERS, INNER_BOUNDARY_NODE_FACTORY, linearRings2, objectStack);
  pushSerializeAndPop(context2, POLYGON_SERIALIZERS, OUTER_BOUNDARY_NODE_FACTORY, [outerRing], objectStack);
}
const POLY_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {
  "color": makeChildAppender(writeColorTextNode),
  "fill": makeChildAppender(writeBooleanTextNode),
  "outline": makeChildAppender(writeBooleanTextNode)
});
function writePolyStyle(node2, style2, objectStack) {
  const context2 = { node: node2 };
  const fill = style2.getFill();
  const stroke = style2.getStroke();
  const properties = {
    "color": fill ? fill.getColor() : void 0,
    "fill": fill ? void 0 : false,
    "outline": stroke ? void 0 : false
  };
  const parentNode = objectStack[objectStack.length - 1].node;
  const orderedKeys = POLY_STYLE_SEQUENCE[parentNode.namespaceURI];
  const values3 = makeSequence(properties, orderedKeys);
  pushSerializeAndPop(context2, POLY_STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values3, objectStack, orderedKeys);
}
function writeScaleTextNode(node2, scale2) {
  writeDecimalTextNode(node2, Math.round(scale2 * 1e6) / 1e6);
}
const STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS$3, [
  "IconStyle",
  "LabelStyle",
  "LineStyle",
  "PolyStyle"
]);
const STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {
  "IconStyle": makeChildAppender(writeIconStyle),
  "LabelStyle": makeChildAppender(writeLabelStyle),
  "LineStyle": makeChildAppender(writeLineStyle),
  "PolyStyle": makeChildAppender(writePolyStyle)
});
function writeStyle(node2, styles, objectStack) {
  const context2 = { node: node2 };
  const properties = {};
  if (styles.pointStyles.length) {
    const textStyle = styles.pointStyles[0].getText();
    if (textStyle) {
      properties["LabelStyle"] = textStyle;
    }
    const imageStyle = styles.pointStyles[0].getImage();
    if (imageStyle && typeof imageStyle.getSrc === "function") {
      properties["IconStyle"] = imageStyle;
    }
  }
  if (styles.lineStyles.length) {
    const strokeStyle = styles.lineStyles[0].getStroke();
    if (strokeStyle) {
      properties["LineStyle"] = strokeStyle;
    }
  }
  if (styles.polyStyles.length) {
    const strokeStyle = styles.polyStyles[0].getStroke();
    if (strokeStyle && !properties["LineStyle"]) {
      properties["LineStyle"] = strokeStyle;
    }
    properties["PolyStyle"] = styles.polyStyles[0];
  }
  const parentNode = objectStack[objectStack.length - 1].node;
  const orderedKeys = STYLE_SEQUENCE[parentNode.namespaceURI];
  const values3 = makeSequence(properties, orderedKeys);
  pushSerializeAndPop(context2, STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values3, objectStack, orderedKeys);
}
function writeVec2(node2, vec2) {
  node2.setAttribute("x", String(vec2.x));
  node2.setAttribute("y", String(vec2.y));
  node2.setAttribute("xunits", vec2.xunits);
  node2.setAttribute("yunits", vec2.yunits);
}
var ieee754$1 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754$1.read = function(buffer2, offset2, isLE, mLen, nBytes) {
  var e2, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i2 = isLE ? nBytes - 1 : 0;
  var d2 = isLE ? -1 : 1;
  var s2 = buffer2[offset2 + i2];
  i2 += d2;
  e2 = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e2 = e2 * 256 + buffer2[offset2 + i2], i2 += d2, nBits -= 8) {
  }
  m2 = e2 & (1 << -nBits) - 1;
  e2 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer2[offset2 + i2], i2 += d2, nBits -= 8) {
  }
  if (e2 === 0) {
    e2 = 1 - eBias;
  } else if (e2 === eMax) {
    return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e2 = e2 - eBias;
  }
  return (s2 ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
};
ieee754$1.write = function(buffer2, value, offset2, isLE, mLen, nBytes) {
  var e2, m2, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i2 = isLE ? 0 : nBytes - 1;
  var d2 = isLE ? 1 : -1;
  var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m2 = isNaN(value) ? 1 : 0;
    e2 = eMax;
  } else {
    e2 = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c2 = Math.pow(2, -e2)) < 1) {
      e2--;
      c2 *= 2;
    }
    if (e2 + eBias >= 1) {
      value += rt2 / c2;
    } else {
      value += rt2 * Math.pow(2, 1 - eBias);
    }
    if (value * c2 >= 2) {
      e2++;
      c2 /= 2;
    }
    if (e2 + eBias >= eMax) {
      m2 = 0;
      e2 = eMax;
    } else if (e2 + eBias >= 1) {
      m2 = (value * c2 - 1) * Math.pow(2, mLen);
      e2 = e2 + eBias;
    } else {
      m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e2 = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset2 + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {
  }
  e2 = e2 << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset2 + i2] = e2 & 255, i2 += d2, e2 /= 256, eLen -= 8) {
  }
  buffer2[offset2 + i2 - d2] |= s2 * 128;
};
var pbf = Pbf;
var ieee754 = ieee754$1;
function Pbf(buf) {
  this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
  this.pos = 0;
  this.type = 0;
  this.length = this.buf.length;
}
Pbf.Varint = 0;
Pbf.Fixed64 = 1;
Pbf.Bytes = 2;
Pbf.Fixed32 = 5;
var SHIFT_LEFT_32 = (1 << 16) * (1 << 16), SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
var TEXT_DECODER_MIN_LENGTH = 12;
var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf8");
Pbf.prototype = {
  destroy: function() {
    this.buf = null;
  },
  readFields: function(readField, result, end) {
    end = end || this.length;
    while (this.pos < end) {
      var val = this.readVarint(), tag = val >> 3, startPos = this.pos;
      this.type = val & 7;
      readField(tag, result, this);
      if (this.pos === startPos)
        this.skip(val);
    }
    return result;
  },
  readMessage: function(readField, result) {
    return this.readFields(readField, result, this.readVarint() + this.pos);
  },
  readFixed32: function() {
    var val = readUInt32(this.buf, this.pos);
    this.pos += 4;
    return val;
  },
  readSFixed32: function() {
    var val = readInt32(this.buf, this.pos);
    this.pos += 4;
    return val;
  },
  readFixed64: function() {
    var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
    this.pos += 8;
    return val;
  },
  readSFixed64: function() {
    var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
    this.pos += 8;
    return val;
  },
  readFloat: function() {
    var val = ieee754.read(this.buf, this.pos, true, 23, 4);
    this.pos += 4;
    return val;
  },
  readDouble: function() {
    var val = ieee754.read(this.buf, this.pos, true, 52, 8);
    this.pos += 8;
    return val;
  },
  readVarint: function(isSigned) {
    var buf = this.buf, val, b2;
    b2 = buf[this.pos++];
    val = b2 & 127;
    if (b2 < 128)
      return val;
    b2 = buf[this.pos++];
    val |= (b2 & 127) << 7;
    if (b2 < 128)
      return val;
    b2 = buf[this.pos++];
    val |= (b2 & 127) << 14;
    if (b2 < 128)
      return val;
    b2 = buf[this.pos++];
    val |= (b2 & 127) << 21;
    if (b2 < 128)
      return val;
    b2 = buf[this.pos];
    val |= (b2 & 15) << 28;
    return readVarintRemainder(val, isSigned, this);
  },
  readVarint64: function() {
    return this.readVarint(true);
  },
  readSVarint: function() {
    var num = this.readVarint();
    return num % 2 === 1 ? (num + 1) / -2 : num / 2;
  },
  readBoolean: function() {
    return Boolean(this.readVarint());
  },
  readString: function() {
    var end = this.readVarint() + this.pos;
    var pos = this.pos;
    this.pos = end;
    if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {
      return readUtf8TextDecoder(this.buf, pos, end);
    }
    return readUtf8(this.buf, pos, end);
  },
  readBytes: function() {
    var end = this.readVarint() + this.pos, buffer2 = this.buf.subarray(this.pos, end);
    this.pos = end;
    return buffer2;
  },
  readPackedVarint: function(arr, isSigned) {
    if (this.type !== Pbf.Bytes)
      return arr.push(this.readVarint(isSigned));
    var end = readPackedEnd(this);
    arr = arr || [];
    while (this.pos < end)
      arr.push(this.readVarint(isSigned));
    return arr;
  },
  readPackedSVarint: function(arr) {
    if (this.type !== Pbf.Bytes)
      return arr.push(this.readSVarint());
    var end = readPackedEnd(this);
    arr = arr || [];
    while (this.pos < end)
      arr.push(this.readSVarint());
    return arr;
  },
  readPackedBoolean: function(arr) {
    if (this.type !== Pbf.Bytes)
      return arr.push(this.readBoolean());
    var end = readPackedEnd(this);
    arr = arr || [];
    while (this.pos < end)
      arr.push(this.readBoolean());
    return arr;
  },
  readPackedFloat: function(arr) {
    if (this.type !== Pbf.Bytes)
      return arr.push(this.readFloat());
    var end = readPackedEnd(this);
    arr = arr || [];
    while (this.pos < end)
      arr.push(this.readFloat());
    return arr;
  },
  readPackedDouble: function(arr) {
    if (this.type !== Pbf.Bytes)
      return arr.push(this.readDouble());
    var end = readPackedEnd(this);
    arr = arr || [];
    while (this.pos < end)
      arr.push(this.readDouble());
    return arr;
  },
  readPackedFixed32: function(arr) {
    if (this.type !== Pbf.Bytes)
      return arr.push(this.readFixed32());
    var end = readPackedEnd(this);
    arr = arr || [];
    while (this.pos < end)
      arr.push(this.readFixed32());
    return arr;
  },
  readPackedSFixed32: function(arr) {
    if (this.type !== Pbf.Bytes)
      return arr.push(this.readSFixed32());
    var end = readPackedEnd(this);
    arr = arr || [];
    while (this.pos < end)
      arr.push(this.readSFixed32());
    return arr;
  },
  readPackedFixed64: function(arr) {
    if (this.type !== Pbf.Bytes)
      return arr.push(this.readFixed64());
    var end = readPackedEnd(this);
    arr = arr || [];
    while (this.pos < end)
      arr.push(this.readFixed64());
    return arr;
  },
  readPackedSFixed64: function(arr) {
    if (this.type !== Pbf.Bytes)
      return arr.push(this.readSFixed64());
    var end = readPackedEnd(this);
    arr = arr || [];
    while (this.pos < end)
      arr.push(this.readSFixed64());
    return arr;
  },
  skip: function(val) {
    var type = val & 7;
    if (type === Pbf.Varint)
      while (this.buf[this.pos++] > 127) {
      }
    else if (type === Pbf.Bytes)
      this.pos = this.readVarint() + this.pos;
    else if (type === Pbf.Fixed32)
      this.pos += 4;
    else if (type === Pbf.Fixed64)
      this.pos += 8;
    else
      throw new Error("Unimplemented type: " + type);
  },
  writeTag: function(tag, type) {
    this.writeVarint(tag << 3 | type);
  },
  realloc: function(min2) {
    var length = this.length || 16;
    while (length < this.pos + min2)
      length *= 2;
    if (length !== this.length) {
      var buf = new Uint8Array(length);
      buf.set(this.buf);
      this.buf = buf;
      this.length = length;
    }
  },
  finish: function() {
    this.length = this.pos;
    this.pos = 0;
    return this.buf.subarray(0, this.length);
  },
  writeFixed32: function(val) {
    this.realloc(4);
    writeInt32(this.buf, val, this.pos);
    this.pos += 4;
  },
  writeSFixed32: function(val) {
    this.realloc(4);
    writeInt32(this.buf, val, this.pos);
    this.pos += 4;
  },
  writeFixed64: function(val) {
    this.realloc(8);
    writeInt32(this.buf, val & -1, this.pos);
    writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
    this.pos += 8;
  },
  writeSFixed64: function(val) {
    this.realloc(8);
    writeInt32(this.buf, val & -1, this.pos);
    writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
    this.pos += 8;
  },
  writeVarint: function(val) {
    val = +val || 0;
    if (val > 268435455 || val < 0) {
      writeBigVarint(val, this);
      return;
    }
    this.realloc(4);
    this.buf[this.pos++] = val & 127 | (val > 127 ? 128 : 0);
    if (val <= 127)
      return;
    this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
    if (val <= 127)
      return;
    this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
    if (val <= 127)
      return;
    this.buf[this.pos++] = val >>> 7 & 127;
  },
  writeSVarint: function(val) {
    this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
  },
  writeBoolean: function(val) {
    this.writeVarint(Boolean(val));
  },
  writeString: function(str) {
    str = String(str);
    this.realloc(str.length * 4);
    this.pos++;
    var startPos = this.pos;
    this.pos = writeUtf8(this.buf, str, this.pos);
    var len = this.pos - startPos;
    if (len >= 128)
      makeRoomForExtraLength(startPos, len, this);
    this.pos = startPos - 1;
    this.writeVarint(len);
    this.pos += len;
  },
  writeFloat: function(val) {
    this.realloc(4);
    ieee754.write(this.buf, val, this.pos, true, 23, 4);
    this.pos += 4;
  },
  writeDouble: function(val) {
    this.realloc(8);
    ieee754.write(this.buf, val, this.pos, true, 52, 8);
    this.pos += 8;
  },
  writeBytes: function(buffer2) {
    var len = buffer2.length;
    this.writeVarint(len);
    this.realloc(len);
    for (var i2 = 0; i2 < len; i2++)
      this.buf[this.pos++] = buffer2[i2];
  },
  writeRawMessage: function(fn, obj) {
    this.pos++;
    var startPos = this.pos;
    fn(obj, this);
    var len = this.pos - startPos;
    if (len >= 128)
      makeRoomForExtraLength(startPos, len, this);
    this.pos = startPos - 1;
    this.writeVarint(len);
    this.pos += len;
  },
  writeMessage: function(tag, fn, obj) {
    this.writeTag(tag, Pbf.Bytes);
    this.writeRawMessage(fn, obj);
  },
  writePackedVarint: function(tag, arr) {
    if (arr.length)
      this.writeMessage(tag, writePackedVarint, arr);
  },
  writePackedSVarint: function(tag, arr) {
    if (arr.length)
      this.writeMessage(tag, writePackedSVarint, arr);
  },
  writePackedBoolean: function(tag, arr) {
    if (arr.length)
      this.writeMessage(tag, writePackedBoolean, arr);
  },
  writePackedFloat: function(tag, arr) {
    if (arr.length)
      this.writeMessage(tag, writePackedFloat, arr);
  },
  writePackedDouble: function(tag, arr) {
    if (arr.length)
      this.writeMessage(tag, writePackedDouble, arr);
  },
  writePackedFixed32: function(tag, arr) {
    if (arr.length)
      this.writeMessage(tag, writePackedFixed32, arr);
  },
  writePackedSFixed32: function(tag, arr) {
    if (arr.length)
      this.writeMessage(tag, writePackedSFixed32, arr);
  },
  writePackedFixed64: function(tag, arr) {
    if (arr.length)
      this.writeMessage(tag, writePackedFixed64, arr);
  },
  writePackedSFixed64: function(tag, arr) {
    if (arr.length)
      this.writeMessage(tag, writePackedSFixed64, arr);
  },
  writeBytesField: function(tag, buffer2) {
    this.writeTag(tag, Pbf.Bytes);
    this.writeBytes(buffer2);
  },
  writeFixed32Field: function(tag, val) {
    this.writeTag(tag, Pbf.Fixed32);
    this.writeFixed32(val);
  },
  writeSFixed32Field: function(tag, val) {
    this.writeTag(tag, Pbf.Fixed32);
    this.writeSFixed32(val);
  },
  writeFixed64Field: function(tag, val) {
    this.writeTag(tag, Pbf.Fixed64);
    this.writeFixed64(val);
  },
  writeSFixed64Field: function(tag, val) {
    this.writeTag(tag, Pbf.Fixed64);
    this.writeSFixed64(val);
  },
  writeVarintField: function(tag, val) {
    this.writeTag(tag, Pbf.Varint);
    this.writeVarint(val);
  },
  writeSVarintField: function(tag, val) {
    this.writeTag(tag, Pbf.Varint);
    this.writeSVarint(val);
  },
  writeStringField: function(tag, str) {
    this.writeTag(tag, Pbf.Bytes);
    this.writeString(str);
  },
  writeFloatField: function(tag, val) {
    this.writeTag(tag, Pbf.Fixed32);
    this.writeFloat(val);
  },
  writeDoubleField: function(tag, val) {
    this.writeTag(tag, Pbf.Fixed64);
    this.writeDouble(val);
  },
  writeBooleanField: function(tag, val) {
    this.writeVarintField(tag, Boolean(val));
  }
};
function readVarintRemainder(l2, s2, p5) {
  var buf = p5.buf, h2, b2;
  b2 = buf[p5.pos++];
  h2 = (b2 & 112) >> 4;
  if (b2 < 128)
    return toNum(l2, h2, s2);
  b2 = buf[p5.pos++];
  h2 |= (b2 & 127) << 3;
  if (b2 < 128)
    return toNum(l2, h2, s2);
  b2 = buf[p5.pos++];
  h2 |= (b2 & 127) << 10;
  if (b2 < 128)
    return toNum(l2, h2, s2);
  b2 = buf[p5.pos++];
  h2 |= (b2 & 127) << 17;
  if (b2 < 128)
    return toNum(l2, h2, s2);
  b2 = buf[p5.pos++];
  h2 |= (b2 & 127) << 24;
  if (b2 < 128)
    return toNum(l2, h2, s2);
  b2 = buf[p5.pos++];
  h2 |= (b2 & 1) << 31;
  if (b2 < 128)
    return toNum(l2, h2, s2);
  throw new Error("Expected varint not more than 10 bytes");
}
function readPackedEnd(pbf2) {
  return pbf2.type === Pbf.Bytes ? pbf2.readVarint() + pbf2.pos : pbf2.pos + 1;
}
function toNum(low, high, isSigned) {
  if (isSigned) {
    return high * 4294967296 + (low >>> 0);
  }
  return (high >>> 0) * 4294967296 + (low >>> 0);
}
function writeBigVarint(val, pbf2) {
  var low, high;
  if (val >= 0) {
    low = val % 4294967296 | 0;
    high = val / 4294967296 | 0;
  } else {
    low = ~(-val % 4294967296);
    high = ~(-val / 4294967296);
    if (low ^ 4294967295) {
      low = low + 1 | 0;
    } else {
      low = 0;
      high = high + 1 | 0;
    }
  }
  if (val >= 18446744073709552e3 || val < -18446744073709552e3) {
    throw new Error("Given varint doesn't fit into 10 bytes");
  }
  pbf2.realloc(10);
  writeBigVarintLow(low, high, pbf2);
  writeBigVarintHigh(high, pbf2);
}
function writeBigVarintLow(low, high, pbf2) {
  pbf2.buf[pbf2.pos++] = low & 127 | 128;
  low >>>= 7;
  pbf2.buf[pbf2.pos++] = low & 127 | 128;
  low >>>= 7;
  pbf2.buf[pbf2.pos++] = low & 127 | 128;
  low >>>= 7;
  pbf2.buf[pbf2.pos++] = low & 127 | 128;
  low >>>= 7;
  pbf2.buf[pbf2.pos] = low & 127;
}
function writeBigVarintHigh(high, pbf2) {
  var lsb = (high & 7) << 4;
  pbf2.buf[pbf2.pos++] |= lsb | ((high >>>= 3) ? 128 : 0);
  if (!high)
    return;
  pbf2.buf[pbf2.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
  if (!high)
    return;
  pbf2.buf[pbf2.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
  if (!high)
    return;
  pbf2.buf[pbf2.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
  if (!high)
    return;
  pbf2.buf[pbf2.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
  if (!high)
    return;
  pbf2.buf[pbf2.pos++] = high & 127;
}
function makeRoomForExtraLength(startPos, len, pbf2) {
  var extraLen = len <= 16383 ? 1 : len <= 2097151 ? 2 : len <= 268435455 ? 3 : Math.floor(Math.log(len) / (Math.LN2 * 7));
  pbf2.realloc(extraLen);
  for (var i2 = pbf2.pos - 1; i2 >= startPos; i2--)
    pbf2.buf[i2 + extraLen] = pbf2.buf[i2];
}
function writePackedVarint(arr, pbf2) {
  for (var i2 = 0; i2 < arr.length; i2++)
    pbf2.writeVarint(arr[i2]);
}
function writePackedSVarint(arr, pbf2) {
  for (var i2 = 0; i2 < arr.length; i2++)
    pbf2.writeSVarint(arr[i2]);
}
function writePackedFloat(arr, pbf2) {
  for (var i2 = 0; i2 < arr.length; i2++)
    pbf2.writeFloat(arr[i2]);
}
function writePackedDouble(arr, pbf2) {
  for (var i2 = 0; i2 < arr.length; i2++)
    pbf2.writeDouble(arr[i2]);
}
function writePackedBoolean(arr, pbf2) {
  for (var i2 = 0; i2 < arr.length; i2++)
    pbf2.writeBoolean(arr[i2]);
}
function writePackedFixed32(arr, pbf2) {
  for (var i2 = 0; i2 < arr.length; i2++)
    pbf2.writeFixed32(arr[i2]);
}
function writePackedSFixed32(arr, pbf2) {
  for (var i2 = 0; i2 < arr.length; i2++)
    pbf2.writeSFixed32(arr[i2]);
}
function writePackedFixed64(arr, pbf2) {
  for (var i2 = 0; i2 < arr.length; i2++)
    pbf2.writeFixed64(arr[i2]);
}
function writePackedSFixed64(arr, pbf2) {
  for (var i2 = 0; i2 < arr.length; i2++)
    pbf2.writeSFixed64(arr[i2]);
}
function readUInt32(buf, pos) {
  return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + buf[pos + 3] * 16777216;
}
function writeInt32(buf, val, pos) {
  buf[pos] = val;
  buf[pos + 1] = val >>> 8;
  buf[pos + 2] = val >>> 16;
  buf[pos + 3] = val >>> 24;
}
function readInt32(buf, pos) {
  return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + (buf[pos + 3] << 24);
}
function readUtf8(buf, pos, end) {
  var str = "";
  var i2 = pos;
  while (i2 < end) {
    var b0 = buf[i2];
    var c2 = null;
    var bytesPerSequence = b0 > 239 ? 4 : b0 > 223 ? 3 : b0 > 191 ? 2 : 1;
    if (i2 + bytesPerSequence > end)
      break;
    var b1, b2, b3;
    if (bytesPerSequence === 1) {
      if (b0 < 128) {
        c2 = b0;
      }
    } else if (bytesPerSequence === 2) {
      b1 = buf[i2 + 1];
      if ((b1 & 192) === 128) {
        c2 = (b0 & 31) << 6 | b1 & 63;
        if (c2 <= 127) {
          c2 = null;
        }
      }
    } else if (bytesPerSequence === 3) {
      b1 = buf[i2 + 1];
      b2 = buf[i2 + 2];
      if ((b1 & 192) === 128 && (b2 & 192) === 128) {
        c2 = (b0 & 15) << 12 | (b1 & 63) << 6 | b2 & 63;
        if (c2 <= 2047 || c2 >= 55296 && c2 <= 57343) {
          c2 = null;
        }
      }
    } else if (bytesPerSequence === 4) {
      b1 = buf[i2 + 1];
      b2 = buf[i2 + 2];
      b3 = buf[i2 + 3];
      if ((b1 & 192) === 128 && (b2 & 192) === 128 && (b3 & 192) === 128) {
        c2 = (b0 & 15) << 18 | (b1 & 63) << 12 | (b2 & 63) << 6 | b3 & 63;
        if (c2 <= 65535 || c2 >= 1114112) {
          c2 = null;
        }
      }
    }
    if (c2 === null) {
      c2 = 65533;
      bytesPerSequence = 1;
    } else if (c2 > 65535) {
      c2 -= 65536;
      str += String.fromCharCode(c2 >>> 10 & 1023 | 55296);
      c2 = 56320 | c2 & 1023;
    }
    str += String.fromCharCode(c2);
    i2 += bytesPerSequence;
  }
  return str;
}
function readUtf8TextDecoder(buf, pos, end) {
  return utf8TextDecoder.decode(buf.subarray(pos, end));
}
function writeUtf8(buf, str, pos) {
  for (var i2 = 0, c2, lead; i2 < str.length; i2++) {
    c2 = str.charCodeAt(i2);
    if (c2 > 55295 && c2 < 57344) {
      if (lead) {
        if (c2 < 56320) {
          buf[pos++] = 239;
          buf[pos++] = 191;
          buf[pos++] = 189;
          lead = c2;
          continue;
        } else {
          c2 = lead - 55296 << 10 | c2 - 56320 | 65536;
          lead = null;
        }
      } else {
        if (c2 > 56319 || i2 + 1 === str.length) {
          buf[pos++] = 239;
          buf[pos++] = 191;
          buf[pos++] = 189;
        } else {
          lead = c2;
        }
        continue;
      }
    } else if (lead) {
      buf[pos++] = 239;
      buf[pos++] = 191;
      buf[pos++] = 189;
      lead = null;
    }
    if (c2 < 128) {
      buf[pos++] = c2;
    } else {
      if (c2 < 2048) {
        buf[pos++] = c2 >> 6 | 192;
      } else {
        if (c2 < 65536) {
          buf[pos++] = c2 >> 12 | 224;
        } else {
          buf[pos++] = c2 >> 18 | 240;
          buf[pos++] = c2 >> 12 & 63 | 128;
        }
        buf[pos++] = c2 >> 6 & 63 | 128;
      }
      buf[pos++] = c2 & 63 | 128;
    }
  }
  return pos;
}
const tmpTransform = create$7();
class RenderFeature {
  constructor(type, flatCoordinates, ends, properties, id) {
    this.styleFunction;
    this.extent_;
    this.id_ = id;
    this.type_ = type;
    this.flatCoordinates_ = flatCoordinates;
    this.flatInteriorPoints_ = null;
    this.flatMidpoints_ = null;
    this.ends_ = ends;
    this.properties_ = properties;
  }
  get(key) {
    return this.properties_[key];
  }
  getExtent() {
    if (!this.extent_) {
      this.extent_ = this.type_ === "Point" ? createOrUpdateFromCoordinate(this.flatCoordinates_) : createOrUpdateFromFlatCoordinates(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2);
    }
    return this.extent_;
  }
  getFlatInteriorPoint() {
    if (!this.flatInteriorPoints_) {
      const flatCenter = getCenter(this.getExtent());
      this.flatInteriorPoints_ = getInteriorPointOfArray(this.flatCoordinates_, 0, this.ends_, 2, flatCenter, 0);
    }
    return this.flatInteriorPoints_;
  }
  getFlatInteriorPoints() {
    if (!this.flatInteriorPoints_) {
      const flatCenters = linearRingss(this.flatCoordinates_, 0, this.ends_, 2);
      this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(this.flatCoordinates_, 0, this.ends_, 2, flatCenters);
    }
    return this.flatInteriorPoints_;
  }
  getFlatMidpoint() {
    if (!this.flatMidpoints_) {
      this.flatMidpoints_ = interpolatePoint(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, 0.5);
    }
    return this.flatMidpoints_;
  }
  getFlatMidpoints() {
    if (!this.flatMidpoints_) {
      this.flatMidpoints_ = [];
      const flatCoordinates = this.flatCoordinates_;
      let offset2 = 0;
      const ends = this.ends_;
      for (let i2 = 0, ii = ends.length; i2 < ii; ++i2) {
        const end = ends[i2];
        const midpoint = interpolatePoint(flatCoordinates, offset2, end, 2, 0.5);
        extend$3(this.flatMidpoints_, midpoint);
        offset2 = end;
      }
    }
    return this.flatMidpoints_;
  }
  getId() {
    return this.id_;
  }
  getOrientedFlatCoordinates() {
    return this.flatCoordinates_;
  }
  getGeometry() {
    return this;
  }
  getSimplifiedGeometry(squaredTolerance) {
    return this;
  }
  simplifyTransformed(squaredTolerance, transform2) {
    return this;
  }
  getProperties() {
    return this.properties_;
  }
  getStride() {
    return 2;
  }
  getStyleFunction() {
    return this.styleFunction;
  }
  getType() {
    return this.type_;
  }
  transform(projection) {
    projection = get$4(projection);
    const pixelExtent = projection.getExtent();
    const projectedExtent = projection.getWorldExtent();
    if (pixelExtent && projectedExtent) {
      const scale2 = getHeight(projectedExtent) / getHeight(pixelExtent);
      compose(tmpTransform, projectedExtent[0], projectedExtent[3], scale2, -scale2, 0, 0, 0);
      transform2D(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, tmpTransform, this.flatCoordinates_);
    }
  }
  getEnds() {
    return this.ends_;
  }
}
RenderFeature.prototype.getEndss = RenderFeature.prototype.getEnds;
RenderFeature.prototype.getFlatCoordinates = RenderFeature.prototype.getOrientedFlatCoordinates;
class MVT extends FeatureFormat {
  constructor(options) {
    super();
    options = options ? options : {};
    this.dataProjection = new Projection$2({
      code: "",
      units: "tile-pixels"
    });
    this.featureClass_ = options.featureClass ? options.featureClass : RenderFeature;
    this.geometryName_ = options.geometryName;
    this.layerName_ = options.layerName ? options.layerName : "layer";
    this.layers_ = options.layers ? options.layers : null;
    this.idProperty_ = options.idProperty;
    this.supportedMediaTypes = [
      "application/vnd.mapbox-vector-tile",
      "application/x-protobuf"
    ];
  }
  readRawGeometry_(pbf2, feature, flatCoordinates, ends) {
    pbf2.pos = feature.geometry;
    const end = pbf2.readVarint() + pbf2.pos;
    let cmd = 1;
    let length = 0;
    let x2 = 0;
    let y2 = 0;
    let coordsLen = 0;
    let currentEnd = 0;
    while (pbf2.pos < end) {
      if (!length) {
        const cmdLen = pbf2.readVarint();
        cmd = cmdLen & 7;
        length = cmdLen >> 3;
      }
      length--;
      if (cmd === 1 || cmd === 2) {
        x2 += pbf2.readSVarint();
        y2 += pbf2.readSVarint();
        if (cmd === 1) {
          if (coordsLen > currentEnd) {
            ends.push(coordsLen);
            currentEnd = coordsLen;
          }
        }
        flatCoordinates.push(x2, y2);
        coordsLen += 2;
      } else if (cmd === 7) {
        if (coordsLen > currentEnd) {
          flatCoordinates.push(flatCoordinates[currentEnd], flatCoordinates[currentEnd + 1]);
          coordsLen += 2;
        }
      } else {
        assert(false, 59);
      }
    }
    if (coordsLen > currentEnd) {
      ends.push(coordsLen);
      currentEnd = coordsLen;
    }
  }
  createFeature_(pbf2, rawFeature, options) {
    const type = rawFeature.type;
    if (type === 0) {
      return null;
    }
    let feature;
    const values3 = rawFeature.properties;
    let id;
    if (!this.idProperty_) {
      id = rawFeature.id;
    } else {
      id = values3[this.idProperty_];
      delete values3[this.idProperty_];
    }
    values3[this.layerName_] = rawFeature.layer.name;
    const flatCoordinates = [];
    const ends = [];
    this.readRawGeometry_(pbf2, rawFeature, flatCoordinates, ends);
    const geometryType = getGeometryType(type, ends.length);
    if (this.featureClass_ === RenderFeature) {
      feature = new this.featureClass_(geometryType, flatCoordinates, ends, values3, id);
      feature.transform(options.dataProjection);
    } else {
      let geom2;
      if (geometryType == "Polygon") {
        const endss = inflateEnds(flatCoordinates, ends);
        geom2 = endss.length > 1 ? new MultiPolygon$1(flatCoordinates, "XY", endss) : new Polygon$1(flatCoordinates, "XY", ends);
      } else {
        geom2 = geometryType === "Point" ? new Point$3(flatCoordinates, "XY") : geometryType === "LineString" ? new LineString$1(flatCoordinates, "XY") : geometryType === "MultiPoint" ? new MultiPoint$1(flatCoordinates, "XY") : geometryType === "MultiLineString" ? new MultiLineString$1(flatCoordinates, "XY", ends) : null;
      }
      const ctor = this.featureClass_;
      feature = new ctor();
      if (this.geometryName_) {
        feature.setGeometryName(this.geometryName_);
      }
      const geometry = transformGeometryWithOptions(geom2, false, options);
      feature.setGeometry(geometry);
      if (id !== void 0) {
        feature.setId(id);
      }
      feature.setProperties(values3, true);
    }
    return feature;
  }
  getType() {
    return "arraybuffer";
  }
  readFeatures(source, options) {
    const layers = this.layers_;
    options = this.adaptOptions(options);
    const dataProjection = get$4(options.dataProjection);
    dataProjection.setWorldExtent(options.extent);
    options.dataProjection = dataProjection;
    const pbf$1 = new pbf(source);
    const pbfLayers = pbf$1.readFields(layersPBFReader, {});
    const features = [];
    for (const name in pbfLayers) {
      if (layers && !layers.includes(name)) {
        continue;
      }
      const pbfLayer = pbfLayers[name];
      const extent2 = pbfLayer ? [0, 0, pbfLayer.extent, pbfLayer.extent] : null;
      dataProjection.setExtent(extent2);
      for (let i2 = 0, ii = pbfLayer.length; i2 < ii; ++i2) {
        const rawFeature = readRawFeature(pbf$1, pbfLayer, i2);
        const feature = this.createFeature_(pbf$1, rawFeature, options);
        if (feature !== null) {
          features.push(feature);
        }
      }
    }
    return features;
  }
  readProjection(source) {
    return this.dataProjection;
  }
  setLayers(layers) {
    this.layers_ = layers;
  }
}
function layersPBFReader(tag, layers, pbf2) {
  if (tag === 3) {
    const layer = {
      keys: [],
      values: [],
      features: []
    };
    const end = pbf2.readVarint() + pbf2.pos;
    pbf2.readFields(layerPBFReader, layer, end);
    layer.length = layer.features.length;
    if (layer.length) {
      layers[layer.name] = layer;
    }
  }
}
function layerPBFReader(tag, layer, pbf2) {
  if (tag === 15) {
    layer.version = pbf2.readVarint();
  } else if (tag === 1) {
    layer.name = pbf2.readString();
  } else if (tag === 5) {
    layer.extent = pbf2.readVarint();
  } else if (tag === 2) {
    layer.features.push(pbf2.pos);
  } else if (tag === 3) {
    layer.keys.push(pbf2.readString());
  } else if (tag === 4) {
    let value = null;
    const end = pbf2.readVarint() + pbf2.pos;
    while (pbf2.pos < end) {
      tag = pbf2.readVarint() >> 3;
      value = tag === 1 ? pbf2.readString() : tag === 2 ? pbf2.readFloat() : tag === 3 ? pbf2.readDouble() : tag === 4 ? pbf2.readVarint64() : tag === 5 ? pbf2.readVarint() : tag === 6 ? pbf2.readSVarint() : tag === 7 ? pbf2.readBoolean() : null;
    }
    layer.values.push(value);
  }
}
function featurePBFReader(tag, feature, pbf2) {
  if (tag == 1) {
    feature.id = pbf2.readVarint();
  } else if (tag == 2) {
    const end = pbf2.readVarint() + pbf2.pos;
    while (pbf2.pos < end) {
      const key = feature.layer.keys[pbf2.readVarint()];
      const value = feature.layer.values[pbf2.readVarint()];
      feature.properties[key] = value;
    }
  } else if (tag == 3) {
    feature.type = pbf2.readVarint();
  } else if (tag == 4) {
    feature.geometry = pbf2.pos;
  }
}
function readRawFeature(pbf2, layer, i2) {
  pbf2.pos = layer.features[i2];
  const end = pbf2.readVarint() + pbf2.pos;
  const feature = {
    layer,
    type: 0,
    properties: {}
  };
  pbf2.readFields(featurePBFReader, feature, end);
  return feature;
}
function getGeometryType(type, numEnds) {
  let geometryType;
  if (type === 1) {
    geometryType = numEnds === 1 ? "Point" : "MultiPoint";
  } else if (type === 2) {
    geometryType = numEnds === 1 ? "LineString" : "MultiLineString";
  } else if (type === 3) {
    geometryType = "Polygon";
  }
  return geometryType;
}
class XML {
  read(source) {
    if (!source) {
      return null;
    } else if (typeof source === "string") {
      const doc = parse$1(source);
      return this.readFromDocument(doc);
    } else if (isDocument(source)) {
      return this.readFromDocument(source);
    }
    return this.readFromNode(source);
  }
  readFromDocument(doc) {
    for (let n2 = doc.firstChild; n2; n2 = n2.nextSibling) {
      if (n2.nodeType == Node.ELEMENT_NODE) {
        return this.readFromNode(n2);
      }
    }
    return null;
  }
  readFromNode(node2) {
  }
}
const NAMESPACE_URI = "http://www.w3.org/1999/xlink";
function readHref(node2) {
  return node2.getAttributeNS(NAMESPACE_URI, "href");
}
const NAMESPACE_URIS$2 = [null, "http://www.opengis.net/ows/1.1"];
const PARSERS$2 = makeStructureNS(NAMESPACE_URIS$2, {
  "ServiceIdentification": makeObjectPropertySetter(readServiceIdentification),
  "ServiceProvider": makeObjectPropertySetter(readServiceProvider),
  "OperationsMetadata": makeObjectPropertySetter(readOperationsMetadata)
});
class OWS extends XML {
  constructor() {
    super();
  }
  readFromNode(node2) {
    const owsObject = pushParseAndPop({}, PARSERS$2, node2, []);
    return owsObject ? owsObject : null;
  }
}
const ADDRESS_PARSERS = makeStructureNS(NAMESPACE_URIS$2, {
  "DeliveryPoint": makeObjectPropertySetter(readString),
  "City": makeObjectPropertySetter(readString),
  "AdministrativeArea": makeObjectPropertySetter(readString),
  "PostalCode": makeObjectPropertySetter(readString),
  "Country": makeObjectPropertySetter(readString),
  "ElectronicMailAddress": makeObjectPropertySetter(readString)
});
const ALLOWED_VALUES_PARSERS = makeStructureNS(NAMESPACE_URIS$2, {
  "Value": makeObjectPropertyPusher(readValue)
});
const CONSTRAINT_PARSERS = makeStructureNS(NAMESPACE_URIS$2, {
  "AllowedValues": makeObjectPropertySetter(readAllowedValues)
});
const CONTACT_INFO_PARSERS = makeStructureNS(NAMESPACE_URIS$2, {
  "Phone": makeObjectPropertySetter(readPhone),
  "Address": makeObjectPropertySetter(readAddress)
});
const DCP_PARSERS = makeStructureNS(NAMESPACE_URIS$2, {
  "HTTP": makeObjectPropertySetter(readHttp)
});
const HTTP_PARSERS$1 = makeStructureNS(NAMESPACE_URIS$2, {
  "Get": makeObjectPropertyPusher(readGet),
  "Post": void 0
});
const OPERATION_PARSERS = makeStructureNS(NAMESPACE_URIS$2, {
  "DCP": makeObjectPropertySetter(readDcp)
});
const OPERATIONS_METADATA_PARSERS = makeStructureNS(NAMESPACE_URIS$2, {
  "Operation": readOperation
});
const PHONE_PARSERS = makeStructureNS(NAMESPACE_URIS$2, {
  "Voice": makeObjectPropertySetter(readString),
  "Facsimile": makeObjectPropertySetter(readString)
});
const REQUEST_METHOD_PARSERS = makeStructureNS(NAMESPACE_URIS$2, {
  "Constraint": makeObjectPropertyPusher(readConstraint)
});
const SERVICE_CONTACT_PARSERS = makeStructureNS(NAMESPACE_URIS$2, {
  "IndividualName": makeObjectPropertySetter(readString),
  "PositionName": makeObjectPropertySetter(readString),
  "ContactInfo": makeObjectPropertySetter(readContactInfo)
});
const SERVICE_IDENTIFICATION_PARSERS = makeStructureNS(NAMESPACE_URIS$2, {
  "Abstract": makeObjectPropertySetter(readString),
  "AccessConstraints": makeObjectPropertySetter(readString),
  "Fees": makeObjectPropertySetter(readString),
  "Title": makeObjectPropertySetter(readString),
  "ServiceTypeVersion": makeObjectPropertySetter(readString),
  "ServiceType": makeObjectPropertySetter(readString)
});
const SERVICE_PROVIDER_PARSERS = makeStructureNS(NAMESPACE_URIS$2, {
  "ProviderName": makeObjectPropertySetter(readString),
  "ProviderSite": makeObjectPropertySetter(readHref),
  "ServiceContact": makeObjectPropertySetter(readServiceContact)
});
function readAddress(node2, objectStack) {
  return pushParseAndPop({}, ADDRESS_PARSERS, node2, objectStack);
}
function readAllowedValues(node2, objectStack) {
  return pushParseAndPop({}, ALLOWED_VALUES_PARSERS, node2, objectStack);
}
function readConstraint(node2, objectStack) {
  const name = node2.getAttribute("name");
  if (!name) {
    return void 0;
  }
  return pushParseAndPop({ "name": name }, CONSTRAINT_PARSERS, node2, objectStack);
}
function readContactInfo(node2, objectStack) {
  return pushParseAndPop({}, CONTACT_INFO_PARSERS, node2, objectStack);
}
function readDcp(node2, objectStack) {
  return pushParseAndPop({}, DCP_PARSERS, node2, objectStack);
}
function readGet(node2, objectStack) {
  const href = readHref(node2);
  if (!href) {
    return void 0;
  }
  return pushParseAndPop({ "href": href }, REQUEST_METHOD_PARSERS, node2, objectStack);
}
function readHttp(node2, objectStack) {
  return pushParseAndPop({}, HTTP_PARSERS$1, node2, objectStack);
}
function readOperation(node2, objectStack) {
  const name = node2.getAttribute("name");
  const value = pushParseAndPop({}, OPERATION_PARSERS, node2, objectStack);
  if (!value) {
    return void 0;
  }
  const object = objectStack[objectStack.length - 1];
  object[name] = value;
}
function readOperationsMetadata(node2, objectStack) {
  return pushParseAndPop({}, OPERATIONS_METADATA_PARSERS, node2, objectStack);
}
function readPhone(node2, objectStack) {
  return pushParseAndPop({}, PHONE_PARSERS, node2, objectStack);
}
function readServiceIdentification(node2, objectStack) {
  return pushParseAndPop({}, SERVICE_IDENTIFICATION_PARSERS, node2, objectStack);
}
function readServiceContact(node2, objectStack) {
  return pushParseAndPop({}, SERVICE_CONTACT_PARSERS, node2, objectStack);
}
function readServiceProvider(node2, objectStack) {
  return pushParseAndPop({}, SERVICE_PROVIDER_PARSERS, node2, objectStack);
}
function readValue(node2, objectStack) {
  return readString(node2);
}
function flipXY(flatCoordinates, offset2, end, stride, dest, destOffset) {
  if (dest !== void 0) {
    dest = dest;
    destOffset = destOffset !== void 0 ? destOffset : 0;
  } else {
    dest = [];
    destOffset = 0;
  }
  let j2 = offset2;
  while (j2 < end) {
    const x2 = flatCoordinates[j2++];
    dest[destOffset++] = flatCoordinates[j2++];
    dest[destOffset++] = x2;
    for (let k2 = 2; k2 < stride; ++k2) {
      dest[destOffset++] = flatCoordinates[j2++];
    }
  }
  dest.length = destOffset;
  return dest;
}
class Polyline extends TextFeature {
  constructor(options) {
    super();
    options = options ? options : {};
    this.dataProjection = get$4("EPSG:4326");
    this.factor_ = options.factor ? options.factor : 1e5;
    this.geometryLayout_ = options.geometryLayout ? options.geometryLayout : "XY";
  }
  readFeatureFromText(text2, options) {
    const geometry = this.readGeometryFromText(text2, options);
    return new Feature$1(geometry);
  }
  readFeaturesFromText(text2, options) {
    const feature = this.readFeatureFromText(text2, options);
    return [feature];
  }
  readGeometryFromText(text2, options) {
    const stride = getStrideForLayout(this.geometryLayout_);
    const flatCoordinates = decodeDeltas(text2, stride, this.factor_);
    flipXY(flatCoordinates, 0, flatCoordinates.length, stride, flatCoordinates);
    const coordinates2 = inflateCoordinates(flatCoordinates, 0, flatCoordinates.length, stride);
    const lineString = new LineString$1(coordinates2, this.geometryLayout_);
    return transformGeometryWithOptions(lineString, false, this.adaptOptions(options));
  }
  writeFeatureText(feature, options) {
    const geometry = feature.getGeometry();
    if (geometry) {
      return this.writeGeometryText(geometry, options);
    }
    assert(false, 40);
    return "";
  }
  writeFeaturesText(features, options) {
    return this.writeFeatureText(features[0], options);
  }
  writeGeometryText(geometry, options) {
    geometry = transformGeometryWithOptions(geometry, true, this.adaptOptions(options));
    const flatCoordinates = geometry.getFlatCoordinates();
    const stride = geometry.getStride();
    flipXY(flatCoordinates, 0, flatCoordinates.length, stride, flatCoordinates);
    return encodeDeltas(flatCoordinates, stride, this.factor_);
  }
}
function encodeDeltas(numbers, stride, factor) {
  factor = factor ? factor : 1e5;
  let d2;
  const lastNumbers = new Array(stride);
  for (d2 = 0; d2 < stride; ++d2) {
    lastNumbers[d2] = 0;
  }
  for (let i2 = 0, ii = numbers.length; i2 < ii; ) {
    for (d2 = 0; d2 < stride; ++d2, ++i2) {
      const num = numbers[i2];
      const delta = num - lastNumbers[d2];
      lastNumbers[d2] = num;
      numbers[i2] = delta;
    }
  }
  return encodeFloats(numbers, factor);
}
function decodeDeltas(encoded, stride, factor) {
  factor = factor ? factor : 1e5;
  let d2;
  const lastNumbers = new Array(stride);
  for (d2 = 0; d2 < stride; ++d2) {
    lastNumbers[d2] = 0;
  }
  const numbers = decodeFloats(encoded, factor);
  for (let i2 = 0, ii = numbers.length; i2 < ii; ) {
    for (d2 = 0; d2 < stride; ++d2, ++i2) {
      lastNumbers[d2] += numbers[i2];
      numbers[i2] = lastNumbers[d2];
    }
  }
  return numbers;
}
function encodeFloats(numbers, factor) {
  factor = factor ? factor : 1e5;
  for (let i2 = 0, ii = numbers.length; i2 < ii; ++i2) {
    numbers[i2] = Math.round(numbers[i2] * factor);
  }
  return encodeSignedIntegers(numbers);
}
function decodeFloats(encoded, factor) {
  factor = factor ? factor : 1e5;
  const numbers = decodeSignedIntegers(encoded);
  for (let i2 = 0, ii = numbers.length; i2 < ii; ++i2) {
    numbers[i2] /= factor;
  }
  return numbers;
}
function encodeSignedIntegers(numbers) {
  for (let i2 = 0, ii = numbers.length; i2 < ii; ++i2) {
    const num = numbers[i2];
    numbers[i2] = num < 0 ? ~(num << 1) : num << 1;
  }
  return encodeUnsignedIntegers(numbers);
}
function decodeSignedIntegers(encoded) {
  const numbers = decodeUnsignedIntegers(encoded);
  for (let i2 = 0, ii = numbers.length; i2 < ii; ++i2) {
    const num = numbers[i2];
    numbers[i2] = num & 1 ? ~(num >> 1) : num >> 1;
  }
  return numbers;
}
function encodeUnsignedIntegers(numbers) {
  let encoded = "";
  for (let i2 = 0, ii = numbers.length; i2 < ii; ++i2) {
    encoded += encodeUnsignedInteger(numbers[i2]);
  }
  return encoded;
}
function decodeUnsignedIntegers(encoded) {
  const numbers = [];
  let current = 0;
  let shift = 0;
  for (let i2 = 0, ii = encoded.length; i2 < ii; ++i2) {
    const b2 = encoded.charCodeAt(i2) - 63;
    current |= (b2 & 31) << shift;
    if (b2 < 32) {
      numbers.push(current);
      current = 0;
      shift = 0;
    } else {
      shift += 5;
    }
  }
  return numbers;
}
function encodeUnsignedInteger(num) {
  let value, encoded = "";
  while (num >= 32) {
    value = (32 | num & 31) + 63;
    encoded += String.fromCharCode(value);
    num >>= 5;
  }
  value = num + 63;
  encoded += String.fromCharCode(value);
  return encoded;
}
class TopoJSON extends JSONFeature {
  constructor(options) {
    super();
    options = options ? options : {};
    this.layerName_ = options.layerName;
    this.layers_ = options.layers ? options.layers : null;
    this.dataProjection = get$4(options.dataProjection ? options.dataProjection : "EPSG:4326");
  }
  readFeaturesFromObject(object, options) {
    if (object.type == "Topology") {
      const topoJSONTopology = object;
      let transform2, scale2 = null, translate2 = null;
      if (topoJSONTopology["transform"]) {
        transform2 = topoJSONTopology["transform"];
        scale2 = transform2["scale"];
        translate2 = transform2["translate"];
      }
      const arcs = topoJSONTopology["arcs"];
      if (transform2) {
        transformArcs(arcs, scale2, translate2);
      }
      const features = [];
      const topoJSONFeatures = topoJSONTopology["objects"];
      const property = this.layerName_;
      let feature;
      for (const objectName in topoJSONFeatures) {
        if (this.layers_ && !this.layers_.includes(objectName)) {
          continue;
        }
        if (topoJSONFeatures[objectName].type === "GeometryCollection") {
          feature = topoJSONFeatures[objectName];
          features.push.apply(features, readFeaturesFromGeometryCollection(feature, arcs, scale2, translate2, property, objectName, options));
        } else {
          feature = topoJSONFeatures[objectName];
          features.push(readFeatureFromGeometry(feature, arcs, scale2, translate2, property, objectName, options));
        }
      }
      return features;
    }
    return [];
  }
  readProjectionFromObject(object) {
    return this.dataProjection;
  }
}
const GEOMETRY_READERS = {
  "Point": readPointGeometry,
  "LineString": readLineStringGeometry,
  "Polygon": readPolygonGeometry,
  "MultiPoint": readMultiPointGeometry,
  "MultiLineString": readMultiLineStringGeometry,
  "MultiPolygon": readMultiPolygonGeometry
};
function concatenateArcs(indices, arcs) {
  const coordinates2 = [];
  let index2;
  for (let i2 = 0, ii = indices.length; i2 < ii; ++i2) {
    index2 = indices[i2];
    if (i2 > 0) {
      coordinates2.pop();
    }
    if (index2 >= 0) {
      const arc = arcs[index2];
      for (let j2 = 0, jj = arc.length; j2 < jj; ++j2) {
        coordinates2.push(arc[j2].slice(0));
      }
    } else {
      const arc = arcs[~index2];
      for (let j2 = arc.length - 1; j2 >= 0; --j2) {
        coordinates2.push(arc[j2].slice(0));
      }
    }
  }
  return coordinates2;
}
function readPointGeometry(object, scale2, translate2) {
  const coordinates2 = object["coordinates"];
  if (scale2 && translate2) {
    transformVertex(coordinates2, scale2, translate2);
  }
  return new Point$3(coordinates2);
}
function readMultiPointGeometry(object, scale2, translate2) {
  const coordinates2 = object["coordinates"];
  if (scale2 && translate2) {
    for (let i2 = 0, ii = coordinates2.length; i2 < ii; ++i2) {
      transformVertex(coordinates2[i2], scale2, translate2);
    }
  }
  return new MultiPoint$1(coordinates2);
}
function readLineStringGeometry(object, arcs) {
  const coordinates2 = concatenateArcs(object["arcs"], arcs);
  return new LineString$1(coordinates2);
}
function readMultiLineStringGeometry(object, arcs) {
  const coordinates2 = [];
  for (let i2 = 0, ii = object["arcs"].length; i2 < ii; ++i2) {
    coordinates2[i2] = concatenateArcs(object["arcs"][i2], arcs);
  }
  return new MultiLineString$1(coordinates2);
}
function readPolygonGeometry(object, arcs) {
  const coordinates2 = [];
  for (let i2 = 0, ii = object["arcs"].length; i2 < ii; ++i2) {
    coordinates2[i2] = concatenateArcs(object["arcs"][i2], arcs);
  }
  return new Polygon$1(coordinates2);
}
function readMultiPolygonGeometry(object, arcs) {
  const coordinates2 = [];
  for (let i2 = 0, ii = object["arcs"].length; i2 < ii; ++i2) {
    const polyArray = object["arcs"][i2];
    const ringCoords = [];
    for (let j2 = 0, jj = polyArray.length; j2 < jj; ++j2) {
      ringCoords[j2] = concatenateArcs(polyArray[j2], arcs);
    }
    coordinates2[i2] = ringCoords;
  }
  return new MultiPolygon$1(coordinates2);
}
function readFeaturesFromGeometryCollection(collection, arcs, scale2, translate2, property, name, options) {
  const geometries = collection["geometries"];
  const features = [];
  for (let i2 = 0, ii = geometries.length; i2 < ii; ++i2) {
    features[i2] = readFeatureFromGeometry(geometries[i2], arcs, scale2, translate2, property, name, options);
  }
  return features;
}
function readFeatureFromGeometry(object, arcs, scale2, translate2, property, name, options) {
  let geometry = null;
  const type = object.type;
  if (type) {
    const geometryReader = GEOMETRY_READERS[type];
    if (type === "Point" || type === "MultiPoint") {
      geometry = geometryReader(object, scale2, translate2);
    } else {
      geometry = geometryReader(object, arcs);
    }
    geometry = transformGeometryWithOptions(geometry, false, options);
  }
  const feature = new Feature$1({ geometry });
  if (object.id !== void 0) {
    feature.setId(object.id);
  }
  let properties = object.properties;
  if (property) {
    if (!properties) {
      properties = {};
    }
    properties[property] = name;
  }
  if (properties) {
    feature.setProperties(properties, true);
  }
  return feature;
}
function transformArcs(arcs, scale2, translate2) {
  for (let i2 = 0, ii = arcs.length; i2 < ii; ++i2) {
    transformArc(arcs[i2], scale2, translate2);
  }
}
function transformArc(arc, scale2, translate2) {
  let x2 = 0;
  let y2 = 0;
  for (let i2 = 0, ii = arc.length; i2 < ii; ++i2) {
    const vertex = arc[i2];
    x2 += vertex[0];
    y2 += vertex[1];
    vertex[0] = x2;
    vertex[1] = y2;
    transformVertex(vertex, scale2, translate2);
  }
}
function transformVertex(vertex, scale2, translate2) {
  vertex[0] = vertex[0] * scale2[0] + translate2[0];
  vertex[1] = vertex[1] * scale2[1] + translate2[1];
}
class GML32 extends GML3 {
  constructor(options) {
    options = options ? options : {};
    super(options);
    this.schemaLocation = options.schemaLocation ? options.schemaLocation : this.namespace + " http://schemas.opengis.net/gml/3.2.1/gml.xsd";
  }
}
GML32.prototype.namespace = "http://www.opengis.net/gml/3.2";
GML32.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "pos": makeReplacer(GML3.prototype.readFlatPos),
    "posList": makeReplacer(GML3.prototype.readFlatPosList),
    "coordinates": makeReplacer(GML2.prototype.readFlatCoordinates)
  }
};
GML32.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "interior": GML3.prototype.interiorParser,
    "exterior": GML3.prototype.exteriorParser
  }
};
GML32.prototype.GEOMETRY_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "Point": makeReplacer(GMLBase.prototype.readPoint),
    "MultiPoint": makeReplacer(GMLBase.prototype.readMultiPoint),
    "LineString": makeReplacer(GMLBase.prototype.readLineString),
    "MultiLineString": makeReplacer(GMLBase.prototype.readMultiLineString),
    "LinearRing": makeReplacer(GMLBase.prototype.readLinearRing),
    "Polygon": makeReplacer(GMLBase.prototype.readPolygon),
    "MultiPolygon": makeReplacer(GMLBase.prototype.readMultiPolygon),
    "Surface": makeReplacer(GML32.prototype.readSurface),
    "MultiSurface": makeReplacer(GML3.prototype.readMultiSurface),
    "Curve": makeReplacer(GML32.prototype.readCurve),
    "MultiCurve": makeReplacer(GML3.prototype.readMultiCurve),
    "Envelope": makeReplacer(GML32.prototype.readEnvelope)
  }
};
GML32.prototype.MULTICURVE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "curveMember": makeArrayPusher(GML3.prototype.curveMemberParser),
    "curveMembers": makeArrayPusher(GML3.prototype.curveMemberParser)
  }
};
GML32.prototype.MULTISURFACE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "surfaceMember": makeArrayPusher(GML3.prototype.surfaceMemberParser),
    "surfaceMembers": makeArrayPusher(GML3.prototype.surfaceMemberParser)
  }
};
GML32.prototype.CURVEMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "LineString": makeArrayPusher(GMLBase.prototype.readLineString),
    "Curve": makeArrayPusher(GML3.prototype.readCurve)
  }
};
GML32.prototype.SURFACEMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "Polygon": makeArrayPusher(GMLBase.prototype.readPolygon),
    "Surface": makeArrayPusher(GML3.prototype.readSurface)
  }
};
GML32.prototype.SURFACE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "patches": makeReplacer(GML3.prototype.readPatch)
  }
};
GML32.prototype.CURVE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "segments": makeReplacer(GML3.prototype.readSegment)
  }
};
GML32.prototype.ENVELOPE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "lowerCorner": makeArrayPusher(GML3.prototype.readFlatPosList),
    "upperCorner": makeArrayPusher(GML3.prototype.readFlatPosList)
  }
};
GML32.prototype.PATCHES_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "PolygonPatch": makeReplacer(GML3.prototype.readPolygonPatch)
  }
};
GML32.prototype.SEGMENTS_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "LineStringSegment": makeArrayExtender(GML3.prototype.readLineStringSegment)
  }
};
GML32.prototype.MULTIPOINT_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "pointMember": makeArrayPusher(GMLBase.prototype.pointMemberParser),
    "pointMembers": makeArrayPusher(GMLBase.prototype.pointMemberParser)
  }
};
GML32.prototype.MULTILINESTRING_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "lineStringMember": makeArrayPusher(GMLBase.prototype.lineStringMemberParser),
    "lineStringMembers": makeArrayPusher(GMLBase.prototype.lineStringMemberParser)
  }
};
GML32.prototype.MULTIPOLYGON_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "polygonMember": makeArrayPusher(GMLBase.prototype.polygonMemberParser),
    "polygonMembers": makeArrayPusher(GMLBase.prototype.polygonMemberParser)
  }
};
GML32.prototype.POINTMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "Point": makeArrayPusher(GMLBase.prototype.readFlatCoordinatesFromNode)
  }
};
GML32.prototype.LINESTRINGMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "LineString": makeArrayPusher(GMLBase.prototype.readLineString)
  }
};
GML32.prototype.POLYGONMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "Polygon": makeArrayPusher(GMLBase.prototype.readPolygon)
  }
};
GML32.prototype.RING_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "LinearRing": makeReplacer(GMLBase.prototype.readFlatLinearRing),
    "Ring": makeReplacer(GML32.prototype.readFlatCurveRing)
  }
};
GML32.prototype.RING_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    "exterior": makeChildAppender(GML3.prototype.writeRing),
    "interior": makeChildAppender(GML3.prototype.writeRing)
  }
};
GML32.prototype.ENVELOPE_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    "lowerCorner": makeChildAppender(writeStringTextNode),
    "upperCorner": makeChildAppender(writeStringTextNode)
  }
};
GML32.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    "surfaceMember": makeChildAppender(GML3.prototype.writeSurfaceOrPolygonMember),
    "polygonMember": makeChildAppender(GML3.prototype.writeSurfaceOrPolygonMember)
  }
};
GML32.prototype.POINTMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    "pointMember": makeChildAppender(GML3.prototype.writePointMember)
  }
};
GML32.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    "lineStringMember": makeChildAppender(GML3.prototype.writeLineStringOrCurveMember),
    "curveMember": makeChildAppender(GML3.prototype.writeLineStringOrCurveMember)
  }
};
GML32.prototype.GEOMETRY_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    "Curve": makeChildAppender(GML3.prototype.writeCurveOrLineString),
    "MultiCurve": makeChildAppender(GML3.prototype.writeMultiCurveOrLineString),
    "Point": makeChildAppender(GML32.prototype.writePoint),
    "MultiPoint": makeChildAppender(GML3.prototype.writeMultiPoint),
    "LineString": makeChildAppender(GML3.prototype.writeCurveOrLineString),
    "MultiLineString": makeChildAppender(GML3.prototype.writeMultiCurveOrLineString),
    "LinearRing": makeChildAppender(GML3.prototype.writeLinearRing),
    "Polygon": makeChildAppender(GML3.prototype.writeSurfaceOrPolygon),
    "MultiPolygon": makeChildAppender(GML3.prototype.writeMultiSurfaceOrPolygon),
    "Surface": makeChildAppender(GML3.prototype.writeSurfaceOrPolygon),
    "MultiSurface": makeChildAppender(GML3.prototype.writeMultiSurfaceOrPolygon),
    "Envelope": makeChildAppender(GML3.prototype.writeEnvelope)
  }
};
class Filter {
  constructor(tagName) {
    this.tagName_ = tagName;
  }
  getTagName() {
    return this.tagName_;
  }
}
class LogicalNary extends Filter {
  constructor(tagName, conditions) {
    super(tagName);
    this.conditions = conditions;
    assert(this.conditions.length >= 2, 57);
  }
}
class And extends LogicalNary {
  constructor(conditions) {
    super("And", Array.prototype.slice.call(arguments));
  }
}
class Bbox extends Filter {
  constructor(geometryName, extent2, srsName) {
    super("BBOX");
    this.geometryName = geometryName;
    this.extent = extent2;
    if (extent2.length !== 4) {
      throw new Error("Expected an extent with four values ([minX, minY, maxX, maxY])");
    }
    this.srsName = srsName;
  }
}
function and(conditions) {
  const params2 = [null].concat(Array.prototype.slice.call(arguments));
  return new (Function.prototype.bind.apply(And, params2))();
}
function bbox(geometryName, extent2, srsName) {
  return new Bbox(geometryName, extent2, srsName);
}
const FEATURE_COLLECTION_PARSERS = {
  "http://www.opengis.net/gml": {
    "boundedBy": makeObjectPropertySetter(GMLBase.prototype.readExtentElement, "bounds")
  },
  "http://www.opengis.net/wfs/2.0": {
    "member": makeArrayPusher(GMLBase.prototype.readFeaturesInternal)
  }
};
const TRANSACTION_SUMMARY_PARSERS = {
  "http://www.opengis.net/wfs": {
    "totalInserted": makeObjectPropertySetter(readPositiveInteger),
    "totalUpdated": makeObjectPropertySetter(readPositiveInteger),
    "totalDeleted": makeObjectPropertySetter(readPositiveInteger)
  },
  "http://www.opengis.net/wfs/2.0": {
    "totalInserted": makeObjectPropertySetter(readPositiveInteger),
    "totalUpdated": makeObjectPropertySetter(readPositiveInteger),
    "totalDeleted": makeObjectPropertySetter(readPositiveInteger)
  }
};
const TRANSACTION_RESPONSE_PARSERS = {
  "http://www.opengis.net/wfs": {
    "TransactionSummary": makeObjectPropertySetter(readTransactionSummary, "transactionSummary"),
    "InsertResults": makeObjectPropertySetter(readInsertResults, "insertIds")
  },
  "http://www.opengis.net/wfs/2.0": {
    "TransactionSummary": makeObjectPropertySetter(readTransactionSummary, "transactionSummary"),
    "InsertResults": makeObjectPropertySetter(readInsertResults, "insertIds")
  }
};
const QUERY_SERIALIZERS = {
  "http://www.opengis.net/wfs": {
    "PropertyName": makeChildAppender(writeStringTextNode)
  },
  "http://www.opengis.net/wfs/2.0": {
    "PropertyName": makeChildAppender(writeStringTextNode)
  }
};
const TRANSACTION_SERIALIZERS = {
  "http://www.opengis.net/wfs": {
    "Insert": makeChildAppender(writeFeature),
    "Update": makeChildAppender(writeUpdate),
    "Delete": makeChildAppender(writeDelete),
    "Property": makeChildAppender(writeProperty),
    "Native": makeChildAppender(writeNative)
  },
  "http://www.opengis.net/wfs/2.0": {
    "Insert": makeChildAppender(writeFeature),
    "Update": makeChildAppender(writeUpdate),
    "Delete": makeChildAppender(writeDelete),
    "Property": makeChildAppender(writeProperty),
    "Native": makeChildAppender(writeNative)
  }
};
const FEATURE_PREFIX = "feature";
const XMLNS = "http://www.w3.org/2000/xmlns/";
const OGCNS = {
  "2.0.0": "http://www.opengis.net/ogc/1.1",
  "1.1.0": "http://www.opengis.net/ogc",
  "1.0.0": "http://www.opengis.net/ogc"
};
const WFSNS = {
  "2.0.0": "http://www.opengis.net/wfs/2.0",
  "1.1.0": "http://www.opengis.net/wfs",
  "1.0.0": "http://www.opengis.net/wfs"
};
const FESNS = {
  "2.0.0": "http://www.opengis.net/fes/2.0",
  "1.1.0": "http://www.opengis.net/fes",
  "1.0.0": "http://www.opengis.net/fes"
};
const SCHEMA_LOCATIONS = {
  "2.0.0": "http://www.opengis.net/wfs/2.0 http://schemas.opengis.net/wfs/2.0/wfs.xsd",
  "1.1.0": "http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd",
  "1.0.0": "http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/wfs.xsd"
};
const GML_FORMATS = {
  "2.0.0": GML32,
  "1.1.0": GML3,
  "1.0.0": GML2
};
const DEFAULT_VERSION = "1.1.0";
class WFS extends XMLFeature {
  constructor(options) {
    super();
    options = options ? options : {};
    this.version_ = options.version ? options.version : DEFAULT_VERSION;
    this.featureType_ = options.featureType;
    this.featureNS_ = options.featureNS;
    this.gmlFormat_ = options.gmlFormat ? options.gmlFormat : new GML_FORMATS[this.version_]();
    this.schemaLocation_ = options.schemaLocation ? options.schemaLocation : SCHEMA_LOCATIONS[this.version_];
  }
  getFeatureType() {
    return this.featureType_;
  }
  setFeatureType(featureType) {
    this.featureType_ = featureType;
  }
  readFeaturesFromNode(node2, options) {
    const context2 = {
      node: node2
    };
    Object.assign(context2, {
      "featureType": this.featureType_,
      "featureNS": this.featureNS_
    });
    Object.assign(context2, this.getReadOptions(node2, options ? options : {}));
    const objectStack = [context2];
    let featuresNS;
    if (this.version_ === "2.0.0") {
      featuresNS = FEATURE_COLLECTION_PARSERS;
    } else {
      featuresNS = this.gmlFormat_.FEATURE_COLLECTION_PARSERS;
    }
    let features = pushParseAndPop([], featuresNS, node2, objectStack, this.gmlFormat_);
    if (!features) {
      features = [];
    }
    return features;
  }
  readTransactionResponse(source) {
    if (!source) {
      return void 0;
    } else if (typeof source === "string") {
      const doc = parse$1(source);
      return this.readTransactionResponseFromDocument(doc);
    } else if (isDocument(source)) {
      return this.readTransactionResponseFromDocument(source);
    }
    return this.readTransactionResponseFromNode(source);
  }
  readFeatureCollectionMetadata(source) {
    if (!source) {
      return void 0;
    } else if (typeof source === "string") {
      const doc = parse$1(source);
      return this.readFeatureCollectionMetadataFromDocument(doc);
    } else if (isDocument(source)) {
      return this.readFeatureCollectionMetadataFromDocument(source);
    }
    return this.readFeatureCollectionMetadataFromNode(source);
  }
  readFeatureCollectionMetadataFromDocument(doc) {
    for (let n2 = doc.firstChild; n2; n2 = n2.nextSibling) {
      if (n2.nodeType == Node.ELEMENT_NODE) {
        return this.readFeatureCollectionMetadataFromNode(n2);
      }
    }
    return void 0;
  }
  readFeatureCollectionMetadataFromNode(node2) {
    const result = {};
    const value = readNonNegativeIntegerString(node2.getAttribute("numberOfFeatures"));
    result["numberOfFeatures"] = value;
    return pushParseAndPop(result, FEATURE_COLLECTION_PARSERS, node2, [], this.gmlFormat_);
  }
  readTransactionResponseFromDocument(doc) {
    for (let n2 = doc.firstChild; n2; n2 = n2.nextSibling) {
      if (n2.nodeType == Node.ELEMENT_NODE) {
        return this.readTransactionResponseFromNode(n2);
      }
    }
    return void 0;
  }
  readTransactionResponseFromNode(node2) {
    return pushParseAndPop({}, TRANSACTION_RESPONSE_PARSERS, node2, []);
  }
  writeGetFeature(options) {
    const node2 = createElementNS(WFSNS[this.version_], "GetFeature");
    node2.setAttribute("service", "WFS");
    node2.setAttribute("version", this.version_);
    if (options.handle) {
      node2.setAttribute("handle", options.handle);
    }
    if (options.outputFormat) {
      node2.setAttribute("outputFormat", options.outputFormat);
    }
    if (options.maxFeatures !== void 0) {
      node2.setAttribute("maxFeatures", String(options.maxFeatures));
    }
    if (options.resultType) {
      node2.setAttribute("resultType", options.resultType);
    }
    if (options.startIndex !== void 0) {
      node2.setAttribute("startIndex", String(options.startIndex));
    }
    if (options.count !== void 0) {
      node2.setAttribute("count", String(options.count));
    }
    if (options.viewParams !== void 0) {
      node2.setAttribute("viewParams", options.viewParams);
    }
    node2.setAttributeNS(XML_SCHEMA_INSTANCE_URI, "xsi:schemaLocation", this.schemaLocation_);
    const context2 = {
      node: node2
    };
    Object.assign(context2, {
      "version": this.version_,
      "srsName": options.srsName,
      "featureNS": options.featureNS ? options.featureNS : this.featureNS_,
      "featurePrefix": options.featurePrefix,
      "propertyNames": options.propertyNames ? options.propertyNames : []
    });
    assert(Array.isArray(options.featureTypes), 11);
    if (typeof options.featureTypes[0] === "string") {
      let filter = options.filter;
      if (options.bbox) {
        assert(options.geometryName, 12);
        filter = this.combineBboxAndFilter(options.geometryName, options.bbox, options.srsName, filter);
      }
      Object.assign(context2, {
        "geometryName": options.geometryName,
        "filter": filter
      });
      writeGetFeature(node2, options.featureTypes, [context2]);
    } else {
      options.featureTypes.forEach((featureType) => {
        const completeFilter = this.combineBboxAndFilter(featureType.geometryName, featureType.bbox, options.srsName, options.filter);
        Object.assign(context2, {
          "geometryName": featureType.geometryName,
          "filter": completeFilter
        });
        writeGetFeature(node2, [featureType.name], [context2]);
      });
    }
    return node2;
  }
  combineBboxAndFilter(geometryName, extent2, srsName, filter) {
    const bboxFilter = bbox(geometryName, extent2, srsName);
    if (filter) {
      return and(filter, bboxFilter);
    }
    return bboxFilter;
  }
  writeTransaction(inserts, updates, deletes, options) {
    const objectStack = [];
    const version2 = options.version ? options.version : this.version_;
    const node2 = createElementNS(WFSNS[version2], "Transaction");
    node2.setAttribute("service", "WFS");
    node2.setAttribute("version", version2);
    let baseObj;
    if (options) {
      baseObj = options.gmlOptions ? options.gmlOptions : {};
      if (options.handle) {
        node2.setAttribute("handle", options.handle);
      }
    }
    node2.setAttributeNS(XML_SCHEMA_INSTANCE_URI, "xsi:schemaLocation", SCHEMA_LOCATIONS[version2]);
    const request = createTransactionRequest(node2, baseObj, version2, options);
    if (inserts) {
      serializeTransactionRequest("Insert", inserts, objectStack, request);
    }
    if (updates) {
      serializeTransactionRequest("Update", updates, objectStack, request);
    }
    if (deletes) {
      serializeTransactionRequest("Delete", deletes, objectStack, request);
    }
    if (options.nativeElements) {
      serializeTransactionRequest("Native", options.nativeElements, objectStack, request);
    }
    return node2;
  }
  readProjectionFromDocument(doc) {
    for (let n2 = doc.firstChild; n2; n2 = n2.nextSibling) {
      if (n2.nodeType == Node.ELEMENT_NODE) {
        return this.readProjectionFromNode(n2);
      }
    }
    return null;
  }
  readProjectionFromNode(node2) {
    if (node2.firstElementChild && node2.firstElementChild.firstElementChild) {
      node2 = node2.firstElementChild.firstElementChild;
      for (let n2 = node2.firstElementChild; n2; n2 = n2.nextElementSibling) {
        if (!(n2.childNodes.length === 0 || n2.childNodes.length === 1 && n2.firstChild.nodeType === 3)) {
          const objectStack = [{}];
          this.gmlFormat_.readGeometryElement(n2, objectStack);
          return get$4(objectStack.pop().srsName);
        }
      }
    }
    return null;
  }
}
function createTransactionRequest(node2, baseObj, version2, options) {
  const featurePrefix = options.featurePrefix ? options.featurePrefix : FEATURE_PREFIX;
  let gmlVersion;
  if (version2 === "1.0.0") {
    gmlVersion = 2;
  } else if (version2 === "1.1.0") {
    gmlVersion = 3;
  } else if (version2 === "2.0.0") {
    gmlVersion = 3.2;
  }
  const obj = Object.assign({ node: node2 }, {
    version: version2,
    "featureNS": options.featureNS,
    "featureType": options.featureType,
    "featurePrefix": featurePrefix,
    "gmlVersion": gmlVersion,
    "hasZ": options.hasZ,
    "srsName": options.srsName
  }, baseObj);
  return obj;
}
function serializeTransactionRequest(type, features, objectStack, request) {
  pushSerializeAndPop(request, TRANSACTION_SERIALIZERS, makeSimpleNodeFactory(type), features, objectStack);
}
function readTransactionSummary(node2, objectStack) {
  return pushParseAndPop({}, TRANSACTION_SUMMARY_PARSERS, node2, objectStack);
}
const OGC_FID_PARSERS = {
  "http://www.opengis.net/ogc": {
    "FeatureId": makeArrayPusher(function(node2, objectStack) {
      return node2.getAttribute("fid");
    })
  },
  "http://www.opengis.net/ogc/1.1": {
    "FeatureId": makeArrayPusher(function(node2, objectStack) {
      return node2.getAttribute("fid");
    })
  }
};
function fidParser(node2, objectStack) {
  parseNode(OGC_FID_PARSERS, node2, objectStack);
}
const INSERT_RESULTS_PARSERS = {
  "http://www.opengis.net/wfs": {
    "Feature": fidParser
  },
  "http://www.opengis.net/wfs/2.0": {
    "Feature": fidParser
  }
};
function readInsertResults(node2, objectStack) {
  return pushParseAndPop([], INSERT_RESULTS_PARSERS, node2, objectStack);
}
function writeFeature(node2, feature, objectStack) {
  const context2 = objectStack[objectStack.length - 1];
  const featureType = context2["featureType"];
  const featureNS = context2["featureNS"];
  const gmlVersion = context2["gmlVersion"];
  const child = createElementNS(featureNS, featureType);
  node2.appendChild(child);
  if (gmlVersion === 2) {
    GML2.prototype.writeFeatureElement(child, feature, objectStack);
  } else if (gmlVersion === 3) {
    GML3.prototype.writeFeatureElement(child, feature, objectStack);
  } else {
    GML32.prototype.writeFeatureElement(child, feature, objectStack);
  }
}
function writeOgcFidFilter(node2, fid, objectStack) {
  const context2 = objectStack[objectStack.length - 1];
  const version2 = context2["version"];
  const ns = OGCNS[version2];
  const filter = createElementNS(ns, "Filter");
  const child = createElementNS(ns, "FeatureId");
  filter.appendChild(child);
  child.setAttribute("fid", fid);
  node2.appendChild(filter);
}
function getTypeName(featurePrefix, featureType) {
  featurePrefix = featurePrefix ? featurePrefix : FEATURE_PREFIX;
  const prefix = featurePrefix + ":";
  if (featureType.startsWith(prefix)) {
    return featureType;
  }
  return prefix + featureType;
}
function writeDelete(node2, feature, objectStack) {
  const context2 = objectStack[objectStack.length - 1];
  assert(feature.getId() !== void 0, 26);
  const featureType = context2["featureType"];
  const featurePrefix = context2["featurePrefix"];
  const featureNS = context2["featureNS"];
  const typeName = getTypeName(featurePrefix, featureType);
  node2.setAttribute("typeName", typeName);
  node2.setAttributeNS(XMLNS, "xmlns:" + featurePrefix, featureNS);
  const fid = feature.getId();
  if (fid !== void 0) {
    writeOgcFidFilter(node2, fid, objectStack);
  }
}
function writeUpdate(node2, feature, objectStack) {
  const context2 = objectStack[objectStack.length - 1];
  assert(feature.getId() !== void 0, 27);
  const version2 = context2["version"];
  const featureType = context2["featureType"];
  const featurePrefix = context2["featurePrefix"];
  const featureNS = context2["featureNS"];
  const typeName = getTypeName(featurePrefix, featureType);
  const geometryName = feature.getGeometryName();
  node2.setAttribute("typeName", typeName);
  node2.setAttributeNS(XMLNS, "xmlns:" + featurePrefix, featureNS);
  const fid = feature.getId();
  if (fid !== void 0) {
    const keys3 = feature.getKeys();
    const values3 = [];
    for (let i2 = 0, ii = keys3.length; i2 < ii; i2++) {
      const value = feature.get(keys3[i2]);
      if (value !== void 0) {
        let name = keys3[i2];
        if (value && typeof value.getSimplifiedGeometry === "function") {
          name = geometryName;
        }
        values3.push({ name, value });
      }
    }
    pushSerializeAndPop({
      version: version2,
      "gmlVersion": context2["gmlVersion"],
      node: node2,
      "hasZ": context2["hasZ"],
      "srsName": context2["srsName"]
    }, TRANSACTION_SERIALIZERS, makeSimpleNodeFactory("Property"), values3, objectStack);
    writeOgcFidFilter(node2, fid, objectStack);
  }
}
function writeProperty(node2, pair, objectStack) {
  const context2 = objectStack[objectStack.length - 1];
  const version2 = context2["version"];
  const ns = WFSNS[version2];
  const name = createElementNS(ns, "Name");
  const gmlVersion = context2["gmlVersion"];
  node2.appendChild(name);
  writeStringTextNode(name, pair.name);
  if (pair.value !== void 0 && pair.value !== null) {
    const value = createElementNS(ns, "Value");
    node2.appendChild(value);
    if (pair.value && typeof pair.value.getSimplifiedGeometry === "function") {
      if (gmlVersion === 2) {
        GML2.prototype.writeGeometryElement(value, pair.value, objectStack);
      } else if (gmlVersion === 3) {
        GML3.prototype.writeGeometryElement(value, pair.value, objectStack);
      } else {
        GML32.prototype.writeGeometryElement(value, pair.value, objectStack);
      }
    } else {
      writeStringTextNode(value, pair.value);
    }
  }
}
function writeNative(node2, nativeElement, objectStack) {
  if (nativeElement.vendorId) {
    node2.setAttribute("vendorId", nativeElement.vendorId);
  }
  if (nativeElement.safeToIgnore !== void 0) {
    node2.setAttribute("safeToIgnore", String(nativeElement.safeToIgnore));
  }
  if (nativeElement.value !== void 0) {
    writeStringTextNode(node2, nativeElement.value);
  }
}
const GETFEATURE_SERIALIZERS = {
  "http://www.opengis.net/wfs": {
    "Query": makeChildAppender(writeQuery)
  },
  "http://www.opengis.net/wfs/2.0": {
    "Query": makeChildAppender(writeQuery)
  },
  "http://www.opengis.net/ogc": {
    "During": makeChildAppender(writeDuringFilter),
    "And": makeChildAppender(writeLogicalFilter),
    "Or": makeChildAppender(writeLogicalFilter),
    "Not": makeChildAppender(writeNotFilter),
    "BBOX": makeChildAppender(writeBboxFilter),
    "Contains": makeChildAppender(writeSpatialFilter),
    "Intersects": makeChildAppender(writeSpatialFilter),
    "Within": makeChildAppender(writeSpatialFilter),
    "DWithin": makeChildAppender(writeDWithinFilter),
    "PropertyIsEqualTo": makeChildAppender(writeComparisonFilter),
    "PropertyIsNotEqualTo": makeChildAppender(writeComparisonFilter),
    "PropertyIsLessThan": makeChildAppender(writeComparisonFilter),
    "PropertyIsLessThanOrEqualTo": makeChildAppender(writeComparisonFilter),
    "PropertyIsGreaterThan": makeChildAppender(writeComparisonFilter),
    "PropertyIsGreaterThanOrEqualTo": makeChildAppender(writeComparisonFilter),
    "PropertyIsNull": makeChildAppender(writeIsNullFilter),
    "PropertyIsBetween": makeChildAppender(writeIsBetweenFilter),
    "PropertyIsLike": makeChildAppender(writeIsLikeFilter)
  },
  "http://www.opengis.net/fes/2.0": {
    "During": makeChildAppender(writeDuringFilter),
    "And": makeChildAppender(writeLogicalFilter),
    "Or": makeChildAppender(writeLogicalFilter),
    "Not": makeChildAppender(writeNotFilter),
    "BBOX": makeChildAppender(writeBboxFilter),
    "Contains": makeChildAppender(writeSpatialFilter),
    "Disjoint": makeChildAppender(writeSpatialFilter),
    "Intersects": makeChildAppender(writeSpatialFilter),
    "ResourceId": makeChildAppender(writeResourceIdFilter),
    "Within": makeChildAppender(writeSpatialFilter),
    "DWithin": makeChildAppender(writeDWithinFilter),
    "PropertyIsEqualTo": makeChildAppender(writeComparisonFilter),
    "PropertyIsNotEqualTo": makeChildAppender(writeComparisonFilter),
    "PropertyIsLessThan": makeChildAppender(writeComparisonFilter),
    "PropertyIsLessThanOrEqualTo": makeChildAppender(writeComparisonFilter),
    "PropertyIsGreaterThan": makeChildAppender(writeComparisonFilter),
    "PropertyIsGreaterThanOrEqualTo": makeChildAppender(writeComparisonFilter),
    "PropertyIsNull": makeChildAppender(writeIsNullFilter),
    "PropertyIsBetween": makeChildAppender(writeIsBetweenFilter),
    "PropertyIsLike": makeChildAppender(writeIsLikeFilter)
  }
};
function writeQuery(node2, featureType, objectStack) {
  const context2 = objectStack[objectStack.length - 1];
  const version2 = context2["version"];
  const featurePrefix = context2["featurePrefix"];
  const featureNS = context2["featureNS"];
  const propertyNames = context2["propertyNames"];
  const srsName = context2["srsName"];
  let typeName;
  if (featurePrefix) {
    typeName = getTypeName(featurePrefix, featureType);
  } else {
    typeName = featureType;
  }
  let typeNameAttr;
  if (version2 === "2.0.0") {
    typeNameAttr = "typeNames";
  } else {
    typeNameAttr = "typeName";
  }
  node2.setAttribute(typeNameAttr, typeName);
  if (srsName) {
    node2.setAttribute("srsName", srsName);
  }
  if (featureNS) {
    node2.setAttributeNS(XMLNS, "xmlns:" + featurePrefix, featureNS);
  }
  const item = Object.assign({}, context2);
  item.node = node2;
  pushSerializeAndPop(item, QUERY_SERIALIZERS, makeSimpleNodeFactory("PropertyName"), propertyNames, objectStack);
  const filter = context2["filter"];
  if (filter) {
    const child = createElementNS(getFilterNS(version2), "Filter");
    node2.appendChild(child);
    writeFilterCondition(child, filter, objectStack);
  }
}
function writeFilterCondition(node2, filter, objectStack) {
  const context2 = objectStack[objectStack.length - 1];
  const item = { node: node2 };
  Object.assign(item, { context: context2 });
  pushSerializeAndPop(item, GETFEATURE_SERIALIZERS, makeSimpleNodeFactory(filter.getTagName()), [filter], objectStack);
}
function writeBboxFilter(node2, filter, objectStack) {
  const parent = objectStack[objectStack.length - 1];
  const context2 = parent["context"];
  const version2 = context2["version"];
  parent["srsName"] = filter.srsName;
  const format2 = GML_FORMATS[version2];
  writePropertyName(version2, node2, filter.geometryName);
  format2.prototype.writeGeometryElement(node2, filter.extent, objectStack);
}
function writeResourceIdFilter(node2, filter, objectStack) {
  node2.setAttribute("rid", filter.rid);
}
function writeSpatialFilter(node2, filter, objectStack) {
  const parent = objectStack[objectStack.length - 1];
  const context2 = parent["context"];
  const version2 = context2["version"];
  parent["srsName"] = filter.srsName;
  const format2 = GML_FORMATS[version2];
  writePropertyName(version2, node2, filter.geometryName);
  format2.prototype.writeGeometryElement(node2, filter.geometry, objectStack);
}
function writeDWithinFilter(node2, filter, objectStack) {
  const parent = objectStack[objectStack.length - 1];
  const context2 = parent["context"];
  const version2 = context2["version"];
  writeSpatialFilter(node2, filter, objectStack);
  const distance2 = createElementNS(getFilterNS(version2), "Distance");
  writeStringTextNode(distance2, filter.distance.toString());
  if (version2 === "2.0.0") {
    distance2.setAttribute("uom", filter.unit);
  } else {
    distance2.setAttribute("units", filter.unit);
  }
  node2.appendChild(distance2);
}
function writeDuringFilter(node2, filter, objectStack) {
  const parent = objectStack[objectStack.length - 1];
  const context2 = parent["context"];
  const version2 = context2["version"];
  writeExpression(FESNS[version2], "ValueReference", node2, filter.propertyName);
  const timePeriod = createElementNS(GMLNS, "TimePeriod");
  node2.appendChild(timePeriod);
  const begin = createElementNS(GMLNS, "begin");
  timePeriod.appendChild(begin);
  writeTimeInstant(begin, filter.begin);
  const end = createElementNS(GMLNS, "end");
  timePeriod.appendChild(end);
  writeTimeInstant(end, filter.end);
}
function writeLogicalFilter(node2, filter, objectStack) {
  const parent = objectStack[objectStack.length - 1];
  const context2 = parent["context"];
  const item = { node: node2 };
  Object.assign(item, { context: context2 });
  const conditions = filter.conditions;
  for (let i2 = 0, ii = conditions.length; i2 < ii; ++i2) {
    const condition = conditions[i2];
    pushSerializeAndPop(item, GETFEATURE_SERIALIZERS, makeSimpleNodeFactory(condition.getTagName()), [condition], objectStack);
  }
}
function writeNotFilter(node2, filter, objectStack) {
  const parent = objectStack[objectStack.length - 1];
  const context2 = parent["context"];
  const item = { node: node2 };
  Object.assign(item, { context: context2 });
  const condition = filter.condition;
  pushSerializeAndPop(item, GETFEATURE_SERIALIZERS, makeSimpleNodeFactory(condition.getTagName()), [condition], objectStack);
}
function writeComparisonFilter(node2, filter, objectStack) {
  const parent = objectStack[objectStack.length - 1];
  const context2 = parent["context"];
  const version2 = context2["version"];
  if (filter.matchCase !== void 0) {
    node2.setAttribute("matchCase", filter.matchCase.toString());
  }
  writePropertyName(version2, node2, filter.propertyName);
  writeLiteral(version2, node2, "" + filter.expression);
}
function writeIsNullFilter(node2, filter, objectStack) {
  const parent = objectStack[objectStack.length - 1];
  const context2 = parent["context"];
  const version2 = context2["version"];
  writePropertyName(version2, node2, filter.propertyName);
}
function writeIsBetweenFilter(node2, filter, objectStack) {
  const parent = objectStack[objectStack.length - 1];
  const context2 = parent["context"];
  const version2 = context2["version"];
  const ns = getFilterNS(version2);
  writePropertyName(version2, node2, filter.propertyName);
  const lowerBoundary = createElementNS(ns, "LowerBoundary");
  node2.appendChild(lowerBoundary);
  writeLiteral(version2, lowerBoundary, "" + filter.lowerBoundary);
  const upperBoundary = createElementNS(ns, "UpperBoundary");
  node2.appendChild(upperBoundary);
  writeLiteral(version2, upperBoundary, "" + filter.upperBoundary);
}
function writeIsLikeFilter(node2, filter, objectStack) {
  const parent = objectStack[objectStack.length - 1];
  const context2 = parent["context"];
  const version2 = context2["version"];
  node2.setAttribute("wildCard", filter.wildCard);
  node2.setAttribute("singleChar", filter.singleChar);
  node2.setAttribute("escapeChar", filter.escapeChar);
  if (filter.matchCase !== void 0) {
    node2.setAttribute("matchCase", filter.matchCase.toString());
  }
  writePropertyName(version2, node2, filter.propertyName);
  writeLiteral(version2, node2, "" + filter.pattern);
}
function writeExpression(ns, tagName, node2, value) {
  const property = createElementNS(ns, tagName);
  writeStringTextNode(property, value);
  node2.appendChild(property);
}
function writeLiteral(version2, node2, value) {
  writeExpression(getFilterNS(version2), "Literal", node2, value);
}
function writePropertyName(version2, node2, value) {
  if (version2 === "2.0.0") {
    writeExpression(FESNS[version2], "ValueReference", node2, value);
  } else {
    writeExpression(OGCNS[version2], "PropertyName", node2, value);
  }
}
function writeTimeInstant(node2, time2) {
  const timeInstant = createElementNS(GMLNS, "TimeInstant");
  node2.appendChild(timeInstant);
  const timePosition = createElementNS(GMLNS, "timePosition");
  timeInstant.appendChild(timePosition);
  writeStringTextNode(timePosition, time2);
}
function writeGetFeature(node2, featureTypes, objectStack) {
  const context2 = objectStack[objectStack.length - 1];
  const item = Object.assign({}, context2);
  item.node = node2;
  pushSerializeAndPop(item, GETFEATURE_SERIALIZERS, makeSimpleNodeFactory("Query"), featureTypes, objectStack);
}
function getFilterNS(version2) {
  let ns;
  if (version2 === "2.0.0") {
    ns = FESNS[version2];
  } else {
    ns = OGCNS[version2];
  }
  return ns;
}
const WKBGeometryType = {
  POINT: 1,
  LINE_STRING: 2,
  POLYGON: 3,
  MULTI_POINT: 4,
  MULTI_LINE_STRING: 5,
  MULTI_POLYGON: 6,
  GEOMETRY_COLLECTION: 7,
  POLYHEDRAL_SURFACE: 15,
  TIN: 16,
  TRIANGLE: 17
};
class WkbReader {
  constructor(view) {
    this.view_ = view;
    this.pos_ = 0;
    this.initialized_ = false;
    this.isLittleEndian_ = false;
    this.hasZ_ = false;
    this.hasM_ = false;
    this.srid_ = null;
    this.layout_ = "XY";
  }
  readUint8() {
    return this.view_.getUint8(this.pos_++);
  }
  readUint32(isLittleEndian) {
    return this.view_.getUint32((this.pos_ += 4) - 4, isLittleEndian !== void 0 ? isLittleEndian : this.isLittleEndian_);
  }
  readDouble(isLittleEndian) {
    return this.view_.getFloat64((this.pos_ += 8) - 8, isLittleEndian !== void 0 ? isLittleEndian : this.isLittleEndian_);
  }
  readPoint() {
    const coords = [];
    coords.push(this.readDouble());
    coords.push(this.readDouble());
    if (this.hasZ_) {
      coords.push(this.readDouble());
    }
    if (this.hasM_) {
      coords.push(this.readDouble());
    }
    return coords;
  }
  readLineString() {
    const numPoints = this.readUint32();
    const coords = [];
    for (let i2 = 0; i2 < numPoints; i2++) {
      coords.push(this.readPoint());
    }
    return coords;
  }
  readPolygon() {
    const numRings = this.readUint32();
    const rings = [];
    for (let i2 = 0; i2 < numRings; i2++) {
      rings.push(this.readLineString());
    }
    return rings;
  }
  readWkbHeader(expectedTypeId) {
    const byteOrder = this.readUint8();
    const isLittleEndian = byteOrder > 0;
    const wkbType = this.readUint32(isLittleEndian);
    const wkbTypeThousandth = Math.floor((wkbType & 268435455) / 1e3);
    const hasZ = Boolean(wkbType & 2147483648) || wkbTypeThousandth === 1 || wkbTypeThousandth === 3;
    const hasM = Boolean(wkbType & 1073741824) || wkbTypeThousandth === 2 || wkbTypeThousandth === 3;
    const hasSRID = Boolean(wkbType & 536870912);
    const typeId = (wkbType & 268435455) % 1e3;
    const layout = ["XY", hasZ ? "Z" : "", hasM ? "M" : ""].join("");
    const srid = hasSRID ? this.readUint32(isLittleEndian) : null;
    if (expectedTypeId !== void 0 && expectedTypeId !== typeId) {
      throw new Error("Unexpected WKB geometry type " + typeId);
    }
    if (this.initialized_) {
      if (this.isLittleEndian_ !== isLittleEndian) {
        throw new Error("Inconsistent endian");
      }
      if (this.layout_ !== layout) {
        throw new Error("Inconsistent geometry layout");
      }
      if (srid && this.srid_ !== srid) {
        throw new Error("Inconsistent coordinate system (SRID)");
      }
    } else {
      this.isLittleEndian_ = isLittleEndian;
      this.hasZ_ = hasZ;
      this.hasM_ = hasM;
      this.layout_ = layout;
      this.srid_ = srid;
      this.initialized_ = true;
    }
    return typeId;
  }
  readWkbPayload(typeId) {
    switch (typeId) {
      case WKBGeometryType.POINT:
        return this.readPoint();
      case WKBGeometryType.LINE_STRING:
        return this.readLineString();
      case WKBGeometryType.POLYGON:
      case WKBGeometryType.TRIANGLE:
        return this.readPolygon();
      case WKBGeometryType.MULTI_POINT:
        return this.readMultiPoint();
      case WKBGeometryType.MULTI_LINE_STRING:
        return this.readMultiLineString();
      case WKBGeometryType.MULTI_POLYGON:
      case WKBGeometryType.POLYHEDRAL_SURFACE:
      case WKBGeometryType.TIN:
        return this.readMultiPolygon();
      case WKBGeometryType.GEOMETRY_COLLECTION:
        return this.readGeometryCollection();
      default:
        throw new Error("Unsupported WKB geometry type " + typeId + " is found");
    }
  }
  readWkbBlock(expectedTypeId) {
    return this.readWkbPayload(this.readWkbHeader(expectedTypeId));
  }
  readWkbCollection(reader, expectedTypeId) {
    const num = this.readUint32();
    const items = [];
    for (let i2 = 0; i2 < num; i2++) {
      const result = reader.call(this, expectedTypeId);
      if (result) {
        items.push(result);
      }
    }
    return items;
  }
  readMultiPoint() {
    return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.POINT);
  }
  readMultiLineString() {
    return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.LINE_STRING);
  }
  readMultiPolygon() {
    return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.POLYGON);
  }
  readGeometryCollection() {
    return this.readWkbCollection(this.readGeometry);
  }
  readGeometry() {
    const typeId = this.readWkbHeader();
    const result = this.readWkbPayload(typeId);
    switch (typeId) {
      case WKBGeometryType.POINT:
        return new Point$3(result, this.layout_);
      case WKBGeometryType.LINE_STRING:
        return new LineString$1(result, this.layout_);
      case WKBGeometryType.POLYGON:
      case WKBGeometryType.TRIANGLE:
        return new Polygon$1(result, this.layout_);
      case WKBGeometryType.MULTI_POINT:
        return new MultiPoint$1(result, this.layout_);
      case WKBGeometryType.MULTI_LINE_STRING:
        return new MultiLineString$1(result, this.layout_);
      case WKBGeometryType.MULTI_POLYGON:
      case WKBGeometryType.POLYHEDRAL_SURFACE:
      case WKBGeometryType.TIN:
        return new MultiPolygon$1(result, this.layout_);
      case WKBGeometryType.GEOMETRY_COLLECTION:
        return new GeometryCollection(result);
      default:
        return null;
    }
  }
  getSrid() {
    return this.srid_;
  }
}
class WkbWriter {
  constructor(opts) {
    opts = opts || {};
    this.layout_ = opts.layout;
    this.isLittleEndian_ = opts.littleEndian !== false;
    this.isEWKB_ = opts.ewkb !== false;
    this.writeQueue_ = [];
    this.nodata_ = Object.assign({ X: 0, Y: 0, Z: 0, M: 0 }, opts.nodata);
  }
  writeUint8(value) {
    this.writeQueue_.push([1, value]);
  }
  writeUint32(value) {
    this.writeQueue_.push([4, value]);
  }
  writeDouble(value) {
    this.writeQueue_.push([8, value]);
  }
  writePoint(coords, layout) {
    const coordsObj = Object.assign.apply(null, layout.split("").map((axis, idx) => ({ [axis]: coords[idx] })));
    for (const axis of this.layout_) {
      this.writeDouble(axis in coordsObj ? coordsObj[axis] : this.nodata_[axis]);
    }
  }
  writeLineString(coords, layout) {
    this.writeUint32(coords.length);
    for (let i2 = 0; i2 < coords.length; i2++) {
      this.writePoint(coords[i2], layout);
    }
  }
  writePolygon(rings, layout) {
    this.writeUint32(rings.length);
    for (let i2 = 0; i2 < rings.length; i2++) {
      this.writeLineString(rings[i2], layout);
    }
  }
  writeWkbHeader(wkbType, srid) {
    wkbType %= 1e3;
    if (this.layout_.includes("Z")) {
      wkbType += this.isEWKB_ ? 2147483648 : 1e3;
    }
    if (this.layout_.includes("M")) {
      wkbType += this.isEWKB_ ? 1073741824 : 2e3;
    }
    if (this.isEWKB_ && Number.isInteger(srid)) {
      wkbType |= 536870912;
    }
    this.writeUint8(this.isLittleEndian_ ? 1 : 0);
    this.writeUint32(wkbType);
    if (this.isEWKB_ && Number.isInteger(srid)) {
      this.writeUint32(srid);
    }
  }
  writeMultiPoint(coords, layout) {
    this.writeUint32(coords.length);
    for (let i2 = 0; i2 < coords.length; i2++) {
      this.writeWkbHeader(1);
      this.writePoint(coords[i2], layout);
    }
  }
  writeMultiLineString(coords, layout) {
    this.writeUint32(coords.length);
    for (let i2 = 0; i2 < coords.length; i2++) {
      this.writeWkbHeader(2);
      this.writeLineString(coords[i2], layout);
    }
  }
  writeMultiPolygon(coords, layout) {
    this.writeUint32(coords.length);
    for (let i2 = 0; i2 < coords.length; i2++) {
      this.writeWkbHeader(3);
      this.writePolygon(coords[i2], layout);
    }
  }
  writeGeometryCollection(geometries) {
    this.writeUint32(geometries.length);
    for (let i2 = 0; i2 < geometries.length; i2++) {
      this.writeGeometry(geometries[i2]);
    }
  }
  findMinimumLayout(geom2, layout = "XYZM") {
    const GeometryLayout_min = (a2, b2) => {
      if (a2 === b2) {
        return a2;
      }
      if (a2 === "XYZM") {
        return b2;
      }
      if (b2 === "XYZM") {
        return a2;
      }
      return "XY";
    };
    if (geom2 instanceof SimpleGeometry) {
      return GeometryLayout_min(geom2.getLayout(), layout);
    }
    if (geom2 instanceof GeometryCollection) {
      const geoms = geom2.getGeometriesArray();
      for (let i2 = 0; i2 < geoms.length && layout !== "XY"; i2++) {
        layout = this.findMinimumLayout(geoms[i2], layout);
      }
    }
    return layout;
  }
  writeGeometry(geom2, srid) {
    const wkblut = {
      Point: WKBGeometryType.POINT,
      LineString: WKBGeometryType.LINE_STRING,
      Polygon: WKBGeometryType.POLYGON,
      MultiPoint: WKBGeometryType.MULTI_POINT,
      MultiLineString: WKBGeometryType.MULTI_LINE_STRING,
      MultiPolygon: WKBGeometryType.MULTI_POLYGON,
      GeometryCollection: WKBGeometryType.GEOMETRY_COLLECTION
    };
    const geomType = geom2.getType();
    const typeId = wkblut[geomType];
    if (!typeId) {
      throw new Error("GeometryType " + geomType + " is not supported");
    }
    if (!this.layout_) {
      this.layout_ = this.findMinimumLayout(geom2);
    }
    this.writeWkbHeader(typeId, srid);
    if (geom2 instanceof SimpleGeometry) {
      const writerLUT = {
        Point: this.writePoint,
        LineString: this.writeLineString,
        Polygon: this.writePolygon,
        MultiPoint: this.writeMultiPoint,
        MultiLineString: this.writeMultiLineString,
        MultiPolygon: this.writeMultiPolygon
      };
      writerLUT[geomType].call(this, geom2.getCoordinates(), geom2.getLayout());
    } else if (geom2 instanceof GeometryCollection) {
      this.writeGeometryCollection(geom2.getGeometriesArray());
    }
  }
  getBuffer() {
    const byteLength = this.writeQueue_.reduce((acc, item) => acc + item[0], 0);
    const buffer2 = new ArrayBuffer(byteLength);
    const view = new DataView(buffer2);
    let pos = 0;
    this.writeQueue_.forEach((item) => {
      switch (item[0]) {
        case 1:
          view.setUint8(pos, item[1]);
          break;
        case 4:
          view.setUint32(pos, item[1], this.isLittleEndian_);
          break;
        case 8:
          view.setFloat64(pos, item[1], this.isLittleEndian_);
          break;
      }
      pos += item[0];
    });
    return buffer2;
  }
}
class WKB extends FeatureFormat {
  constructor(options) {
    super();
    options = options ? options : {};
    this.splitCollection = Boolean(options.splitCollection);
    this.viewCache_ = null;
    this.hex_ = options.hex !== false;
    this.littleEndian_ = options.littleEndian !== false;
    this.ewkb_ = options.ewkb !== false;
    this.layout_ = options.geometryLayout;
    this.nodataZ_ = options.nodataZ || 0;
    this.nodataM_ = options.nodataM || 0;
    this.srid_ = options.srid;
  }
  getType() {
    return this.hex_ ? "text" : "arraybuffer";
  }
  readFeature(source, options) {
    return new Feature$1({
      geometry: this.readGeometry(source, options)
    });
  }
  readFeatures(source, options) {
    let geometries = [];
    const geometry = this.readGeometry(source, options);
    if (this.splitCollection && geometry instanceof GeometryCollection) {
      geometries = geometry.getGeometriesArray();
    } else {
      geometries = [geometry];
    }
    return geometries.map((geometry2) => new Feature$1({ geometry: geometry2 }));
  }
  readGeometry(source, options) {
    const view = getDataView(source);
    if (!view) {
      return null;
    }
    const reader = new WkbReader(view);
    const geometry = reader.readGeometry();
    this.viewCache_ = view;
    options = this.getReadOptions(source, options);
    this.viewCache_ = null;
    return transformGeometryWithOptions(geometry, false, options);
  }
  readProjection(source) {
    const view = this.viewCache_ || getDataView(source);
    if (!view) {
      return void 0;
    }
    const reader = new WkbReader(view);
    reader.readWkbHeader();
    return reader.getSrid() && get$4("EPSG:" + reader.getSrid()) || void 0;
  }
  writeFeature(feature, options) {
    return this.writeGeometry(feature.getGeometry(), options);
  }
  writeFeatures(features, options) {
    return this.writeGeometry(new GeometryCollection(features.map((f2) => f2.getGeometry())), options);
  }
  writeGeometry(geometry, options) {
    options = this.adaptOptions(options);
    const writer = new WkbWriter({
      layout: this.layout_,
      littleEndian: this.littleEndian_,
      ewkb: this.ewkb_,
      nodata: {
        Z: this.nodataZ_,
        M: this.nodataM_
      }
    });
    let srid = Number.isInteger(this.srid_) ? Number(this.srid_) : null;
    if (this.srid_ !== false && !Number.isInteger(this.srid_)) {
      const dataProjection = options.dataProjection && get$4(options.dataProjection);
      if (dataProjection) {
        const code = dataProjection.getCode();
        if (code.startsWith("EPSG:")) {
          srid = Number(code.substring(5));
        }
      }
    }
    writer.writeGeometry(transformGeometryWithOptions(geometry, true, options), srid);
    const buffer2 = writer.getBuffer();
    return this.hex_ ? encodeHexString(buffer2) : buffer2;
  }
}
function encodeHexString(buffer2) {
  const view = new Uint8Array(buffer2);
  return Array.from(view.values()).map((x2) => (x2 < 16 ? "0" : "") + Number(x2).toString(16).toUpperCase()).join("");
}
function decodeHexString(text2) {
  const buffer2 = new Uint8Array(text2.length / 2);
  for (let i2 = 0; i2 < text2.length / 2; i2++) {
    buffer2[i2] = parseInt(text2.substr(i2 * 2, 2), 16);
  }
  return new DataView(buffer2.buffer);
}
function getDataView(source) {
  if (typeof source === "string") {
    return decodeHexString(source);
  } else if (ArrayBuffer.isView(source)) {
    if (source instanceof DataView) {
      return source;
    }
    return new DataView(source.buffer, source.byteOffset, source.byteLength);
  } else if (source instanceof ArrayBuffer) {
    return new DataView(source);
  }
  return null;
}
const GeometryConstructor = {
  "POINT": Point$3,
  "LINESTRING": LineString$1,
  "POLYGON": Polygon$1,
  "MULTIPOINT": MultiPoint$1,
  "MULTILINESTRING": MultiLineString$1,
  "MULTIPOLYGON": MultiPolygon$1
};
const EMPTY = "EMPTY";
const Z$1 = "Z";
const M = "M";
const ZM = "ZM";
const TokenType = {
  START: 0,
  TEXT: 1,
  LEFT_PAREN: 2,
  RIGHT_PAREN: 3,
  NUMBER: 4,
  COMMA: 5,
  EOF: 6
};
const wktTypeLookup = {
  Point: "POINT",
  LineString: "LINESTRING",
  Polygon: "POLYGON",
  MultiPoint: "MULTIPOINT",
  MultiLineString: "MULTILINESTRING",
  MultiPolygon: "MULTIPOLYGON",
  GeometryCollection: "GEOMETRYCOLLECTION",
  Circle: "CIRCLE"
};
class Lexer {
  constructor(wkt2) {
    this.wkt = wkt2;
    this.index_ = -1;
  }
  isAlpha_(c2) {
    return c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z";
  }
  isNumeric_(c2, decimal) {
    decimal = decimal !== void 0 ? decimal : false;
    return c2 >= "0" && c2 <= "9" || c2 == "." && !decimal;
  }
  isWhiteSpace_(c2) {
    return c2 == " " || c2 == "	" || c2 == "\r" || c2 == "\n";
  }
  nextChar_() {
    return this.wkt.charAt(++this.index_);
  }
  nextToken() {
    const c2 = this.nextChar_();
    const position2 = this.index_;
    let value = c2;
    let type;
    if (c2 == "(") {
      type = TokenType.LEFT_PAREN;
    } else if (c2 == ",") {
      type = TokenType.COMMA;
    } else if (c2 == ")") {
      type = TokenType.RIGHT_PAREN;
    } else if (this.isNumeric_(c2) || c2 == "-") {
      type = TokenType.NUMBER;
      value = this.readNumber_();
    } else if (this.isAlpha_(c2)) {
      type = TokenType.TEXT;
      value = this.readText_();
    } else if (this.isWhiteSpace_(c2)) {
      return this.nextToken();
    } else if (c2 === "") {
      type = TokenType.EOF;
    } else {
      throw new Error("Unexpected character: " + c2);
    }
    return { position: position2, value, type };
  }
  readNumber_() {
    let c2;
    const index2 = this.index_;
    let decimal = false;
    let scientificNotation = false;
    do {
      if (c2 == ".") {
        decimal = true;
      } else if (c2 == "e" || c2 == "E") {
        scientificNotation = true;
      }
      c2 = this.nextChar_();
    } while (this.isNumeric_(c2, decimal) || !scientificNotation && (c2 == "e" || c2 == "E") || scientificNotation && (c2 == "-" || c2 == "+"));
    return parseFloat(this.wkt.substring(index2, this.index_--));
  }
  readText_() {
    let c2;
    const index2 = this.index_;
    do {
      c2 = this.nextChar_();
    } while (this.isAlpha_(c2));
    return this.wkt.substring(index2, this.index_--).toUpperCase();
  }
}
class Parser$2 {
  constructor(lexer) {
    this.lexer_ = lexer;
    this.token_ = {
      position: 0,
      type: TokenType.START
    };
    this.layout_ = "XY";
  }
  consume_() {
    this.token_ = this.lexer_.nextToken();
  }
  isTokenType(type) {
    return this.token_.type == type;
  }
  match(type) {
    const isMatch = this.isTokenType(type);
    if (isMatch) {
      this.consume_();
    }
    return isMatch;
  }
  parse() {
    this.consume_();
    return this.parseGeometry_();
  }
  parseGeometryLayout_() {
    let layout = "XY";
    const dimToken = this.token_;
    if (this.isTokenType(TokenType.TEXT)) {
      const dimInfo = dimToken.value;
      if (dimInfo === Z$1) {
        layout = "XYZ";
      } else if (dimInfo === M) {
        layout = "XYM";
      } else if (dimInfo === ZM) {
        layout = "XYZM";
      }
      if (layout !== "XY") {
        this.consume_();
      }
    }
    return layout;
  }
  parseGeometryCollectionText_() {
    if (this.match(TokenType.LEFT_PAREN)) {
      const geometries = [];
      do {
        geometries.push(this.parseGeometry_());
      } while (this.match(TokenType.COMMA));
      if (this.match(TokenType.RIGHT_PAREN)) {
        return geometries;
      }
    }
    throw new Error(this.formatErrorMessage_());
  }
  parsePointText_() {
    if (this.match(TokenType.LEFT_PAREN)) {
      const coordinates2 = this.parsePoint_();
      if (this.match(TokenType.RIGHT_PAREN)) {
        return coordinates2;
      }
    }
    throw new Error(this.formatErrorMessage_());
  }
  parseLineStringText_() {
    if (this.match(TokenType.LEFT_PAREN)) {
      const coordinates2 = this.parsePointList_();
      if (this.match(TokenType.RIGHT_PAREN)) {
        return coordinates2;
      }
    }
    throw new Error(this.formatErrorMessage_());
  }
  parsePolygonText_() {
    if (this.match(TokenType.LEFT_PAREN)) {
      const coordinates2 = this.parseLineStringTextList_();
      if (this.match(TokenType.RIGHT_PAREN)) {
        return coordinates2;
      }
    }
    throw new Error(this.formatErrorMessage_());
  }
  parseMultiPointText_() {
    if (this.match(TokenType.LEFT_PAREN)) {
      let coordinates2;
      if (this.token_.type == TokenType.LEFT_PAREN) {
        coordinates2 = this.parsePointTextList_();
      } else {
        coordinates2 = this.parsePointList_();
      }
      if (this.match(TokenType.RIGHT_PAREN)) {
        return coordinates2;
      }
    }
    throw new Error(this.formatErrorMessage_());
  }
  parseMultiLineStringText_() {
    if (this.match(TokenType.LEFT_PAREN)) {
      const coordinates2 = this.parseLineStringTextList_();
      if (this.match(TokenType.RIGHT_PAREN)) {
        return coordinates2;
      }
    }
    throw new Error(this.formatErrorMessage_());
  }
  parseMultiPolygonText_() {
    if (this.match(TokenType.LEFT_PAREN)) {
      const coordinates2 = this.parsePolygonTextList_();
      if (this.match(TokenType.RIGHT_PAREN)) {
        return coordinates2;
      }
    }
    throw new Error(this.formatErrorMessage_());
  }
  parsePoint_() {
    const coordinates2 = [];
    const dimensions = this.layout_.length;
    for (let i2 = 0; i2 < dimensions; ++i2) {
      const token = this.token_;
      if (this.match(TokenType.NUMBER)) {
        coordinates2.push(token.value);
      } else {
        break;
      }
    }
    if (coordinates2.length == dimensions) {
      return coordinates2;
    }
    throw new Error(this.formatErrorMessage_());
  }
  parsePointList_() {
    const coordinates2 = [this.parsePoint_()];
    while (this.match(TokenType.COMMA)) {
      coordinates2.push(this.parsePoint_());
    }
    return coordinates2;
  }
  parsePointTextList_() {
    const coordinates2 = [this.parsePointText_()];
    while (this.match(TokenType.COMMA)) {
      coordinates2.push(this.parsePointText_());
    }
    return coordinates2;
  }
  parseLineStringTextList_() {
    const coordinates2 = [this.parseLineStringText_()];
    while (this.match(TokenType.COMMA)) {
      coordinates2.push(this.parseLineStringText_());
    }
    return coordinates2;
  }
  parsePolygonTextList_() {
    const coordinates2 = [this.parsePolygonText_()];
    while (this.match(TokenType.COMMA)) {
      coordinates2.push(this.parsePolygonText_());
    }
    return coordinates2;
  }
  isEmptyGeometry_() {
    const isEmpty2 = this.isTokenType(TokenType.TEXT) && this.token_.value == EMPTY;
    if (isEmpty2) {
      this.consume_();
    }
    return isEmpty2;
  }
  formatErrorMessage_() {
    return "Unexpected `" + this.token_.value + "` at position " + this.token_.position + " in `" + this.lexer_.wkt + "`";
  }
  parseGeometry_() {
    const token = this.token_;
    if (this.match(TokenType.TEXT)) {
      const geomType = token.value;
      this.layout_ = this.parseGeometryLayout_();
      const isEmpty2 = this.isEmptyGeometry_();
      if (geomType == "GEOMETRYCOLLECTION") {
        if (isEmpty2) {
          return new GeometryCollection([]);
        }
        const geometries = this.parseGeometryCollectionText_();
        return new GeometryCollection(geometries);
      }
      const ctor = GeometryConstructor[geomType];
      if (!ctor) {
        throw new Error("Invalid geometry type: " + geomType);
      }
      let coordinates2;
      if (isEmpty2) {
        if (geomType == "POINT") {
          coordinates2 = [NaN, NaN];
        } else {
          coordinates2 = [];
        }
      } else {
        switch (geomType) {
          case "POINT": {
            coordinates2 = this.parsePointText_();
            break;
          }
          case "LINESTRING": {
            coordinates2 = this.parseLineStringText_();
            break;
          }
          case "POLYGON": {
            coordinates2 = this.parsePolygonText_();
            break;
          }
          case "MULTIPOINT": {
            coordinates2 = this.parseMultiPointText_();
            break;
          }
          case "MULTILINESTRING": {
            coordinates2 = this.parseMultiLineStringText_();
            break;
          }
          case "MULTIPOLYGON": {
            coordinates2 = this.parseMultiPolygonText_();
            break;
          }
        }
      }
      return new ctor(coordinates2, this.layout_);
    }
    throw new Error(this.formatErrorMessage_());
  }
}
class WKT extends TextFeature {
  constructor(options) {
    super();
    options = options ? options : {};
    this.splitCollection_ = options.splitCollection !== void 0 ? options.splitCollection : false;
  }
  parse_(wkt2) {
    const lexer = new Lexer(wkt2);
    const parser = new Parser$2(lexer);
    return parser.parse();
  }
  readFeatureFromText(text2, options) {
    const geom2 = this.readGeometryFromText(text2, options);
    const feature = new Feature$1();
    feature.setGeometry(geom2);
    return feature;
  }
  readFeaturesFromText(text2, options) {
    let geometries = [];
    const geometry = this.readGeometryFromText(text2, options);
    if (this.splitCollection_ && geometry.getType() == "GeometryCollection") {
      geometries = geometry.getGeometriesArray();
    } else {
      geometries = [geometry];
    }
    const features = [];
    for (let i2 = 0, ii = geometries.length; i2 < ii; ++i2) {
      const feature = new Feature$1();
      feature.setGeometry(geometries[i2]);
      features.push(feature);
    }
    return features;
  }
  readGeometryFromText(text2, options) {
    const geometry = this.parse_(text2);
    return transformGeometryWithOptions(geometry, false, options);
  }
  writeFeatureText(feature, options) {
    const geometry = feature.getGeometry();
    if (geometry) {
      return this.writeGeometryText(geometry, options);
    }
    return "";
  }
  writeFeaturesText(features, options) {
    if (features.length == 1) {
      return this.writeFeatureText(features[0], options);
    }
    const geometries = [];
    for (let i2 = 0, ii = features.length; i2 < ii; ++i2) {
      geometries.push(features[i2].getGeometry());
    }
    const collection = new GeometryCollection(geometries);
    return this.writeGeometryText(collection, options);
  }
  writeGeometryText(geometry, options) {
    return encode(transformGeometryWithOptions(geometry, true, options));
  }
}
function encodePointGeometry(geom2) {
  const coordinates2 = geom2.getCoordinates();
  if (coordinates2.length === 0) {
    return "";
  }
  return coordinates2.join(" ");
}
function encodeMultiPointGeometry(geom2) {
  const array = [];
  const components = geom2.getPoints();
  for (let i2 = 0, ii = components.length; i2 < ii; ++i2) {
    array.push("(" + encodePointGeometry(components[i2]) + ")");
  }
  return array.join(",");
}
function encodeGeometryCollectionGeometry(geom2) {
  const array = [];
  const geoms = geom2.getGeometries();
  for (let i2 = 0, ii = geoms.length; i2 < ii; ++i2) {
    array.push(encode(geoms[i2]));
  }
  return array.join(",");
}
function encodeLineStringGeometry(geom2) {
  const coordinates2 = geom2.getCoordinates();
  const array = [];
  for (let i2 = 0, ii = coordinates2.length; i2 < ii; ++i2) {
    array.push(coordinates2[i2].join(" "));
  }
  return array.join(",");
}
function encodeMultiLineStringGeometry(geom2) {
  const array = [];
  const components = geom2.getLineStrings();
  for (let i2 = 0, ii = components.length; i2 < ii; ++i2) {
    array.push("(" + encodeLineStringGeometry(components[i2]) + ")");
  }
  return array.join(",");
}
function encodePolygonGeometry(geom2) {
  const array = [];
  const rings = geom2.getLinearRings();
  for (let i2 = 0, ii = rings.length; i2 < ii; ++i2) {
    array.push("(" + encodeLineStringGeometry(rings[i2]) + ")");
  }
  return array.join(",");
}
function encodeMultiPolygonGeometry(geom2) {
  const array = [];
  const components = geom2.getPolygons();
  for (let i2 = 0, ii = components.length; i2 < ii; ++i2) {
    array.push("(" + encodePolygonGeometry(components[i2]) + ")");
  }
  return array.join(",");
}
function encodeGeometryLayout(geom2) {
  const layout = geom2.getLayout();
  let dimInfo = "";
  if (layout === "XYZ" || layout === "XYZM") {
    dimInfo += Z$1;
  }
  if (layout === "XYM" || layout === "XYZM") {
    dimInfo += M;
  }
  return dimInfo;
}
const GeometryEncoder = {
  "Point": encodePointGeometry,
  "LineString": encodeLineStringGeometry,
  "Polygon": encodePolygonGeometry,
  "MultiPoint": encodeMultiPointGeometry,
  "MultiLineString": encodeMultiLineStringGeometry,
  "MultiPolygon": encodeMultiPolygonGeometry,
  "GeometryCollection": encodeGeometryCollectionGeometry
};
function encode(geom2) {
  const type = geom2.getType();
  const geometryEncoder = GeometryEncoder[type];
  const enc = geometryEncoder(geom2);
  let wktType = wktTypeLookup[type];
  if (typeof geom2.getFlatCoordinates === "function") {
    const dimInfo = encodeGeometryLayout(geom2);
    if (dimInfo.length > 0) {
      wktType += " " + dimInfo;
    }
  }
  if (enc.length === 0) {
    return wktType + " " + EMPTY;
  }
  return wktType + "(" + enc + ")";
}
const NAMESPACE_URIS$1 = [null, "http://www.opengis.net/wms"];
const PARSERS$1 = makeStructureNS(NAMESPACE_URIS$1, {
  "Service": makeObjectPropertySetter(readService),
  "Capability": makeObjectPropertySetter(readCapability)
});
const CAPABILITY_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {
  "Request": makeObjectPropertySetter(readRequest),
  "Exception": makeObjectPropertySetter(readException),
  "Layer": makeObjectPropertySetter(readCapabilityLayer)
});
class WMSCapabilities extends XML {
  constructor() {
    super();
    this.version = void 0;
  }
  readFromNode(node2) {
    this.version = node2.getAttribute("version").trim();
    const wmsCapabilityObject = pushParseAndPop({
      "version": this.version
    }, PARSERS$1, node2, []);
    return wmsCapabilityObject ? wmsCapabilityObject : null;
  }
}
const SERVICE_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {
  "Name": makeObjectPropertySetter(readString),
  "Title": makeObjectPropertySetter(readString),
  "Abstract": makeObjectPropertySetter(readString),
  "KeywordList": makeObjectPropertySetter(readKeywordList),
  "OnlineResource": makeObjectPropertySetter(readHref),
  "ContactInformation": makeObjectPropertySetter(readContactInformation),
  "Fees": makeObjectPropertySetter(readString),
  "AccessConstraints": makeObjectPropertySetter(readString),
  "LayerLimit": makeObjectPropertySetter(readPositiveInteger),
  "MaxWidth": makeObjectPropertySetter(readPositiveInteger),
  "MaxHeight": makeObjectPropertySetter(readPositiveInteger)
});
const CONTACT_INFORMATION_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {
  "ContactPersonPrimary": makeObjectPropertySetter(readContactPersonPrimary),
  "ContactPosition": makeObjectPropertySetter(readString),
  "ContactAddress": makeObjectPropertySetter(readContactAddress),
  "ContactVoiceTelephone": makeObjectPropertySetter(readString),
  "ContactFacsimileTelephone": makeObjectPropertySetter(readString),
  "ContactElectronicMailAddress": makeObjectPropertySetter(readString)
});
const CONTACT_PERSON_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {
  "ContactPerson": makeObjectPropertySetter(readString),
  "ContactOrganization": makeObjectPropertySetter(readString)
});
const CONTACT_ADDRESS_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {
  "AddressType": makeObjectPropertySetter(readString),
  "Address": makeObjectPropertySetter(readString),
  "City": makeObjectPropertySetter(readString),
  "StateOrProvince": makeObjectPropertySetter(readString),
  "PostCode": makeObjectPropertySetter(readString),
  "Country": makeObjectPropertySetter(readString)
});
const EXCEPTION_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {
  "Format": makeArrayPusher(readString)
});
const LAYER_PARSERS$1 = makeStructureNS(NAMESPACE_URIS$1, {
  "Name": makeObjectPropertySetter(readString),
  "Title": makeObjectPropertySetter(readString),
  "Abstract": makeObjectPropertySetter(readString),
  "KeywordList": makeObjectPropertySetter(readKeywordList),
  "CRS": makeObjectPropertyPusher(readString),
  "EX_GeographicBoundingBox": makeObjectPropertySetter(readEXGeographicBoundingBox),
  "BoundingBox": makeObjectPropertyPusher(readBoundingBox$1),
  "Dimension": makeObjectPropertyPusher(readDimension),
  "Attribution": makeObjectPropertySetter(readAttribution),
  "AuthorityURL": makeObjectPropertyPusher(readAuthorityURL),
  "Identifier": makeObjectPropertyPusher(readString),
  "MetadataURL": makeObjectPropertyPusher(readMetadataURL),
  "DataURL": makeObjectPropertyPusher(readFormatOnlineresource),
  "FeatureListURL": makeObjectPropertyPusher(readFormatOnlineresource),
  "Style": makeObjectPropertyPusher(readStyle$1),
  "MinScaleDenominator": makeObjectPropertySetter(readDecimal),
  "MaxScaleDenominator": makeObjectPropertySetter(readDecimal),
  "Layer": makeObjectPropertyPusher(readLayer$1)
});
const ATTRIBUTION_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {
  "Title": makeObjectPropertySetter(readString),
  "OnlineResource": makeObjectPropertySetter(readHref),
  "LogoURL": makeObjectPropertySetter(readSizedFormatOnlineresource)
});
const EX_GEOGRAPHIC_BOUNDING_BOX_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {
  "westBoundLongitude": makeObjectPropertySetter(readDecimal),
  "eastBoundLongitude": makeObjectPropertySetter(readDecimal),
  "southBoundLatitude": makeObjectPropertySetter(readDecimal),
  "northBoundLatitude": makeObjectPropertySetter(readDecimal)
});
const REQUEST_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {
  "GetCapabilities": makeObjectPropertySetter(readOperationType),
  "GetMap": makeObjectPropertySetter(readOperationType),
  "GetFeatureInfo": makeObjectPropertySetter(readOperationType)
});
const OPERATIONTYPE_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {
  "Format": makeObjectPropertyPusher(readString),
  "DCPType": makeObjectPropertyPusher(readDCPType)
});
const DCPTYPE_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {
  "HTTP": makeObjectPropertySetter(readHTTP)
});
const HTTP_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {
  "Get": makeObjectPropertySetter(readFormatOnlineresource),
  "Post": makeObjectPropertySetter(readFormatOnlineresource)
});
const STYLE_PARSERS$1 = makeStructureNS(NAMESPACE_URIS$1, {
  "Name": makeObjectPropertySetter(readString),
  "Title": makeObjectPropertySetter(readString),
  "Abstract": makeObjectPropertySetter(readString),
  "LegendURL": makeObjectPropertyPusher(readSizedFormatOnlineresource),
  "StyleSheetURL": makeObjectPropertySetter(readFormatOnlineresource),
  "StyleURL": makeObjectPropertySetter(readFormatOnlineresource)
});
const FORMAT_ONLINERESOURCE_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {
  "Format": makeObjectPropertySetter(readString),
  "OnlineResource": makeObjectPropertySetter(readHref)
});
const KEYWORDLIST_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {
  "Keyword": makeArrayPusher(readString)
});
function readAttribution(node2, objectStack) {
  return pushParseAndPop({}, ATTRIBUTION_PARSERS, node2, objectStack);
}
function readBoundingBox$1(node2, objectStack) {
  const extent2 = [
    readDecimalString(node2.getAttribute("minx")),
    readDecimalString(node2.getAttribute("miny")),
    readDecimalString(node2.getAttribute("maxx")),
    readDecimalString(node2.getAttribute("maxy"))
  ];
  const resolutions = [
    readDecimalString(node2.getAttribute("resx")),
    readDecimalString(node2.getAttribute("resy"))
  ];
  return {
    "crs": node2.getAttribute("CRS"),
    "extent": extent2,
    "res": resolutions
  };
}
function readEXGeographicBoundingBox(node2, objectStack) {
  const geographicBoundingBox = pushParseAndPop({}, EX_GEOGRAPHIC_BOUNDING_BOX_PARSERS, node2, objectStack);
  if (!geographicBoundingBox) {
    return void 0;
  }
  const westBoundLongitude = geographicBoundingBox["westBoundLongitude"];
  const southBoundLatitude = geographicBoundingBox["southBoundLatitude"];
  const eastBoundLongitude = geographicBoundingBox["eastBoundLongitude"];
  const northBoundLatitude = geographicBoundingBox["northBoundLatitude"];
  if (westBoundLongitude === void 0 || southBoundLatitude === void 0 || eastBoundLongitude === void 0 || northBoundLatitude === void 0) {
    return void 0;
  }
  return [
    westBoundLongitude,
    southBoundLatitude,
    eastBoundLongitude,
    northBoundLatitude
  ];
}
function readCapability(node2, objectStack) {
  return pushParseAndPop({}, CAPABILITY_PARSERS, node2, objectStack);
}
function readService(node2, objectStack) {
  return pushParseAndPop({}, SERVICE_PARSERS, node2, objectStack);
}
function readContactInformation(node2, objectStack) {
  return pushParseAndPop({}, CONTACT_INFORMATION_PARSERS, node2, objectStack);
}
function readContactPersonPrimary(node2, objectStack) {
  return pushParseAndPop({}, CONTACT_PERSON_PARSERS, node2, objectStack);
}
function readContactAddress(node2, objectStack) {
  return pushParseAndPop({}, CONTACT_ADDRESS_PARSERS, node2, objectStack);
}
function readException(node2, objectStack) {
  return pushParseAndPop([], EXCEPTION_PARSERS, node2, objectStack);
}
function readCapabilityLayer(node2, objectStack) {
  const layerObject = pushParseAndPop({}, LAYER_PARSERS$1, node2, objectStack);
  if (layerObject["Layer"] === void 0) {
    return Object.assign(layerObject, readLayer$1(node2, objectStack));
  }
  return layerObject;
}
function readLayer$1(node2, objectStack) {
  const parentLayerObject = objectStack[objectStack.length - 1];
  const layerObject = pushParseAndPop({}, LAYER_PARSERS$1, node2, objectStack);
  if (!layerObject) {
    return void 0;
  }
  let queryable = readBooleanString(node2.getAttribute("queryable"));
  if (queryable === void 0) {
    queryable = parentLayerObject["queryable"];
  }
  layerObject["queryable"] = queryable !== void 0 ? queryable : false;
  let cascaded = readNonNegativeIntegerString(node2.getAttribute("cascaded"));
  if (cascaded === void 0) {
    cascaded = parentLayerObject["cascaded"];
  }
  layerObject["cascaded"] = cascaded;
  let opaque = readBooleanString(node2.getAttribute("opaque"));
  if (opaque === void 0) {
    opaque = parentLayerObject["opaque"];
  }
  layerObject["opaque"] = opaque !== void 0 ? opaque : false;
  let noSubsets = readBooleanString(node2.getAttribute("noSubsets"));
  if (noSubsets === void 0) {
    noSubsets = parentLayerObject["noSubsets"];
  }
  layerObject["noSubsets"] = noSubsets !== void 0 ? noSubsets : false;
  let fixedWidth = readDecimalString(node2.getAttribute("fixedWidth"));
  if (!fixedWidth) {
    fixedWidth = parentLayerObject["fixedWidth"];
  }
  layerObject["fixedWidth"] = fixedWidth;
  let fixedHeight = readDecimalString(node2.getAttribute("fixedHeight"));
  if (!fixedHeight) {
    fixedHeight = parentLayerObject["fixedHeight"];
  }
  layerObject["fixedHeight"] = fixedHeight;
  const addKeys = ["Style", "CRS", "AuthorityURL"];
  addKeys.forEach(function(key) {
    if (key in parentLayerObject) {
      const childValue = layerObject[key] || [];
      layerObject[key] = childValue.concat(parentLayerObject[key]);
    }
  });
  const replaceKeys = [
    "EX_GeographicBoundingBox",
    "BoundingBox",
    "Dimension",
    "Attribution",
    "MinScaleDenominator",
    "MaxScaleDenominator"
  ];
  replaceKeys.forEach(function(key) {
    if (!(key in layerObject)) {
      const parentValue = parentLayerObject[key];
      layerObject[key] = parentValue;
    }
  });
  return layerObject;
}
function readDimension(node2, objectStack) {
  const dimensionObject = {
    "name": node2.getAttribute("name"),
    "units": node2.getAttribute("units"),
    "unitSymbol": node2.getAttribute("unitSymbol"),
    "default": node2.getAttribute("default"),
    "multipleValues": readBooleanString(node2.getAttribute("multipleValues")),
    "nearestValue": readBooleanString(node2.getAttribute("nearestValue")),
    "current": readBooleanString(node2.getAttribute("current")),
    "values": readString(node2)
  };
  return dimensionObject;
}
function readFormatOnlineresource(node2, objectStack) {
  return pushParseAndPop({}, FORMAT_ONLINERESOURCE_PARSERS, node2, objectStack);
}
function readRequest(node2, objectStack) {
  return pushParseAndPop({}, REQUEST_PARSERS, node2, objectStack);
}
function readDCPType(node2, objectStack) {
  return pushParseAndPop({}, DCPTYPE_PARSERS, node2, objectStack);
}
function readHTTP(node2, objectStack) {
  return pushParseAndPop({}, HTTP_PARSERS, node2, objectStack);
}
function readOperationType(node2, objectStack) {
  return pushParseAndPop({}, OPERATIONTYPE_PARSERS, node2, objectStack);
}
function readSizedFormatOnlineresource(node2, objectStack) {
  const formatOnlineresource = readFormatOnlineresource(node2, objectStack);
  if (formatOnlineresource) {
    const size = [
      readNonNegativeIntegerString(node2.getAttribute("width")),
      readNonNegativeIntegerString(node2.getAttribute("height"))
    ];
    formatOnlineresource["size"] = size;
    return formatOnlineresource;
  }
  return void 0;
}
function readAuthorityURL(node2, objectStack) {
  const authorityObject = readFormatOnlineresource(node2, objectStack);
  if (authorityObject) {
    authorityObject["name"] = node2.getAttribute("name");
    return authorityObject;
  }
  return void 0;
}
function readMetadataURL(node2, objectStack) {
  const metadataObject = readFormatOnlineresource(node2, objectStack);
  if (metadataObject) {
    metadataObject["type"] = node2.getAttribute("type");
    return metadataObject;
  }
  return void 0;
}
function readStyle$1(node2, objectStack) {
  return pushParseAndPop({}, STYLE_PARSERS$1, node2, objectStack);
}
function readKeywordList(node2, objectStack) {
  return pushParseAndPop([], KEYWORDLIST_PARSERS, node2, objectStack);
}
const featureIdentifier = "_feature";
const layerIdentifier = "_layer";
class WMSGetFeatureInfo extends XMLFeature {
  constructor(options) {
    super();
    options = options ? options : {};
    this.featureNS_ = "http://mapserver.gis.umn.edu/mapserver";
    this.gmlFormat_ = new GML2();
    this.layers_ = options.layers ? options.layers : null;
  }
  getLayers() {
    return this.layers_;
  }
  setLayers(layers) {
    this.layers_ = layers;
  }
  readFeatures_(node2, objectStack) {
    node2.setAttribute("namespaceURI", this.featureNS_);
    const localName = node2.localName;
    let features = [];
    if (node2.childNodes.length === 0) {
      return features;
    }
    if (localName == "msGMLOutput") {
      for (let i2 = 0, ii = node2.childNodes.length; i2 < ii; i2++) {
        const layer = node2.childNodes[i2];
        if (layer.nodeType !== Node.ELEMENT_NODE) {
          continue;
        }
        const layerElement = layer;
        const context2 = objectStack[0];
        const toRemove = layerIdentifier;
        const layerName = layerElement.localName.replace(toRemove, "");
        if (this.layers_ && !this.layers_.includes(layerName)) {
          continue;
        }
        const featureType = layerName + featureIdentifier;
        context2["featureType"] = featureType;
        context2["featureNS"] = this.featureNS_;
        const parsers = {};
        parsers[featureType] = makeArrayPusher(this.gmlFormat_.readFeatureElement, this.gmlFormat_);
        const parsersNS = makeStructureNS([context2["featureNS"], null], parsers);
        layerElement.setAttribute("namespaceURI", this.featureNS_);
        const layerFeatures = pushParseAndPop([], parsersNS, layerElement, objectStack, this.gmlFormat_);
        if (layerFeatures) {
          extend$3(features, layerFeatures);
        }
      }
    }
    if (localName == "FeatureCollection") {
      const gmlFeatures = pushParseAndPop([], this.gmlFormat_.FEATURE_COLLECTION_PARSERS, node2, [{}], this.gmlFormat_);
      if (gmlFeatures) {
        features = gmlFeatures;
      }
    }
    return features;
  }
  readFeaturesFromNode(node2, options) {
    const internalOptions = {};
    if (options) {
      Object.assign(internalOptions, this.getReadOptions(node2, options));
    }
    return this.readFeatures_(node2, [internalOptions]);
  }
}
const NAMESPACE_URIS = [null, "http://www.opengis.net/wmts/1.0"];
const OWS_NAMESPACE_URIS = [null, "http://www.opengis.net/ows/1.1"];
const PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "Contents": makeObjectPropertySetter(readContents)
});
class WMTSCapabilities extends XML {
  constructor() {
    super();
    this.owsParser_ = new OWS();
  }
  readFromNode(node2) {
    let version2 = node2.getAttribute("version");
    if (version2) {
      version2 = version2.trim();
    }
    let WMTSCapabilityObject = this.owsParser_.readFromNode(node2);
    if (!WMTSCapabilityObject) {
      return null;
    }
    WMTSCapabilityObject["version"] = version2;
    WMTSCapabilityObject = pushParseAndPop(WMTSCapabilityObject, PARSERS, node2, []);
    return WMTSCapabilityObject ? WMTSCapabilityObject : null;
  }
}
const CONTENTS_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "Layer": makeObjectPropertyPusher(readLayer),
  "TileMatrixSet": makeObjectPropertyPusher(readTileMatrixSet)
});
const LAYER_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "Style": makeObjectPropertyPusher(readStyle),
  "Format": makeObjectPropertyPusher(readString),
  "TileMatrixSetLink": makeObjectPropertyPusher(readTileMatrixSetLink),
  "Dimension": makeObjectPropertyPusher(readDimensions),
  "ResourceURL": makeObjectPropertyPusher(readResourceUrl)
}, makeStructureNS(OWS_NAMESPACE_URIS, {
  "Title": makeObjectPropertySetter(readString),
  "Abstract": makeObjectPropertySetter(readString),
  "WGS84BoundingBox": makeObjectPropertySetter(readBoundingBox),
  "Identifier": makeObjectPropertySetter(readString)
}));
const STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "LegendURL": makeObjectPropertyPusher(readLegendUrl)
}, makeStructureNS(OWS_NAMESPACE_URIS, {
  "Title": makeObjectPropertySetter(readString),
  "Identifier": makeObjectPropertySetter(readString)
}));
const TMS_LINKS_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "TileMatrixSet": makeObjectPropertySetter(readString),
  "TileMatrixSetLimits": makeObjectPropertySetter(readTileMatrixLimitsList)
});
const TMS_LIMITS_LIST_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "TileMatrixLimits": makeArrayPusher(readTileMatrixLimits)
});
const TMS_LIMITS_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "TileMatrix": makeObjectPropertySetter(readString),
  "MinTileRow": makeObjectPropertySetter(readPositiveInteger),
  "MaxTileRow": makeObjectPropertySetter(readPositiveInteger),
  "MinTileCol": makeObjectPropertySetter(readPositiveInteger),
  "MaxTileCol": makeObjectPropertySetter(readPositiveInteger)
});
const DIMENSION_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "Default": makeObjectPropertySetter(readString),
  "Value": makeObjectPropertyPusher(readString)
}, makeStructureNS(OWS_NAMESPACE_URIS, {
  "Identifier": makeObjectPropertySetter(readString)
}));
const WGS84_BBOX_READERS = makeStructureNS(OWS_NAMESPACE_URIS, {
  "LowerCorner": makeArrayPusher(readCoordinates),
  "UpperCorner": makeArrayPusher(readCoordinates)
});
const TMS_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "WellKnownScaleSet": makeObjectPropertySetter(readString),
  "TileMatrix": makeObjectPropertyPusher(readTileMatrix)
}, makeStructureNS(OWS_NAMESPACE_URIS, {
  "SupportedCRS": makeObjectPropertySetter(readString),
  "Identifier": makeObjectPropertySetter(readString),
  "BoundingBox": makeObjectPropertySetter(readBoundingBox)
}));
const TM_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "TopLeftCorner": makeObjectPropertySetter(readCoordinates),
  "ScaleDenominator": makeObjectPropertySetter(readDecimal),
  "TileWidth": makeObjectPropertySetter(readPositiveInteger),
  "TileHeight": makeObjectPropertySetter(readPositiveInteger),
  "MatrixWidth": makeObjectPropertySetter(readPositiveInteger),
  "MatrixHeight": makeObjectPropertySetter(readPositiveInteger)
}, makeStructureNS(OWS_NAMESPACE_URIS, {
  "Identifier": makeObjectPropertySetter(readString)
}));
function readContents(node2, objectStack) {
  return pushParseAndPop({}, CONTENTS_PARSERS, node2, objectStack);
}
function readLayer(node2, objectStack) {
  return pushParseAndPop({}, LAYER_PARSERS, node2, objectStack);
}
function readTileMatrixSet(node2, objectStack) {
  return pushParseAndPop({}, TMS_PARSERS, node2, objectStack);
}
function readStyle(node2, objectStack) {
  const style2 = pushParseAndPop({}, STYLE_PARSERS, node2, objectStack);
  if (!style2) {
    return void 0;
  }
  const isDefault = node2.getAttribute("isDefault") === "true";
  style2["isDefault"] = isDefault;
  return style2;
}
function readTileMatrixSetLink(node2, objectStack) {
  return pushParseAndPop({}, TMS_LINKS_PARSERS, node2, objectStack);
}
function readDimensions(node2, objectStack) {
  return pushParseAndPop({}, DIMENSION_PARSERS, node2, objectStack);
}
function readResourceUrl(node2, objectStack) {
  const format2 = node2.getAttribute("format");
  const template = node2.getAttribute("template");
  const resourceType = node2.getAttribute("resourceType");
  const resource = {};
  if (format2) {
    resource["format"] = format2;
  }
  if (template) {
    resource["template"] = template;
  }
  if (resourceType) {
    resource["resourceType"] = resourceType;
  }
  return resource;
}
function readBoundingBox(node2, objectStack) {
  const coordinates2 = pushParseAndPop([], WGS84_BBOX_READERS, node2, objectStack);
  if (coordinates2.length != 2) {
    return void 0;
  }
  return boundingExtent(coordinates2);
}
function readLegendUrl(node2, objectStack) {
  const legend = {};
  legend["format"] = node2.getAttribute("format");
  legend["href"] = readHref(node2);
  return legend;
}
function readCoordinates(node2, objectStack) {
  const coordinates2 = readString(node2).split(/\s+/);
  if (!coordinates2 || coordinates2.length != 2) {
    return void 0;
  }
  const x2 = +coordinates2[0];
  const y2 = +coordinates2[1];
  if (isNaN(x2) || isNaN(y2)) {
    return void 0;
  }
  return [x2, y2];
}
function readTileMatrix(node2, objectStack) {
  return pushParseAndPop({}, TM_PARSERS, node2, objectStack);
}
function readTileMatrixLimitsList(node2, objectStack) {
  return pushParseAndPop([], TMS_LIMITS_LIST_PARSERS, node2, objectStack);
}
function readTileMatrixLimits(node2, objectStack) {
  return pushParseAndPop({}, TMS_LIMITS_PARSERS, node2, objectStack);
}
var format = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  EsriJSON,
  GeoJSON,
  GML,
  GPX,
  IGC,
  IIIFInfo,
  KML,
  MVT,
  OWS,
  Polyline,
  TopoJSON,
  WFS,
  WKB,
  WKT,
  WMSCapabilities,
  WMSGetFeatureInfo,
  WMTSCapabilities
}, Symbol.toStringTag, { value: "Module" }));
function install(app) {
  if (install.installed) {
    console.error("OPENLAYERS MAP ALREADY INSTALLED");
    return;
  }
  install.installed = true;
  app.use(Map$1);
  app.use(Layers);
  app.use(Sources);
  app.use(MapControls);
  app.use(Geometries);
  app.use(Styles);
  app.use(Interactions);
  app.use(Animations);
  app.provide("ol-feature", Feature$1);
  app.provide("ol-geom", geom);
  app.provide("ol-animations", animations);
  app.provide("ol-format", format);
  app.provide("ol-loadingstrategy", loadingstrategy);
  app.provide("ol-selectconditions", selectconditions);
  app.provide("ol-extent", extent);
}
function decodeRowAcc(row, stride) {
  let length = row.length - stride;
  let offset2 = 0;
  do {
    for (let i2 = stride; i2 > 0; i2--) {
      row[offset2 + stride] += row[offset2];
      offset2++;
    }
    length -= stride;
  } while (length > 0);
}
function decodeRowFloatingPoint(row, stride, bytesPerSample) {
  let index2 = 0;
  let count = row.length;
  const wc = count / bytesPerSample;
  while (count > stride) {
    for (let i2 = stride; i2 > 0; --i2) {
      row[index2 + stride] += row[index2];
      ++index2;
    }
    count -= stride;
  }
  const copy = row.slice();
  for (let i2 = 0; i2 < wc; ++i2) {
    for (let b2 = 0; b2 < bytesPerSample; ++b2) {
      row[bytesPerSample * i2 + b2] = copy[(bytesPerSample - b2 - 1) * wc + i2];
    }
  }
}
function applyPredictor(block, predictor, width, height, bitsPerSample, planarConfiguration) {
  if (!predictor || predictor === 1) {
    return block;
  }
  for (let i2 = 0; i2 < bitsPerSample.length; ++i2) {
    if (bitsPerSample[i2] % 8 !== 0) {
      throw new Error("When decoding with predictor, only multiple of 8 bits are supported.");
    }
    if (bitsPerSample[i2] !== bitsPerSample[0]) {
      throw new Error("When decoding with predictor, all samples must have the same size.");
    }
  }
  const bytesPerSample = bitsPerSample[0] / 8;
  const stride = planarConfiguration === 2 ? 1 : bitsPerSample.length;
  for (let i2 = 0; i2 < height; ++i2) {
    if (i2 * stride * width * bytesPerSample >= block.byteLength) {
      break;
    }
    let row;
    if (predictor === 2) {
      switch (bitsPerSample[0]) {
        case 8:
          row = new Uint8Array(block, i2 * stride * width * bytesPerSample, stride * width * bytesPerSample);
          break;
        case 16:
          row = new Uint16Array(block, i2 * stride * width * bytesPerSample, stride * width * bytesPerSample / 2);
          break;
        case 32:
          row = new Uint32Array(block, i2 * stride * width * bytesPerSample, stride * width * bytesPerSample / 4);
          break;
        default:
          throw new Error(`Predictor 2 not allowed with ${bitsPerSample[0]} bits per sample.`);
      }
      decodeRowAcc(row, stride);
    } else if (predictor === 3) {
      row = new Uint8Array(block, i2 * stride * width * bytesPerSample, stride * width * bytesPerSample);
      decodeRowFloatingPoint(row, stride, bytesPerSample);
    }
  }
  return block;
}
class BaseDecoder {
  async decode(fileDirectory, buffer2) {
    const decoded = await this.decodeBlock(buffer2);
    const predictor = fileDirectory.Predictor || 1;
    if (predictor !== 1) {
      const isTiled = !fileDirectory.StripOffsets;
      const tileWidth = isTiled ? fileDirectory.TileWidth : fileDirectory.ImageWidth;
      const tileHeight = isTiled ? fileDirectory.TileLength : fileDirectory.RowsPerStrip || fileDirectory.ImageLength;
      return applyPredictor(decoded, predictor, tileWidth, tileHeight, fileDirectory.BitsPerSample, fileDirectory.PlanarConfiguration);
    }
    return decoded;
  }
}
class RawDecoder extends BaseDecoder {
  decodeBlock(buffer2) {
    return buffer2;
  }
}
var raw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": RawDecoder
}, Symbol.toStringTag, { value: "Module" }));
const MIN_BITS = 9;
const CLEAR_CODE = 256;
const EOI_CODE = 257;
const MAX_BYTELENGTH = 12;
function getByte(array, position2, length) {
  const d2 = position2 % 8;
  const a2 = Math.floor(position2 / 8);
  const de2 = 8 - d2;
  const ef = position2 + length - (a2 + 1) * 8;
  let fg = 8 * (a2 + 2) - (position2 + length);
  const dg = (a2 + 2) * 8 - position2;
  fg = Math.max(0, fg);
  if (a2 >= array.length) {
    console.warn("ran off the end of the buffer before finding EOI_CODE (end on input code)");
    return EOI_CODE;
  }
  let chunk1 = array[a2] & 2 ** (8 - d2) - 1;
  chunk1 <<= length - de2;
  let chunks = chunk1;
  if (a2 + 1 < array.length) {
    let chunk2 = array[a2 + 1] >>> fg;
    chunk2 <<= Math.max(0, length - dg);
    chunks += chunk2;
  }
  if (ef > 8 && a2 + 2 < array.length) {
    const hi = (a2 + 3) * 8 - (position2 + length);
    const chunk3 = array[a2 + 2] >>> hi;
    chunks += chunk3;
  }
  return chunks;
}
function appendReversed(dest, source) {
  for (let i2 = source.length - 1; i2 >= 0; i2--) {
    dest.push(source[i2]);
  }
  return dest;
}
function decompress(input) {
  const dictionaryIndex = new Uint16Array(4093);
  const dictionaryChar = new Uint8Array(4093);
  for (let i2 = 0; i2 <= 257; i2++) {
    dictionaryIndex[i2] = 4096;
    dictionaryChar[i2] = i2;
  }
  let dictionaryLength = 258;
  let byteLength = MIN_BITS;
  let position2 = 0;
  function initDictionary() {
    dictionaryLength = 258;
    byteLength = MIN_BITS;
  }
  function getNext(array2) {
    const byte = getByte(array2, position2, byteLength);
    position2 += byteLength;
    return byte;
  }
  function addToDictionary(i2, c2) {
    dictionaryChar[dictionaryLength] = c2;
    dictionaryIndex[dictionaryLength] = i2;
    dictionaryLength++;
    return dictionaryLength - 1;
  }
  function getDictionaryReversed(n2) {
    const rev2 = [];
    for (let i2 = n2; i2 !== 4096; i2 = dictionaryIndex[i2]) {
      rev2.push(dictionaryChar[i2]);
    }
    return rev2;
  }
  const result = [];
  initDictionary();
  const array = new Uint8Array(input);
  let code = getNext(array);
  let oldCode;
  while (code !== EOI_CODE) {
    if (code === CLEAR_CODE) {
      initDictionary();
      code = getNext(array);
      while (code === CLEAR_CODE) {
        code = getNext(array);
      }
      if (code === EOI_CODE) {
        break;
      } else if (code > CLEAR_CODE) {
        throw new Error(`corrupted code at scanline ${code}`);
      } else {
        const val = getDictionaryReversed(code);
        appendReversed(result, val);
        oldCode = code;
      }
    } else if (code < dictionaryLength) {
      const val = getDictionaryReversed(code);
      appendReversed(result, val);
      addToDictionary(oldCode, val[val.length - 1]);
      oldCode = code;
    } else {
      const oldVal = getDictionaryReversed(oldCode);
      if (!oldVal) {
        throw new Error(`Bogus entry. Not in dictionary, ${oldCode} / ${dictionaryLength}, position: ${position2}`);
      }
      appendReversed(result, oldVal);
      result.push(oldVal[oldVal.length - 1]);
      addToDictionary(oldCode, oldVal[oldVal.length - 1]);
      oldCode = code;
    }
    if (dictionaryLength + 1 >= 2 ** byteLength) {
      if (byteLength === MAX_BYTELENGTH) {
        oldCode = void 0;
      } else {
        byteLength++;
      }
    }
    code = getNext(array);
  }
  return new Uint8Array(result);
}
class LZWDecoder extends BaseDecoder {
  decodeBlock(buffer2) {
    return decompress(buffer2).buffer;
  }
}
var lzw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": LZWDecoder
}, Symbol.toStringTag, { value: "Module" }));
const dctZigZag = new Int32Array([
  0,
  1,
  8,
  16,
  9,
  2,
  3,
  10,
  17,
  24,
  32,
  25,
  18,
  11,
  4,
  5,
  12,
  19,
  26,
  33,
  40,
  48,
  41,
  34,
  27,
  20,
  13,
  6,
  7,
  14,
  21,
  28,
  35,
  42,
  49,
  56,
  57,
  50,
  43,
  36,
  29,
  22,
  15,
  23,
  30,
  37,
  44,
  51,
  58,
  59,
  52,
  45,
  38,
  31,
  39,
  46,
  53,
  60,
  61,
  54,
  47,
  55,
  62,
  63
]);
const dctCos1 = 4017;
const dctSin1 = 799;
const dctCos3 = 3406;
const dctSin3 = 2276;
const dctCos6 = 1567;
const dctSin6 = 3784;
const dctSqrt2 = 5793;
const dctSqrt1d2 = 2896;
function buildHuffmanTable(codeLengths, values3) {
  let k2 = 0;
  const code = [];
  let length = 16;
  while (length > 0 && !codeLengths[length - 1]) {
    --length;
  }
  code.push({ children: [], index: 0 });
  let p5 = code[0];
  let q2;
  for (let i2 = 0; i2 < length; i2++) {
    for (let j2 = 0; j2 < codeLengths[i2]; j2++) {
      p5 = code.pop();
      p5.children[p5.index] = values3[k2];
      while (p5.index > 0) {
        p5 = code.pop();
      }
      p5.index++;
      code.push(p5);
      while (code.length <= i2) {
        code.push(q2 = { children: [], index: 0 });
        p5.children[p5.index] = q2.children;
        p5 = q2;
      }
      k2++;
    }
    if (i2 + 1 < length) {
      code.push(q2 = { children: [], index: 0 });
      p5.children[p5.index] = q2.children;
      p5 = q2;
    }
  }
  return code[0].children;
}
function decodeScan(data2, initialOffset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive) {
  const { mcusPerLine, progressive } = frame;
  const startOffset = initialOffset;
  let offset2 = initialOffset;
  let bitsData = 0;
  let bitsCount = 0;
  function readBit() {
    if (bitsCount > 0) {
      bitsCount--;
      return bitsData >> bitsCount & 1;
    }
    bitsData = data2[offset2++];
    if (bitsData === 255) {
      const nextByte = data2[offset2++];
      if (nextByte) {
        throw new Error(`unexpected marker: ${(bitsData << 8 | nextByte).toString(16)}`);
      }
    }
    bitsCount = 7;
    return bitsData >>> 7;
  }
  function decodeHuffman(tree) {
    let node2 = tree;
    let bit;
    while ((bit = readBit()) !== null) {
      node2 = node2[bit];
      if (typeof node2 === "number") {
        return node2;
      }
      if (typeof node2 !== "object") {
        throw new Error("invalid huffman sequence");
      }
    }
    return null;
  }
  function receive(initialLength) {
    let length = initialLength;
    let n3 = 0;
    while (length > 0) {
      const bit = readBit();
      if (bit === null) {
        return void 0;
      }
      n3 = n3 << 1 | bit;
      --length;
    }
    return n3;
  }
  function receiveAndExtend(length) {
    const n3 = receive(length);
    if (n3 >= 1 << length - 1) {
      return n3;
    }
    return n3 + (-1 << length) + 1;
  }
  function decodeBaseline(component2, zz) {
    const t3 = decodeHuffman(component2.huffmanTableDC);
    const diff = t3 === 0 ? 0 : receiveAndExtend(t3);
    component2.pred += diff;
    zz[0] = component2.pred;
    let k3 = 1;
    while (k3 < 64) {
      const rs = decodeHuffman(component2.huffmanTableAC);
      const s2 = rs & 15;
      const r2 = rs >> 4;
      if (s2 === 0) {
        if (r2 < 15) {
          break;
        }
        k3 += 16;
      } else {
        k3 += r2;
        const z2 = dctZigZag[k3];
        zz[z2] = receiveAndExtend(s2);
        k3++;
      }
    }
  }
  function decodeDCFirst(component2, zz) {
    const t3 = decodeHuffman(component2.huffmanTableDC);
    const diff = t3 === 0 ? 0 : receiveAndExtend(t3) << successive;
    component2.pred += diff;
    zz[0] = component2.pred;
  }
  function decodeDCSuccessive(component2, zz) {
    zz[0] |= readBit() << successive;
  }
  let eobrun = 0;
  function decodeACFirst(component2, zz) {
    if (eobrun > 0) {
      eobrun--;
      return;
    }
    let k3 = spectralStart;
    const e2 = spectralEnd;
    while (k3 <= e2) {
      const rs = decodeHuffman(component2.huffmanTableAC);
      const s2 = rs & 15;
      const r2 = rs >> 4;
      if (s2 === 0) {
        if (r2 < 15) {
          eobrun = receive(r2) + (1 << r2) - 1;
          break;
        }
        k3 += 16;
      } else {
        k3 += r2;
        const z2 = dctZigZag[k3];
        zz[z2] = receiveAndExtend(s2) * (1 << successive);
        k3++;
      }
    }
  }
  let successiveACState = 0;
  let successiveACNextValue;
  function decodeACSuccessive(component2, zz) {
    let k3 = spectralStart;
    const e2 = spectralEnd;
    let r2 = 0;
    while (k3 <= e2) {
      const z2 = dctZigZag[k3];
      const direction2 = zz[z2] < 0 ? -1 : 1;
      switch (successiveACState) {
        case 0: {
          const rs = decodeHuffman(component2.huffmanTableAC);
          const s2 = rs & 15;
          r2 = rs >> 4;
          if (s2 === 0) {
            if (r2 < 15) {
              eobrun = receive(r2) + (1 << r2);
              successiveACState = 4;
            } else {
              r2 = 16;
              successiveACState = 1;
            }
          } else {
            if (s2 !== 1) {
              throw new Error("invalid ACn encoding");
            }
            successiveACNextValue = receiveAndExtend(s2);
            successiveACState = r2 ? 2 : 3;
          }
          continue;
        }
        case 1:
        case 2:
          if (zz[z2]) {
            zz[z2] += (readBit() << successive) * direction2;
          } else {
            r2--;
            if (r2 === 0) {
              successiveACState = successiveACState === 2 ? 3 : 0;
            }
          }
          break;
        case 3:
          if (zz[z2]) {
            zz[z2] += (readBit() << successive) * direction2;
          } else {
            zz[z2] = successiveACNextValue << successive;
            successiveACState = 0;
          }
          break;
        case 4:
          if (zz[z2]) {
            zz[z2] += (readBit() << successive) * direction2;
          }
          break;
      }
      k3++;
    }
    if (successiveACState === 4) {
      eobrun--;
      if (eobrun === 0) {
        successiveACState = 0;
      }
    }
  }
  function decodeMcu(component2, decodeFunction, mcu2, row, col) {
    const mcuRow = mcu2 / mcusPerLine | 0;
    const mcuCol = mcu2 % mcusPerLine;
    const blockRow = mcuRow * component2.v + row;
    const blockCol = mcuCol * component2.h + col;
    decodeFunction(component2, component2.blocks[blockRow][blockCol]);
  }
  function decodeBlock(component2, decodeFunction, mcu2) {
    const blockRow = mcu2 / component2.blocksPerLine | 0;
    const blockCol = mcu2 % component2.blocksPerLine;
    decodeFunction(component2, component2.blocks[blockRow][blockCol]);
  }
  const componentsLength = components.length;
  let component;
  let i2;
  let j2;
  let k2;
  let n2;
  let decodeFn;
  if (progressive) {
    if (spectralStart === 0) {
      decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
    } else {
      decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
    }
  } else {
    decodeFn = decodeBaseline;
  }
  let mcu = 0;
  let marker;
  let mcuExpected;
  if (componentsLength === 1) {
    mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
  } else {
    mcuExpected = mcusPerLine * frame.mcusPerColumn;
  }
  const usedResetInterval = resetInterval || mcuExpected;
  while (mcu < mcuExpected) {
    for (i2 = 0; i2 < componentsLength; i2++) {
      components[i2].pred = 0;
    }
    eobrun = 0;
    if (componentsLength === 1) {
      component = components[0];
      for (n2 = 0; n2 < usedResetInterval; n2++) {
        decodeBlock(component, decodeFn, mcu);
        mcu++;
      }
    } else {
      for (n2 = 0; n2 < usedResetInterval; n2++) {
        for (i2 = 0; i2 < componentsLength; i2++) {
          component = components[i2];
          const { h: h2, v: v2 } = component;
          for (j2 = 0; j2 < v2; j2++) {
            for (k2 = 0; k2 < h2; k2++) {
              decodeMcu(component, decodeFn, mcu, j2, k2);
            }
          }
        }
        mcu++;
        if (mcu === mcuExpected) {
          break;
        }
      }
    }
    bitsCount = 0;
    marker = data2[offset2] << 8 | data2[offset2 + 1];
    if (marker < 65280) {
      throw new Error("marker was not found");
    }
    if (marker >= 65488 && marker <= 65495) {
      offset2 += 2;
    } else {
      break;
    }
  }
  return offset2 - startOffset;
}
function buildComponentData(frame, component) {
  const lines = [];
  const { blocksPerLine, blocksPerColumn } = component;
  const samplesPerLine = blocksPerLine << 3;
  const R2 = new Int32Array(64);
  const r2 = new Uint8Array(64);
  function quantizeAndInverse(zz, dataOut, dataIn) {
    const qt2 = component.quantizationTable;
    let v0;
    let v1;
    let v2;
    let v3;
    let v4;
    let v5;
    let v6;
    let v7;
    let t3;
    const p5 = dataIn;
    let i2;
    for (i2 = 0; i2 < 64; i2++) {
      p5[i2] = zz[i2] * qt2[i2];
    }
    for (i2 = 0; i2 < 8; ++i2) {
      const row = 8 * i2;
      if (p5[1 + row] === 0 && p5[2 + row] === 0 && p5[3 + row] === 0 && p5[4 + row] === 0 && p5[5 + row] === 0 && p5[6 + row] === 0 && p5[7 + row] === 0) {
        t3 = dctSqrt2 * p5[0 + row] + 512 >> 10;
        p5[0 + row] = t3;
        p5[1 + row] = t3;
        p5[2 + row] = t3;
        p5[3 + row] = t3;
        p5[4 + row] = t3;
        p5[5 + row] = t3;
        p5[6 + row] = t3;
        p5[7 + row] = t3;
        continue;
      }
      v0 = dctSqrt2 * p5[0 + row] + 128 >> 8;
      v1 = dctSqrt2 * p5[4 + row] + 128 >> 8;
      v2 = p5[2 + row];
      v3 = p5[6 + row];
      v4 = dctSqrt1d2 * (p5[1 + row] - p5[7 + row]) + 128 >> 8;
      v7 = dctSqrt1d2 * (p5[1 + row] + p5[7 + row]) + 128 >> 8;
      v5 = p5[3 + row] << 4;
      v6 = p5[5 + row] << 4;
      t3 = v0 - v1 + 1 >> 1;
      v0 = v0 + v1 + 1 >> 1;
      v1 = t3;
      t3 = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;
      v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;
      v3 = t3;
      t3 = v4 - v6 + 1 >> 1;
      v4 = v4 + v6 + 1 >> 1;
      v6 = t3;
      t3 = v7 + v5 + 1 >> 1;
      v5 = v7 - v5 + 1 >> 1;
      v7 = t3;
      t3 = v0 - v3 + 1 >> 1;
      v0 = v0 + v3 + 1 >> 1;
      v3 = t3;
      t3 = v1 - v2 + 1 >> 1;
      v1 = v1 + v2 + 1 >> 1;
      v2 = t3;
      t3 = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
      v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
      v7 = t3;
      t3 = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
      v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
      v6 = t3;
      p5[0 + row] = v0 + v7;
      p5[7 + row] = v0 - v7;
      p5[1 + row] = v1 + v6;
      p5[6 + row] = v1 - v6;
      p5[2 + row] = v2 + v5;
      p5[5 + row] = v2 - v5;
      p5[3 + row] = v3 + v4;
      p5[4 + row] = v3 - v4;
    }
    for (i2 = 0; i2 < 8; ++i2) {
      const col = i2;
      if (p5[1 * 8 + col] === 0 && p5[2 * 8 + col] === 0 && p5[3 * 8 + col] === 0 && p5[4 * 8 + col] === 0 && p5[5 * 8 + col] === 0 && p5[6 * 8 + col] === 0 && p5[7 * 8 + col] === 0) {
        t3 = dctSqrt2 * dataIn[i2 + 0] + 8192 >> 14;
        p5[0 * 8 + col] = t3;
        p5[1 * 8 + col] = t3;
        p5[2 * 8 + col] = t3;
        p5[3 * 8 + col] = t3;
        p5[4 * 8 + col] = t3;
        p5[5 * 8 + col] = t3;
        p5[6 * 8 + col] = t3;
        p5[7 * 8 + col] = t3;
        continue;
      }
      v0 = dctSqrt2 * p5[0 * 8 + col] + 2048 >> 12;
      v1 = dctSqrt2 * p5[4 * 8 + col] + 2048 >> 12;
      v2 = p5[2 * 8 + col];
      v3 = p5[6 * 8 + col];
      v4 = dctSqrt1d2 * (p5[1 * 8 + col] - p5[7 * 8 + col]) + 2048 >> 12;
      v7 = dctSqrt1d2 * (p5[1 * 8 + col] + p5[7 * 8 + col]) + 2048 >> 12;
      v5 = p5[3 * 8 + col];
      v6 = p5[5 * 8 + col];
      t3 = v0 - v1 + 1 >> 1;
      v0 = v0 + v1 + 1 >> 1;
      v1 = t3;
      t3 = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;
      v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;
      v3 = t3;
      t3 = v4 - v6 + 1 >> 1;
      v4 = v4 + v6 + 1 >> 1;
      v6 = t3;
      t3 = v7 + v5 + 1 >> 1;
      v5 = v7 - v5 + 1 >> 1;
      v7 = t3;
      t3 = v0 - v3 + 1 >> 1;
      v0 = v0 + v3 + 1 >> 1;
      v3 = t3;
      t3 = v1 - v2 + 1 >> 1;
      v1 = v1 + v2 + 1 >> 1;
      v2 = t3;
      t3 = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
      v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
      v7 = t3;
      t3 = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
      v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
      v6 = t3;
      p5[0 * 8 + col] = v0 + v7;
      p5[7 * 8 + col] = v0 - v7;
      p5[1 * 8 + col] = v1 + v6;
      p5[6 * 8 + col] = v1 - v6;
      p5[2 * 8 + col] = v2 + v5;
      p5[5 * 8 + col] = v2 - v5;
      p5[3 * 8 + col] = v3 + v4;
      p5[4 * 8 + col] = v3 - v4;
    }
    for (i2 = 0; i2 < 64; ++i2) {
      const sample = 128 + (p5[i2] + 8 >> 4);
      if (sample < 0) {
        dataOut[i2] = 0;
      } else if (sample > 255) {
        dataOut[i2] = 255;
      } else {
        dataOut[i2] = sample;
      }
    }
  }
  for (let blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
    const scanLine = blockRow << 3;
    for (let i2 = 0; i2 < 8; i2++) {
      lines.push(new Uint8Array(samplesPerLine));
    }
    for (let blockCol = 0; blockCol < blocksPerLine; blockCol++) {
      quantizeAndInverse(component.blocks[blockRow][blockCol], r2, R2);
      let offset2 = 0;
      const sample = blockCol << 3;
      for (let j2 = 0; j2 < 8; j2++) {
        const line = lines[scanLine + j2];
        for (let i2 = 0; i2 < 8; i2++) {
          line[sample + i2] = r2[offset2++];
        }
      }
    }
  }
  return lines;
}
class JpegStreamReader {
  constructor() {
    this.jfif = null;
    this.adobe = null;
    this.quantizationTables = [];
    this.huffmanTablesAC = [];
    this.huffmanTablesDC = [];
    this.resetFrames();
  }
  resetFrames() {
    this.frames = [];
  }
  parse(data2) {
    let offset2 = 0;
    function readUint16() {
      const value = data2[offset2] << 8 | data2[offset2 + 1];
      offset2 += 2;
      return value;
    }
    function readDataBlock() {
      const length = readUint16();
      const array = data2.subarray(offset2, offset2 + length - 2);
      offset2 += array.length;
      return array;
    }
    function prepareComponents(frame) {
      let maxH = 0;
      let maxV = 0;
      let component;
      let componentId;
      for (componentId in frame.components) {
        if (frame.components.hasOwnProperty(componentId)) {
          component = frame.components[componentId];
          if (maxH < component.h) {
            maxH = component.h;
          }
          if (maxV < component.v) {
            maxV = component.v;
          }
        }
      }
      const mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / maxH);
      const mcusPerColumn = Math.ceil(frame.scanLines / 8 / maxV);
      for (componentId in frame.components) {
        if (frame.components.hasOwnProperty(componentId)) {
          component = frame.components[componentId];
          const blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / maxH);
          const blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines / 8) * component.v / maxV);
          const blocksPerLineForMcu = mcusPerLine * component.h;
          const blocksPerColumnForMcu = mcusPerColumn * component.v;
          const blocks = [];
          for (let i2 = 0; i2 < blocksPerColumnForMcu; i2++) {
            const row = [];
            for (let j2 = 0; j2 < blocksPerLineForMcu; j2++) {
              row.push(new Int32Array(64));
            }
            blocks.push(row);
          }
          component.blocksPerLine = blocksPerLine;
          component.blocksPerColumn = blocksPerColumn;
          component.blocks = blocks;
        }
      }
      frame.maxH = maxH;
      frame.maxV = maxV;
      frame.mcusPerLine = mcusPerLine;
      frame.mcusPerColumn = mcusPerColumn;
    }
    let fileMarker = readUint16();
    if (fileMarker !== 65496) {
      throw new Error("SOI not found");
    }
    fileMarker = readUint16();
    while (fileMarker !== 65497) {
      switch (fileMarker) {
        case 65280:
          break;
        case 65504:
        case 65505:
        case 65506:
        case 65507:
        case 65508:
        case 65509:
        case 65510:
        case 65511:
        case 65512:
        case 65513:
        case 65514:
        case 65515:
        case 65516:
        case 65517:
        case 65518:
        case 65519:
        case 65534: {
          const appData = readDataBlock();
          if (fileMarker === 65504) {
            if (appData[0] === 74 && appData[1] === 70 && appData[2] === 73 && appData[3] === 70 && appData[4] === 0) {
              this.jfif = {
                version: { major: appData[5], minor: appData[6] },
                densityUnits: appData[7],
                xDensity: appData[8] << 8 | appData[9],
                yDensity: appData[10] << 8 | appData[11],
                thumbWidth: appData[12],
                thumbHeight: appData[13],
                thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
              };
            }
          }
          if (fileMarker === 65518) {
            if (appData[0] === 65 && appData[1] === 100 && appData[2] === 111 && appData[3] === 98 && appData[4] === 101 && appData[5] === 0) {
              this.adobe = {
                version: appData[6],
                flags0: appData[7] << 8 | appData[8],
                flags1: appData[9] << 8 | appData[10],
                transformCode: appData[11]
              };
            }
          }
          break;
        }
        case 65499: {
          const quantizationTablesLength = readUint16();
          const quantizationTablesEnd = quantizationTablesLength + offset2 - 2;
          while (offset2 < quantizationTablesEnd) {
            const quantizationTableSpec = data2[offset2++];
            const tableData = new Int32Array(64);
            if (quantizationTableSpec >> 4 === 0) {
              for (let j2 = 0; j2 < 64; j2++) {
                const z2 = dctZigZag[j2];
                tableData[z2] = data2[offset2++];
              }
            } else if (quantizationTableSpec >> 4 === 1) {
              for (let j2 = 0; j2 < 64; j2++) {
                const z2 = dctZigZag[j2];
                tableData[z2] = readUint16();
              }
            } else {
              throw new Error("DQT: invalid table spec");
            }
            this.quantizationTables[quantizationTableSpec & 15] = tableData;
          }
          break;
        }
        case 65472:
        case 65473:
        case 65474: {
          readUint16();
          const frame = {
            extended: fileMarker === 65473,
            progressive: fileMarker === 65474,
            precision: data2[offset2++],
            scanLines: readUint16(),
            samplesPerLine: readUint16(),
            components: {},
            componentsOrder: []
          };
          const componentsCount = data2[offset2++];
          let componentId;
          for (let i2 = 0; i2 < componentsCount; i2++) {
            componentId = data2[offset2];
            const h2 = data2[offset2 + 1] >> 4;
            const v2 = data2[offset2 + 1] & 15;
            const qId = data2[offset2 + 2];
            frame.componentsOrder.push(componentId);
            frame.components[componentId] = {
              h: h2,
              v: v2,
              quantizationIdx: qId
            };
            offset2 += 3;
          }
          prepareComponents(frame);
          this.frames.push(frame);
          break;
        }
        case 65476: {
          const huffmanLength = readUint16();
          for (let i2 = 2; i2 < huffmanLength; ) {
            const huffmanTableSpec = data2[offset2++];
            const codeLengths = new Uint8Array(16);
            let codeLengthSum = 0;
            for (let j2 = 0; j2 < 16; j2++, offset2++) {
              codeLengths[j2] = data2[offset2];
              codeLengthSum += codeLengths[j2];
            }
            const huffmanValues = new Uint8Array(codeLengthSum);
            for (let j2 = 0; j2 < codeLengthSum; j2++, offset2++) {
              huffmanValues[j2] = data2[offset2];
            }
            i2 += 17 + codeLengthSum;
            if (huffmanTableSpec >> 4 === 0) {
              this.huffmanTablesDC[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);
            } else {
              this.huffmanTablesAC[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);
            }
          }
          break;
        }
        case 65501:
          readUint16();
          this.resetInterval = readUint16();
          break;
        case 65498: {
          readUint16();
          const selectorsCount = data2[offset2++];
          const components = [];
          const frame = this.frames[0];
          for (let i2 = 0; i2 < selectorsCount; i2++) {
            const component = frame.components[data2[offset2++]];
            const tableSpec = data2[offset2++];
            component.huffmanTableDC = this.huffmanTablesDC[tableSpec >> 4];
            component.huffmanTableAC = this.huffmanTablesAC[tableSpec & 15];
            components.push(component);
          }
          const spectralStart = data2[offset2++];
          const spectralEnd = data2[offset2++];
          const successiveApproximation = data2[offset2++];
          const processed = decodeScan(data2, offset2, frame, components, this.resetInterval, spectralStart, spectralEnd, successiveApproximation >> 4, successiveApproximation & 15);
          offset2 += processed;
          break;
        }
        case 65535:
          if (data2[offset2] !== 255) {
            offset2--;
          }
          break;
        default:
          if (data2[offset2 - 3] === 255 && data2[offset2 - 2] >= 192 && data2[offset2 - 2] <= 254) {
            offset2 -= 3;
            break;
          }
          throw new Error(`unknown JPEG marker ${fileMarker.toString(16)}`);
      }
      fileMarker = readUint16();
    }
  }
  getResult() {
    const { frames } = this;
    if (this.frames.length === 0) {
      throw new Error("no frames were decoded");
    } else if (this.frames.length > 1) {
      console.warn("more than one frame is not supported");
    }
    for (let i2 = 0; i2 < this.frames.length; i2++) {
      const cp = this.frames[i2].components;
      for (const j2 of Object.keys(cp)) {
        cp[j2].quantizationTable = this.quantizationTables[cp[j2].quantizationIdx];
        delete cp[j2].quantizationIdx;
      }
    }
    const frame = frames[0];
    const { components, componentsOrder } = frame;
    const outComponents = [];
    const width = frame.samplesPerLine;
    const height = frame.scanLines;
    for (let i2 = 0; i2 < componentsOrder.length; i2++) {
      const component = components[componentsOrder[i2]];
      outComponents.push({
        lines: buildComponentData(frame, component),
        scaleX: component.h / frame.maxH,
        scaleY: component.v / frame.maxV
      });
    }
    const out = new Uint8Array(width * height * outComponents.length);
    let oi = 0;
    for (let y2 = 0; y2 < height; ++y2) {
      for (let x2 = 0; x2 < width; ++x2) {
        for (let i2 = 0; i2 < outComponents.length; ++i2) {
          const component = outComponents[i2];
          out[oi] = component.lines[0 | y2 * component.scaleY][0 | x2 * component.scaleX];
          ++oi;
        }
      }
    }
    return out;
  }
}
class JpegDecoder extends BaseDecoder {
  constructor(fileDirectory) {
    super();
    this.reader = new JpegStreamReader();
    if (fileDirectory.JPEGTables) {
      this.reader.parse(fileDirectory.JPEGTables);
    }
  }
  decodeBlock(buffer2) {
    this.reader.resetFrames();
    this.reader.parse(new Uint8Array(buffer2));
    return this.reader.getResult().buffer;
  }
}
var jpeg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": JpegDecoder
}, Symbol.toStringTag, { value: "Module" }));
/*! pako 2.0.4 https://github.com/nodeca/pako @license (MIT AND Zlib) */
const Z_FIXED$1 = 4;
const Z_BINARY = 0;
const Z_TEXT = 1;
const Z_UNKNOWN$1 = 2;
function zero$1(buf) {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
const STORED_BLOCK = 0;
const STATIC_TREES = 1;
const DYN_TREES = 2;
const MIN_MATCH$1 = 3;
const MAX_MATCH$1 = 258;
const LENGTH_CODES$1 = 29;
const LITERALS$1 = 256;
const L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
const D_CODES$1 = 30;
const BL_CODES$1 = 19;
const HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
const MAX_BITS$1 = 15;
const Buf_size = 16;
const MAX_BL_BITS = 7;
const END_BLOCK = 256;
const REP_3_6 = 16;
const REPZ_3_10 = 17;
const REPZ_11_138 = 18;
const extra_lbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
const extra_dbits = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
const extra_blbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
const bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
const DIST_CODE_LEN = 512;
const static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
const static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
const _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
const _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
const base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
const base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
let static_l_desc;
let static_d_desc;
let static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
const d_code = (dist) => {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};
const put_short = (s2, w2) => {
  s2.pending_buf[s2.pending++] = w2 & 255;
  s2.pending_buf[s2.pending++] = w2 >>> 8 & 255;
};
const send_bits = (s2, value, length) => {
  if (s2.bi_valid > Buf_size - length) {
    s2.bi_buf |= value << s2.bi_valid & 65535;
    put_short(s2, s2.bi_buf);
    s2.bi_buf = value >> Buf_size - s2.bi_valid;
    s2.bi_valid += length - Buf_size;
  } else {
    s2.bi_buf |= value << s2.bi_valid & 65535;
    s2.bi_valid += length;
  }
};
const send_code = (s2, c2, tree) => {
  send_bits(s2, tree[c2 * 2], tree[c2 * 2 + 1]);
};
const bi_reverse = (code, len) => {
  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};
const bi_flush = (s2) => {
  if (s2.bi_valid === 16) {
    put_short(s2, s2.bi_buf);
    s2.bi_buf = 0;
    s2.bi_valid = 0;
  } else if (s2.bi_valid >= 8) {
    s2.pending_buf[s2.pending++] = s2.bi_buf & 255;
    s2.bi_buf >>= 8;
    s2.bi_valid -= 8;
  }
};
const gen_bitlen = (s2, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h2;
  let n2, m2;
  let bits2;
  let xbits;
  let f2;
  let overflow2 = 0;
  for (bits2 = 0; bits2 <= MAX_BITS$1; bits2++) {
    s2.bl_count[bits2] = 0;
  }
  tree[s2.heap[s2.heap_max] * 2 + 1] = 0;
  for (h2 = s2.heap_max + 1; h2 < HEAP_SIZE$1; h2++) {
    n2 = s2.heap[h2];
    bits2 = tree[tree[n2 * 2 + 1] * 2 + 1] + 1;
    if (bits2 > max_length) {
      bits2 = max_length;
      overflow2++;
    }
    tree[n2 * 2 + 1] = bits2;
    if (n2 > max_code) {
      continue;
    }
    s2.bl_count[bits2]++;
    xbits = 0;
    if (n2 >= base) {
      xbits = extra[n2 - base];
    }
    f2 = tree[n2 * 2];
    s2.opt_len += f2 * (bits2 + xbits);
    if (has_stree) {
      s2.static_len += f2 * (stree[n2 * 2 + 1] + xbits);
    }
  }
  if (overflow2 === 0) {
    return;
  }
  do {
    bits2 = max_length - 1;
    while (s2.bl_count[bits2] === 0) {
      bits2--;
    }
    s2.bl_count[bits2]--;
    s2.bl_count[bits2 + 1] += 2;
    s2.bl_count[max_length]--;
    overflow2 -= 2;
  } while (overflow2 > 0);
  for (bits2 = max_length; bits2 !== 0; bits2--) {
    n2 = s2.bl_count[bits2];
    while (n2 !== 0) {
      m2 = s2.heap[--h2];
      if (m2 > max_code) {
        continue;
      }
      if (tree[m2 * 2 + 1] !== bits2) {
        s2.opt_len += (bits2 - tree[m2 * 2 + 1]) * tree[m2 * 2];
        tree[m2 * 2 + 1] = bits2;
      }
      n2--;
    }
  }
};
const gen_codes = (tree, max_code, bl_count) => {
  const next_code = new Array(MAX_BITS$1 + 1);
  let code = 0;
  let bits2;
  let n2;
  for (bits2 = 1; bits2 <= MAX_BITS$1; bits2++) {
    next_code[bits2] = code = code + bl_count[bits2 - 1] << 1;
  }
  for (n2 = 0; n2 <= max_code; n2++) {
    let len = tree[n2 * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n2 * 2] = bi_reverse(next_code[len]++, len);
  }
};
const tr_static_init = () => {
  let n2;
  let bits2;
  let length;
  let code;
  let dist;
  const bl_count = new Array(MAX_BITS$1 + 1);
  length = 0;
  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
    base_length[code] = length;
    for (n2 = 0; n2 < 1 << extra_lbits[code]; n2++) {
      _length_code[length++] = code;
    }
  }
  _length_code[length - 1] = code;
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n2 = 0; n2 < 1 << extra_dbits[code]; n2++) {
      _dist_code[dist++] = code;
    }
  }
  dist >>= 7;
  for (; code < D_CODES$1; code++) {
    base_dist[code] = dist << 7;
    for (n2 = 0; n2 < 1 << extra_dbits[code] - 7; n2++) {
      _dist_code[256 + dist++] = code;
    }
  }
  for (bits2 = 0; bits2 <= MAX_BITS$1; bits2++) {
    bl_count[bits2] = 0;
  }
  n2 = 0;
  while (n2 <= 143) {
    static_ltree[n2 * 2 + 1] = 8;
    n2++;
    bl_count[8]++;
  }
  while (n2 <= 255) {
    static_ltree[n2 * 2 + 1] = 9;
    n2++;
    bl_count[9]++;
  }
  while (n2 <= 279) {
    static_ltree[n2 * 2 + 1] = 7;
    n2++;
    bl_count[7]++;
  }
  while (n2 <= 287) {
    static_ltree[n2 * 2 + 1] = 8;
    n2++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n2 = 0; n2 < D_CODES$1; n2++) {
    static_dtree[n2 * 2 + 1] = 5;
    static_dtree[n2 * 2] = bi_reverse(n2, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
};
const init_block = (s2) => {
  let n2;
  for (n2 = 0; n2 < L_CODES$1; n2++) {
    s2.dyn_ltree[n2 * 2] = 0;
  }
  for (n2 = 0; n2 < D_CODES$1; n2++) {
    s2.dyn_dtree[n2 * 2] = 0;
  }
  for (n2 = 0; n2 < BL_CODES$1; n2++) {
    s2.bl_tree[n2 * 2] = 0;
  }
  s2.dyn_ltree[END_BLOCK * 2] = 1;
  s2.opt_len = s2.static_len = 0;
  s2.last_lit = s2.matches = 0;
};
const bi_windup = (s2) => {
  if (s2.bi_valid > 8) {
    put_short(s2, s2.bi_buf);
  } else if (s2.bi_valid > 0) {
    s2.pending_buf[s2.pending++] = s2.bi_buf;
  }
  s2.bi_buf = 0;
  s2.bi_valid = 0;
};
const copy_block = (s2, buf, len, header) => {
  bi_windup(s2);
  if (header) {
    put_short(s2, len);
    put_short(s2, ~len);
  }
  s2.pending_buf.set(s2.window.subarray(buf, buf + len), s2.pending);
  s2.pending += len;
};
const smaller = (tree, n2, m2, depth) => {
  const _n2 = n2 * 2;
  const _m2 = m2 * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n2] <= depth[m2];
};
const pqdownheap = (s2, tree, k2) => {
  const v2 = s2.heap[k2];
  let j2 = k2 << 1;
  while (j2 <= s2.heap_len) {
    if (j2 < s2.heap_len && smaller(tree, s2.heap[j2 + 1], s2.heap[j2], s2.depth)) {
      j2++;
    }
    if (smaller(tree, v2, s2.heap[j2], s2.depth)) {
      break;
    }
    s2.heap[k2] = s2.heap[j2];
    k2 = j2;
    j2 <<= 1;
  }
  s2.heap[k2] = v2;
};
const compress_block = (s2, ltree, dtree) => {
  let dist;
  let lc2;
  let lx = 0;
  let code;
  let extra;
  if (s2.last_lit !== 0) {
    do {
      dist = s2.pending_buf[s2.d_buf + lx * 2] << 8 | s2.pending_buf[s2.d_buf + lx * 2 + 1];
      lc2 = s2.pending_buf[s2.l_buf + lx];
      lx++;
      if (dist === 0) {
        send_code(s2, lc2, ltree);
      } else {
        code = _length_code[lc2];
        send_code(s2, code + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc2 -= base_length[code];
          send_bits(s2, lc2, extra);
        }
        dist--;
        code = d_code(dist);
        send_code(s2, code, dtree);
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s2, dist, extra);
        }
      }
    } while (lx < s2.last_lit);
  }
  send_code(s2, END_BLOCK, ltree);
};
const build_tree = (s2, desc) => {
  const tree = desc.dyn_tree;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems = desc.stat_desc.elems;
  let n2, m2;
  let max_code = -1;
  let node2;
  s2.heap_len = 0;
  s2.heap_max = HEAP_SIZE$1;
  for (n2 = 0; n2 < elems; n2++) {
    if (tree[n2 * 2] !== 0) {
      s2.heap[++s2.heap_len] = max_code = n2;
      s2.depth[n2] = 0;
    } else {
      tree[n2 * 2 + 1] = 0;
    }
  }
  while (s2.heap_len < 2) {
    node2 = s2.heap[++s2.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node2 * 2] = 1;
    s2.depth[node2] = 0;
    s2.opt_len--;
    if (has_stree) {
      s2.static_len -= stree[node2 * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n2 = s2.heap_len >> 1; n2 >= 1; n2--) {
    pqdownheap(s2, tree, n2);
  }
  node2 = elems;
  do {
    n2 = s2.heap[1];
    s2.heap[1] = s2.heap[s2.heap_len--];
    pqdownheap(s2, tree, 1);
    m2 = s2.heap[1];
    s2.heap[--s2.heap_max] = n2;
    s2.heap[--s2.heap_max] = m2;
    tree[node2 * 2] = tree[n2 * 2] + tree[m2 * 2];
    s2.depth[node2] = (s2.depth[n2] >= s2.depth[m2] ? s2.depth[n2] : s2.depth[m2]) + 1;
    tree[n2 * 2 + 1] = tree[m2 * 2 + 1] = node2;
    s2.heap[1] = node2++;
    pqdownheap(s2, tree, 1);
  } while (s2.heap_len >= 2);
  s2.heap[--s2.heap_max] = s2.heap[1];
  gen_bitlen(s2, desc);
  gen_codes(tree, max_code, s2.bl_count);
};
const scan_tree = (s2, tree, max_code) => {
  let n2;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n2 = 0; n2 <= max_code; n2++) {
    curlen = nextlen;
    nextlen = tree[(n2 + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s2.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s2.bl_tree[curlen * 2]++;
      }
      s2.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s2.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s2.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
const send_tree = (s2, tree, max_code) => {
  let n2;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n2 = 0; n2 <= max_code; n2++) {
    curlen = nextlen;
    nextlen = tree[(n2 + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s2, curlen, s2.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s2, curlen, s2.bl_tree);
        count--;
      }
      send_code(s2, REP_3_6, s2.bl_tree);
      send_bits(s2, count - 3, 2);
    } else if (count <= 10) {
      send_code(s2, REPZ_3_10, s2.bl_tree);
      send_bits(s2, count - 3, 3);
    } else {
      send_code(s2, REPZ_11_138, s2.bl_tree);
      send_bits(s2, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
const build_bl_tree = (s2) => {
  let max_blindex;
  scan_tree(s2, s2.dyn_ltree, s2.l_desc.max_code);
  scan_tree(s2, s2.dyn_dtree, s2.d_desc.max_code);
  build_tree(s2, s2.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s2.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s2.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
};
const send_all_trees = (s2, lcodes, dcodes, blcodes) => {
  let rank2;
  send_bits(s2, lcodes - 257, 5);
  send_bits(s2, dcodes - 1, 5);
  send_bits(s2, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s2, s2.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s2, s2.dyn_ltree, lcodes - 1);
  send_tree(s2, s2.dyn_dtree, dcodes - 1);
};
const detect_data_type = (s2) => {
  let black_mask = 4093624447;
  let n2;
  for (n2 = 0; n2 <= 31; n2++, black_mask >>>= 1) {
    if (black_mask & 1 && s2.dyn_ltree[n2 * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s2.dyn_ltree[9 * 2] !== 0 || s2.dyn_ltree[10 * 2] !== 0 || s2.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n2 = 32; n2 < LITERALS$1; n2++) {
    if (s2.dyn_ltree[n2 * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
};
let static_init_done = false;
const _tr_init$1 = (s2) => {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s2.l_desc = new TreeDesc(s2.dyn_ltree, static_l_desc);
  s2.d_desc = new TreeDesc(s2.dyn_dtree, static_d_desc);
  s2.bl_desc = new TreeDesc(s2.bl_tree, static_bl_desc);
  s2.bi_buf = 0;
  s2.bi_valid = 0;
  init_block(s2);
};
const _tr_stored_block$1 = (s2, buf, stored_len, last) => {
  send_bits(s2, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
  copy_block(s2, buf, stored_len, true);
};
const _tr_align$1 = (s2) => {
  send_bits(s2, STATIC_TREES << 1, 3);
  send_code(s2, END_BLOCK, static_ltree);
  bi_flush(s2);
};
const _tr_flush_block$1 = (s2, buf, stored_len, last) => {
  let opt_lenb, static_lenb;
  let max_blindex = 0;
  if (s2.level > 0) {
    if (s2.strm.data_type === Z_UNKNOWN$1) {
      s2.strm.data_type = detect_data_type(s2);
    }
    build_tree(s2, s2.l_desc);
    build_tree(s2, s2.d_desc);
    max_blindex = build_bl_tree(s2);
    opt_lenb = s2.opt_len + 3 + 7 >>> 3;
    static_lenb = s2.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block$1(s2, buf, stored_len, last);
  } else if (s2.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s2, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s2, static_ltree, static_dtree);
  } else {
    send_bits(s2, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s2, s2.l_desc.max_code + 1, s2.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s2, s2.dyn_ltree, s2.dyn_dtree);
  }
  init_block(s2);
  if (last) {
    bi_windup(s2);
  }
};
const _tr_tally$1 = (s2, dist, lc2) => {
  s2.pending_buf[s2.d_buf + s2.last_lit * 2] = dist >>> 8 & 255;
  s2.pending_buf[s2.d_buf + s2.last_lit * 2 + 1] = dist & 255;
  s2.pending_buf[s2.l_buf + s2.last_lit] = lc2 & 255;
  s2.last_lit++;
  if (dist === 0) {
    s2.dyn_ltree[lc2 * 2]++;
  } else {
    s2.matches++;
    dist--;
    s2.dyn_ltree[(_length_code[lc2] + LITERALS$1 + 1) * 2]++;
    s2.dyn_dtree[d_code(dist) * 2]++;
  }
  return s2.last_lit === s2.lit_bufsize - 1;
};
var _tr_init_1 = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1 = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;
var trees = {
  _tr_init: _tr_init_1,
  _tr_stored_block: _tr_stored_block_1,
  _tr_flush_block: _tr_flush_block_1,
  _tr_tally: _tr_tally_1,
  _tr_align: _tr_align_1
};
const adler32 = (adler2, buf, len, pos) => {
  let s1 = adler2 & 65535 | 0, s2 = adler2 >>> 16 & 65535 | 0, n2 = 0;
  while (len !== 0) {
    n2 = len > 2e3 ? 2e3 : len;
    len -= n2;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n2);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
};
var adler32_1 = adler32;
const makeTable = () => {
  let c2, table = [];
  for (var n2 = 0; n2 < 256; n2++) {
    c2 = n2;
    for (var k2 = 0; k2 < 8; k2++) {
      c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
    }
    table[n2] = c2;
  }
  return table;
};
const crcTable = new Uint32Array(makeTable());
const crc32 = (crc, buf, len, pos) => {
  const t3 = crcTable;
  const end = pos + len;
  crc ^= -1;
  for (let i2 = pos; i2 < end; i2++) {
    crc = crc >>> 8 ^ t3[(crc ^ buf[i2]) & 255];
  }
  return crc ^ -1;
};
var crc32_1 = crc32;
var messages = {
  2: "need dictionary",
  1: "stream end",
  0: "",
  "-1": "file error",
  "-2": "stream error",
  "-3": "data error",
  "-4": "insufficient memory",
  "-5": "buffer error",
  "-6": "incompatible version"
};
var constants$2 = {
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  Z_BINARY: 0,
  Z_TEXT: 1,
  Z_UNKNOWN: 2,
  Z_DEFLATED: 8
};
const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
const {
  Z_NO_FLUSH: Z_NO_FLUSH$2,
  Z_PARTIAL_FLUSH,
  Z_FULL_FLUSH: Z_FULL_FLUSH$1,
  Z_FINISH: Z_FINISH$3,
  Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3,
  Z_STREAM_END: Z_STREAM_END$3,
  Z_STREAM_ERROR: Z_STREAM_ERROR$2,
  Z_DATA_ERROR: Z_DATA_ERROR$2,
  Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED,
  Z_HUFFMAN_ONLY,
  Z_RLE,
  Z_FIXED,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;
const MAX_MEM_LEVEL = 9;
const MAX_WBITS$1 = 15;
const DEF_MEM_LEVEL = 8;
const LENGTH_CODES = 29;
const LITERALS = 256;
const L_CODES = LITERALS + 1 + LENGTH_CODES;
const D_CODES = 30;
const BL_CODES = 19;
const HEAP_SIZE = 2 * L_CODES + 1;
const MAX_BITS = 15;
const MIN_MATCH = 3;
const MAX_MATCH = 258;
const MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
const PRESET_DICT = 32;
const INIT_STATE = 42;
const EXTRA_STATE = 69;
const NAME_STATE = 73;
const COMMENT_STATE = 91;
const HCRC_STATE = 103;
const BUSY_STATE = 113;
const FINISH_STATE = 666;
const BS_NEED_MORE = 1;
const BS_BLOCK_DONE = 2;
const BS_FINISH_STARTED = 3;
const BS_FINISH_DONE = 4;
const OS_CODE = 3;
const err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};
const rank = (f2) => {
  return (f2 << 1) - (f2 > 4 ? 9 : 0);
};
const zero = (buf) => {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
};
let HASH_ZLIB = (s2, prev, data2) => (prev << s2.hash_shift ^ data2) & s2.hash_mask;
let HASH = HASH_ZLIB;
const flush_pending = (strm) => {
  const s2 = strm.state;
  let len = s2.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  strm.output.set(s2.pending_buf.subarray(s2.pending_out, s2.pending_out + len), strm.next_out);
  strm.next_out += len;
  s2.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s2.pending -= len;
  if (s2.pending === 0) {
    s2.pending_out = 0;
  }
};
const flush_block_only = (s2, last) => {
  _tr_flush_block(s2, s2.block_start >= 0 ? s2.block_start : -1, s2.strstart - s2.block_start, last);
  s2.block_start = s2.strstart;
  flush_pending(s2.strm);
};
const put_byte = (s2, b2) => {
  s2.pending_buf[s2.pending++] = b2;
};
const putShortMSB = (s2, b2) => {
  s2.pending_buf[s2.pending++] = b2 >>> 8 & 255;
  s2.pending_buf[s2.pending++] = b2 & 255;
};
const read_buf = (strm, buf, start2, size) => {
  let len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start2);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start2);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start2);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
};
const longest_match = (s2, cur_match) => {
  let chain_length = s2.max_chain_length;
  let scan = s2.strstart;
  let match2;
  let len;
  let best_len = s2.prev_length;
  let nice_match = s2.nice_match;
  const limit = s2.strstart > s2.w_size - MIN_LOOKAHEAD ? s2.strstart - (s2.w_size - MIN_LOOKAHEAD) : 0;
  const _win = s2.window;
  const wmask = s2.w_mask;
  const prev = s2.prev;
  const strend = s2.strstart + MAX_MATCH;
  let scan_end1 = _win[scan + best_len - 1];
  let scan_end = _win[scan + best_len];
  if (s2.prev_length >= s2.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s2.lookahead) {
    nice_match = s2.lookahead;
  }
  do {
    match2 = cur_match;
    if (_win[match2 + best_len] !== scan_end || _win[match2 + best_len - 1] !== scan_end1 || _win[match2] !== _win[scan] || _win[++match2] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match2++;
    do {
    } while (_win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && scan < strend);
    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len > best_len) {
      s2.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s2.lookahead) {
    return best_len;
  }
  return s2.lookahead;
};
const fill_window = (s2) => {
  const _w_size = s2.w_size;
  let p5, n2, m2, more, str;
  do {
    more = s2.window_size - s2.lookahead - s2.strstart;
    if (s2.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      s2.window.set(s2.window.subarray(_w_size, _w_size + _w_size), 0);
      s2.match_start -= _w_size;
      s2.strstart -= _w_size;
      s2.block_start -= _w_size;
      n2 = s2.hash_size;
      p5 = n2;
      do {
        m2 = s2.head[--p5];
        s2.head[p5] = m2 >= _w_size ? m2 - _w_size : 0;
      } while (--n2);
      n2 = _w_size;
      p5 = n2;
      do {
        m2 = s2.prev[--p5];
        s2.prev[p5] = m2 >= _w_size ? m2 - _w_size : 0;
      } while (--n2);
      more += _w_size;
    }
    if (s2.strm.avail_in === 0) {
      break;
    }
    n2 = read_buf(s2.strm, s2.window, s2.strstart + s2.lookahead, more);
    s2.lookahead += n2;
    if (s2.lookahead + s2.insert >= MIN_MATCH) {
      str = s2.strstart - s2.insert;
      s2.ins_h = s2.window[str];
      s2.ins_h = HASH(s2, s2.ins_h, s2.window[str + 1]);
      while (s2.insert) {
        s2.ins_h = HASH(s2, s2.ins_h, s2.window[str + MIN_MATCH - 1]);
        s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
        s2.head[s2.ins_h] = str;
        str++;
        s2.insert--;
        if (s2.lookahead + s2.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s2.lookahead < MIN_LOOKAHEAD && s2.strm.avail_in !== 0);
};
const deflate_stored = (s2, flush2) => {
  let max_block_size = 65535;
  if (max_block_size > s2.pending_buf_size - 5) {
    max_block_size = s2.pending_buf_size - 5;
  }
  for (; ; ) {
    if (s2.lookahead <= 1) {
      fill_window(s2);
      if (s2.lookahead === 0 && flush2 === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s2.lookahead === 0) {
        break;
      }
    }
    s2.strstart += s2.lookahead;
    s2.lookahead = 0;
    const max_start = s2.block_start + max_block_size;
    if (s2.strstart === 0 || s2.strstart >= max_start) {
      s2.lookahead = s2.strstart - max_start;
      s2.strstart = max_start;
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    if (s2.strstart - s2.block_start >= s2.w_size - MIN_LOOKAHEAD) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s2.insert = 0;
  if (flush2 === Z_FINISH$3) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.strstart > s2.block_start) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_NEED_MORE;
};
const deflate_fast = (s2, flush2) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s2.lookahead < MIN_LOOKAHEAD) {
      fill_window(s2);
      if (s2.lookahead < MIN_LOOKAHEAD && flush2 === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s2.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s2.lookahead >= MIN_MATCH) {
      s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
      hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
      s2.head[s2.ins_h] = s2.strstart;
    }
    if (hash_head !== 0 && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
      s2.match_length = longest_match(s2, hash_head);
    }
    if (s2.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s2, s2.strstart - s2.match_start, s2.match_length - MIN_MATCH);
      s2.lookahead -= s2.match_length;
      if (s2.match_length <= s2.max_lazy_match && s2.lookahead >= MIN_MATCH) {
        s2.match_length--;
        do {
          s2.strstart++;
          s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        } while (--s2.match_length !== 0);
        s2.strstart++;
      } else {
        s2.strstart += s2.match_length;
        s2.match_length = 0;
        s2.ins_h = s2.window[s2.strstart];
        s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + 1]);
      }
    } else {
      bflush = _tr_tally(s2, 0, s2.window[s2.strstart]);
      s2.lookahead--;
      s2.strstart++;
    }
    if (bflush) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
  if (flush2 === Z_FINISH$3) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.last_lit) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
const deflate_slow = (s2, flush2) => {
  let hash_head;
  let bflush;
  let max_insert;
  for (; ; ) {
    if (s2.lookahead < MIN_LOOKAHEAD) {
      fill_window(s2);
      if (s2.lookahead < MIN_LOOKAHEAD && flush2 === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s2.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s2.lookahead >= MIN_MATCH) {
      s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
      hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
      s2.head[s2.ins_h] = s2.strstart;
    }
    s2.prev_length = s2.match_length;
    s2.prev_match = s2.match_start;
    s2.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s2.prev_length < s2.max_lazy_match && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
      s2.match_length = longest_match(s2, hash_head);
      if (s2.match_length <= 5 && (s2.strategy === Z_FILTERED || s2.match_length === MIN_MATCH && s2.strstart - s2.match_start > 4096)) {
        s2.match_length = MIN_MATCH - 1;
      }
    }
    if (s2.prev_length >= MIN_MATCH && s2.match_length <= s2.prev_length) {
      max_insert = s2.strstart + s2.lookahead - MIN_MATCH;
      bflush = _tr_tally(s2, s2.strstart - 1 - s2.prev_match, s2.prev_length - MIN_MATCH);
      s2.lookahead -= s2.prev_length - 1;
      s2.prev_length -= 2;
      do {
        if (++s2.strstart <= max_insert) {
          s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        }
      } while (--s2.prev_length !== 0);
      s2.match_available = 0;
      s2.match_length = MIN_MATCH - 1;
      s2.strstart++;
      if (bflush) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s2.match_available) {
      bflush = _tr_tally(s2, 0, s2.window[s2.strstart - 1]);
      if (bflush) {
        flush_block_only(s2, false);
      }
      s2.strstart++;
      s2.lookahead--;
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s2.match_available = 1;
      s2.strstart++;
      s2.lookahead--;
    }
  }
  if (s2.match_available) {
    bflush = _tr_tally(s2, 0, s2.window[s2.strstart - 1]);
    s2.match_available = 0;
  }
  s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
  if (flush2 === Z_FINISH$3) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.last_lit) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
const deflate_rle = (s2, flush2) => {
  let bflush;
  let prev;
  let scan, strend;
  const _win = s2.window;
  for (; ; ) {
    if (s2.lookahead <= MAX_MATCH) {
      fill_window(s2);
      if (s2.lookahead <= MAX_MATCH && flush2 === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s2.lookahead === 0) {
        break;
      }
    }
    s2.match_length = 0;
    if (s2.lookahead >= MIN_MATCH && s2.strstart > 0) {
      scan = s2.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s2.strstart + MAX_MATCH;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s2.match_length = MAX_MATCH - (strend - scan);
        if (s2.match_length > s2.lookahead) {
          s2.match_length = s2.lookahead;
        }
      }
    }
    if (s2.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s2, 1, s2.match_length - MIN_MATCH);
      s2.lookahead -= s2.match_length;
      s2.strstart += s2.match_length;
      s2.match_length = 0;
    } else {
      bflush = _tr_tally(s2, 0, s2.window[s2.strstart]);
      s2.lookahead--;
      s2.strstart++;
    }
    if (bflush) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s2.insert = 0;
  if (flush2 === Z_FINISH$3) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.last_lit) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
const deflate_huff = (s2, flush2) => {
  let bflush;
  for (; ; ) {
    if (s2.lookahead === 0) {
      fill_window(s2);
      if (s2.lookahead === 0) {
        if (flush2 === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s2.match_length = 0;
    bflush = _tr_tally(s2, 0, s2.window[s2.strstart]);
    s2.lookahead--;
    s2.strstart++;
    if (bflush) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s2.insert = 0;
  if (flush2 === Z_FINISH$3) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.last_lit) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
const configuration_table = [
  new Config(0, 0, 0, 0, deflate_stored),
  new Config(4, 4, 8, 4, deflate_fast),
  new Config(4, 5, 16, 8, deflate_fast),
  new Config(4, 6, 32, 32, deflate_fast),
  new Config(4, 4, 16, 16, deflate_slow),
  new Config(8, 16, 32, 32, deflate_slow),
  new Config(8, 16, 128, 128, deflate_slow),
  new Config(8, 32, 128, 256, deflate_slow),
  new Config(32, 128, 258, 1024, deflate_slow),
  new Config(32, 258, 258, 4096, deflate_slow)
];
const lm_init = (s2) => {
  s2.window_size = 2 * s2.w_size;
  zero(s2.head);
  s2.max_lazy_match = configuration_table[s2.level].max_lazy;
  s2.good_match = configuration_table[s2.level].good_length;
  s2.nice_match = configuration_table[s2.level].nice_length;
  s2.max_chain_length = configuration_table[s2.level].max_chain;
  s2.strstart = 0;
  s2.block_start = 0;
  s2.lookahead = 0;
  s2.insert = 0;
  s2.match_length = s2.prev_length = MIN_MATCH - 1;
  s2.match_available = 0;
  s2.ins_h = 0;
};
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  this.heap = new Uint16Array(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES + 1);
  zero(this.depth);
  this.l_buf = 0;
  this.lit_bufsize = 0;
  this.last_lit = 0;
  this.d_buf = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
const deflateResetKeep = (strm) => {
  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  const s2 = strm.state;
  s2.pending = 0;
  s2.pending_out = 0;
  if (s2.wrap < 0) {
    s2.wrap = -s2.wrap;
  }
  s2.status = s2.wrap ? INIT_STATE : BUSY_STATE;
  strm.adler = s2.wrap === 2 ? 0 : 1;
  s2.last_flush = Z_NO_FLUSH$2;
  _tr_init(s2);
  return Z_OK$3;
};
const deflateReset = (strm) => {
  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};
const deflateSetHeader = (strm, head2) => {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$2;
  }
  if (strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head2;
  return Z_OK$3;
};
const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
  if (!strm) {
    return Z_STREAM_ERROR$2;
  }
  let wrap = 1;
  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  const s2 = new DeflateState();
  strm.state = s2;
  s2.strm = strm;
  s2.wrap = wrap;
  s2.gzhead = null;
  s2.w_bits = windowBits;
  s2.w_size = 1 << s2.w_bits;
  s2.w_mask = s2.w_size - 1;
  s2.hash_bits = memLevel + 7;
  s2.hash_size = 1 << s2.hash_bits;
  s2.hash_mask = s2.hash_size - 1;
  s2.hash_shift = ~~((s2.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s2.window = new Uint8Array(s2.w_size * 2);
  s2.head = new Uint16Array(s2.hash_size);
  s2.prev = new Uint16Array(s2.w_size);
  s2.lit_bufsize = 1 << memLevel + 6;
  s2.pending_buf_size = s2.lit_bufsize * 4;
  s2.pending_buf = new Uint8Array(s2.pending_buf_size);
  s2.d_buf = 1 * s2.lit_bufsize;
  s2.l_buf = (1 + 2) * s2.lit_bufsize;
  s2.level = level;
  s2.strategy = strategy;
  s2.method = method;
  return deflateReset(strm);
};
const deflateInit = (strm, level) => {
  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};
const deflate$2 = (strm, flush2) => {
  let beg, val;
  if (!strm || !strm.state || flush2 > Z_BLOCK$1 || flush2 < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }
  const s2 = strm.state;
  if (!strm.output || !strm.input && strm.avail_in !== 0 || s2.status === FINISH_STATE && flush2 !== Z_FINISH$3) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }
  s2.strm = strm;
  const old_flush = s2.last_flush;
  s2.last_flush = flush2;
  if (s2.status === INIT_STATE) {
    if (s2.wrap === 2) {
      strm.adler = 0;
      put_byte(s2, 31);
      put_byte(s2, 139);
      put_byte(s2, 8);
      if (!s2.gzhead) {
        put_byte(s2, 0);
        put_byte(s2, 0);
        put_byte(s2, 0);
        put_byte(s2, 0);
        put_byte(s2, 0);
        put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
        put_byte(s2, OS_CODE);
        s2.status = BUSY_STATE;
      } else {
        put_byte(s2, (s2.gzhead.text ? 1 : 0) + (s2.gzhead.hcrc ? 2 : 0) + (!s2.gzhead.extra ? 0 : 4) + (!s2.gzhead.name ? 0 : 8) + (!s2.gzhead.comment ? 0 : 16));
        put_byte(s2, s2.gzhead.time & 255);
        put_byte(s2, s2.gzhead.time >> 8 & 255);
        put_byte(s2, s2.gzhead.time >> 16 & 255);
        put_byte(s2, s2.gzhead.time >> 24 & 255);
        put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
        put_byte(s2, s2.gzhead.os & 255);
        if (s2.gzhead.extra && s2.gzhead.extra.length) {
          put_byte(s2, s2.gzhead.extra.length & 255);
          put_byte(s2, s2.gzhead.extra.length >> 8 & 255);
        }
        if (s2.gzhead.hcrc) {
          strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending, 0);
        }
        s2.gzindex = 0;
        s2.status = EXTRA_STATE;
      }
    } else {
      let header = Z_DEFLATED$2 + (s2.w_bits - 8 << 4) << 8;
      let level_flags = -1;
      if (s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2) {
        level_flags = 0;
      } else if (s2.level < 6) {
        level_flags = 1;
      } else if (s2.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= level_flags << 6;
      if (s2.strstart !== 0) {
        header |= PRESET_DICT;
      }
      header += 31 - header % 31;
      s2.status = BUSY_STATE;
      putShortMSB(s2, header);
      if (s2.strstart !== 0) {
        putShortMSB(s2, strm.adler >>> 16);
        putShortMSB(s2, strm.adler & 65535);
      }
      strm.adler = 1;
    }
  }
  if (s2.status === EXTRA_STATE) {
    if (s2.gzhead.extra) {
      beg = s2.pending;
      while (s2.gzindex < (s2.gzhead.extra.length & 65535)) {
        if (s2.pending === s2.pending_buf_size) {
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s2.pending;
          if (s2.pending === s2.pending_buf_size) {
            break;
          }
        }
        put_byte(s2, s2.gzhead.extra[s2.gzindex] & 255);
        s2.gzindex++;
      }
      if (s2.gzhead.hcrc && s2.pending > beg) {
        strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
      }
      if (s2.gzindex === s2.gzhead.extra.length) {
        s2.gzindex = 0;
        s2.status = NAME_STATE;
      }
    } else {
      s2.status = NAME_STATE;
    }
  }
  if (s2.status === NAME_STATE) {
    if (s2.gzhead.name) {
      beg = s2.pending;
      do {
        if (s2.pending === s2.pending_buf_size) {
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s2.pending;
          if (s2.pending === s2.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s2.gzindex < s2.gzhead.name.length) {
          val = s2.gzhead.name.charCodeAt(s2.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s2, val);
      } while (val !== 0);
      if (s2.gzhead.hcrc && s2.pending > beg) {
        strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
      }
      if (val === 0) {
        s2.gzindex = 0;
        s2.status = COMMENT_STATE;
      }
    } else {
      s2.status = COMMENT_STATE;
    }
  }
  if (s2.status === COMMENT_STATE) {
    if (s2.gzhead.comment) {
      beg = s2.pending;
      do {
        if (s2.pending === s2.pending_buf_size) {
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s2.pending;
          if (s2.pending === s2.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s2.gzindex < s2.gzhead.comment.length) {
          val = s2.gzhead.comment.charCodeAt(s2.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s2, val);
      } while (val !== 0);
      if (s2.gzhead.hcrc && s2.pending > beg) {
        strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
      }
      if (val === 0) {
        s2.status = HCRC_STATE;
      }
    } else {
      s2.status = HCRC_STATE;
    }
  }
  if (s2.status === HCRC_STATE) {
    if (s2.gzhead.hcrc) {
      if (s2.pending + 2 > s2.pending_buf_size) {
        flush_pending(strm);
      }
      if (s2.pending + 2 <= s2.pending_buf_size) {
        put_byte(s2, strm.adler & 255);
        put_byte(s2, strm.adler >> 8 & 255);
        strm.adler = 0;
        s2.status = BUSY_STATE;
      }
    } else {
      s2.status = BUSY_STATE;
    }
  }
  if (s2.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s2.last_flush = -1;
      return Z_OK$3;
    }
  } else if (strm.avail_in === 0 && rank(flush2) <= rank(old_flush) && flush2 !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s2.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (strm.avail_in !== 0 || s2.lookahead !== 0 || flush2 !== Z_NO_FLUSH$2 && s2.status !== FINISH_STATE) {
    let bstate = s2.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s2, flush2) : s2.strategy === Z_RLE ? deflate_rle(s2, flush2) : configuration_table[s2.level].func(s2, flush2);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s2.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s2.last_flush = -1;
      }
      return Z_OK$3;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush2 === Z_PARTIAL_FLUSH) {
        _tr_align(s2);
      } else if (flush2 !== Z_BLOCK$1) {
        _tr_stored_block(s2, 0, 0, false);
        if (flush2 === Z_FULL_FLUSH$1) {
          zero(s2.head);
          if (s2.lookahead === 0) {
            s2.strstart = 0;
            s2.block_start = 0;
            s2.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s2.last_flush = -1;
        return Z_OK$3;
      }
    }
  }
  if (flush2 !== Z_FINISH$3) {
    return Z_OK$3;
  }
  if (s2.wrap <= 0) {
    return Z_STREAM_END$3;
  }
  if (s2.wrap === 2) {
    put_byte(s2, strm.adler & 255);
    put_byte(s2, strm.adler >> 8 & 255);
    put_byte(s2, strm.adler >> 16 & 255);
    put_byte(s2, strm.adler >> 24 & 255);
    put_byte(s2, strm.total_in & 255);
    put_byte(s2, strm.total_in >> 8 & 255);
    put_byte(s2, strm.total_in >> 16 & 255);
    put_byte(s2, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s2, strm.adler >>> 16);
    putShortMSB(s2, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s2.wrap > 0) {
    s2.wrap = -s2.wrap;
  }
  return s2.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};
const deflateEnd = (strm) => {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$2;
  }
  const status = strm.state.status;
  if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};
const deflateSetDictionary = (strm, dictionary) => {
  let dictLength = dictionary.length;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$2;
  }
  const s2 = strm.state;
  const wrap = s2.wrap;
  if (wrap === 2 || wrap === 1 && s2.status !== INIT_STATE || s2.lookahead) {
    return Z_STREAM_ERROR$2;
  }
  if (wrap === 1) {
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }
  s2.wrap = 0;
  if (dictLength >= s2.w_size) {
    if (wrap === 0) {
      zero(s2.head);
      s2.strstart = 0;
      s2.block_start = 0;
      s2.insert = 0;
    }
    let tmpDict = new Uint8Array(s2.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s2.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s2.w_size;
  }
  const avail = strm.avail_in;
  const next3 = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s2);
  while (s2.lookahead >= MIN_MATCH) {
    let str = s2.strstart;
    let n2 = s2.lookahead - (MIN_MATCH - 1);
    do {
      s2.ins_h = HASH(s2, s2.ins_h, s2.window[str + MIN_MATCH - 1]);
      s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
      s2.head[s2.ins_h] = str;
      str++;
    } while (--n2);
    s2.strstart = str;
    s2.lookahead = MIN_MATCH - 1;
    fill_window(s2);
  }
  s2.strstart += s2.lookahead;
  s2.block_start = s2.strstart;
  s2.insert = s2.lookahead;
  s2.lookahead = 0;
  s2.match_length = s2.prev_length = MIN_MATCH - 1;
  s2.match_available = 0;
  strm.next_in = next3;
  strm.input = input;
  strm.avail_in = avail;
  s2.wrap = wrap;
  return Z_OK$3;
};
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = "pako deflate (from Nodeca project)";
var deflate_1$2 = {
  deflateInit: deflateInit_1,
  deflateInit2: deflateInit2_1,
  deflateReset: deflateReset_1,
  deflateResetKeep: deflateResetKeep_1,
  deflateSetHeader: deflateSetHeader_1,
  deflate: deflate_2$1,
  deflateEnd: deflateEnd_1,
  deflateSetDictionary: deflateSetDictionary_1,
  deflateInfo
};
const _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (const p5 in source) {
      if (_has(source, p5)) {
        obj[p5] = source[p5];
      }
    }
  }
  return obj;
};
var flattenChunks = (chunks) => {
  let len = 0;
  for (let i2 = 0, l2 = chunks.length; i2 < l2; i2++) {
    len += chunks[i2].length;
  }
  const result = new Uint8Array(len);
  for (let i2 = 0, pos = 0, l2 = chunks.length; i2 < l2; i2++) {
    let chunk = chunks[i2];
    result.set(chunk, pos);
    pos += chunk.length;
  }
  return result;
};
var common = {
  assign,
  flattenChunks
};
let STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
const _utf8len = new Uint8Array(256);
for (let q2 = 0; q2 < 256; q2++) {
  _utf8len[q2] = q2 >= 252 ? 6 : q2 >= 248 ? 5 : q2 >= 240 ? 4 : q2 >= 224 ? 3 : q2 >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (str) => {
  if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }
  let buf, c2, c22, m_pos, i2, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c2 = str.charCodeAt(m_pos);
    if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
      c22 = str.charCodeAt(m_pos + 1);
      if ((c22 & 64512) === 56320) {
        c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
        m_pos++;
      }
    }
    buf_len += c2 < 128 ? 1 : c2 < 2048 ? 2 : c2 < 65536 ? 3 : 4;
  }
  buf = new Uint8Array(buf_len);
  for (i2 = 0, m_pos = 0; i2 < buf_len; m_pos++) {
    c2 = str.charCodeAt(m_pos);
    if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
      c22 = str.charCodeAt(m_pos + 1);
      if ((c22 & 64512) === 56320) {
        c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
        m_pos++;
      }
    }
    if (c2 < 128) {
      buf[i2++] = c2;
    } else if (c2 < 2048) {
      buf[i2++] = 192 | c2 >>> 6;
      buf[i2++] = 128 | c2 & 63;
    } else if (c2 < 65536) {
      buf[i2++] = 224 | c2 >>> 12;
      buf[i2++] = 128 | c2 >>> 6 & 63;
      buf[i2++] = 128 | c2 & 63;
    } else {
      buf[i2++] = 240 | c2 >>> 18;
      buf[i2++] = 128 | c2 >>> 12 & 63;
      buf[i2++] = 128 | c2 >>> 6 & 63;
      buf[i2++] = 128 | c2 & 63;
    }
  }
  return buf;
};
const buf2binstring = (buf, len) => {
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }
  let result = "";
  for (let i2 = 0; i2 < len; i2++) {
    result += String.fromCharCode(buf[i2]);
  }
  return result;
};
var buf2string = (buf, max2) => {
  const len = max2 || buf.length;
  if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max2));
  }
  let i2, out;
  const utf16buf = new Array(len * 2);
  for (out = 0, i2 = 0; i2 < len; ) {
    let c2 = buf[i2++];
    if (c2 < 128) {
      utf16buf[out++] = c2;
      continue;
    }
    let c_len = _utf8len[c2];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i2 += c_len - 1;
      continue;
    }
    c2 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i2 < len) {
      c2 = c2 << 6 | buf[i2++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c2 < 65536) {
      utf16buf[out++] = c2;
    } else {
      c2 -= 65536;
      utf16buf[out++] = 55296 | c2 >> 10 & 1023;
      utf16buf[out++] = 56320 | c2 & 1023;
    }
  }
  return buf2binstring(utf16buf, out);
};
var utf8border = (buf, max2) => {
  max2 = max2 || buf.length;
  if (max2 > buf.length) {
    max2 = buf.length;
  }
  let pos = max2 - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max2;
  }
  if (pos === 0) {
    return max2;
  }
  return pos + _utf8len[buf[pos]] > max2 ? pos : max2;
};
var strings = {
  string2buf,
  buf2string,
  utf8border
};
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
const toString$1$1 = Object.prototype.toString;
const {
  Z_NO_FLUSH: Z_NO_FLUSH$1,
  Z_SYNC_FLUSH,
  Z_FULL_FLUSH,
  Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2,
  Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2;
function Deflate$1(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = deflate_1$2.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }
  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    this._dict_set = true;
  }
}
Deflate$1.prototype.push = function(data2, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;
  if (this.ended) {
    return false;
  }
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
  if (typeof data2 === "string") {
    strm.input = strings.string2buf(data2);
  } else if (toString$1$1.call(data2) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data2);
  } else {
    strm.input = data2;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    status = deflate_1$2.deflate(strm, _flush_mode);
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Deflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
const BAD$1 = 30;
const TYPE$1 = 12;
var inffast = function inflate_fast(strm, start2) {
  let _in;
  let last;
  let _out;
  let beg;
  let end;
  let dmax;
  let wsize;
  let whave;
  let wnext;
  let s_window;
  let hold;
  let bits2;
  let lcode;
  let dcode;
  let lmask;
  let dmask;
  let here;
  let op;
  let len;
  let dist;
  let from;
  let from_source;
  let input, output;
  const state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start2 - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits2 = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits2 < 15) {
        hold += input[_in++] << bits2;
        bits2 += 8;
        hold += input[_in++] << bits2;
        bits2 += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits2 -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits2 < op) {
                hold += input[_in++] << bits2;
                bits2 += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits2 -= op;
            }
            if (bits2 < 15) {
              hold += input[_in++] << bits2;
              bits2 += 8;
              hold += input[_in++] << bits2;
              bits2 += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits2 -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits2 < op) {
                    hold += input[_in++] << bits2;
                    bits2 += 8;
                    if (bits2 < op) {
                      hold += input[_in++] << bits2;
                      bits2 += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$1;
                    break top;
                  }
                  hold >>>= op;
                  bits2 -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext < len) {
                          op = wnext;
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    }
                    while (len > 2) {
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      len -= 3;
                    }
                    if (len) {
                      output[_out++] = from_source[from++];
                      if (len > 1) {
                        output[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output[_out++] = output[from++];
                      if (len > 1) {
                        output[_out++] = output[from++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in < last && _out < end);
  len = bits2 >> 3;
  _in -= len;
  bits2 -= len << 3;
  hold &= (1 << bits2) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits2;
  return;
};
const MAXBITS = 15;
const ENOUGH_LENS$1 = 852;
const ENOUGH_DISTS$1 = 592;
const CODES$1 = 0;
const LENS$1 = 1;
const DISTS$1 = 2;
const lbase = new Uint16Array([
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
const lext = new Uint8Array([
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
const dbase = new Uint16Array([
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
const dext = new Uint8Array([
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
const inflate_table = (type, lens, lens_index, codes2, table, table_index, work, opts) => {
  const bits2 = opts.bits;
  let len = 0;
  let sym = 0;
  let min2 = 0, max2 = 0;
  let root2 = 0;
  let curr = 0;
  let drop = 0;
  let left = 0;
  let used = 0;
  let huff = 0;
  let incr;
  let fill;
  let low;
  let mask;
  let next3;
  let base = null;
  let base_index = 0;
  let end;
  const count = new Uint16Array(MAXBITS + 1);
  const offs = new Uint16Array(MAXBITS + 1);
  let extra = null;
  let extra_index = 0;
  let here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes2; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root2 = bits2;
  for (max2 = MAXBITS; max2 >= 1; max2--) {
    if (count[max2] !== 0) {
      break;
    }
  }
  if (root2 > max2) {
    root2 = max2;
  }
  if (max2 === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min2 = 1; min2 < max2; min2++) {
    if (count[min2] !== 0) {
      break;
    }
  }
  if (root2 < min2) {
    root2 = min2;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type === CODES$1 || max2 !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes2; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES$1) {
    base = extra = work;
    end = 19;
  } else if (type === LENS$1) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;
  } else {
    base = dbase;
    extra = dext;
    end = -1;
  }
  huff = 0;
  sym = 0;
  len = min2;
  next3 = table_index;
  curr = root2;
  drop = 0;
  low = -1;
  used = 1 << root2;
  mask = used - 1;
  if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill = 1 << curr;
    min2 = fill;
    do {
      fill -= incr;
      table[next3 + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max2) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root2 && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root2;
      }
      next3 += min2;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max2) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask;
      table[low] = root2 << 24 | curr << 16 | next3 - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next3 + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root2;
  return 0;
};
var inftrees = inflate_table;
const CODES = 0;
const LENS = 1;
const DISTS = 2;
const {
  Z_FINISH: Z_FINISH$1,
  Z_BLOCK,
  Z_TREES,
  Z_OK: Z_OK$1,
  Z_STREAM_END: Z_STREAM_END$1,
  Z_NEED_DICT: Z_NEED_DICT$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1,
  Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;
const HEAD = 1;
const FLAGS = 2;
const TIME = 3;
const OS = 4;
const EXLEN = 5;
const EXTRA = 6;
const NAME = 7;
const COMMENT = 8;
const HCRC = 9;
const DICTID = 10;
const DICT = 11;
const TYPE = 12;
const TYPEDO = 13;
const STORED = 14;
const COPY_ = 15;
const COPY = 16;
const TABLE = 17;
const LENLENS = 18;
const CODELENS = 19;
const LEN_ = 20;
const LEN = 21;
const LENEXT = 22;
const DIST = 23;
const DISTEXT = 24;
const MATCH$2 = 25;
const LIT = 26;
const CHECK = 27;
const LENGTH = 28;
const DONE = 29;
const BAD = 30;
const MEM = 31;
const SYNC = 32;
const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
const MAX_WBITS = 15;
const DEF_WBITS = MAX_WBITS;
const zswap32 = (q2) => {
  return (q2 >>> 24 & 255) + (q2 >>> 8 & 65280) + ((q2 & 65280) << 8) + ((q2 & 255) << 24);
};
function InflateState() {
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
const inflateResetKeep = (strm) => {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1;
  return Z_OK$1;
};
const inflateReset = (strm) => {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
};
const inflateReset2 = (strm, windowBits) => {
  let wrap;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};
const inflateInit2 = (strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  const state = new InflateState();
  strm.state = state;
  state.window = null;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null;
  }
  return ret;
};
const inflateInit = (strm) => {
  return inflateInit2(strm, DEF_WBITS);
};
let virgin = true;
let lenfix, distfix;
const fixedtables = (state) => {
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);
    let sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};
const updatewindow = (strm, src, end, copy) => {
  let dist;
  const state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Uint8Array(state.wsize);
  }
  if (copy >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
};
const inflate$2 = (strm, flush2) => {
  let state;
  let input, output;
  let next3;
  let put;
  let have, left;
  let hold;
  let bits2;
  let _in, _out;
  let copy;
  let from;
  let from_source;
  let here = 0;
  let here_bits, here_op, here_val;
  let last_bits, last_op, last_val;
  let len;
  let ret;
  const hbuf = new Uint8Array(4);
  let opts;
  let n2;
  const order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next3 = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits2 = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK$1;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits2 < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next3++] << bits2;
            bits2 += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            hold = 0;
            bits2 = 0;
            state.mode = FLAGS;
            break;
          }
          state.flags = 0;
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits2 -= 4;
          len = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len;
          } else if (len > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD;
            break;
          }
          state.dmax = 1 << state.wbits;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits2 = 0;
          break;
        case FLAGS:
          while (bits2 < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next3++] << bits2;
            bits2 += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits2 = 0;
          state.mode = TIME;
        case TIME:
          while (bits2 < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next3++] << bits2;
            bits2 += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32_1(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits2 = 0;
          state.mode = OS;
        case OS:
          while (bits2 < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next3++] << bits2;
            bits2 += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits2 = 0;
          state.mode = EXLEN;
        case EXLEN:
          if (state.flags & 1024) {
            while (bits2 < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next3++] << bits2;
              bits2 += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits2 = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA;
        case EXTRA:
          if (state.flags & 1024) {
            copy = state.length;
            if (copy > have) {
              copy = have;
            }
            if (copy) {
              if (state.head) {
                len = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }
                state.head.extra.set(input.subarray(next3, next3 + copy), len);
              }
              if (state.flags & 512) {
                state.check = crc32_1(state.check, input, copy, next3);
              }
              have -= copy;
              next3 += copy;
              state.length -= copy;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME;
        case NAME:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next3 + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512) {
              state.check = crc32_1(state.check, input, copy, next3);
            }
            have -= copy;
            next3 += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        case COMMENT:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next3 + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512) {
              state.check = crc32_1(state.check, input, copy, next3);
            }
            have -= copy;
            next3 += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        case HCRC:
          if (state.flags & 512) {
            while (bits2 < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next3++] << bits2;
              bits2 += 8;
            }
            if (hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits2 = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE;
          break;
        case DICTID:
          while (bits2 < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next3++] << bits2;
            bits2 += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits2 = 0;
          state.mode = DICT;
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next3;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits2;
            return Z_NEED_DICT$1;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE;
        case TYPE:
          if (flush2 === Z_BLOCK || flush2 === Z_TREES) {
            break inf_leave;
          }
        case TYPEDO:
          if (state.last) {
            hold >>>= bits2 & 7;
            bits2 -= bits2 & 7;
            state.mode = CHECK;
            break;
          }
          while (bits2 < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next3++] << bits2;
            bits2 += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits2 -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush2 === Z_TREES) {
                hold >>>= 2;
                bits2 -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD;
          }
          hold >>>= 2;
          bits2 -= 2;
          break;
        case STORED:
          hold >>>= bits2 & 7;
          bits2 -= bits2 & 7;
          while (bits2 < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next3++] << bits2;
            bits2 += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits2 = 0;
          state.mode = COPY_;
          if (flush2 === Z_TREES) {
            break inf_leave;
          }
        case COPY_:
          state.mode = COPY;
        case COPY:
          copy = state.length;
          if (copy) {
            if (copy > have) {
              copy = have;
            }
            if (copy > left) {
              copy = left;
            }
            if (copy === 0) {
              break inf_leave;
            }
            output.set(input.subarray(next3, next3 + copy), put);
            have -= copy;
            next3 += copy;
            left -= copy;
            put += copy;
            state.length -= copy;
            break;
          }
          state.mode = TYPE;
          break;
        case TABLE:
          while (bits2 < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next3++] << bits2;
            bits2 += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits2 -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits2 -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits2 -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        case LENLENS:
          while (state.have < state.ncode) {
            while (bits2 < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next3++] << bits2;
              bits2 += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits2 -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits2) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next3++] << bits2;
              bits2 += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits2 -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n2 = here_bits + 2;
                while (bits2 < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next3++] << bits2;
                  bits2 += 8;
                }
                hold >>>= here_bits;
                bits2 -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                len = state.lens[state.have - 1];
                copy = 3 + (hold & 3);
                hold >>>= 2;
                bits2 -= 2;
              } else if (here_val === 17) {
                n2 = here_bits + 3;
                while (bits2 < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next3++] << bits2;
                  bits2 += 8;
                }
                hold >>>= here_bits;
                bits2 -= here_bits;
                len = 0;
                copy = 3 + (hold & 7);
                hold >>>= 3;
                bits2 -= 3;
              } else {
                n2 = here_bits + 7;
                while (bits2 < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next3++] << bits2;
                  bits2 += 8;
                }
                hold >>>= here_bits;
                bits2 -= here_bits;
                len = 0;
                copy = 11 + (hold & 127);
                hold >>>= 7;
                bits2 -= 7;
              }
              if (state.have + copy > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD;
                break;
              }
              while (copy--) {
                state.lens[state.have++] = len;
              }
            }
          }
          if (state.mode === BAD) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD;
            break;
          }
          state.mode = LEN_;
          if (flush2 === Z_TREES) {
            break inf_leave;
          }
        case LEN_:
          state.mode = LEN;
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next3;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits2;
            inffast(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next3 = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits2 = state.bits;
            if (state.mode === TYPE) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits2) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next3++] << bits2;
            bits2 += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits2) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next3++] << bits2;
              bits2 += 8;
            }
            hold >>>= last_bits;
            bits2 -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits2 -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
        case LENEXT:
          if (state.extra) {
            n2 = state.extra;
            while (bits2 < n2) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next3++] << bits2;
              bits2 += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits2 -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        case DIST:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits2) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next3++] << bits2;
            bits2 += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits2) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next3++] << bits2;
              bits2 += 8;
            }
            hold >>>= last_bits;
            bits2 -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits2 -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;
        case DISTEXT:
          if (state.extra) {
            n2 = state.extra;
            while (bits2 < n2) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next3++] << bits2;
              bits2 += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits2 -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD;
            break;
          }
          state.mode = MATCH$2;
        case MATCH$2:
          if (left === 0) {
            break inf_leave;
          }
          copy = _out - left;
          if (state.offset > copy) {
            copy = state.offset - copy;
            if (copy > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
            }
            if (copy > state.wnext) {
              copy -= state.wnext;
              from = state.wsize - copy;
            } else {
              from = state.wnext - copy;
            }
            if (copy > state.length) {
              copy = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output;
            from = put - state.offset;
            copy = state.length;
          }
          if (copy > left) {
            copy = left;
          }
          left -= copy;
          state.length -= copy;
          do {
            output[put++] = from_source[from++];
          } while (--copy);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits2 < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next3++] << bits2;
              bits2 += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (_out) {
              strm.adler = state.check = state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
            }
            _out = left;
            if ((state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits2 = 0;
          }
          state.mode = LENGTH;
        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits2 < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next3++] << bits2;
              bits2 += 8;
            }
            if (hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits2 = 0;
          }
          state.mode = DONE;
        case DONE:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
        default:
          return Z_STREAM_ERROR$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next3;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits2;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush2 !== Z_FINISH$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))
      ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush2 === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};
const inflateEnd = (strm) => {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};
const inflateGetHeader = (strm, head2) => {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }
  state.head = head2;
  head2.done = false;
  return Z_OK$1;
};
const inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;
  let state;
  let dictid;
  let ret;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }
  if (state.mode === DICT) {
    dictid = 1;
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  return Z_OK$1;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = "pako inflate (from Nodeca project)";
var inflate_1$2 = {
  inflateReset: inflateReset_1,
  inflateReset2: inflateReset2_1,
  inflateResetKeep: inflateResetKeep_1,
  inflateInit: inflateInit_1,
  inflateInit2: inflateInit2_1,
  inflate: inflate_2$1,
  inflateEnd: inflateEnd_1,
  inflateGetHeader: inflateGetHeader_1,
  inflateSetDictionary: inflateSetDictionary_1,
  inflateInfo
};
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader = GZheader;
const toString$c = Object.prototype.toString;
const {
  Z_NO_FLUSH,
  Z_FINISH,
  Z_OK,
  Z_STREAM_END,
  Z_NEED_DICT,
  Z_STREAM_ERROR,
  Z_DATA_ERROR,
  Z_MEM_ERROR
} = constants$2;
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(this.strm, opt.windowBits);
  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString$c.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}
Inflate$1.prototype.push = function(data2, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended)
    return false;
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (toString$c.call(data2) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data2);
  } else {
    strm.input = data2;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate_1$2.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        status = Z_NEED_DICT;
      }
    }
    while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data2[strm.next_in] !== 0) {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {
        if (this.options.to === "string") {
          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail)
            strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }
    if (status === Z_OK && last_avail_out === 0)
      continue;
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Inflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);
  inflator.push(input);
  if (inflator.err)
    throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}
var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var constants = constants$2;
var inflate_1$1 = {
  Inflate: Inflate_1$1,
  inflate: inflate_2,
  inflateRaw: inflateRaw_1$1,
  ungzip: ungzip$1,
  constants
};
const { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;
var inflate_1 = inflate;
class DeflateDecoder extends BaseDecoder {
  decodeBlock(buffer2) {
    return inflate_1(new Uint8Array(buffer2)).buffer;
  }
}
var deflate = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": DeflateDecoder
}, Symbol.toStringTag, { value: "Module" }));
class PackbitsDecoder extends BaseDecoder {
  decodeBlock(buffer2) {
    const dataView = new DataView(buffer2);
    const out = [];
    for (let i2 = 0; i2 < buffer2.byteLength; ++i2) {
      let header = dataView.getInt8(i2);
      if (header < 0) {
        const next3 = dataView.getUint8(i2 + 1);
        header = -header;
        for (let j2 = 0; j2 <= header; ++j2) {
          out.push(next3);
        }
        i2 += 1;
      } else {
        for (let j2 = 0; j2 <= header; ++j2) {
          out.push(dataView.getUint8(i2 + j2 + 1));
        }
        i2 += header + 1;
      }
    }
    return new Uint8Array(out).buffer;
  }
}
var packbits = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": PackbitsDecoder
}, Symbol.toStringTag, { value: "Module" }));
var LercDecode = { exports: {} };
(function(module) {
  /* Copyright 2015-2021 Esri. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 @preserve */
  (function() {
    var LercDecode2 = function() {
      var CntZImage = {};
      CntZImage.defaultNoDataValue = -34027999387901484e22;
      CntZImage.decode = function(input, options) {
        options = options || {};
        var skipMask = options.encodedMaskData || options.encodedMaskData === null;
        var parsedData = parse2(input, options.inputOffset || 0, skipMask);
        var noDataValue = options.noDataValue !== null ? options.noDataValue : CntZImage.defaultNoDataValue;
        var uncompressedData = uncompressPixelValues(parsedData, options.pixelType || Float32Array, options.encodedMaskData, noDataValue, options.returnMask);
        var result = {
          width: parsedData.width,
          height: parsedData.height,
          pixelData: uncompressedData.resultPixels,
          minValue: uncompressedData.minValue,
          maxValue: parsedData.pixels.maxValue,
          noDataValue
        };
        if (uncompressedData.resultMask) {
          result.maskData = uncompressedData.resultMask;
        }
        if (options.returnEncodedMask && parsedData.mask) {
          result.encodedMaskData = parsedData.mask.bitset ? parsedData.mask.bitset : null;
        }
        if (options.returnFileInfo) {
          result.fileInfo = formatFileInfo(parsedData);
          if (options.computeUsedBitDepths) {
            result.fileInfo.bitDepths = computeUsedBitDepths(parsedData);
          }
        }
        return result;
      };
      var uncompressPixelValues = function(data2, TypedArrayClass, maskBitset, noDataValue, storeDecodedMask) {
        var blockIdx = 0;
        var numX = data2.pixels.numBlocksX;
        var numY = data2.pixels.numBlocksY;
        var blockWidth = Math.floor(data2.width / numX);
        var blockHeight = Math.floor(data2.height / numY);
        var scale2 = 2 * data2.maxZError;
        var minValue = Number.MAX_VALUE, currentValue;
        maskBitset = maskBitset || (data2.mask ? data2.mask.bitset : null);
        var resultPixels, resultMask;
        resultPixels = new TypedArrayClass(data2.width * data2.height);
        if (storeDecodedMask && maskBitset) {
          resultMask = new Uint8Array(data2.width * data2.height);
        }
        var blockDataBuffer = new Float32Array(blockWidth * blockHeight);
        var xx, yy;
        for (var y2 = 0; y2 <= numY; y2++) {
          var thisBlockHeight = y2 !== numY ? blockHeight : data2.height % numY;
          if (thisBlockHeight === 0) {
            continue;
          }
          for (var x2 = 0; x2 <= numX; x2++) {
            var thisBlockWidth = x2 !== numX ? blockWidth : data2.width % numX;
            if (thisBlockWidth === 0) {
              continue;
            }
            var outPtr = y2 * data2.width * blockHeight + x2 * blockWidth;
            var outStride = data2.width - thisBlockWidth;
            var block = data2.pixels.blocks[blockIdx];
            var blockData, blockPtr, constValue;
            if (block.encoding < 2) {
              if (block.encoding === 0) {
                blockData = block.rawData;
              } else {
                unstuff(block.stuffedData, block.bitsPerPixel, block.numValidPixels, block.offset, scale2, blockDataBuffer, data2.pixels.maxValue);
                blockData = blockDataBuffer;
              }
              blockPtr = 0;
            } else if (block.encoding === 2) {
              constValue = 0;
            } else {
              constValue = block.offset;
            }
            var maskByte;
            if (maskBitset) {
              for (yy = 0; yy < thisBlockHeight; yy++) {
                if (outPtr & 7) {
                  maskByte = maskBitset[outPtr >> 3];
                  maskByte <<= outPtr & 7;
                }
                for (xx = 0; xx < thisBlockWidth; xx++) {
                  if (!(outPtr & 7)) {
                    maskByte = maskBitset[outPtr >> 3];
                  }
                  if (maskByte & 128) {
                    if (resultMask) {
                      resultMask[outPtr] = 1;
                    }
                    currentValue = block.encoding < 2 ? blockData[blockPtr++] : constValue;
                    minValue = minValue > currentValue ? currentValue : minValue;
                    resultPixels[outPtr++] = currentValue;
                  } else {
                    if (resultMask) {
                      resultMask[outPtr] = 0;
                    }
                    resultPixels[outPtr++] = noDataValue;
                  }
                  maskByte <<= 1;
                }
                outPtr += outStride;
              }
            } else {
              if (block.encoding < 2) {
                for (yy = 0; yy < thisBlockHeight; yy++) {
                  for (xx = 0; xx < thisBlockWidth; xx++) {
                    currentValue = blockData[blockPtr++];
                    minValue = minValue > currentValue ? currentValue : minValue;
                    resultPixels[outPtr++] = currentValue;
                  }
                  outPtr += outStride;
                }
              } else {
                minValue = minValue > constValue ? constValue : minValue;
                for (yy = 0; yy < thisBlockHeight; yy++) {
                  for (xx = 0; xx < thisBlockWidth; xx++) {
                    resultPixels[outPtr++] = constValue;
                  }
                  outPtr += outStride;
                }
              }
            }
            if (block.encoding === 1 && blockPtr !== block.numValidPixels) {
              throw "Block and Mask do not match";
            }
            blockIdx++;
          }
        }
        return {
          resultPixels,
          resultMask,
          minValue
        };
      };
      var formatFileInfo = function(data2) {
        return {
          "fileIdentifierString": data2.fileIdentifierString,
          "fileVersion": data2.fileVersion,
          "imageType": data2.imageType,
          "height": data2.height,
          "width": data2.width,
          "maxZError": data2.maxZError,
          "eofOffset": data2.eofOffset,
          "mask": data2.mask ? {
            "numBlocksX": data2.mask.numBlocksX,
            "numBlocksY": data2.mask.numBlocksY,
            "numBytes": data2.mask.numBytes,
            "maxValue": data2.mask.maxValue
          } : null,
          "pixels": {
            "numBlocksX": data2.pixels.numBlocksX,
            "numBlocksY": data2.pixels.numBlocksY,
            "numBytes": data2.pixels.numBytes,
            "maxValue": data2.pixels.maxValue,
            "noDataValue": data2.noDataValue
          }
        };
      };
      var computeUsedBitDepths = function(data2) {
        var numBlocks = data2.pixels.numBlocksX * data2.pixels.numBlocksY;
        var bitDepths = {};
        for (var i2 = 0; i2 < numBlocks; i2++) {
          var block = data2.pixels.blocks[i2];
          if (block.encoding === 0) {
            bitDepths.float32 = true;
          } else if (block.encoding === 1) {
            bitDepths[block.bitsPerPixel] = true;
          } else {
            bitDepths[0] = true;
          }
        }
        return Object.keys(bitDepths);
      };
      var parse2 = function(input, fp, skipMask) {
        var data2 = {};
        var fileIdView = new Uint8Array(input, fp, 10);
        data2.fileIdentifierString = String.fromCharCode.apply(null, fileIdView);
        if (data2.fileIdentifierString.trim() !== "CntZImage") {
          throw "Unexpected file identifier string: " + data2.fileIdentifierString;
        }
        fp += 10;
        var view = new DataView(input, fp, 24);
        data2.fileVersion = view.getInt32(0, true);
        data2.imageType = view.getInt32(4, true);
        data2.height = view.getUint32(8, true);
        data2.width = view.getUint32(12, true);
        data2.maxZError = view.getFloat64(16, true);
        fp += 24;
        if (!skipMask) {
          view = new DataView(input, fp, 16);
          data2.mask = {};
          data2.mask.numBlocksY = view.getUint32(0, true);
          data2.mask.numBlocksX = view.getUint32(4, true);
          data2.mask.numBytes = view.getUint32(8, true);
          data2.mask.maxValue = view.getFloat32(12, true);
          fp += 16;
          if (data2.mask.numBytes > 0) {
            var bitset = new Uint8Array(Math.ceil(data2.width * data2.height / 8));
            view = new DataView(input, fp, data2.mask.numBytes);
            var cnt = view.getInt16(0, true);
            var ip = 2, op = 0;
            do {
              if (cnt > 0) {
                while (cnt--) {
                  bitset[op++] = view.getUint8(ip++);
                }
              } else {
                var val = view.getUint8(ip++);
                cnt = -cnt;
                while (cnt--) {
                  bitset[op++] = val;
                }
              }
              cnt = view.getInt16(ip, true);
              ip += 2;
            } while (ip < data2.mask.numBytes);
            if (cnt !== -32768 || op < bitset.length) {
              throw "Unexpected end of mask RLE encoding";
            }
            data2.mask.bitset = bitset;
            fp += data2.mask.numBytes;
          } else if ((data2.mask.numBytes | data2.mask.numBlocksY | data2.mask.maxValue) === 0) {
            data2.mask.bitset = new Uint8Array(Math.ceil(data2.width * data2.height / 8));
          }
        }
        view = new DataView(input, fp, 16);
        data2.pixels = {};
        data2.pixels.numBlocksY = view.getUint32(0, true);
        data2.pixels.numBlocksX = view.getUint32(4, true);
        data2.pixels.numBytes = view.getUint32(8, true);
        data2.pixels.maxValue = view.getFloat32(12, true);
        fp += 16;
        var numBlocksX = data2.pixels.numBlocksX;
        var numBlocksY = data2.pixels.numBlocksY;
        var actualNumBlocksX = numBlocksX + (data2.width % numBlocksX > 0 ? 1 : 0);
        var actualNumBlocksY = numBlocksY + (data2.height % numBlocksY > 0 ? 1 : 0);
        data2.pixels.blocks = new Array(actualNumBlocksX * actualNumBlocksY);
        var blockI = 0;
        for (var blockY = 0; blockY < actualNumBlocksY; blockY++) {
          for (var blockX = 0; blockX < actualNumBlocksX; blockX++) {
            var size = 0;
            var bytesLeft = input.byteLength - fp;
            view = new DataView(input, fp, Math.min(10, bytesLeft));
            var block = {};
            data2.pixels.blocks[blockI++] = block;
            var headerByte = view.getUint8(0);
            size++;
            block.encoding = headerByte & 63;
            if (block.encoding > 3) {
              throw "Invalid block encoding (" + block.encoding + ")";
            }
            if (block.encoding === 2) {
              fp++;
              continue;
            }
            if (headerByte !== 0 && headerByte !== 2) {
              headerByte >>= 6;
              block.offsetType = headerByte;
              if (headerByte === 2) {
                block.offset = view.getInt8(1);
                size++;
              } else if (headerByte === 1) {
                block.offset = view.getInt16(1, true);
                size += 2;
              } else if (headerByte === 0) {
                block.offset = view.getFloat32(1, true);
                size += 4;
              } else {
                throw "Invalid block offset type";
              }
              if (block.encoding === 1) {
                headerByte = view.getUint8(size);
                size++;
                block.bitsPerPixel = headerByte & 63;
                headerByte >>= 6;
                block.numValidPixelsType = headerByte;
                if (headerByte === 2) {
                  block.numValidPixels = view.getUint8(size);
                  size++;
                } else if (headerByte === 1) {
                  block.numValidPixels = view.getUint16(size, true);
                  size += 2;
                } else if (headerByte === 0) {
                  block.numValidPixels = view.getUint32(size, true);
                  size += 4;
                } else {
                  throw "Invalid valid pixel count type";
                }
              }
            }
            fp += size;
            if (block.encoding === 3) {
              continue;
            }
            var arrayBuf, store8;
            if (block.encoding === 0) {
              var numPixels = (data2.pixels.numBytes - 1) / 4;
              if (numPixels !== Math.floor(numPixels)) {
                throw "uncompressed block has invalid length";
              }
              arrayBuf = new ArrayBuffer(numPixels * 4);
              store8 = new Uint8Array(arrayBuf);
              store8.set(new Uint8Array(input, fp, numPixels * 4));
              var rawData = new Float32Array(arrayBuf);
              block.rawData = rawData;
              fp += numPixels * 4;
            } else if (block.encoding === 1) {
              var dataBytes = Math.ceil(block.numValidPixels * block.bitsPerPixel / 8);
              var dataWords = Math.ceil(dataBytes / 4);
              arrayBuf = new ArrayBuffer(dataWords * 4);
              store8 = new Uint8Array(arrayBuf);
              store8.set(new Uint8Array(input, fp, dataBytes));
              block.stuffedData = new Uint32Array(arrayBuf);
              fp += dataBytes;
            }
          }
        }
        data2.eofOffset = fp;
        return data2;
      };
      var unstuff = function(src, bitsPerPixel, numPixels, offset2, scale2, dest, maxValue) {
        var bitMask = (1 << bitsPerPixel) - 1;
        var i2 = 0, o2;
        var bitsLeft = 0;
        var n2, buffer2;
        var nmax = Math.ceil((maxValue - offset2) / scale2);
        var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);
        src[src.length - 1] <<= 8 * numInvalidTailBytes;
        for (o2 = 0; o2 < numPixels; o2++) {
          if (bitsLeft === 0) {
            buffer2 = src[i2++];
            bitsLeft = 32;
          }
          if (bitsLeft >= bitsPerPixel) {
            n2 = buffer2 >>> bitsLeft - bitsPerPixel & bitMask;
            bitsLeft -= bitsPerPixel;
          } else {
            var missingBits = bitsPerPixel - bitsLeft;
            n2 = (buffer2 & bitMask) << missingBits & bitMask;
            buffer2 = src[i2++];
            bitsLeft = 32 - missingBits;
            n2 += buffer2 >>> bitsLeft;
          }
          dest[o2] = n2 < nmax ? offset2 + n2 * scale2 : maxValue;
        }
        return dest;
      };
      return CntZImage;
    }();
    var Lerc2Decode = function() {
      var BitStuffer = {
        unstuff: function(src, dest, bitsPerPixel, numPixels, lutArr, offset2, scale2, maxValue) {
          var bitMask = (1 << bitsPerPixel) - 1;
          var i2 = 0, o2;
          var bitsLeft = 0;
          var n2, buffer2, missingBits, nmax;
          var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);
          src[src.length - 1] <<= 8 * numInvalidTailBytes;
          if (lutArr) {
            for (o2 = 0; o2 < numPixels; o2++) {
              if (bitsLeft === 0) {
                buffer2 = src[i2++];
                bitsLeft = 32;
              }
              if (bitsLeft >= bitsPerPixel) {
                n2 = buffer2 >>> bitsLeft - bitsPerPixel & bitMask;
                bitsLeft -= bitsPerPixel;
              } else {
                missingBits = bitsPerPixel - bitsLeft;
                n2 = (buffer2 & bitMask) << missingBits & bitMask;
                buffer2 = src[i2++];
                bitsLeft = 32 - missingBits;
                n2 += buffer2 >>> bitsLeft;
              }
              dest[o2] = lutArr[n2];
            }
          } else {
            nmax = Math.ceil((maxValue - offset2) / scale2);
            for (o2 = 0; o2 < numPixels; o2++) {
              if (bitsLeft === 0) {
                buffer2 = src[i2++];
                bitsLeft = 32;
              }
              if (bitsLeft >= bitsPerPixel) {
                n2 = buffer2 >>> bitsLeft - bitsPerPixel & bitMask;
                bitsLeft -= bitsPerPixel;
              } else {
                missingBits = bitsPerPixel - bitsLeft;
                n2 = (buffer2 & bitMask) << missingBits & bitMask;
                buffer2 = src[i2++];
                bitsLeft = 32 - missingBits;
                n2 += buffer2 >>> bitsLeft;
              }
              dest[o2] = n2 < nmax ? offset2 + n2 * scale2 : maxValue;
            }
          }
        },
        unstuffLUT: function(src, bitsPerPixel, numPixels, offset2, scale2, maxValue) {
          var bitMask = (1 << bitsPerPixel) - 1;
          var i2 = 0, o2 = 0, missingBits = 0, bitsLeft = 0, n2 = 0;
          var buffer2;
          var dest = [];
          var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);
          src[src.length - 1] <<= 8 * numInvalidTailBytes;
          var nmax = Math.ceil((maxValue - offset2) / scale2);
          for (o2 = 0; o2 < numPixels; o2++) {
            if (bitsLeft === 0) {
              buffer2 = src[i2++];
              bitsLeft = 32;
            }
            if (bitsLeft >= bitsPerPixel) {
              n2 = buffer2 >>> bitsLeft - bitsPerPixel & bitMask;
              bitsLeft -= bitsPerPixel;
            } else {
              missingBits = bitsPerPixel - bitsLeft;
              n2 = (buffer2 & bitMask) << missingBits & bitMask;
              buffer2 = src[i2++];
              bitsLeft = 32 - missingBits;
              n2 += buffer2 >>> bitsLeft;
            }
            dest[o2] = n2 < nmax ? offset2 + n2 * scale2 : maxValue;
          }
          dest.unshift(offset2);
          return dest;
        },
        unstuff2: function(src, dest, bitsPerPixel, numPixels, lutArr, offset2, scale2, maxValue) {
          var bitMask = (1 << bitsPerPixel) - 1;
          var i2 = 0, o2;
          var bitsLeft = 0, bitPos = 0;
          var n2, buffer2, missingBits;
          if (lutArr) {
            for (o2 = 0; o2 < numPixels; o2++) {
              if (bitsLeft === 0) {
                buffer2 = src[i2++];
                bitsLeft = 32;
                bitPos = 0;
              }
              if (bitsLeft >= bitsPerPixel) {
                n2 = buffer2 >>> bitPos & bitMask;
                bitsLeft -= bitsPerPixel;
                bitPos += bitsPerPixel;
              } else {
                missingBits = bitsPerPixel - bitsLeft;
                n2 = buffer2 >>> bitPos & bitMask;
                buffer2 = src[i2++];
                bitsLeft = 32 - missingBits;
                n2 |= (buffer2 & (1 << missingBits) - 1) << bitsPerPixel - missingBits;
                bitPos = missingBits;
              }
              dest[o2] = lutArr[n2];
            }
          } else {
            var nmax = Math.ceil((maxValue - offset2) / scale2);
            for (o2 = 0; o2 < numPixels; o2++) {
              if (bitsLeft === 0) {
                buffer2 = src[i2++];
                bitsLeft = 32;
                bitPos = 0;
              }
              if (bitsLeft >= bitsPerPixel) {
                n2 = buffer2 >>> bitPos & bitMask;
                bitsLeft -= bitsPerPixel;
                bitPos += bitsPerPixel;
              } else {
                missingBits = bitsPerPixel - bitsLeft;
                n2 = buffer2 >>> bitPos & bitMask;
                buffer2 = src[i2++];
                bitsLeft = 32 - missingBits;
                n2 |= (buffer2 & (1 << missingBits) - 1) << bitsPerPixel - missingBits;
                bitPos = missingBits;
              }
              dest[o2] = n2 < nmax ? offset2 + n2 * scale2 : maxValue;
            }
          }
          return dest;
        },
        unstuffLUT2: function(src, bitsPerPixel, numPixels, offset2, scale2, maxValue) {
          var bitMask = (1 << bitsPerPixel) - 1;
          var i2 = 0, o2 = 0, missingBits = 0, bitsLeft = 0, n2 = 0, bitPos = 0;
          var buffer2;
          var dest = [];
          var nmax = Math.ceil((maxValue - offset2) / scale2);
          for (o2 = 0; o2 < numPixels; o2++) {
            if (bitsLeft === 0) {
              buffer2 = src[i2++];
              bitsLeft = 32;
              bitPos = 0;
            }
            if (bitsLeft >= bitsPerPixel) {
              n2 = buffer2 >>> bitPos & bitMask;
              bitsLeft -= bitsPerPixel;
              bitPos += bitsPerPixel;
            } else {
              missingBits = bitsPerPixel - bitsLeft;
              n2 = buffer2 >>> bitPos & bitMask;
              buffer2 = src[i2++];
              bitsLeft = 32 - missingBits;
              n2 |= (buffer2 & (1 << missingBits) - 1) << bitsPerPixel - missingBits;
              bitPos = missingBits;
            }
            dest[o2] = n2 < nmax ? offset2 + n2 * scale2 : maxValue;
          }
          dest.unshift(offset2);
          return dest;
        },
        originalUnstuff: function(src, dest, bitsPerPixel, numPixels) {
          var bitMask = (1 << bitsPerPixel) - 1;
          var i2 = 0, o2;
          var bitsLeft = 0;
          var n2, buffer2, missingBits;
          var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);
          src[src.length - 1] <<= 8 * numInvalidTailBytes;
          for (o2 = 0; o2 < numPixels; o2++) {
            if (bitsLeft === 0) {
              buffer2 = src[i2++];
              bitsLeft = 32;
            }
            if (bitsLeft >= bitsPerPixel) {
              n2 = buffer2 >>> bitsLeft - bitsPerPixel & bitMask;
              bitsLeft -= bitsPerPixel;
            } else {
              missingBits = bitsPerPixel - bitsLeft;
              n2 = (buffer2 & bitMask) << missingBits & bitMask;
              buffer2 = src[i2++];
              bitsLeft = 32 - missingBits;
              n2 += buffer2 >>> bitsLeft;
            }
            dest[o2] = n2;
          }
          return dest;
        },
        originalUnstuff2: function(src, dest, bitsPerPixel, numPixels) {
          var bitMask = (1 << bitsPerPixel) - 1;
          var i2 = 0, o2;
          var bitsLeft = 0, bitPos = 0;
          var n2, buffer2, missingBits;
          for (o2 = 0; o2 < numPixels; o2++) {
            if (bitsLeft === 0) {
              buffer2 = src[i2++];
              bitsLeft = 32;
              bitPos = 0;
            }
            if (bitsLeft >= bitsPerPixel) {
              n2 = buffer2 >>> bitPos & bitMask;
              bitsLeft -= bitsPerPixel;
              bitPos += bitsPerPixel;
            } else {
              missingBits = bitsPerPixel - bitsLeft;
              n2 = buffer2 >>> bitPos & bitMask;
              buffer2 = src[i2++];
              bitsLeft = 32 - missingBits;
              n2 |= (buffer2 & (1 << missingBits) - 1) << bitsPerPixel - missingBits;
              bitPos = missingBits;
            }
            dest[o2] = n2;
          }
          return dest;
        }
      };
      var Lerc2Helpers = {
        HUFFMAN_LUT_BITS_MAX: 12,
        computeChecksumFletcher32: function(input) {
          var sum1 = 65535, sum2 = 65535;
          var len = input.length;
          var words = Math.floor(len / 2);
          var i2 = 0;
          while (words) {
            var tlen = words >= 359 ? 359 : words;
            words -= tlen;
            do {
              sum1 += input[i2++] << 8;
              sum2 += sum1 += input[i2++];
            } while (--tlen);
            sum1 = (sum1 & 65535) + (sum1 >>> 16);
            sum2 = (sum2 & 65535) + (sum2 >>> 16);
          }
          if (len & 1) {
            sum2 += sum1 += input[i2] << 8;
          }
          sum1 = (sum1 & 65535) + (sum1 >>> 16);
          sum2 = (sum2 & 65535) + (sum2 >>> 16);
          return (sum2 << 16 | sum1) >>> 0;
        },
        readHeaderInfo: function(input, data2) {
          var ptr = data2.ptr;
          var fileIdView = new Uint8Array(input, ptr, 6);
          var headerInfo = {};
          headerInfo.fileIdentifierString = String.fromCharCode.apply(null, fileIdView);
          if (headerInfo.fileIdentifierString.lastIndexOf("Lerc2", 0) !== 0) {
            throw "Unexpected file identifier string (expect Lerc2 ): " + headerInfo.fileIdentifierString;
          }
          ptr += 6;
          var view = new DataView(input, ptr, 8);
          var fileVersion = view.getInt32(0, true);
          headerInfo.fileVersion = fileVersion;
          ptr += 4;
          if (fileVersion >= 3) {
            headerInfo.checksum = view.getUint32(4, true);
            ptr += 4;
          }
          view = new DataView(input, ptr, 12);
          headerInfo.height = view.getUint32(0, true);
          headerInfo.width = view.getUint32(4, true);
          ptr += 8;
          if (fileVersion >= 4) {
            headerInfo.numDims = view.getUint32(8, true);
            ptr += 4;
          } else {
            headerInfo.numDims = 1;
          }
          view = new DataView(input, ptr, 40);
          headerInfo.numValidPixel = view.getUint32(0, true);
          headerInfo.microBlockSize = view.getInt32(4, true);
          headerInfo.blobSize = view.getInt32(8, true);
          headerInfo.imageType = view.getInt32(12, true);
          headerInfo.maxZError = view.getFloat64(16, true);
          headerInfo.zMin = view.getFloat64(24, true);
          headerInfo.zMax = view.getFloat64(32, true);
          ptr += 40;
          data2.headerInfo = headerInfo;
          data2.ptr = ptr;
          var checksum, keyLength;
          if (fileVersion >= 3) {
            keyLength = fileVersion >= 4 ? 52 : 48;
            checksum = this.computeChecksumFletcher32(new Uint8Array(input, ptr - keyLength, headerInfo.blobSize - 14));
            if (checksum !== headerInfo.checksum) {
              throw "Checksum failed.";
            }
          }
          return true;
        },
        checkMinMaxRanges: function(input, data2) {
          var headerInfo = data2.headerInfo;
          var OutPixelTypeArray = this.getDataTypeArray(headerInfo.imageType);
          var rangeBytes = headerInfo.numDims * this.getDataTypeSize(headerInfo.imageType);
          var minValues = this.readSubArray(input, data2.ptr, OutPixelTypeArray, rangeBytes);
          var maxValues = this.readSubArray(input, data2.ptr + rangeBytes, OutPixelTypeArray, rangeBytes);
          data2.ptr += 2 * rangeBytes;
          var i2, equal = true;
          for (i2 = 0; i2 < headerInfo.numDims; i2++) {
            if (minValues[i2] !== maxValues[i2]) {
              equal = false;
              break;
            }
          }
          headerInfo.minValues = minValues;
          headerInfo.maxValues = maxValues;
          return equal;
        },
        readSubArray: function(input, ptr, OutPixelTypeArray, numBytes) {
          var rawData;
          if (OutPixelTypeArray === Uint8Array) {
            rawData = new Uint8Array(input, ptr, numBytes);
          } else {
            var arrayBuf = new ArrayBuffer(numBytes);
            var store8 = new Uint8Array(arrayBuf);
            store8.set(new Uint8Array(input, ptr, numBytes));
            rawData = new OutPixelTypeArray(arrayBuf);
          }
          return rawData;
        },
        readMask: function(input, data2) {
          var ptr = data2.ptr;
          var headerInfo = data2.headerInfo;
          var numPixels = headerInfo.width * headerInfo.height;
          var numValidPixel = headerInfo.numValidPixel;
          var view = new DataView(input, ptr, 4);
          var mask = {};
          mask.numBytes = view.getUint32(0, true);
          ptr += 4;
          if ((numValidPixel === 0 || numPixels === numValidPixel) && mask.numBytes !== 0) {
            throw "invalid mask";
          }
          var bitset, resultMask;
          if (numValidPixel === 0) {
            bitset = new Uint8Array(Math.ceil(numPixels / 8));
            mask.bitset = bitset;
            resultMask = new Uint8Array(numPixels);
            data2.pixels.resultMask = resultMask;
            ptr += mask.numBytes;
          } else if (mask.numBytes > 0) {
            bitset = new Uint8Array(Math.ceil(numPixels / 8));
            view = new DataView(input, ptr, mask.numBytes);
            var cnt = view.getInt16(0, true);
            var ip = 2, op = 0, val = 0;
            do {
              if (cnt > 0) {
                while (cnt--) {
                  bitset[op++] = view.getUint8(ip++);
                }
              } else {
                val = view.getUint8(ip++);
                cnt = -cnt;
                while (cnt--) {
                  bitset[op++] = val;
                }
              }
              cnt = view.getInt16(ip, true);
              ip += 2;
            } while (ip < mask.numBytes);
            if (cnt !== -32768 || op < bitset.length) {
              throw "Unexpected end of mask RLE encoding";
            }
            resultMask = new Uint8Array(numPixels);
            var mb = 0, k2 = 0;
            for (k2 = 0; k2 < numPixels; k2++) {
              if (k2 & 7) {
                mb = bitset[k2 >> 3];
                mb <<= k2 & 7;
              } else {
                mb = bitset[k2 >> 3];
              }
              if (mb & 128) {
                resultMask[k2] = 1;
              }
            }
            data2.pixels.resultMask = resultMask;
            mask.bitset = bitset;
            ptr += mask.numBytes;
          }
          data2.ptr = ptr;
          data2.mask = mask;
          return true;
        },
        readDataOneSweep: function(input, data2, OutPixelTypeArray, useBSQForOutputDim) {
          var ptr = data2.ptr;
          var headerInfo = data2.headerInfo;
          var numDims = headerInfo.numDims;
          var numPixels = headerInfo.width * headerInfo.height;
          var imageType = headerInfo.imageType;
          var numBytes = headerInfo.numValidPixel * Lerc2Helpers.getDataTypeSize(imageType) * numDims;
          var rawData;
          var mask = data2.pixels.resultMask;
          if (OutPixelTypeArray === Uint8Array) {
            rawData = new Uint8Array(input, ptr, numBytes);
          } else {
            var arrayBuf = new ArrayBuffer(numBytes);
            var store8 = new Uint8Array(arrayBuf);
            store8.set(new Uint8Array(input, ptr, numBytes));
            rawData = new OutPixelTypeArray(arrayBuf);
          }
          if (rawData.length === numPixels * numDims) {
            if (useBSQForOutputDim) {
              data2.pixels.resultPixels = Lerc2Helpers.swapDimensionOrder(rawData, numPixels, numDims, OutPixelTypeArray, true);
            } else {
              data2.pixels.resultPixels = rawData;
            }
          } else {
            data2.pixels.resultPixels = new OutPixelTypeArray(numPixels * numDims);
            var z2 = 0, k2 = 0, i2 = 0, nStart = 0;
            if (numDims > 1) {
              if (useBSQForOutputDim) {
                for (k2 = 0; k2 < numPixels; k2++) {
                  if (mask[k2]) {
                    nStart = k2;
                    for (i2 = 0; i2 < numDims; i2++, nStart += numPixels) {
                      data2.pixels.resultPixels[nStart] = rawData[z2++];
                    }
                  }
                }
              } else {
                for (k2 = 0; k2 < numPixels; k2++) {
                  if (mask[k2]) {
                    nStart = k2 * numDims;
                    for (i2 = 0; i2 < numDims; i2++) {
                      data2.pixels.resultPixels[nStart + i2] = rawData[z2++];
                    }
                  }
                }
              }
            } else {
              for (k2 = 0; k2 < numPixels; k2++) {
                if (mask[k2]) {
                  data2.pixels.resultPixels[k2] = rawData[z2++];
                }
              }
            }
          }
          ptr += numBytes;
          data2.ptr = ptr;
          return true;
        },
        readHuffmanTree: function(input, data2) {
          var BITS_MAX = this.HUFFMAN_LUT_BITS_MAX;
          var view = new DataView(input, data2.ptr, 16);
          data2.ptr += 16;
          var version2 = view.getInt32(0, true);
          if (version2 < 2) {
            throw "unsupported Huffman version";
          }
          var size = view.getInt32(4, true);
          var i0 = view.getInt32(8, true);
          var i1 = view.getInt32(12, true);
          if (i0 >= i1) {
            return false;
          }
          var blockDataBuffer = new Uint32Array(i1 - i0);
          Lerc2Helpers.decodeBits(input, data2, blockDataBuffer);
          var codeTable = [];
          var i2, j2, k2, len;
          for (i2 = i0; i2 < i1; i2++) {
            j2 = i2 - (i2 < size ? 0 : size);
            codeTable[j2] = { first: blockDataBuffer[i2 - i0], second: null };
          }
          var dataBytes = input.byteLength - data2.ptr;
          var dataWords = Math.ceil(dataBytes / 4);
          var arrayBuf = new ArrayBuffer(dataWords * 4);
          var store8 = new Uint8Array(arrayBuf);
          store8.set(new Uint8Array(input, data2.ptr, dataBytes));
          var stuffedData = new Uint32Array(arrayBuf);
          var bitPos = 0, word, srcPtr = 0;
          word = stuffedData[0];
          for (i2 = i0; i2 < i1; i2++) {
            j2 = i2 - (i2 < size ? 0 : size);
            len = codeTable[j2].first;
            if (len > 0) {
              codeTable[j2].second = word << bitPos >>> 32 - len;
              if (32 - bitPos >= len) {
                bitPos += len;
                if (bitPos === 32) {
                  bitPos = 0;
                  srcPtr++;
                  word = stuffedData[srcPtr];
                }
              } else {
                bitPos += len - 32;
                srcPtr++;
                word = stuffedData[srcPtr];
                codeTable[j2].second |= word >>> 32 - bitPos;
              }
            }
          }
          var numBitsLUT = 0, numBitsLUTQick = 0;
          var tree = new TreeNode();
          for (i2 = 0; i2 < codeTable.length; i2++) {
            if (codeTable[i2] !== void 0) {
              numBitsLUT = Math.max(numBitsLUT, codeTable[i2].first);
            }
          }
          if (numBitsLUT >= BITS_MAX) {
            numBitsLUTQick = BITS_MAX;
          } else {
            numBitsLUTQick = numBitsLUT;
          }
          var decodeLut = [], entry, code, numEntries, jj, currentBit, node2;
          for (i2 = i0; i2 < i1; i2++) {
            j2 = i2 - (i2 < size ? 0 : size);
            len = codeTable[j2].first;
            if (len > 0) {
              entry = [len, j2];
              if (len <= numBitsLUTQick) {
                code = codeTable[j2].second << numBitsLUTQick - len;
                numEntries = 1 << numBitsLUTQick - len;
                for (k2 = 0; k2 < numEntries; k2++) {
                  decodeLut[code | k2] = entry;
                }
              } else {
                code = codeTable[j2].second;
                node2 = tree;
                for (jj = len - 1; jj >= 0; jj--) {
                  currentBit = code >>> jj & 1;
                  if (currentBit) {
                    if (!node2.right) {
                      node2.right = new TreeNode();
                    }
                    node2 = node2.right;
                  } else {
                    if (!node2.left) {
                      node2.left = new TreeNode();
                    }
                    node2 = node2.left;
                  }
                  if (jj === 0 && !node2.val) {
                    node2.val = entry[1];
                  }
                }
              }
            }
          }
          return {
            decodeLut,
            numBitsLUTQick,
            numBitsLUT,
            tree,
            stuffedData,
            srcPtr,
            bitPos
          };
        },
        readHuffman: function(input, data2, OutPixelTypeArray, useBSQForOutputDim) {
          var headerInfo = data2.headerInfo;
          var numDims = headerInfo.numDims;
          var height = data2.headerInfo.height;
          var width = data2.headerInfo.width;
          var numPixels = width * height;
          var huffmanInfo = this.readHuffmanTree(input, data2);
          var decodeLut = huffmanInfo.decodeLut;
          var tree = huffmanInfo.tree;
          var stuffedData = huffmanInfo.stuffedData;
          var srcPtr = huffmanInfo.srcPtr;
          var bitPos = huffmanInfo.bitPos;
          var numBitsLUTQick = huffmanInfo.numBitsLUTQick;
          var numBitsLUT = huffmanInfo.numBitsLUT;
          var offset2 = data2.headerInfo.imageType === 0 ? 128 : 0;
          var node2, val, delta, mask = data2.pixels.resultMask, valTmp, valTmpQuick, currentBit;
          var i2, j2, k2, ii;
          var prevVal = 0;
          if (bitPos > 0) {
            srcPtr++;
            bitPos = 0;
          }
          var word = stuffedData[srcPtr];
          var deltaEncode = data2.encodeMode === 1;
          var resultPixelsAllDim = new OutPixelTypeArray(numPixels * numDims);
          var resultPixels = resultPixelsAllDim;
          var iDim;
          if (numDims < 2 || deltaEncode) {
            for (iDim = 0; iDim < numDims; iDim++) {
              if (numDims > 1) {
                resultPixels = new OutPixelTypeArray(resultPixelsAllDim.buffer, numPixels * iDim, numPixels);
                prevVal = 0;
              }
              if (data2.headerInfo.numValidPixel === width * height) {
                for (k2 = 0, i2 = 0; i2 < height; i2++) {
                  for (j2 = 0; j2 < width; j2++, k2++) {
                    val = 0;
                    valTmp = word << bitPos >>> 32 - numBitsLUTQick;
                    valTmpQuick = valTmp;
                    if (32 - bitPos < numBitsLUTQick) {
                      valTmp |= stuffedData[srcPtr + 1] >>> 64 - bitPos - numBitsLUTQick;
                      valTmpQuick = valTmp;
                    }
                    if (decodeLut[valTmpQuick]) {
                      val = decodeLut[valTmpQuick][1];
                      bitPos += decodeLut[valTmpQuick][0];
                    } else {
                      valTmp = word << bitPos >>> 32 - numBitsLUT;
                      valTmpQuick = valTmp;
                      if (32 - bitPos < numBitsLUT) {
                        valTmp |= stuffedData[srcPtr + 1] >>> 64 - bitPos - numBitsLUT;
                        valTmpQuick = valTmp;
                      }
                      node2 = tree;
                      for (ii = 0; ii < numBitsLUT; ii++) {
                        currentBit = valTmp >>> numBitsLUT - ii - 1 & 1;
                        node2 = currentBit ? node2.right : node2.left;
                        if (!(node2.left || node2.right)) {
                          val = node2.val;
                          bitPos = bitPos + ii + 1;
                          break;
                        }
                      }
                    }
                    if (bitPos >= 32) {
                      bitPos -= 32;
                      srcPtr++;
                      word = stuffedData[srcPtr];
                    }
                    delta = val - offset2;
                    if (deltaEncode) {
                      if (j2 > 0) {
                        delta += prevVal;
                      } else if (i2 > 0) {
                        delta += resultPixels[k2 - width];
                      } else {
                        delta += prevVal;
                      }
                      delta &= 255;
                      resultPixels[k2] = delta;
                      prevVal = delta;
                    } else {
                      resultPixels[k2] = delta;
                    }
                  }
                }
              } else {
                for (k2 = 0, i2 = 0; i2 < height; i2++) {
                  for (j2 = 0; j2 < width; j2++, k2++) {
                    if (mask[k2]) {
                      val = 0;
                      valTmp = word << bitPos >>> 32 - numBitsLUTQick;
                      valTmpQuick = valTmp;
                      if (32 - bitPos < numBitsLUTQick) {
                        valTmp |= stuffedData[srcPtr + 1] >>> 64 - bitPos - numBitsLUTQick;
                        valTmpQuick = valTmp;
                      }
                      if (decodeLut[valTmpQuick]) {
                        val = decodeLut[valTmpQuick][1];
                        bitPos += decodeLut[valTmpQuick][0];
                      } else {
                        valTmp = word << bitPos >>> 32 - numBitsLUT;
                        valTmpQuick = valTmp;
                        if (32 - bitPos < numBitsLUT) {
                          valTmp |= stuffedData[srcPtr + 1] >>> 64 - bitPos - numBitsLUT;
                          valTmpQuick = valTmp;
                        }
                        node2 = tree;
                        for (ii = 0; ii < numBitsLUT; ii++) {
                          currentBit = valTmp >>> numBitsLUT - ii - 1 & 1;
                          node2 = currentBit ? node2.right : node2.left;
                          if (!(node2.left || node2.right)) {
                            val = node2.val;
                            bitPos = bitPos + ii + 1;
                            break;
                          }
                        }
                      }
                      if (bitPos >= 32) {
                        bitPos -= 32;
                        srcPtr++;
                        word = stuffedData[srcPtr];
                      }
                      delta = val - offset2;
                      if (deltaEncode) {
                        if (j2 > 0 && mask[k2 - 1]) {
                          delta += prevVal;
                        } else if (i2 > 0 && mask[k2 - width]) {
                          delta += resultPixels[k2 - width];
                        } else {
                          delta += prevVal;
                        }
                        delta &= 255;
                        resultPixels[k2] = delta;
                        prevVal = delta;
                      } else {
                        resultPixels[k2] = delta;
                      }
                    }
                  }
                }
              }
            }
          } else {
            for (k2 = 0, i2 = 0; i2 < height; i2++) {
              for (j2 = 0; j2 < width; j2++) {
                k2 = i2 * width + j2;
                if (!mask || mask[k2]) {
                  for (iDim = 0; iDim < numDims; iDim++, k2 += numPixels) {
                    val = 0;
                    valTmp = word << bitPos >>> 32 - numBitsLUTQick;
                    valTmpQuick = valTmp;
                    if (32 - bitPos < numBitsLUTQick) {
                      valTmp |= stuffedData[srcPtr + 1] >>> 64 - bitPos - numBitsLUTQick;
                      valTmpQuick = valTmp;
                    }
                    if (decodeLut[valTmpQuick]) {
                      val = decodeLut[valTmpQuick][1];
                      bitPos += decodeLut[valTmpQuick][0];
                    } else {
                      valTmp = word << bitPos >>> 32 - numBitsLUT;
                      valTmpQuick = valTmp;
                      if (32 - bitPos < numBitsLUT) {
                        valTmp |= stuffedData[srcPtr + 1] >>> 64 - bitPos - numBitsLUT;
                        valTmpQuick = valTmp;
                      }
                      node2 = tree;
                      for (ii = 0; ii < numBitsLUT; ii++) {
                        currentBit = valTmp >>> numBitsLUT - ii - 1 & 1;
                        node2 = currentBit ? node2.right : node2.left;
                        if (!(node2.left || node2.right)) {
                          val = node2.val;
                          bitPos = bitPos + ii + 1;
                          break;
                        }
                      }
                    }
                    if (bitPos >= 32) {
                      bitPos -= 32;
                      srcPtr++;
                      word = stuffedData[srcPtr];
                    }
                    delta = val - offset2;
                    resultPixels[k2] = delta;
                  }
                }
              }
            }
          }
          data2.ptr = data2.ptr + (srcPtr + 1) * 4 + (bitPos > 0 ? 4 : 0);
          data2.pixels.resultPixels = resultPixelsAllDim;
          if (numDims > 1 && !useBSQForOutputDim) {
            data2.pixels.resultPixels = Lerc2Helpers.swapDimensionOrder(resultPixelsAllDim, numPixels, numDims, OutPixelTypeArray);
          }
        },
        decodeBits: function(input, data2, blockDataBuffer, offset2, iDim) {
          {
            var headerInfo = data2.headerInfo;
            var fileVersion = headerInfo.fileVersion;
            var blockPtr = 0;
            var viewByteLength = input.byteLength - data2.ptr >= 5 ? 5 : input.byteLength - data2.ptr;
            var view = new DataView(input, data2.ptr, viewByteLength);
            var headerByte = view.getUint8(0);
            blockPtr++;
            var bits67 = headerByte >> 6;
            var n2 = bits67 === 0 ? 4 : 3 - bits67;
            var doLut = (headerByte & 32) > 0 ? true : false;
            var numBits = headerByte & 31;
            var numElements = 0;
            if (n2 === 1) {
              numElements = view.getUint8(blockPtr);
              blockPtr++;
            } else if (n2 === 2) {
              numElements = view.getUint16(blockPtr, true);
              blockPtr += 2;
            } else if (n2 === 4) {
              numElements = view.getUint32(blockPtr, true);
              blockPtr += 4;
            } else {
              throw "Invalid valid pixel count type";
            }
            var scale2 = 2 * headerInfo.maxZError;
            var stuffedData, arrayBuf, store8, dataBytes, dataWords;
            var lutArr, lutData, lutBytes, bitsPerPixel;
            var zMax = headerInfo.numDims > 1 ? headerInfo.maxValues[iDim] : headerInfo.zMax;
            if (doLut) {
              data2.counter.lut++;
              lutBytes = view.getUint8(blockPtr);
              blockPtr++;
              dataBytes = Math.ceil((lutBytes - 1) * numBits / 8);
              dataWords = Math.ceil(dataBytes / 4);
              arrayBuf = new ArrayBuffer(dataWords * 4);
              store8 = new Uint8Array(arrayBuf);
              data2.ptr += blockPtr;
              store8.set(new Uint8Array(input, data2.ptr, dataBytes));
              lutData = new Uint32Array(arrayBuf);
              data2.ptr += dataBytes;
              bitsPerPixel = 0;
              while (lutBytes - 1 >>> bitsPerPixel) {
                bitsPerPixel++;
              }
              dataBytes = Math.ceil(numElements * bitsPerPixel / 8);
              dataWords = Math.ceil(dataBytes / 4);
              arrayBuf = new ArrayBuffer(dataWords * 4);
              store8 = new Uint8Array(arrayBuf);
              store8.set(new Uint8Array(input, data2.ptr, dataBytes));
              stuffedData = new Uint32Array(arrayBuf);
              data2.ptr += dataBytes;
              if (fileVersion >= 3) {
                lutArr = BitStuffer.unstuffLUT2(lutData, numBits, lutBytes - 1, offset2, scale2, zMax);
              } else {
                lutArr = BitStuffer.unstuffLUT(lutData, numBits, lutBytes - 1, offset2, scale2, zMax);
              }
              if (fileVersion >= 3) {
                BitStuffer.unstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements, lutArr);
              } else {
                BitStuffer.unstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements, lutArr);
              }
            } else {
              data2.counter.bitstuffer++;
              bitsPerPixel = numBits;
              data2.ptr += blockPtr;
              if (bitsPerPixel > 0) {
                dataBytes = Math.ceil(numElements * bitsPerPixel / 8);
                dataWords = Math.ceil(dataBytes / 4);
                arrayBuf = new ArrayBuffer(dataWords * 4);
                store8 = new Uint8Array(arrayBuf);
                store8.set(new Uint8Array(input, data2.ptr, dataBytes));
                stuffedData = new Uint32Array(arrayBuf);
                data2.ptr += dataBytes;
                if (fileVersion >= 3) {
                  if (offset2 == null) {
                    BitStuffer.originalUnstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements);
                  } else {
                    BitStuffer.unstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements, false, offset2, scale2, zMax);
                  }
                } else {
                  if (offset2 == null) {
                    BitStuffer.originalUnstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements);
                  } else {
                    BitStuffer.unstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements, false, offset2, scale2, zMax);
                  }
                }
              }
            }
          }
        },
        readTiles: function(input, data2, OutPixelTypeArray, useBSQForOutputDim) {
          var headerInfo = data2.headerInfo;
          var width = headerInfo.width;
          var height = headerInfo.height;
          var numPixels = width * height;
          var microBlockSize = headerInfo.microBlockSize;
          var imageType = headerInfo.imageType;
          var dataTypeSize = Lerc2Helpers.getDataTypeSize(imageType);
          var numBlocksX = Math.ceil(width / microBlockSize);
          var numBlocksY = Math.ceil(height / microBlockSize);
          data2.pixels.numBlocksY = numBlocksY;
          data2.pixels.numBlocksX = numBlocksX;
          data2.pixels.ptr = 0;
          var row = 0, col = 0, blockY = 0, blockX = 0, thisBlockHeight = 0, thisBlockWidth = 0, bytesLeft = 0, headerByte = 0, bits67 = 0, testCode = 0, outPtr = 0, outStride = 0, numBytes = 0, bytesleft = 0, z2 = 0, blockPtr = 0;
          var view, block, arrayBuf, store8, rawData;
          var blockEncoding;
          var blockDataBuffer = new OutPixelTypeArray(microBlockSize * microBlockSize);
          var lastBlockHeight = height % microBlockSize || microBlockSize;
          var lastBlockWidth = width % microBlockSize || microBlockSize;
          var offsetType, offset2;
          var numDims = headerInfo.numDims, iDim;
          var mask = data2.pixels.resultMask;
          var resultPixels = data2.pixels.resultPixels;
          var fileVersion = headerInfo.fileVersion;
          var fileVersionCheckNum = fileVersion >= 5 ? 14 : 15;
          var isDiffEncoding;
          var zMax = headerInfo.zMax;
          var resultPixelsPrevDim;
          for (blockY = 0; blockY < numBlocksY; blockY++) {
            thisBlockHeight = blockY !== numBlocksY - 1 ? microBlockSize : lastBlockHeight;
            for (blockX = 0; blockX < numBlocksX; blockX++) {
              thisBlockWidth = blockX !== numBlocksX - 1 ? microBlockSize : lastBlockWidth;
              outPtr = blockY * width * microBlockSize + blockX * microBlockSize;
              outStride = width - thisBlockWidth;
              for (iDim = 0; iDim < numDims; iDim++) {
                if (numDims > 1) {
                  resultPixelsPrevDim = resultPixels;
                  outPtr = blockY * width * microBlockSize + blockX * microBlockSize;
                  resultPixels = new OutPixelTypeArray(data2.pixels.resultPixels.buffer, numPixels * iDim * dataTypeSize, numPixels);
                  zMax = headerInfo.maxValues[iDim];
                } else {
                  resultPixelsPrevDim = null;
                }
                bytesLeft = input.byteLength - data2.ptr;
                view = new DataView(input, data2.ptr, Math.min(10, bytesLeft));
                block = {};
                blockPtr = 0;
                headerByte = view.getUint8(0);
                blockPtr++;
                isDiffEncoding = headerInfo.fileVersion >= 5 ? headerByte & 4 : 0;
                bits67 = headerByte >> 6 & 255;
                testCode = headerByte >> 2 & fileVersionCheckNum;
                if (testCode !== (blockX * microBlockSize >> 3 & fileVersionCheckNum)) {
                  throw "integrity issue";
                }
                if (isDiffEncoding && iDim === 0) {
                  throw "integrity issue";
                }
                blockEncoding = headerByte & 3;
                if (blockEncoding > 3) {
                  data2.ptr += blockPtr;
                  throw "Invalid block encoding (" + blockEncoding + ")";
                } else if (blockEncoding === 2) {
                  if (isDiffEncoding) {
                    if (mask) {
                      for (row = 0; row < thisBlockHeight; row++) {
                        for (col = 0; col < thisBlockWidth; col++) {
                          if (mask[outPtr]) {
                            resultPixels[outPtr] = resultPixelsPrevDim[outPtr];
                          }
                          outPtr++;
                        }
                      }
                    } else {
                      for (row = 0; row < thisBlockHeight; row++) {
                        for (col = 0; col < thisBlockWidth; col++) {
                          resultPixels[outPtr] = resultPixelsPrevDim[outPtr];
                          outPtr++;
                        }
                      }
                    }
                  }
                  data2.counter.constant++;
                  data2.ptr += blockPtr;
                  continue;
                } else if (blockEncoding === 0) {
                  if (isDiffEncoding) {
                    throw "integrity issue";
                  }
                  data2.counter.uncompressed++;
                  data2.ptr += blockPtr;
                  numBytes = thisBlockHeight * thisBlockWidth * dataTypeSize;
                  bytesleft = input.byteLength - data2.ptr;
                  numBytes = numBytes < bytesleft ? numBytes : bytesleft;
                  arrayBuf = new ArrayBuffer(numBytes % dataTypeSize === 0 ? numBytes : numBytes + dataTypeSize - numBytes % dataTypeSize);
                  store8 = new Uint8Array(arrayBuf);
                  store8.set(new Uint8Array(input, data2.ptr, numBytes));
                  rawData = new OutPixelTypeArray(arrayBuf);
                  z2 = 0;
                  if (mask) {
                    for (row = 0; row < thisBlockHeight; row++) {
                      for (col = 0; col < thisBlockWidth; col++) {
                        if (mask[outPtr]) {
                          resultPixels[outPtr] = rawData[z2++];
                        }
                        outPtr++;
                      }
                      outPtr += outStride;
                    }
                  } else {
                    for (row = 0; row < thisBlockHeight; row++) {
                      for (col = 0; col < thisBlockWidth; col++) {
                        resultPixels[outPtr++] = rawData[z2++];
                      }
                      outPtr += outStride;
                    }
                  }
                  data2.ptr += z2 * dataTypeSize;
                } else {
                  offsetType = Lerc2Helpers.getDataTypeUsed(isDiffEncoding && imageType < 6 ? 4 : imageType, bits67);
                  offset2 = Lerc2Helpers.getOnePixel(block, blockPtr, offsetType, view);
                  blockPtr += Lerc2Helpers.getDataTypeSize(offsetType);
                  if (blockEncoding === 3) {
                    data2.ptr += blockPtr;
                    data2.counter.constantoffset++;
                    if (mask) {
                      for (row = 0; row < thisBlockHeight; row++) {
                        for (col = 0; col < thisBlockWidth; col++) {
                          if (mask[outPtr]) {
                            resultPixels[outPtr] = isDiffEncoding ? Math.min(zMax, resultPixelsPrevDim[outPtr] + offset2) : offset2;
                          }
                          outPtr++;
                        }
                        outPtr += outStride;
                      }
                    } else {
                      for (row = 0; row < thisBlockHeight; row++) {
                        for (col = 0; col < thisBlockWidth; col++) {
                          resultPixels[outPtr] = isDiffEncoding ? Math.min(zMax, resultPixelsPrevDim[outPtr] + offset2) : offset2;
                          outPtr++;
                        }
                        outPtr += outStride;
                      }
                    }
                  } else {
                    data2.ptr += blockPtr;
                    Lerc2Helpers.decodeBits(input, data2, blockDataBuffer, offset2, iDim);
                    blockPtr = 0;
                    if (isDiffEncoding) {
                      if (mask) {
                        for (row = 0; row < thisBlockHeight; row++) {
                          for (col = 0; col < thisBlockWidth; col++) {
                            if (mask[outPtr]) {
                              resultPixels[outPtr] = blockDataBuffer[blockPtr++] + resultPixelsPrevDim[outPtr];
                            }
                            outPtr++;
                          }
                          outPtr += outStride;
                        }
                      } else {
                        for (row = 0; row < thisBlockHeight; row++) {
                          for (col = 0; col < thisBlockWidth; col++) {
                            resultPixels[outPtr] = blockDataBuffer[blockPtr++] + resultPixelsPrevDim[outPtr];
                            outPtr++;
                          }
                          outPtr += outStride;
                        }
                      }
                    } else if (mask) {
                      for (row = 0; row < thisBlockHeight; row++) {
                        for (col = 0; col < thisBlockWidth; col++) {
                          if (mask[outPtr]) {
                            resultPixels[outPtr] = blockDataBuffer[blockPtr++];
                          }
                          outPtr++;
                        }
                        outPtr += outStride;
                      }
                    } else {
                      for (row = 0; row < thisBlockHeight; row++) {
                        for (col = 0; col < thisBlockWidth; col++) {
                          resultPixels[outPtr++] = blockDataBuffer[blockPtr++];
                        }
                        outPtr += outStride;
                      }
                    }
                  }
                }
              }
            }
          }
          if (numDims > 1 && !useBSQForOutputDim) {
            data2.pixels.resultPixels = Lerc2Helpers.swapDimensionOrder(data2.pixels.resultPixels, numPixels, numDims, OutPixelTypeArray);
          }
        },
        formatFileInfo: function(data2) {
          return {
            "fileIdentifierString": data2.headerInfo.fileIdentifierString,
            "fileVersion": data2.headerInfo.fileVersion,
            "imageType": data2.headerInfo.imageType,
            "height": data2.headerInfo.height,
            "width": data2.headerInfo.width,
            "numValidPixel": data2.headerInfo.numValidPixel,
            "microBlockSize": data2.headerInfo.microBlockSize,
            "blobSize": data2.headerInfo.blobSize,
            "maxZError": data2.headerInfo.maxZError,
            "pixelType": Lerc2Helpers.getPixelType(data2.headerInfo.imageType),
            "eofOffset": data2.eofOffset,
            "mask": data2.mask ? {
              "numBytes": data2.mask.numBytes
            } : null,
            "pixels": {
              "numBlocksX": data2.pixels.numBlocksX,
              "numBlocksY": data2.pixels.numBlocksY,
              "maxValue": data2.headerInfo.zMax,
              "minValue": data2.headerInfo.zMin,
              "noDataValue": data2.noDataValue
            }
          };
        },
        constructConstantSurface: function(data2, useBSQForOutputDim) {
          var val = data2.headerInfo.zMax;
          var valMin = data2.headerInfo.zMin;
          var maxValues = data2.headerInfo.maxValues;
          var numDims = data2.headerInfo.numDims;
          var numPixels = data2.headerInfo.height * data2.headerInfo.width;
          var i2 = 0, k2 = 0, nStart = 0;
          var mask = data2.pixels.resultMask;
          var resultPixels = data2.pixels.resultPixels;
          if (mask) {
            if (numDims > 1) {
              if (useBSQForOutputDim) {
                for (i2 = 0; i2 < numDims; i2++) {
                  nStart = i2 * numPixels;
                  val = maxValues[i2];
                  for (k2 = 0; k2 < numPixels; k2++) {
                    if (mask[k2]) {
                      resultPixels[nStart + k2] = val;
                    }
                  }
                }
              } else {
                for (k2 = 0; k2 < numPixels; k2++) {
                  if (mask[k2]) {
                    nStart = k2 * numDims;
                    for (i2 = 0; i2 < numDims; i2++) {
                      resultPixels[nStart + numDims] = maxValues[i2];
                    }
                  }
                }
              }
            } else {
              for (k2 = 0; k2 < numPixels; k2++) {
                if (mask[k2]) {
                  resultPixels[k2] = val;
                }
              }
            }
          } else {
            if (numDims > 1 && valMin !== val) {
              if (useBSQForOutputDim) {
                for (i2 = 0; i2 < numDims; i2++) {
                  nStart = i2 * numPixels;
                  val = maxValues[i2];
                  for (k2 = 0; k2 < numPixels; k2++) {
                    resultPixels[nStart + k2] = val;
                  }
                }
              } else {
                for (k2 = 0; k2 < numPixels; k2++) {
                  nStart = k2 * numDims;
                  for (i2 = 0; i2 < numDims; i2++) {
                    resultPixels[nStart + i2] = maxValues[i2];
                  }
                }
              }
            } else {
              for (k2 = 0; k2 < numPixels * numDims; k2++) {
                resultPixels[k2] = val;
              }
            }
          }
          return;
        },
        getDataTypeArray: function(t3) {
          var tp;
          switch (t3) {
            case 0:
              tp = Int8Array;
              break;
            case 1:
              tp = Uint8Array;
              break;
            case 2:
              tp = Int16Array;
              break;
            case 3:
              tp = Uint16Array;
              break;
            case 4:
              tp = Int32Array;
              break;
            case 5:
              tp = Uint32Array;
              break;
            case 6:
              tp = Float32Array;
              break;
            case 7:
              tp = Float64Array;
              break;
            default:
              tp = Float32Array;
          }
          return tp;
        },
        getPixelType: function(t3) {
          var tp;
          switch (t3) {
            case 0:
              tp = "S8";
              break;
            case 1:
              tp = "U8";
              break;
            case 2:
              tp = "S16";
              break;
            case 3:
              tp = "U16";
              break;
            case 4:
              tp = "S32";
              break;
            case 5:
              tp = "U32";
              break;
            case 6:
              tp = "F32";
              break;
            case 7:
              tp = "F64";
              break;
            default:
              tp = "F32";
          }
          return tp;
        },
        isValidPixelValue: function(t3, val) {
          if (val == null) {
            return false;
          }
          var isValid;
          switch (t3) {
            case 0:
              isValid = val >= -128 && val <= 127;
              break;
            case 1:
              isValid = val >= 0 && val <= 255;
              break;
            case 2:
              isValid = val >= -32768 && val <= 32767;
              break;
            case 3:
              isValid = val >= 0 && val <= 65536;
              break;
            case 4:
              isValid = val >= -2147483648 && val <= 2147483647;
              break;
            case 5:
              isValid = val >= 0 && val <= 4294967296;
              break;
            case 6:
              isValid = val >= -34027999387901484e22 && val <= 34027999387901484e22;
              break;
            case 7:
              isValid = val >= -17976931348623157e292 && val <= 17976931348623157e292;
              break;
            default:
              isValid = false;
          }
          return isValid;
        },
        getDataTypeSize: function(t3) {
          var s2 = 0;
          switch (t3) {
            case 0:
            case 1:
              s2 = 1;
              break;
            case 2:
            case 3:
              s2 = 2;
              break;
            case 4:
            case 5:
            case 6:
              s2 = 4;
              break;
            case 7:
              s2 = 8;
              break;
            default:
              s2 = t3;
          }
          return s2;
        },
        getDataTypeUsed: function(dt2, tc) {
          var t3 = dt2;
          switch (dt2) {
            case 2:
            case 4:
              t3 = dt2 - tc;
              break;
            case 3:
            case 5:
              t3 = dt2 - 2 * tc;
              break;
            case 6:
              if (tc === 0) {
                t3 = dt2;
              } else if (tc === 1) {
                t3 = 2;
              } else {
                t3 = 1;
              }
              break;
            case 7:
              if (tc === 0) {
                t3 = dt2;
              } else {
                t3 = dt2 - 2 * tc + 1;
              }
              break;
            default:
              t3 = dt2;
              break;
          }
          return t3;
        },
        getOnePixel: function(block, blockPtr, offsetType, view) {
          var temp = 0;
          switch (offsetType) {
            case 0:
              temp = view.getInt8(blockPtr);
              break;
            case 1:
              temp = view.getUint8(blockPtr);
              break;
            case 2:
              temp = view.getInt16(blockPtr, true);
              break;
            case 3:
              temp = view.getUint16(blockPtr, true);
              break;
            case 4:
              temp = view.getInt32(blockPtr, true);
              break;
            case 5:
              temp = view.getUInt32(blockPtr, true);
              break;
            case 6:
              temp = view.getFloat32(blockPtr, true);
              break;
            case 7:
              temp = view.getFloat64(blockPtr, true);
              break;
            default:
              throw "the decoder does not understand this pixel type";
          }
          return temp;
        },
        swapDimensionOrder: function(pixels, numPixels, numDims, OutPixelTypeArray, inputIsBIP) {
          var i2 = 0, j2 = 0, iDim = 0, temp = 0, swap2 = pixels;
          if (numDims > 1) {
            swap2 = new OutPixelTypeArray(numPixels * numDims);
            if (inputIsBIP) {
              for (i2 = 0; i2 < numPixels; i2++) {
                temp = i2;
                for (iDim = 0; iDim < numDims; iDim++, temp += numPixels) {
                  swap2[temp] = pixels[j2++];
                }
              }
            } else {
              for (i2 = 0; i2 < numPixels; i2++) {
                temp = i2;
                for (iDim = 0; iDim < numDims; iDim++, temp += numPixels) {
                  swap2[j2++] = pixels[temp];
                }
              }
            }
          }
          return swap2;
        }
      };
      var TreeNode = function(val, left, right) {
        this.val = val;
        this.left = left;
        this.right = right;
      };
      var Lerc2Decode2 = {
        decode: function(input, options) {
          options = options || {};
          var noDataValue = options.noDataValue;
          var i2 = 0, data2 = {};
          data2.ptr = options.inputOffset || 0;
          data2.pixels = {};
          if (!Lerc2Helpers.readHeaderInfo(input, data2))
            ;
          var headerInfo = data2.headerInfo;
          var fileVersion = headerInfo.fileVersion;
          var OutPixelTypeArray = Lerc2Helpers.getDataTypeArray(headerInfo.imageType);
          if (fileVersion > 5) {
            throw "unsupported lerc version 2." + fileVersion;
          }
          Lerc2Helpers.readMask(input, data2);
          if (headerInfo.numValidPixel !== headerInfo.width * headerInfo.height && !data2.pixels.resultMask) {
            data2.pixels.resultMask = options.maskData;
          }
          var numPixels = headerInfo.width * headerInfo.height;
          data2.pixels.resultPixels = new OutPixelTypeArray(numPixels * headerInfo.numDims);
          data2.counter = {
            onesweep: 0,
            uncompressed: 0,
            lut: 0,
            bitstuffer: 0,
            constant: 0,
            constantoffset: 0
          };
          var useBSQForOutputDim = !options.returnPixelInterleavedDims;
          if (headerInfo.numValidPixel !== 0) {
            if (headerInfo.zMax === headerInfo.zMin) {
              Lerc2Helpers.constructConstantSurface(data2, useBSQForOutputDim);
            } else if (fileVersion >= 4 && Lerc2Helpers.checkMinMaxRanges(input, data2)) {
              Lerc2Helpers.constructConstantSurface(data2, useBSQForOutputDim);
            } else {
              var view = new DataView(input, data2.ptr, 2);
              var bReadDataOneSweep = view.getUint8(0);
              data2.ptr++;
              if (bReadDataOneSweep) {
                Lerc2Helpers.readDataOneSweep(input, data2, OutPixelTypeArray, useBSQForOutputDim);
              } else {
                if (fileVersion > 1 && headerInfo.imageType <= 1 && Math.abs(headerInfo.maxZError - 0.5) < 1e-5) {
                  var flagHuffman = view.getUint8(1);
                  data2.ptr++;
                  data2.encodeMode = flagHuffman;
                  if (flagHuffman > 2 || fileVersion < 4 && flagHuffman > 1) {
                    throw "Invalid Huffman flag " + flagHuffman;
                  }
                  if (flagHuffman) {
                    Lerc2Helpers.readHuffman(input, data2, OutPixelTypeArray, useBSQForOutputDim);
                  } else {
                    Lerc2Helpers.readTiles(input, data2, OutPixelTypeArray, useBSQForOutputDim);
                  }
                } else {
                  Lerc2Helpers.readTiles(input, data2, OutPixelTypeArray, useBSQForOutputDim);
                }
              }
            }
          }
          data2.eofOffset = data2.ptr;
          var diff;
          if (options.inputOffset) {
            diff = data2.headerInfo.blobSize + options.inputOffset - data2.ptr;
            if (Math.abs(diff) >= 1) {
              data2.eofOffset = options.inputOffset + data2.headerInfo.blobSize;
            }
          } else {
            diff = data2.headerInfo.blobSize - data2.ptr;
            if (Math.abs(diff) >= 1) {
              data2.eofOffset = data2.headerInfo.blobSize;
            }
          }
          var result = {
            width: headerInfo.width,
            height: headerInfo.height,
            pixelData: data2.pixels.resultPixels,
            minValue: headerInfo.zMin,
            maxValue: headerInfo.zMax,
            validPixelCount: headerInfo.numValidPixel,
            dimCount: headerInfo.numDims,
            dimStats: {
              minValues: headerInfo.minValues,
              maxValues: headerInfo.maxValues
            },
            maskData: data2.pixels.resultMask
          };
          if (data2.pixels.resultMask && Lerc2Helpers.isValidPixelValue(headerInfo.imageType, noDataValue)) {
            var mask = data2.pixels.resultMask;
            for (i2 = 0; i2 < numPixels; i2++) {
              if (!mask[i2]) {
                result.pixelData[i2] = noDataValue;
              }
            }
            result.noDataValue = noDataValue;
          }
          data2.noDataValue = noDataValue;
          if (options.returnFileInfo) {
            result.fileInfo = Lerc2Helpers.formatFileInfo(data2);
          }
          return result;
        },
        getBandCount: function(input) {
          var count = 0;
          var i2 = 0;
          var temp = {};
          temp.ptr = 0;
          temp.pixels = {};
          while (i2 < input.byteLength - 58) {
            Lerc2Helpers.readHeaderInfo(input, temp);
            i2 += temp.headerInfo.blobSize;
            count++;
            temp.ptr = i2;
          }
          return count;
        }
      };
      return Lerc2Decode2;
    }();
    var isPlatformLittleEndian = function() {
      var a2 = new ArrayBuffer(4);
      var b2 = new Uint8Array(a2);
      var c2 = new Uint32Array(a2);
      c2[0] = 1;
      return b2[0] === 1;
    }();
    var Lerc2 = {
      decode: function(encodedData, options) {
        if (!isPlatformLittleEndian) {
          throw "Big endian system is not supported.";
        }
        options = options || {};
        var inputOffset = options.inputOffset || 0;
        var fileIdView = new Uint8Array(encodedData, inputOffset, 10);
        var fileIdentifierString = String.fromCharCode.apply(null, fileIdView);
        var lerc2, majorVersion;
        if (fileIdentifierString.trim() === "CntZImage") {
          lerc2 = LercDecode2;
          majorVersion = 1;
        } else if (fileIdentifierString.substring(0, 5) === "Lerc2") {
          lerc2 = Lerc2Decode;
          majorVersion = 2;
        } else {
          throw "Unexpected file identifier string: " + fileIdentifierString;
        }
        var iPlane = 0, eof = encodedData.byteLength - 10, encodedMaskData, bandMasks = [], bandMask, maskData;
        var decodedPixelBlock = {
          width: 0,
          height: 0,
          pixels: [],
          pixelType: options.pixelType,
          mask: null,
          statistics: []
        };
        var uniqueBandMaskCount = 0;
        while (inputOffset < eof) {
          var result = lerc2.decode(encodedData, {
            inputOffset,
            encodedMaskData,
            maskData,
            returnMask: iPlane === 0 ? true : false,
            returnEncodedMask: iPlane === 0 ? true : false,
            returnFileInfo: true,
            returnPixelInterleavedDims: options.returnPixelInterleavedDims,
            pixelType: options.pixelType || null,
            noDataValue: options.noDataValue || null
          });
          inputOffset = result.fileInfo.eofOffset;
          maskData = result.maskData;
          if (iPlane === 0) {
            encodedMaskData = result.encodedMaskData;
            decodedPixelBlock.width = result.width;
            decodedPixelBlock.height = result.height;
            decodedPixelBlock.dimCount = result.dimCount || 1;
            decodedPixelBlock.pixelType = result.pixelType || result.fileInfo.pixelType;
            decodedPixelBlock.mask = maskData;
          }
          if (majorVersion > 1) {
            if (maskData) {
              bandMasks.push(maskData);
            }
            if (result.fileInfo.mask && result.fileInfo.mask.numBytes > 0) {
              uniqueBandMaskCount++;
            }
          }
          iPlane++;
          decodedPixelBlock.pixels.push(result.pixelData);
          decodedPixelBlock.statistics.push({
            minValue: result.minValue,
            maxValue: result.maxValue,
            noDataValue: result.noDataValue,
            dimStats: result.dimStats
          });
        }
        var i2, j2, numPixels;
        if (majorVersion > 1 && uniqueBandMaskCount > 1) {
          numPixels = decodedPixelBlock.width * decodedPixelBlock.height;
          decodedPixelBlock.bandMasks = bandMasks;
          maskData = new Uint8Array(numPixels);
          maskData.set(bandMasks[0]);
          for (i2 = 1; i2 < bandMasks.length; i2++) {
            bandMask = bandMasks[i2];
            for (j2 = 0; j2 < numPixels; j2++) {
              maskData[j2] = maskData[j2] & bandMask[j2];
            }
          }
          decodedPixelBlock.maskData = maskData;
        }
        return decodedPixelBlock;
      }
    };
    if (module.exports) {
      module.exports = Lerc2;
    } else {
      this.Lerc = Lerc2;
    }
  })();
})(LercDecode);
var Lerc = LercDecode.exports;
class LercDecoder extends BaseDecoder {
  constructor(fileDirectory) {
    super();
    this.planarConfiguration = typeof fileDirectory.PlanarConfiguration !== "undefined" ? fileDirectory.PlanarConfiguration : 1;
    this.samplesPerPixel = typeof fileDirectory.SamplesPerPixel !== "undefined" ? fileDirectory.SamplesPerPixel : 1;
    this.addCompression = fileDirectory.LercParameters[LercParameters.AddCompression];
  }
  decodeBlock(buffer2) {
    switch (this.addCompression) {
      case LercAddCompression.None:
        break;
      case LercAddCompression.Deflate:
        buffer2 = inflate_1(new Uint8Array(buffer2)).buffer;
        break;
      default:
        throw new Error(`Unsupported LERC additional compression method identifier: ${this.addCompression}`);
    }
    const lercResult = Lerc.decode(buffer2, { returnPixelInterleavedDims: this.planarConfiguration === 1 });
    const lercData = lercResult.pixels[0];
    return lercData.buffer;
  }
}
var lerc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": LercDecoder
}, Symbol.toStringTag, { value: "Module" }));
class WebImageDecoder extends BaseDecoder {
  constructor() {
    super();
    if (typeof createImageBitmap === "undefined") {
      throw new Error("Cannot decode WebImage as `createImageBitmap` is not available");
    } else if (typeof document === "undefined" && typeof OffscreenCanvas === "undefined") {
      throw new Error("Cannot decode WebImage as neither `document` nor `OffscreenCanvas` is not available");
    }
  }
  async decode(fileDirectory, buffer2) {
    const blob = new Blob([buffer2]);
    const imageBitmap = await createImageBitmap(blob);
    let canvas;
    if (typeof document !== "undefined") {
      canvas = document.createElement("canvas");
      canvas.width = imageBitmap.width;
      canvas.height = imageBitmap.height;
    } else {
      canvas = new OffscreenCanvas(imageBitmap.width, imageBitmap.height);
    }
    const ctx = canvas.getContext("2d");
    ctx.drawImage(imageBitmap, 0, 0);
    return ctx.getImageData(0, 0, imageBitmap.width, imageBitmap.height).data.buffer;
  }
}
var webimage = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": WebImageDecoder
}, Symbol.toStringTag, { value: "Module" }));
var browser = Worker;
function create$4() {
  const source = 'function e(e,t,r,n,i,a,o){try{var s=e[a](o),f=s.value}catch(e){return void r(e)}s.done?t(f):Promise.resolve(f).then(n,i)}function t(t){return function(){var r=this,n=arguments;return new Promise((function(i,a){var o=t.apply(r,n);function s(t){e(o,i,a,s,f,"next",t)}function f(t){e(o,i,a,s,f,"throw",t)}s(void 0)}))}}function r(e){return r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},r(e)}var n={exports:{}};!function(e){var t=function(e){var t,n=Object.prototype,i=n.hasOwnProperty,a="function"==typeof Symbol?Symbol:{},o=a.iterator||"@@iterator",s=a.asyncIterator||"@@asyncIterator",f=a.toStringTag||"@@toStringTag";function l(e,t,r){return Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}),e[t]}try{l({},"")}catch(e){l=function(e,t,r){return e[t]=r}}function u(e,t,r,n){var i=t&&t.prototype instanceof y?t:y,a=Object.create(i.prototype),o=new T(n||[]);return a._invoke=function(e,t,r){var n=h;return function(i,a){if(n===p)throw new Error("Generator is already running");if(n===m){if("throw"===i)throw a;return E()}for(r.method=i,r.arg=a;;){var o=r.delegate;if(o){var s=I(o,r);if(s){if(s===v)continue;return s}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(n===h)throw n=m,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);n=p;var f=c(e,t,r);if("normal"===f.type){if(n=r.done?m:d,f.arg===v)continue;return{value:f.arg,done:r.done}}"throw"===f.type&&(n=m,r.method="throw",r.arg=f.arg)}}}(e,r,o),a}function c(e,t,r){try{return{type:"normal",arg:e.call(t,r)}}catch(e){return{type:"throw",arg:e}}}e.wrap=u;var h="suspendedStart",d="suspendedYield",p="executing",m="completed",v={};function y(){}function w(){}function g(){}var b={};l(b,o,(function(){return this}));var k=Object.getPrototypeOf,x=k&&k(k(D([])));x&&x!==n&&i.call(x,o)&&(b=x);var _=g.prototype=y.prototype=Object.create(b);function A(e){["next","throw","return"].forEach((function(t){l(e,t,(function(e){return this._invoke(t,e)}))}))}function P(e,t){function n(a,o,s,f){var l=c(e[a],e,o);if("throw"!==l.type){var u=l.arg,h=u.value;return h&&"object"===r(h)&&i.call(h,"__await")?t.resolve(h.__await).then((function(e){n("next",e,s,f)}),(function(e){n("throw",e,s,f)})):t.resolve(h).then((function(e){u.value=e,s(u)}),(function(e){return n("throw",e,s,f)}))}f(l.arg)}var a;this._invoke=function(e,r){function i(){return new t((function(t,i){n(e,r,t,i)}))}return a=a?a.then(i,i):i()}}function I(e,r){var n=e.iterator[r.method];if(n===t){if(r.delegate=null,"throw"===r.method){if(e.iterator.return&&(r.method="return",r.arg=t,I(e,r),"throw"===r.method))return v;r.method="throw",r.arg=new TypeError("The iterator does not provide a \'throw\' method")}return v}var i=c(n,e.iterator,r.arg);if("throw"===i.type)return r.method="throw",r.arg=i.arg,r.delegate=null,v;var a=i.arg;return a?a.done?(r[e.resultName]=a.value,r.next=e.nextLoc,"return"!==r.method&&(r.method="next",r.arg=t),r.delegate=null,v):a:(r.method="throw",r.arg=new TypeError("iterator result is not an object"),r.delegate=null,v)}function U(e){var t={tryLoc:e[0]};1 in e&&(t.catchLoc=e[1]),2 in e&&(t.finallyLoc=e[2],t.afterLoc=e[3]),this.tryEntries.push(t)}function S(e){var t=e.completion||{};t.type="normal",delete t.arg,e.completion=t}function T(e){this.tryEntries=[{tryLoc:"root"}],e.forEach(U,this),this.reset(!0)}function D(e){if(e){var r=e[o];if(r)return r.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var n=-1,a=function r(){for(;++n<e.length;)if(i.call(e,n))return r.value=e[n],r.done=!1,r;return r.value=t,r.done=!0,r};return a.next=a}}return{next:E}}function E(){return{value:t,done:!0}}return w.prototype=g,l(_,"constructor",g),l(g,"constructor",w),w.displayName=l(g,f,"GeneratorFunction"),e.isGeneratorFunction=function(e){var t="function"==typeof e&&e.constructor;return!!t&&(t===w||"GeneratorFunction"===(t.displayName||t.name))},e.mark=function(e){return Object.setPrototypeOf?Object.setPrototypeOf(e,g):(e.__proto__=g,l(e,f,"GeneratorFunction")),e.prototype=Object.create(_),e},e.awrap=function(e){return{__await:e}},A(P.prototype),l(P.prototype,s,(function(){return this})),e.AsyncIterator=P,e.async=function(t,r,n,i,a){void 0===a&&(a=Promise);var o=new P(u(t,r,n,i),a);return e.isGeneratorFunction(r)?o:o.next().then((function(e){return e.done?e.value:o.next()}))},A(_),l(_,f,"Generator"),l(_,o,(function(){return this})),l(_,"toString",(function(){return"[object Generator]"})),e.keys=function(e){var t=[];for(var r in e)t.push(r);return t.reverse(),function r(){for(;t.length;){var n=t.pop();if(n in e)return r.value=n,r.done=!1,r}return r.done=!0,r}},e.values=D,T.prototype={constructor:T,reset:function(e){if(this.prev=0,this.next=0,this.sent=this._sent=t,this.done=!1,this.delegate=null,this.method="next",this.arg=t,this.tryEntries.forEach(S),!e)for(var r in this)"t"===r.charAt(0)&&i.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=t)},stop:function(){this.done=!0;var e=this.tryEntries[0].completion;if("throw"===e.type)throw e.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var r=this;function n(n,i){return s.type="throw",s.arg=e,r.next=n,i&&(r.method="next",r.arg=t),!!i}for(var a=this.tryEntries.length-1;a>=0;--a){var o=this.tryEntries[a],s=o.completion;if("root"===o.tryLoc)return n("end");if(o.tryLoc<=this.prev){var f=i.call(o,"catchLoc"),l=i.call(o,"finallyLoc");if(f&&l){if(this.prev<o.catchLoc)return n(o.catchLoc,!0);if(this.prev<o.finallyLoc)return n(o.finallyLoc)}else if(f){if(this.prev<o.catchLoc)return n(o.catchLoc,!0)}else{if(!l)throw new Error("try statement without catch or finally");if(this.prev<o.finallyLoc)return n(o.finallyLoc)}}}},abrupt:function(e,t){for(var r=this.tryEntries.length-1;r>=0;--r){var n=this.tryEntries[r];if(n.tryLoc<=this.prev&&i.call(n,"finallyLoc")&&this.prev<n.finallyLoc){var a=n;break}}a&&("break"===e||"continue"===e)&&a.tryLoc<=t&&t<=a.finallyLoc&&(a=null);var o=a?a.completion:{};return o.type=e,o.arg=t,a?(this.method="next",this.next=a.finallyLoc,v):this.complete(o)},complete:function(e,t){if("throw"===e.type)throw e.arg;return"break"===e.type||"continue"===e.type?this.next=e.arg:"return"===e.type?(this.rval=this.arg=e.arg,this.method="return",this.next="end"):"normal"===e.type&&t&&(this.next=t),v},finish:function(e){for(var t=this.tryEntries.length-1;t>=0;--t){var r=this.tryEntries[t];if(r.finallyLoc===e)return this.complete(r.completion,r.afterLoc),S(r),v}},catch:function(e){for(var t=this.tryEntries.length-1;t>=0;--t){var r=this.tryEntries[t];if(r.tryLoc===e){var n=r.completion;if("throw"===n.type){var i=n.arg;S(r)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(e,r,n){return this.delegate={iterator:D(e),resultName:r,nextLoc:n},"next"===this.method&&(this.arg=t),v}},e}(e.exports);try{regeneratorRuntime=t}catch(e){"object"===("undefined"==typeof globalThis?"undefined":r(globalThis))?globalThis.regeneratorRuntime=t:Function("r","regeneratorRuntime = r")(t)}}(n);var i=n.exports,a=new Map;function o(e,t){Array.isArray(e)||(e=[e]),e.forEach((function(e){return a.set(e,t)}))}function s(e){return f.apply(this,arguments)}function f(){return(f=t(i.mark((function e(t){var r,n;return i.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(r=a.get(t.Compression)){e.next=3;break}throw new Error("Unknown compression method identifier: ".concat(t.Compression));case 3:return e.next=5,r();case 5:return n=e.sent,e.abrupt("return",new n(t));case 7:case"end":return e.stop()}}),e)})))).apply(this,arguments)}o([void 0,1],(function(){return Promise.resolve().then((function(){return _})).then((function(e){return e.default}))})),o(5,(function(){return Promise.resolve().then((function(){return S})).then((function(e){return e.default}))})),o(6,(function(){throw new Error("old style JPEG compression is not supported.")})),o(7,(function(){return Promise.resolve().then((function(){return L})).then((function(e){return e.default}))})),o([8,32946],(function(){return Promise.resolve().then((function(){return Ne})).then((function(e){return e.default}))})),o(32773,(function(){return Promise.resolve().then((function(){return Ye})).then((function(e){return e.default}))})),o(34887,(function(){return Promise.resolve().then((function(){return ut})).then((function(e){return e.default}))})),o(50001,(function(){return Promise.resolve().then((function(){return dt})).then((function(e){return e.default}))}));var l=globalThis;function u(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function c(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}function h(e,t,r){return t&&c(e.prototype,t),r&&c(e,r),e}function d(e,t){return d=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e},d(e,t)}function p(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&d(e,t)}function m(e,t){if(t&&("object"===r(t)||"function"==typeof t))return t;if(void 0!==t)throw new TypeError("Derived constructors may only return object or undefined");return function(e){if(void 0===e)throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");return e}(e)}function v(e){return v=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)},v(e)}function y(e,t){var r=e.length-t,n=0;do{for(var i=t;i>0;i--)e[n+t]+=e[n],n++;r-=t}while(r>0)}function w(e,t,r){for(var n=0,i=e.length,a=i/r;i>t;){for(var o=t;o>0;--o)e[n+t]+=e[n],++n;i-=t}for(var s=e.slice(),f=0;f<a;++f)for(var l=0;l<r;++l)e[r*f+l]=s[(r-l-1)*a+f]}function g(e,t,r,n,i,a){if(!t||1===t)return e;for(var o=0;o<i.length;++o){if(i[o]%8!=0)throw new Error("When decoding with predictor, only multiple of 8 bits are supported.");if(i[o]!==i[0])throw new Error("When decoding with predictor, all samples must have the same size.")}for(var s=i[0]/8,f=2===a?1:i.length,l=0;l<n&&!(l*f*r*s>=e.byteLength);++l){var u=void 0;if(2===t){switch(i[0]){case 8:u=new Uint8Array(e,l*f*r*s,f*r*s);break;case 16:u=new Uint16Array(e,l*f*r*s,f*r*s/2);break;case 32:u=new Uint32Array(e,l*f*r*s,f*r*s/4);break;default:throw new Error("Predictor 2 not allowed with ".concat(i[0]," bits per sample."))}y(u,f)}else 3===t&&w(u=new Uint8Array(e,l*f*r*s,f*r*s),f,s)}return e}l.addEventListener("message",function(){var e=t(i.mark((function e(t){var r,n,a,o,f,u;return i.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return r=t.data,n=r.id,a=r.fileDirectory,o=r.buffer,e.next=3,s(a);case 3:return f=e.sent,e.next=6,f.decode(a,o);case 6:u=e.sent,l.postMessage({decoded:u,id:n},[u]);case 8:case"end":return e.stop()}}),e)})));return function(t){return e.apply(this,arguments)}}());var b=function(){function e(){u(this,e)}var r;return h(e,[{key:"decode",value:(r=t(i.mark((function e(t,r){var n,a,o,s,f;return i.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.decodeBlock(r);case 2:if(n=e.sent,1===(a=t.Predictor||1)){e.next=9;break}return o=!t.StripOffsets,s=o?t.TileWidth:t.ImageWidth,f=o?t.TileLength:t.RowsPerStrip||t.ImageLength,e.abrupt("return",g(n,a,s,f,t.BitsPerSample,t.PlanarConfiguration));case 9:return e.abrupt("return",n);case 10:case"end":return e.stop()}}),e,this)}))),function(e,t){return r.apply(this,arguments)})}]),e}();function k(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}();return function(){var r,n=v(e);if(t){var i=v(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return m(this,r)}}var x=function(e){p(r,b);var t=k(r);function r(){return u(this,r),t.apply(this,arguments)}return h(r,[{key:"decodeBlock",value:function(e){return e}}]),r}(),_=Object.freeze({__proto__:null,default:x});function A(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}();return function(){var r,n=v(e);if(t){var i=v(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return m(this,r)}}function P(e,t){for(var r=t.length-1;r>=0;r--)e.push(t[r]);return e}function I(e){for(var t=new Uint16Array(4093),r=new Uint8Array(4093),n=0;n<=257;n++)t[n]=4096,r[n]=n;var i=258,a=9,o=0;function s(){i=258,a=9}function f(e){var t=function(e,t,r){var n=t%8,i=Math.floor(t/8),a=8-n,o=t+r-8*(i+1),s=8*(i+2)-(t+r),f=8*(i+2)-t;if(s=Math.max(0,s),i>=e.length)return console.warn("ran off the end of the buffer before finding EOI_CODE (end on input code)"),257;var l=e[i]&Math.pow(2,8-n)-1,u=l<<=r-a;if(i+1<e.length){var c=e[i+1]>>>s;u+=c<<=Math.max(0,r-f)}if(o>8&&i+2<e.length){var h=8*(i+3)-(t+r);u+=e[i+2]>>>h}return u}(e,o,a);return o+=a,t}function l(e,n){return r[i]=n,t[i]=e,++i-1}function u(e){for(var n=[],i=e;4096!==i;i=t[i])n.push(r[i]);return n}var c=[];s();for(var h,d=new Uint8Array(e),p=f(d);257!==p;){if(256===p){for(s(),p=f(d);256===p;)p=f(d);if(257===p)break;if(p>256)throw new Error("corrupted code at scanline ".concat(p));P(c,u(p)),h=p}else if(p<i){var m=u(p);P(c,m),l(h,m[m.length-1]),h=p}else{var v=u(h);if(!v)throw new Error("Bogus entry. Not in dictionary, ".concat(h," / ").concat(i,", position: ").concat(o));P(c,v),c.push(v[v.length-1]),l(h,v[v.length-1]),h=p}i+1>=Math.pow(2,a)&&(12===a?h=void 0:a++),p=f(d)}return new Uint8Array(c)}var U=function(e){p(r,b);var t=A(r);function r(){return u(this,r),t.apply(this,arguments)}return h(r,[{key:"decodeBlock",value:function(e){return I(e).buffer}}]),r}(),S=Object.freeze({__proto__:null,default:U});function T(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}();return function(){var r,n=v(e);if(t){var i=v(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return m(this,r)}}var D=new Int32Array([0,1,8,16,9,2,3,10,17,24,32,25,18,11,4,5,12,19,26,33,40,48,41,34,27,20,13,6,7,14,21,28,35,42,49,56,57,50,43,36,29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,47,55,62,63]);function E(e,t){for(var r=0,n=[],i=16;i>0&&!e[i-1];)--i;n.push({children:[],index:0});for(var a,o=n[0],s=0;s<i;s++){for(var f=0;f<e[s];f++){for((o=n.pop()).children[o.index]=t[r];o.index>0;)o=n.pop();for(o.index++,n.push(o);n.length<=s;)n.push(a={children:[],index:0}),o.children[o.index]=a.children,o=a;r++}s+1<i&&(n.push(a={children:[],index:0}),o.children[o.index]=a.children,o=a)}return n[0].children}function B(e,t,n,i,a,o,s,f,l){var u=n.mcusPerLine,c=n.progressive,h=t,d=t,p=0,m=0;function v(){if(m>0)return m--,p>>m&1;if(255===(p=e[d++])){var t=e[d++];if(t)throw new Error("unexpected marker: ".concat((p<<8|t).toString(16)))}return m=7,p>>>7}function y(e){for(var t,n=e;null!==(t=v());){if("number"==typeof(n=n[t]))return n;if("object"!==r(n))throw new Error("invalid huffman sequence")}return null}function w(e){for(var t=e,r=0;t>0;){var n=v();if(null===n)return;r=r<<1|n,--t}return r}function g(e){var t=w(e);return t>=1<<e-1?t:t+(-1<<e)+1}var b=0;var k,x=0;function _(e,t,r,n,i){var a=r%u,o=(r/u|0)*e.v+n,s=a*e.h+i;t(e,e.blocks[o][s])}function A(e,t,r){var n=r/e.blocksPerLine|0,i=r%e.blocksPerLine;t(e,e.blocks[n][i])}var P,I,U,S,T,E,B=i.length;E=c?0===o?0===f?function(e,t){var r=y(e.huffmanTableDC),n=0===r?0:g(r)<<l;e.pred+=n,t[0]=e.pred}:function(e,t){t[0]|=v()<<l}:0===f?function(e,t){if(b>0)b--;else for(var r=o,n=s;r<=n;){var i=y(e.huffmanTableAC),a=15&i,f=i>>4;if(0===a){if(f<15){b=w(f)+(1<<f)-1;break}r+=16}else t[D[r+=f]]=g(a)*(1<<l),r++}}:function(e,t){for(var r=o,n=s,i=0;r<=n;){var a=D[r],f=t[a]<0?-1:1;switch(x){case 0:var u=y(e.huffmanTableAC),c=15&u;if(i=u>>4,0===c)i<15?(b=w(i)+(1<<i),x=4):(i=16,x=1);else{if(1!==c)throw new Error("invalid ACn encoding");k=g(c),x=i?2:3}continue;case 1:case 2:t[a]?t[a]+=(v()<<l)*f:0==--i&&(x=2===x?3:0);break;case 3:t[a]?t[a]+=(v()<<l)*f:(t[a]=k<<l,x=0);break;case 4:t[a]&&(t[a]+=(v()<<l)*f)}r++}4===x&&0==--b&&(x=0)}:function(e,t){var r=y(e.huffmanTableDC),n=0===r?0:g(r);e.pred+=n,t[0]=e.pred;for(var i=1;i<64;){var a=y(e.huffmanTableAC),o=15&a,s=a>>4;if(0===o){if(s<15)break;i+=16}else t[D[i+=s]]=g(o),i++}};var O,M,C=0;M=1===B?i[0].blocksPerLine*i[0].blocksPerColumn:u*n.mcusPerColumn;for(var L=a||M;C<M;){for(I=0;I<B;I++)i[I].pred=0;if(b=0,1===B)for(P=i[0],T=0;T<L;T++)A(P,E,C),C++;else for(T=0;T<L;T++){for(I=0;I<B;I++){var R=P=i[I],V=R.h,G=R.v;for(U=0;U<G;U++)for(S=0;S<V;S++)_(P,E,C,U,S)}if(++C===M)break}if(m=0,(O=e[d]<<8|e[d+1])<65280)throw new Error("marker was not found");if(!(O>=65488&&O<=65495))break;d+=2}return d-h}function O(e,t){var r=[],n=t.blocksPerLine,i=t.blocksPerColumn,a=n<<3,o=new Int32Array(64),s=new Uint8Array(64);function f(e,r,n){var i,a,o,s,f,l,u,c,h,d,p=t.quantizationTable,m=n;for(d=0;d<64;d++)m[d]=e[d]*p[d];for(d=0;d<8;++d){var v=8*d;0!==m[1+v]||0!==m[2+v]||0!==m[3+v]||0!==m[4+v]||0!==m[5+v]||0!==m[6+v]||0!==m[7+v]?(i=5793*m[0+v]+128>>8,a=5793*m[4+v]+128>>8,o=m[2+v],s=m[6+v],f=2896*(m[1+v]-m[7+v])+128>>8,c=2896*(m[1+v]+m[7+v])+128>>8,l=m[3+v]<<4,h=i-a+1>>1,i=i+a+1>>1,a=h,h=3784*o+1567*s+128>>8,o=1567*o-3784*s+128>>8,s=h,h=f-(u=m[5+v]<<4)+1>>1,f=f+u+1>>1,u=h,h=c+l+1>>1,l=c-l+1>>1,c=h,h=i-s+1>>1,i=i+s+1>>1,s=h,h=a-o+1>>1,a=a+o+1>>1,o=h,h=2276*f+3406*c+2048>>12,f=3406*f-2276*c+2048>>12,c=h,h=799*l+4017*u+2048>>12,l=4017*l-799*u+2048>>12,u=h,m[0+v]=i+c,m[7+v]=i-c,m[1+v]=a+u,m[6+v]=a-u,m[2+v]=o+l,m[5+v]=o-l,m[3+v]=s+f,m[4+v]=s-f):(h=5793*m[0+v]+512>>10,m[0+v]=h,m[1+v]=h,m[2+v]=h,m[3+v]=h,m[4+v]=h,m[5+v]=h,m[6+v]=h,m[7+v]=h)}for(d=0;d<8;++d){var y=d;0!==m[8+y]||0!==m[16+y]||0!==m[24+y]||0!==m[32+y]||0!==m[40+y]||0!==m[48+y]||0!==m[56+y]?(i=5793*m[0+y]+2048>>12,a=5793*m[32+y]+2048>>12,o=m[16+y],s=m[48+y],f=2896*(m[8+y]-m[56+y])+2048>>12,c=2896*(m[8+y]+m[56+y])+2048>>12,l=m[24+y],h=i-a+1>>1,i=i+a+1>>1,a=h,h=3784*o+1567*s+2048>>12,o=1567*o-3784*s+2048>>12,s=h,h=f-(u=m[40+y])+1>>1,f=f+u+1>>1,u=h,h=c+l+1>>1,l=c-l+1>>1,c=h,h=i-s+1>>1,i=i+s+1>>1,s=h,h=a-o+1>>1,a=a+o+1>>1,o=h,h=2276*f+3406*c+2048>>12,f=3406*f-2276*c+2048>>12,c=h,h=799*l+4017*u+2048>>12,l=4017*l-799*u+2048>>12,u=h,m[0+y]=i+c,m[56+y]=i-c,m[8+y]=a+u,m[48+y]=a-u,m[16+y]=o+l,m[40+y]=o-l,m[24+y]=s+f,m[32+y]=s-f):(h=5793*n[d+0]+8192>>14,m[0+y]=h,m[8+y]=h,m[16+y]=h,m[24+y]=h,m[32+y]=h,m[40+y]=h,m[48+y]=h,m[56+y]=h)}for(d=0;d<64;++d){var w=128+(m[d]+8>>4);r[d]=w<0?0:w>255?255:w}}for(var l=0;l<i;l++){for(var u=l<<3,c=0;c<8;c++)r.push(new Uint8Array(a));for(var h=0;h<n;h++){f(t.blocks[l][h],s,o);for(var d=0,p=h<<3,m=0;m<8;m++)for(var v=r[u+m],y=0;y<8;y++)v[p+y]=s[d++]}}return r}var M=function(){function e(){u(this,e),this.jfif=null,this.adobe=null,this.quantizationTables=[],this.huffmanTablesAC=[],this.huffmanTablesDC=[],this.resetFrames()}return h(e,[{key:"resetFrames",value:function(){this.frames=[]}},{key:"parse",value:function(e){var t=0;function r(){var r=e[t]<<8|e[t+1];return t+=2,r}function n(e){var t,r,n=0,i=0;for(r in e.components)e.components.hasOwnProperty(r)&&(n<(t=e.components[r]).h&&(n=t.h),i<t.v&&(i=t.v));var a=Math.ceil(e.samplesPerLine/8/n),o=Math.ceil(e.scanLines/8/i);for(r in e.components)if(e.components.hasOwnProperty(r)){t=e.components[r];for(var s=Math.ceil(Math.ceil(e.samplesPerLine/8)*t.h/n),f=Math.ceil(Math.ceil(e.scanLines/8)*t.v/i),l=a*t.h,u=o*t.v,c=[],h=0;h<u;h++){for(var d=[],p=0;p<l;p++)d.push(new Int32Array(64));c.push(d)}t.blocksPerLine=s,t.blocksPerColumn=f,t.blocks=c}e.maxH=n,e.maxV=i,e.mcusPerLine=a,e.mcusPerColumn=o}var i,a,o=r();if(65496!==o)throw new Error("SOI not found");for(o=r();65497!==o;){switch(o){case 65280:break;case 65504:case 65505:case 65506:case 65507:case 65508:case 65509:case 65510:case 65511:case 65512:case 65513:case 65514:case 65515:case 65516:case 65517:case 65518:case 65519:case 65534:var s=(i=void 0,a=void 0,i=r(),a=e.subarray(t,t+i-2),t+=a.length,a);65504===o&&74===s[0]&&70===s[1]&&73===s[2]&&70===s[3]&&0===s[4]&&(this.jfif={version:{major:s[5],minor:s[6]},densityUnits:s[7],xDensity:s[8]<<8|s[9],yDensity:s[10]<<8|s[11],thumbWidth:s[12],thumbHeight:s[13],thumbData:s.subarray(14,14+3*s[12]*s[13])}),65518===o&&65===s[0]&&100===s[1]&&111===s[2]&&98===s[3]&&101===s[4]&&0===s[5]&&(this.adobe={version:s[6],flags0:s[7]<<8|s[8],flags1:s[9]<<8|s[10],transformCode:s[11]});break;case 65499:for(var f=r()+t-2;t<f;){var l=e[t++],u=new Int32Array(64);if(l>>4==0)for(var c=0;c<64;c++){u[D[c]]=e[t++]}else{if(l>>4!=1)throw new Error("DQT: invalid table spec");for(var h=0;h<64;h++){u[D[h]]=r()}}this.quantizationTables[15&l]=u}break;case 65472:case 65473:case 65474:r();for(var d={extended:65473===o,progressive:65474===o,precision:e[t++],scanLines:r(),samplesPerLine:r(),components:{},componentsOrder:[]},p=e[t++],m=void 0,v=0;v<p;v++){m=e[t];var y=e[t+1]>>4,w=15&e[t+1],g=e[t+2];d.componentsOrder.push(m),d.components[m]={h:y,v:w,quantizationIdx:g},t+=3}n(d),this.frames.push(d);break;case 65476:for(var b=r(),k=2;k<b;){for(var x=e[t++],_=new Uint8Array(16),A=0,P=0;P<16;P++,t++)_[P]=e[t],A+=_[P];for(var I=new Uint8Array(A),U=0;U<A;U++,t++)I[U]=e[t];k+=17+A,x>>4==0?this.huffmanTablesDC[15&x]=E(_,I):this.huffmanTablesAC[15&x]=E(_,I)}break;case 65501:r(),this.resetInterval=r();break;case 65498:r();for(var S=e[t++],T=[],O=this.frames[0],M=0;M<S;M++){var C=O.components[e[t++]],L=e[t++];C.huffmanTableDC=this.huffmanTablesDC[L>>4],C.huffmanTableAC=this.huffmanTablesAC[15&L],T.push(C)}var R=e[t++],V=e[t++],G=e[t++],F=B(e,t,O,T,this.resetInterval,R,V,G>>4,15&G);t+=F;break;case 65535:255!==e[t]&&t--;break;default:if(255===e[t-3]&&e[t-2]>=192&&e[t-2]<=254){t-=3;break}throw new Error("unknown JPEG marker ".concat(o.toString(16)))}o=r()}}},{key:"getResult",value:function(){var e=this.frames;if(0===this.frames.length)throw new Error("no frames were decoded");this.frames.length>1&&console.warn("more than one frame is not supported");for(var t=0;t<this.frames.length;t++)for(var r=this.frames[t].components,n=0,i=Object.keys(r);n<i.length;n++){var a=i[n];r[a].quantizationTable=this.quantizationTables[r[a].quantizationIdx],delete r[a].quantizationIdx}for(var o=e[0],s=o.components,f=o.componentsOrder,l=[],u=o.samplesPerLine,c=o.scanLines,h=0;h<f.length;h++){var d=s[f[h]];l.push({lines:O(0,d),scaleX:d.h/o.maxH,scaleY:d.v/o.maxV})}for(var p=new Uint8Array(u*c*l.length),m=0,v=0;v<c;++v)for(var y=0;y<u;++y)for(var w=0;w<l.length;++w){var g=l[w];p[m]=g.lines[0|v*g.scaleY][0|y*g.scaleX],++m}return p}}]),e}(),C=function(e){p(r,b);var t=T(r);function r(e){var n;return u(this,r),(n=t.call(this)).reader=new M,e.JPEGTables&&n.reader.parse(e.JPEGTables),n}return h(r,[{key:"decodeBlock",value:function(e){return this.reader.resetFrames(),this.reader.parse(new Uint8Array(e)),this.reader.getResult().buffer}}]),r}(),L=Object.freeze({__proto__:null,default:C});function R(e){for(var t=e.length;--t>=0;)e[t]=0}R(new Array(576)),R(new Array(60)),R(new Array(512)),R(new Array(256)),R(new Array(29)),R(new Array(30));var V=function(e,t,r,n){for(var i=65535&e|0,a=e>>>16&65535|0,o=0;0!==r;){r-=o=r>2e3?2e3:r;do{a=a+(i=i+t[n++]|0)|0}while(--o);i%=65521,a%=65521}return i|a<<16|0},G=new Uint32Array(function(){for(var e,t=[],r=0;r<256;r++){e=r;for(var n=0;n<8;n++)e=1&e?3988292384^e>>>1:e>>>1;t[r]=e}return t}()),F=function(e,t,r,n){var i=G,a=n+r;e^=-1;for(var o=n;o<a;o++)e=e>>>8^i[255&(e^t[o])];return-1^e},z={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},j={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8},N=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},Z=function(e){for(var t=Array.prototype.slice.call(arguments,1);t.length;){var n=t.shift();if(n){if("object"!==r(n))throw new TypeError(n+"must be non-object");for(var i in n)N(n,i)&&(e[i]=n[i])}}return e},K=function(e){for(var t=0,r=0,n=e.length;r<n;r++)t+=e[r].length;for(var i=new Uint8Array(t),a=0,o=0,s=e.length;a<s;a++){var f=e[a];i.set(f,o),o+=f.length}return i},H=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(e){H=!1}for(var Y=new Uint8Array(256),X=0;X<256;X++)Y[X]=X>=252?6:X>=248?5:X>=240?4:X>=224?3:X>=192?2:1;Y[254]=Y[254]=1;var W=function(e){if("function"==typeof TextEncoder&&TextEncoder.prototype.encode)return(new TextEncoder).encode(e);var t,r,n,i,a,o=e.length,s=0;for(i=0;i<o;i++)55296==(64512&(r=e.charCodeAt(i)))&&i+1<o&&56320==(64512&(n=e.charCodeAt(i+1)))&&(r=65536+(r-55296<<10)+(n-56320),i++),s+=r<128?1:r<2048?2:r<65536?3:4;for(t=new Uint8Array(s),a=0,i=0;a<s;i++)55296==(64512&(r=e.charCodeAt(i)))&&i+1<o&&56320==(64512&(n=e.charCodeAt(i+1)))&&(r=65536+(r-55296<<10)+(n-56320),i++),r<128?t[a++]=r:r<2048?(t[a++]=192|r>>>6,t[a++]=128|63&r):r<65536?(t[a++]=224|r>>>12,t[a++]=128|r>>>6&63,t[a++]=128|63&r):(t[a++]=240|r>>>18,t[a++]=128|r>>>12&63,t[a++]=128|r>>>6&63,t[a++]=128|63&r);return t},q=function(e,t){var r,n,i=t||e.length;if("function"==typeof TextDecoder&&TextDecoder.prototype.decode)return(new TextDecoder).decode(e.subarray(0,t));var a=new Array(2*i);for(n=0,r=0;r<i;){var o=e[r++];if(o<128)a[n++]=o;else{var s=Y[o];if(s>4)a[n++]=65533,r+=s-1;else{for(o&=2===s?31:3===s?15:7;s>1&&r<i;)o=o<<6|63&e[r++],s--;s>1?a[n++]=65533:o<65536?a[n++]=o:(o-=65536,a[n++]=55296|o>>10&1023,a[n++]=56320|1023&o)}}}return function(e,t){if(t<65534&&e.subarray&&H)return String.fromCharCode.apply(null,e.length===t?e:e.subarray(0,t));for(var r="",n=0;n<t;n++)r+=String.fromCharCode(e[n]);return r}(a,n)},J=function(e,t){(t=t||e.length)>e.length&&(t=e.length);for(var r=t-1;r>=0&&128==(192&e[r]);)r--;return r<0||0===r?t:r+Y[e[r]]>t?r:t};var Q=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0},$=function(e,t){var r,n,i,a,o,s,f,l,u,c,h,d,p,m,v,y,w,g,b,k,x,_,A,P,I=e.state;r=e.next_in,A=e.input,n=r+(e.avail_in-5),i=e.next_out,P=e.output,a=i-(t-e.avail_out),o=i+(e.avail_out-257),s=I.dmax,f=I.wsize,l=I.whave,u=I.wnext,c=I.window,h=I.hold,d=I.bits,p=I.lencode,m=I.distcode,v=(1<<I.lenbits)-1,y=(1<<I.distbits)-1;e:do{d<15&&(h+=A[r++]<<d,d+=8,h+=A[r++]<<d,d+=8),w=p[h&v];t:for(;;){if(h>>>=g=w>>>24,d-=g,0===(g=w>>>16&255))P[i++]=65535&w;else{if(!(16&g)){if(0==(64&g)){w=p[(65535&w)+(h&(1<<g)-1)];continue t}if(32&g){I.mode=12;break e}e.msg="invalid literal/length code",I.mode=30;break e}b=65535&w,(g&=15)&&(d<g&&(h+=A[r++]<<d,d+=8),b+=h&(1<<g)-1,h>>>=g,d-=g),d<15&&(h+=A[r++]<<d,d+=8,h+=A[r++]<<d,d+=8),w=m[h&y];r:for(;;){if(h>>>=g=w>>>24,d-=g,!(16&(g=w>>>16&255))){if(0==(64&g)){w=m[(65535&w)+(h&(1<<g)-1)];continue r}e.msg="invalid distance code",I.mode=30;break e}if(k=65535&w,d<(g&=15)&&(h+=A[r++]<<d,(d+=8)<g&&(h+=A[r++]<<d,d+=8)),(k+=h&(1<<g)-1)>s){e.msg="invalid distance too far back",I.mode=30;break e}if(h>>>=g,d-=g,k>(g=i-a)){if((g=k-g)>l&&I.sane){e.msg="invalid distance too far back",I.mode=30;break e}if(x=0,_=c,0===u){if(x+=f-g,g<b){b-=g;do{P[i++]=c[x++]}while(--g);x=i-k,_=P}}else if(u<g){if(x+=f+u-g,(g-=u)<b){b-=g;do{P[i++]=c[x++]}while(--g);if(x=0,u<b){b-=g=u;do{P[i++]=c[x++]}while(--g);x=i-k,_=P}}}else if(x+=u-g,g<b){b-=g;do{P[i++]=c[x++]}while(--g);x=i-k,_=P}for(;b>2;)P[i++]=_[x++],P[i++]=_[x++],P[i++]=_[x++],b-=3;b&&(P[i++]=_[x++],b>1&&(P[i++]=_[x++]))}else{x=i-k;do{P[i++]=P[x++],P[i++]=P[x++],P[i++]=P[x++],b-=3}while(b>2);b&&(P[i++]=P[x++],b>1&&(P[i++]=P[x++]))}break}}break}}while(r<n&&i<o);r-=b=d>>3,h&=(1<<(d-=b<<3))-1,e.next_in=r,e.next_out=i,e.avail_in=r<n?n-r+5:5-(r-n),e.avail_out=i<o?o-i+257:257-(i-o),I.hold=h,I.bits=d},ee=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),te=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),re=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),ne=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),ie=function(e,t,r,n,i,a,o,s){var f,l,u,c,h,d,p,m,v,y=s.bits,w=0,g=0,b=0,k=0,x=0,_=0,A=0,P=0,I=0,U=0,S=null,T=0,D=new Uint16Array(16),E=new Uint16Array(16),B=null,O=0;for(w=0;w<=15;w++)D[w]=0;for(g=0;g<n;g++)D[t[r+g]]++;for(x=y,k=15;k>=1&&0===D[k];k--);if(x>k&&(x=k),0===k)return i[a++]=20971520,i[a++]=20971520,s.bits=1,0;for(b=1;b<k&&0===D[b];b++);for(x<b&&(x=b),P=1,w=1;w<=15;w++)if(P<<=1,(P-=D[w])<0)return-1;if(P>0&&(0===e||1!==k))return-1;for(E[1]=0,w=1;w<15;w++)E[w+1]=E[w]+D[w];for(g=0;g<n;g++)0!==t[r+g]&&(o[E[t[r+g]]++]=g);if(0===e?(S=B=o,d=19):1===e?(S=ee,T-=257,B=te,O-=257,d=256):(S=re,B=ne,d=-1),U=0,g=0,w=b,h=a,_=x,A=0,u=-1,c=(I=1<<x)-1,1===e&&I>852||2===e&&I>592)return 1;for(;;){p=w-A,o[g]<d?(m=0,v=o[g]):o[g]>d?(m=B[O+o[g]],v=S[T+o[g]]):(m=96,v=0),f=1<<w-A,b=l=1<<_;do{i[h+(U>>A)+(l-=f)]=p<<24|m<<16|v|0}while(0!==l);for(f=1<<w-1;U&f;)f>>=1;if(0!==f?(U&=f-1,U+=f):U=0,g++,0==--D[w]){if(w===k)break;w=t[r+o[g]]}if(w>x&&(U&c)!==u){for(0===A&&(A=x),h+=b,P=1<<(_=w-A);_+A<k&&!((P-=D[_+A])<=0);)_++,P<<=1;if(I+=1<<_,1===e&&I>852||2===e&&I>592)return 1;i[u=U&c]=x<<24|_<<16|h-a|0}}return 0!==U&&(i[h+U]=w-A<<24|64<<16|0),s.bits=x,0},ae=j.Z_FINISH,oe=j.Z_BLOCK,se=j.Z_TREES,fe=j.Z_OK,le=j.Z_STREAM_END,ue=j.Z_NEED_DICT,ce=j.Z_STREAM_ERROR,he=j.Z_DATA_ERROR,de=j.Z_MEM_ERROR,pe=j.Z_BUF_ERROR,me=j.Z_DEFLATED,ve=function(e){return(e>>>24&255)+(e>>>8&65280)+((65280&e)<<8)+((255&e)<<24)};function ye(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}var we,ge,be=function(e){if(!e||!e.state)return ce;var t=e.state;return e.total_in=e.total_out=t.total=0,e.msg="",t.wrap&&(e.adler=1&t.wrap),t.mode=1,t.last=0,t.havedict=0,t.dmax=32768,t.head=null,t.hold=0,t.bits=0,t.lencode=t.lendyn=new Int32Array(852),t.distcode=t.distdyn=new Int32Array(592),t.sane=1,t.back=-1,fe},ke=function(e){if(!e||!e.state)return ce;var t=e.state;return t.wsize=0,t.whave=0,t.wnext=0,be(e)},xe=function(e,t){var r;if(!e||!e.state)return ce;var n=e.state;return t<0?(r=0,t=-t):(r=1+(t>>4),t<48&&(t&=15)),t&&(t<8||t>15)?ce:(null!==n.window&&n.wbits!==t&&(n.window=null),n.wrap=r,n.wbits=t,ke(e))},_e=function(e,t){if(!e)return ce;var r=new ye;e.state=r,r.window=null;var n=xe(e,t);return n!==fe&&(e.state=null),n},Ae=!0,Pe=function(e){if(Ae){we=new Int32Array(512),ge=new Int32Array(32);for(var t=0;t<144;)e.lens[t++]=8;for(;t<256;)e.lens[t++]=9;for(;t<280;)e.lens[t++]=7;for(;t<288;)e.lens[t++]=8;for(ie(1,e.lens,0,288,we,0,e.work,{bits:9}),t=0;t<32;)e.lens[t++]=5;ie(2,e.lens,0,32,ge,0,e.work,{bits:5}),Ae=!1}e.lencode=we,e.lenbits=9,e.distcode=ge,e.distbits=5},Ie=function(e,t,r,n){var i,a=e.state;return null===a.window&&(a.wsize=1<<a.wbits,a.wnext=0,a.whave=0,a.window=new Uint8Array(a.wsize)),n>=a.wsize?(a.window.set(t.subarray(r-a.wsize,r),0),a.wnext=0,a.whave=a.wsize):((i=a.wsize-a.wnext)>n&&(i=n),a.window.set(t.subarray(r-n,r-n+i),a.wnext),(n-=i)?(a.window.set(t.subarray(r-n,r),0),a.wnext=n,a.whave=a.wsize):(a.wnext+=i,a.wnext===a.wsize&&(a.wnext=0),a.whave<a.wsize&&(a.whave+=i))),0},Ue={inflateReset:ke,inflateReset2:xe,inflateResetKeep:be,inflateInit:function(e){return _e(e,15)},inflateInit2:_e,inflate:function(e,t){var r,n,i,a,o,s,f,l,u,c,h,d,p,m,v,y,w,g,b,k,x,_,A,P,I=0,U=new Uint8Array(4),S=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(!e||!e.state||!e.output||!e.input&&0!==e.avail_in)return ce;12===(r=e.state).mode&&(r.mode=13),o=e.next_out,i=e.output,f=e.avail_out,a=e.next_in,n=e.input,s=e.avail_in,l=r.hold,u=r.bits,c=s,h=f,_=fe;e:for(;;)switch(r.mode){case 1:if(0===r.wrap){r.mode=13;break}for(;u<16;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}if(2&r.wrap&&35615===l){r.check=0,U[0]=255&l,U[1]=l>>>8&255,r.check=F(r.check,U,2,0),l=0,u=0,r.mode=2;break}if(r.flags=0,r.head&&(r.head.done=!1),!(1&r.wrap)||(((255&l)<<8)+(l>>8))%31){e.msg="incorrect header check",r.mode=30;break}if((15&l)!==me){e.msg="unknown compression method",r.mode=30;break}if(u-=4,x=8+(15&(l>>>=4)),0===r.wbits)r.wbits=x;else if(x>r.wbits){e.msg="invalid window size",r.mode=30;break}r.dmax=1<<r.wbits,e.adler=r.check=1,r.mode=512&l?10:12,l=0,u=0;break;case 2:for(;u<16;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}if(r.flags=l,(255&r.flags)!==me){e.msg="unknown compression method",r.mode=30;break}if(57344&r.flags){e.msg="unknown header flags set",r.mode=30;break}r.head&&(r.head.text=l>>8&1),512&r.flags&&(U[0]=255&l,U[1]=l>>>8&255,r.check=F(r.check,U,2,0)),l=0,u=0,r.mode=3;case 3:for(;u<32;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}r.head&&(r.head.time=l),512&r.flags&&(U[0]=255&l,U[1]=l>>>8&255,U[2]=l>>>16&255,U[3]=l>>>24&255,r.check=F(r.check,U,4,0)),l=0,u=0,r.mode=4;case 4:for(;u<16;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}r.head&&(r.head.xflags=255&l,r.head.os=l>>8),512&r.flags&&(U[0]=255&l,U[1]=l>>>8&255,r.check=F(r.check,U,2,0)),l=0,u=0,r.mode=5;case 5:if(1024&r.flags){for(;u<16;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}r.length=l,r.head&&(r.head.extra_len=l),512&r.flags&&(U[0]=255&l,U[1]=l>>>8&255,r.check=F(r.check,U,2,0)),l=0,u=0}else r.head&&(r.head.extra=null);r.mode=6;case 6:if(1024&r.flags&&((d=r.length)>s&&(d=s),d&&(r.head&&(x=r.head.extra_len-r.length,r.head.extra||(r.head.extra=new Uint8Array(r.head.extra_len)),r.head.extra.set(n.subarray(a,a+d),x)),512&r.flags&&(r.check=F(r.check,n,d,a)),s-=d,a+=d,r.length-=d),r.length))break e;r.length=0,r.mode=7;case 7:if(2048&r.flags){if(0===s)break e;d=0;do{x=n[a+d++],r.head&&x&&r.length<65536&&(r.head.name+=String.fromCharCode(x))}while(x&&d<s);if(512&r.flags&&(r.check=F(r.check,n,d,a)),s-=d,a+=d,x)break e}else r.head&&(r.head.name=null);r.length=0,r.mode=8;case 8:if(4096&r.flags){if(0===s)break e;d=0;do{x=n[a+d++],r.head&&x&&r.length<65536&&(r.head.comment+=String.fromCharCode(x))}while(x&&d<s);if(512&r.flags&&(r.check=F(r.check,n,d,a)),s-=d,a+=d,x)break e}else r.head&&(r.head.comment=null);r.mode=9;case 9:if(512&r.flags){for(;u<16;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}if(l!==(65535&r.check)){e.msg="header crc mismatch",r.mode=30;break}l=0,u=0}r.head&&(r.head.hcrc=r.flags>>9&1,r.head.done=!0),e.adler=r.check=0,r.mode=12;break;case 10:for(;u<32;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}e.adler=r.check=ve(l),l=0,u=0,r.mode=11;case 11:if(0===r.havedict)return e.next_out=o,e.avail_out=f,e.next_in=a,e.avail_in=s,r.hold=l,r.bits=u,ue;e.adler=r.check=1,r.mode=12;case 12:if(t===oe||t===se)break e;case 13:if(r.last){l>>>=7&u,u-=7&u,r.mode=27;break}for(;u<3;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}switch(r.last=1&l,u-=1,3&(l>>>=1)){case 0:r.mode=14;break;case 1:if(Pe(r),r.mode=20,t===se){l>>>=2,u-=2;break e}break;case 2:r.mode=17;break;case 3:e.msg="invalid block type",r.mode=30}l>>>=2,u-=2;break;case 14:for(l>>>=7&u,u-=7&u;u<32;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}if((65535&l)!=(l>>>16^65535)){e.msg="invalid stored block lengths",r.mode=30;break}if(r.length=65535&l,l=0,u=0,r.mode=15,t===se)break e;case 15:r.mode=16;case 16:if(d=r.length){if(d>s&&(d=s),d>f&&(d=f),0===d)break e;i.set(n.subarray(a,a+d),o),s-=d,a+=d,f-=d,o+=d,r.length-=d;break}r.mode=12;break;case 17:for(;u<14;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}if(r.nlen=257+(31&l),l>>>=5,u-=5,r.ndist=1+(31&l),l>>>=5,u-=5,r.ncode=4+(15&l),l>>>=4,u-=4,r.nlen>286||r.ndist>30){e.msg="too many length or distance symbols",r.mode=30;break}r.have=0,r.mode=18;case 18:for(;r.have<r.ncode;){for(;u<3;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}r.lens[S[r.have++]]=7&l,l>>>=3,u-=3}for(;r.have<19;)r.lens[S[r.have++]]=0;if(r.lencode=r.lendyn,r.lenbits=7,A={bits:r.lenbits},_=ie(0,r.lens,0,19,r.lencode,0,r.work,A),r.lenbits=A.bits,_){e.msg="invalid code lengths set",r.mode=30;break}r.have=0,r.mode=19;case 19:for(;r.have<r.nlen+r.ndist;){for(;y=(I=r.lencode[l&(1<<r.lenbits)-1])>>>16&255,w=65535&I,!((v=I>>>24)<=u);){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}if(w<16)l>>>=v,u-=v,r.lens[r.have++]=w;else{if(16===w){for(P=v+2;u<P;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}if(l>>>=v,u-=v,0===r.have){e.msg="invalid bit length repeat",r.mode=30;break}x=r.lens[r.have-1],d=3+(3&l),l>>>=2,u-=2}else if(17===w){for(P=v+3;u<P;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}u-=v,x=0,d=3+(7&(l>>>=v)),l>>>=3,u-=3}else{for(P=v+7;u<P;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}u-=v,x=0,d=11+(127&(l>>>=v)),l>>>=7,u-=7}if(r.have+d>r.nlen+r.ndist){e.msg="invalid bit length repeat",r.mode=30;break}for(;d--;)r.lens[r.have++]=x}}if(30===r.mode)break;if(0===r.lens[256]){e.msg="invalid code -- missing end-of-block",r.mode=30;break}if(r.lenbits=9,A={bits:r.lenbits},_=ie(1,r.lens,0,r.nlen,r.lencode,0,r.work,A),r.lenbits=A.bits,_){e.msg="invalid literal/lengths set",r.mode=30;break}if(r.distbits=6,r.distcode=r.distdyn,A={bits:r.distbits},_=ie(2,r.lens,r.nlen,r.ndist,r.distcode,0,r.work,A),r.distbits=A.bits,_){e.msg="invalid distances set",r.mode=30;break}if(r.mode=20,t===se)break e;case 20:r.mode=21;case 21:if(s>=6&&f>=258){e.next_out=o,e.avail_out=f,e.next_in=a,e.avail_in=s,r.hold=l,r.bits=u,$(e,h),o=e.next_out,i=e.output,f=e.avail_out,a=e.next_in,n=e.input,s=e.avail_in,l=r.hold,u=r.bits,12===r.mode&&(r.back=-1);break}for(r.back=0;y=(I=r.lencode[l&(1<<r.lenbits)-1])>>>16&255,w=65535&I,!((v=I>>>24)<=u);){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}if(y&&0==(240&y)){for(g=v,b=y,k=w;y=(I=r.lencode[k+((l&(1<<g+b)-1)>>g)])>>>16&255,w=65535&I,!(g+(v=I>>>24)<=u);){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}l>>>=g,u-=g,r.back+=g}if(l>>>=v,u-=v,r.back+=v,r.length=w,0===y){r.mode=26;break}if(32&y){r.back=-1,r.mode=12;break}if(64&y){e.msg="invalid literal/length code",r.mode=30;break}r.extra=15&y,r.mode=22;case 22:if(r.extra){for(P=r.extra;u<P;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}r.length+=l&(1<<r.extra)-1,l>>>=r.extra,u-=r.extra,r.back+=r.extra}r.was=r.length,r.mode=23;case 23:for(;y=(I=r.distcode[l&(1<<r.distbits)-1])>>>16&255,w=65535&I,!((v=I>>>24)<=u);){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}if(0==(240&y)){for(g=v,b=y,k=w;y=(I=r.distcode[k+((l&(1<<g+b)-1)>>g)])>>>16&255,w=65535&I,!(g+(v=I>>>24)<=u);){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}l>>>=g,u-=g,r.back+=g}if(l>>>=v,u-=v,r.back+=v,64&y){e.msg="invalid distance code",r.mode=30;break}r.offset=w,r.extra=15&y,r.mode=24;case 24:if(r.extra){for(P=r.extra;u<P;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}r.offset+=l&(1<<r.extra)-1,l>>>=r.extra,u-=r.extra,r.back+=r.extra}if(r.offset>r.dmax){e.msg="invalid distance too far back",r.mode=30;break}r.mode=25;case 25:if(0===f)break e;if(d=h-f,r.offset>d){if((d=r.offset-d)>r.whave&&r.sane){e.msg="invalid distance too far back",r.mode=30;break}d>r.wnext?(d-=r.wnext,p=r.wsize-d):p=r.wnext-d,d>r.length&&(d=r.length),m=r.window}else m=i,p=o-r.offset,d=r.length;d>f&&(d=f),f-=d,r.length-=d;do{i[o++]=m[p++]}while(--d);0===r.length&&(r.mode=21);break;case 26:if(0===f)break e;i[o++]=r.length,f--,r.mode=21;break;case 27:if(r.wrap){for(;u<32;){if(0===s)break e;s--,l|=n[a++]<<u,u+=8}if(h-=f,e.total_out+=h,r.total+=h,h&&(e.adler=r.check=r.flags?F(r.check,i,h,o-h):V(r.check,i,h,o-h)),h=f,(r.flags?l:ve(l))!==r.check){e.msg="incorrect data check",r.mode=30;break}l=0,u=0}r.mode=28;case 28:if(r.wrap&&r.flags){for(;u<32;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}if(l!==(4294967295&r.total)){e.msg="incorrect length check",r.mode=30;break}l=0,u=0}r.mode=29;case 29:_=le;break e;case 30:_=he;break e;case 31:return de;default:return ce}return e.next_out=o,e.avail_out=f,e.next_in=a,e.avail_in=s,r.hold=l,r.bits=u,(r.wsize||h!==e.avail_out&&r.mode<30&&(r.mode<27||t!==ae))&&Ie(e,e.output,e.next_out,h-e.avail_out),c-=e.avail_in,h-=e.avail_out,e.total_in+=c,e.total_out+=h,r.total+=h,r.wrap&&h&&(e.adler=r.check=r.flags?F(r.check,i,h,e.next_out-h):V(r.check,i,h,e.next_out-h)),e.data_type=r.bits+(r.last?64:0)+(12===r.mode?128:0)+(20===r.mode||15===r.mode?256:0),(0===c&&0===h||t===ae)&&_===fe&&(_=pe),_},inflateEnd:function(e){if(!e||!e.state)return ce;var t=e.state;return t.window&&(t.window=null),e.state=null,fe},inflateGetHeader:function(e,t){if(!e||!e.state)return ce;var r=e.state;return 0==(2&r.wrap)?ce:(r.head=t,t.done=!1,fe)},inflateSetDictionary:function(e,t){var r,n=t.length;return e&&e.state?0!==(r=e.state).wrap&&11!==r.mode?ce:11===r.mode&&V(1,t,n,0)!==r.check?he:Ie(e,t,n,n)?(r.mode=31,de):(r.havedict=1,fe):ce},inflateInfo:"pako inflate (from Nodeca project)"};var Se=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1},Te=Object.prototype.toString,De=j.Z_NO_FLUSH,Ee=j.Z_FINISH,Be=j.Z_OK,Oe=j.Z_STREAM_END,Me=j.Z_NEED_DICT,Ce=j.Z_STREAM_ERROR,Le=j.Z_DATA_ERROR,Re=j.Z_MEM_ERROR;function Ve(e){this.options=Z({chunkSize:65536,windowBits:15,to:""},e||{});var t=this.options;t.raw&&t.windowBits>=0&&t.windowBits<16&&(t.windowBits=-t.windowBits,0===t.windowBits&&(t.windowBits=-15)),!(t.windowBits>=0&&t.windowBits<16)||e&&e.windowBits||(t.windowBits+=32),t.windowBits>15&&t.windowBits<48&&0==(15&t.windowBits)&&(t.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new Q,this.strm.avail_out=0;var r=Ue.inflateInit2(this.strm,t.windowBits);if(r!==Be)throw new Error(z[r]);if(this.header=new Se,Ue.inflateGetHeader(this.strm,this.header),t.dictionary&&("string"==typeof t.dictionary?t.dictionary=W(t.dictionary):"[object ArrayBuffer]"===Te.call(t.dictionary)&&(t.dictionary=new Uint8Array(t.dictionary)),t.raw&&(r=Ue.inflateSetDictionary(this.strm,t.dictionary))!==Be))throw new Error(z[r])}function Ge(e,t){var r=new Ve(t);if(r.push(e),r.err)throw r.msg||z[r.err];return r.result}Ve.prototype.push=function(e,t){var r,n,i,a=this.strm,o=this.options.chunkSize,s=this.options.dictionary;if(this.ended)return!1;for(n=t===~~t?t:!0===t?Ee:De,"[object ArrayBuffer]"===Te.call(e)?a.input=new Uint8Array(e):a.input=e,a.next_in=0,a.avail_in=a.input.length;;){for(0===a.avail_out&&(a.output=new Uint8Array(o),a.next_out=0,a.avail_out=o),(r=Ue.inflate(a,n))===Me&&s&&((r=Ue.inflateSetDictionary(a,s))===Be?r=Ue.inflate(a,n):r===Le&&(r=Me));a.avail_in>0&&r===Oe&&a.state.wrap>0&&0!==e[a.next_in];)Ue.inflateReset(a),r=Ue.inflate(a,n);switch(r){case Ce:case Le:case Me:case Re:return this.onEnd(r),this.ended=!0,!1}if(i=a.avail_out,a.next_out&&(0===a.avail_out||r===Oe))if("string"===this.options.to){var f=J(a.output,a.next_out),l=a.next_out-f,u=q(a.output,f);a.next_out=l,a.avail_out=o-l,l&&a.output.set(a.output.subarray(f,f+l),0),this.onData(u)}else this.onData(a.output.length===a.next_out?a.output:a.output.subarray(0,a.next_out));if(r!==Be||0!==i){if(r===Oe)return r=Ue.inflateEnd(this.strm),this.onEnd(r),this.ended=!0,!0;if(0===a.avail_in)break}}return!0},Ve.prototype.onData=function(e){this.chunks.push(e)},Ve.prototype.onEnd=function(e){e===Be&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=K(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg};var Fe={Inflate:Ve,inflate:Ge,inflateRaw:function(e,t){return(t=t||{}).raw=!0,Ge(e,t)},ungzip:Ge,constants:j}.inflate;function ze(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}();return function(){var r,n=v(e);if(t){var i=v(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return m(this,r)}}var je=function(e){p(r,b);var t=ze(r);function r(){return u(this,r),t.apply(this,arguments)}return h(r,[{key:"decodeBlock",value:function(e){return Fe(new Uint8Array(e)).buffer}}]),r}(),Ne=Object.freeze({__proto__:null,default:je});function Ze(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}();return function(){var r,n=v(e);if(t){var i=v(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return m(this,r)}}var Ke,He=function(e){p(r,b);var t=Ze(r);function r(){return u(this,r),t.apply(this,arguments)}return h(r,[{key:"decodeBlock",value:function(e){for(var t=new DataView(e),r=[],n=0;n<e.byteLength;++n){var i=t.getInt8(n);if(i<0){var a=t.getUint8(n+1);i=-i;for(var o=0;o<=i;++o)r.push(a);n+=1}else{for(var s=0;s<=i;++s)r.push(t.getUint8(n+s+1));n+=i+1}}return new Uint8Array(r).buffer}}]),r}(),Ye=Object.freeze({__proto__:null,default:He}),Xe={exports:{}};Ke=Xe,\n/* Copyright 2015-2021 Esri. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 @preserve */\nfunction(){var e,t,r,n,i,a,o,s,f,l,u,c,h,d,p,m,v=(e={defaultNoDataValue:-34027999387901484e22,decode:function(a,o){var s=(o=o||{}).encodedMaskData||null===o.encodedMaskData,f=i(a,o.inputOffset||0,s),l=null!==o.noDataValue?o.noDataValue:e.defaultNoDataValue,u=t(f,o.pixelType||Float32Array,o.encodedMaskData,l,o.returnMask),c={width:f.width,height:f.height,pixelData:u.resultPixels,minValue:u.minValue,maxValue:f.pixels.maxValue,noDataValue:l};return u.resultMask&&(c.maskData=u.resultMask),o.returnEncodedMask&&f.mask&&(c.encodedMaskData=f.mask.bitset?f.mask.bitset:null),o.returnFileInfo&&(c.fileInfo=r(f),o.computeUsedBitDepths&&(c.fileInfo.bitDepths=n(f))),c}},t=function(e,t,r,n,i){var o,s,f,l=0,u=e.pixels.numBlocksX,c=e.pixels.numBlocksY,h=Math.floor(e.width/u),d=Math.floor(e.height/c),p=2*e.maxZError,m=Number.MAX_VALUE;r=r||(e.mask?e.mask.bitset:null),s=new t(e.width*e.height),i&&r&&(f=new Uint8Array(e.width*e.height));for(var v,y,w=new Float32Array(h*d),g=0;g<=c;g++){var b=g!==c?d:e.height%c;if(0!==b)for(var k=0;k<=u;k++){var x=k!==u?h:e.width%u;if(0!==x){var _,A,P,I,U=g*e.width*d+k*h,S=e.width-x,T=e.pixels.blocks[l];if(T.encoding<2?(0===T.encoding?_=T.rawData:(a(T.stuffedData,T.bitsPerPixel,T.numValidPixels,T.offset,p,w,e.pixels.maxValue),_=w),A=0):P=2===T.encoding?0:T.offset,r)for(y=0;y<b;y++){for(7&U&&(I=r[U>>3],I<<=7&U),v=0;v<x;v++)7&U||(I=r[U>>3]),128&I?(f&&(f[U]=1),m=m>(o=T.encoding<2?_[A++]:P)?o:m,s[U++]=o):(f&&(f[U]=0),s[U++]=n),I<<=1;U+=S}else if(T.encoding<2)for(y=0;y<b;y++){for(v=0;v<x;v++)m=m>(o=_[A++])?o:m,s[U++]=o;U+=S}else for(m=m>P?P:m,y=0;y<b;y++){for(v=0;v<x;v++)s[U++]=P;U+=S}if(1===T.encoding&&A!==T.numValidPixels)throw"Block and Mask do not match";l++}}}return{resultPixels:s,resultMask:f,minValue:m}},r=function(e){return{fileIdentifierString:e.fileIdentifierString,fileVersion:e.fileVersion,imageType:e.imageType,height:e.height,width:e.width,maxZError:e.maxZError,eofOffset:e.eofOffset,mask:e.mask?{numBlocksX:e.mask.numBlocksX,numBlocksY:e.mask.numBlocksY,numBytes:e.mask.numBytes,maxValue:e.mask.maxValue}:null,pixels:{numBlocksX:e.pixels.numBlocksX,numBlocksY:e.pixels.numBlocksY,numBytes:e.pixels.numBytes,maxValue:e.pixels.maxValue,noDataValue:e.noDataValue}}},n=function(e){for(var t=e.pixels.numBlocksX*e.pixels.numBlocksY,r={},n=0;n<t;n++){var i=e.pixels.blocks[n];0===i.encoding?r.float32=!0:1===i.encoding?r[i.bitsPerPixel]=!0:r[0]=!0}return Object.keys(r)},i=function(e,t,r){var n={},i=new Uint8Array(e,t,10);if(n.fileIdentifierString=String.fromCharCode.apply(null,i),"CntZImage"!==n.fileIdentifierString.trim())throw"Unexpected file identifier string: "+n.fileIdentifierString;t+=10;var a=new DataView(e,t,24);if(n.fileVersion=a.getInt32(0,!0),n.imageType=a.getInt32(4,!0),n.height=a.getUint32(8,!0),n.width=a.getUint32(12,!0),n.maxZError=a.getFloat64(16,!0),t+=24,!r)if(a=new DataView(e,t,16),n.mask={},n.mask.numBlocksY=a.getUint32(0,!0),n.mask.numBlocksX=a.getUint32(4,!0),n.mask.numBytes=a.getUint32(8,!0),n.mask.maxValue=a.getFloat32(12,!0),t+=16,n.mask.numBytes>0){var o=new Uint8Array(Math.ceil(n.width*n.height/8)),s=(a=new DataView(e,t,n.mask.numBytes)).getInt16(0,!0),f=2,l=0;do{if(s>0)for(;s--;)o[l++]=a.getUint8(f++);else{var u=a.getUint8(f++);for(s=-s;s--;)o[l++]=u}s=a.getInt16(f,!0),f+=2}while(f<n.mask.numBytes);if(-32768!==s||l<o.length)throw"Unexpected end of mask RLE encoding";n.mask.bitset=o,t+=n.mask.numBytes}else 0==(n.mask.numBytes|n.mask.numBlocksY|n.mask.maxValue)&&(n.mask.bitset=new Uint8Array(Math.ceil(n.width*n.height/8)));a=new DataView(e,t,16),n.pixels={},n.pixels.numBlocksY=a.getUint32(0,!0),n.pixels.numBlocksX=a.getUint32(4,!0),n.pixels.numBytes=a.getUint32(8,!0),n.pixels.maxValue=a.getFloat32(12,!0),t+=16;var c=n.pixels.numBlocksX,h=n.pixels.numBlocksY,d=c+(n.width%c>0?1:0),p=h+(n.height%h>0?1:0);n.pixels.blocks=new Array(d*p);for(var m=0,v=0;v<p;v++)for(var y=0;y<d;y++){var w=0,g=e.byteLength-t;a=new DataView(e,t,Math.min(10,g));var b={};n.pixels.blocks[m++]=b;var k=a.getUint8(0);if(w++,b.encoding=63&k,b.encoding>3)throw"Invalid block encoding ("+b.encoding+")";if(2!==b.encoding){if(0!==k&&2!==k){if(k>>=6,b.offsetType=k,2===k)b.offset=a.getInt8(1),w++;else if(1===k)b.offset=a.getInt16(1,!0),w+=2;else{if(0!==k)throw"Invalid block offset type";b.offset=a.getFloat32(1,!0),w+=4}if(1===b.encoding)if(k=a.getUint8(w),w++,b.bitsPerPixel=63&k,k>>=6,b.numValidPixelsType=k,2===k)b.numValidPixels=a.getUint8(w),w++;else if(1===k)b.numValidPixels=a.getUint16(w,!0),w+=2;else{if(0!==k)throw"Invalid valid pixel count type";b.numValidPixels=a.getUint32(w,!0),w+=4}}var x;if(t+=w,3!==b.encoding)if(0===b.encoding){var _=(n.pixels.numBytes-1)/4;if(_!==Math.floor(_))throw"uncompressed block has invalid length";x=new ArrayBuffer(4*_),new Uint8Array(x).set(new Uint8Array(e,t,4*_));var A=new Float32Array(x);b.rawData=A,t+=4*_}else if(1===b.encoding){var P=Math.ceil(b.numValidPixels*b.bitsPerPixel/8),I=Math.ceil(P/4);x=new ArrayBuffer(4*I),new Uint8Array(x).set(new Uint8Array(e,t,P)),b.stuffedData=new Uint32Array(x),t+=P}}else t++}return n.eofOffset=t,n},a=function(e,t,r,n,i,a,o){var s,f,l,u=(1<<t)-1,c=0,h=0,d=Math.ceil((o-n)/i),p=4*e.length-Math.ceil(t*r/8);for(e[e.length-1]<<=8*p,s=0;s<r;s++){if(0===h&&(l=e[c++],h=32),h>=t)f=l>>>h-t&u,h-=t;else{var m=t-h;f=(l&u)<<m&u,f+=(l=e[c++])>>>(h=32-m)}a[s]=f<d?n+f*i:o}return a},e),y=(o=function(e,t,r,n,i,a,o,s){var f,l,u,c,h,d=(1<<r)-1,p=0,m=0,v=4*e.length-Math.ceil(r*n/8);if(e[e.length-1]<<=8*v,i)for(f=0;f<n;f++)0===m&&(u=e[p++],m=32),m>=r?(l=u>>>m-r&d,m-=r):(l=(u&d)<<(c=r-m)&d,l+=(u=e[p++])>>>(m=32-c)),t[f]=i[l];else for(h=Math.ceil((s-a)/o),f=0;f<n;f++)0===m&&(u=e[p++],m=32),m>=r?(l=u>>>m-r&d,m-=r):(l=(u&d)<<(c=r-m)&d,l+=(u=e[p++])>>>(m=32-c)),t[f]=l<h?a+l*o:s},s=function(e,t,r,n,i,a){var o,s=(1<<t)-1,f=0,l=0,u=0,c=0,h=0,d=[],p=4*e.length-Math.ceil(t*r/8);e[e.length-1]<<=8*p;var m=Math.ceil((a-n)/i);for(l=0;l<r;l++)0===c&&(o=e[f++],c=32),c>=t?(h=o>>>c-t&s,c-=t):(h=(o&s)<<(u=t-c)&s,h+=(o=e[f++])>>>(c=32-u)),d[l]=h<m?n+h*i:a;return d.unshift(n),d},f=function(e,t,r,n,i,a,o,s){var f,l,u,c,h=(1<<r)-1,d=0,p=0,m=0;if(i)for(f=0;f<n;f++)0===p&&(u=e[d++],p=32,m=0),p>=r?(l=u>>>m&h,p-=r,m+=r):(l=u>>>m&h,p=32-(c=r-p),l|=((u=e[d++])&(1<<c)-1)<<r-c,m=c),t[f]=i[l];else{var v=Math.ceil((s-a)/o);for(f=0;f<n;f++)0===p&&(u=e[d++],p=32,m=0),p>=r?(l=u>>>m&h,p-=r,m+=r):(l=u>>>m&h,p=32-(c=r-p),l|=((u=e[d++])&(1<<c)-1)<<r-c,m=c),t[f]=l<v?a+l*o:s}return t},l=function(e,t,r,n,i,a){var o,s=(1<<t)-1,f=0,l=0,u=0,c=0,h=0,d=0,p=[],m=Math.ceil((a-n)/i);for(l=0;l<r;l++)0===c&&(o=e[f++],c=32,d=0),c>=t?(h=o>>>d&s,c-=t,d+=t):(h=o>>>d&s,c=32-(u=t-c),h|=((o=e[f++])&(1<<u)-1)<<t-u,d=u),p[l]=h<m?n+h*i:a;return p.unshift(n),p},u=function(e,t,r,n){var i,a,o,s,f=(1<<r)-1,l=0,u=0,c=4*e.length-Math.ceil(r*n/8);for(e[e.length-1]<<=8*c,i=0;i<n;i++)0===u&&(o=e[l++],u=32),u>=r?(a=o>>>u-r&f,u-=r):(a=(o&f)<<(s=r-u)&f,a+=(o=e[l++])>>>(u=32-s)),t[i]=a;return t},c=function(e,t,r,n){var i,a,o,s,f=(1<<r)-1,l=0,u=0,c=0;for(i=0;i<n;i++)0===u&&(o=e[l++],u=32,c=0),u>=r?(a=o>>>c&f,u-=r,c+=r):(a=o>>>c&f,u=32-(s=r-u),a|=((o=e[l++])&(1<<s)-1)<<r-s,c=s),t[i]=a;return t},h={HUFFMAN_LUT_BITS_MAX:12,computeChecksumFletcher32:function(e){for(var t=65535,r=65535,n=e.length,i=Math.floor(n/2),a=0;i;){var o=i>=359?359:i;i-=o;do{t+=e[a++]<<8,r+=t+=e[a++]}while(--o);t=(65535&t)+(t>>>16),r=(65535&r)+(r>>>16)}return 1&n&&(r+=t+=e[a]<<8),((r=(65535&r)+(r>>>16))<<16|(t=(65535&t)+(t>>>16)))>>>0},readHeaderInfo:function(e,t){var r=t.ptr,n=new Uint8Array(e,r,6),i={};if(i.fileIdentifierString=String.fromCharCode.apply(null,n),0!==i.fileIdentifierString.lastIndexOf("Lerc2",0))throw"Unexpected file identifier string (expect Lerc2 ): "+i.fileIdentifierString;r+=6;var a,o=new DataView(e,r,8),s=o.getInt32(0,!0);if(i.fileVersion=s,r+=4,s>=3&&(i.checksum=o.getUint32(4,!0),r+=4),o=new DataView(e,r,12),i.height=o.getUint32(0,!0),i.width=o.getUint32(4,!0),r+=8,s>=4?(i.numDims=o.getUint32(8,!0),r+=4):i.numDims=1,o=new DataView(e,r,40),i.numValidPixel=o.getUint32(0,!0),i.microBlockSize=o.getInt32(4,!0),i.blobSize=o.getInt32(8,!0),i.imageType=o.getInt32(12,!0),i.maxZError=o.getFloat64(16,!0),i.zMin=o.getFloat64(24,!0),i.zMax=o.getFloat64(32,!0),r+=40,t.headerInfo=i,t.ptr=r,s>=3&&(a=s>=4?52:48,this.computeChecksumFletcher32(new Uint8Array(e,r-a,i.blobSize-14))!==i.checksum))throw"Checksum failed.";return!0},checkMinMaxRanges:function(e,t){var r=t.headerInfo,n=this.getDataTypeArray(r.imageType),i=r.numDims*this.getDataTypeSize(r.imageType),a=this.readSubArray(e,t.ptr,n,i),o=this.readSubArray(e,t.ptr+i,n,i);t.ptr+=2*i;var s,f=!0;for(s=0;s<r.numDims;s++)if(a[s]!==o[s]){f=!1;break}return r.minValues=a,r.maxValues=o,f},readSubArray:function(e,t,r,n){var i;if(r===Uint8Array)i=new Uint8Array(e,t,n);else{var a=new ArrayBuffer(n);new Uint8Array(a).set(new Uint8Array(e,t,n)),i=new r(a)}return i},readMask:function(e,t){var r,n,i=t.ptr,a=t.headerInfo,o=a.width*a.height,s=a.numValidPixel,f=new DataView(e,i,4),l={};if(l.numBytes=f.getUint32(0,!0),i+=4,(0===s||o===s)&&0!==l.numBytes)throw"invalid mask";if(0===s)r=new Uint8Array(Math.ceil(o/8)),l.bitset=r,n=new Uint8Array(o),t.pixels.resultMask=n,i+=l.numBytes;else if(l.numBytes>0){r=new Uint8Array(Math.ceil(o/8));var u=(f=new DataView(e,i,l.numBytes)).getInt16(0,!0),c=2,h=0,d=0;do{if(u>0)for(;u--;)r[h++]=f.getUint8(c++);else for(d=f.getUint8(c++),u=-u;u--;)r[h++]=d;u=f.getInt16(c,!0),c+=2}while(c<l.numBytes);if(-32768!==u||h<r.length)throw"Unexpected end of mask RLE encoding";n=new Uint8Array(o);var p=0,m=0;for(m=0;m<o;m++)7&m?(p=r[m>>3],p<<=7&m):p=r[m>>3],128&p&&(n[m]=1);t.pixels.resultMask=n,l.bitset=r,i+=l.numBytes}return t.ptr=i,t.mask=l,!0},readDataOneSweep:function(e,t,r,n){var i,a=t.ptr,o=t.headerInfo,s=o.numDims,f=o.width*o.height,l=o.imageType,u=o.numValidPixel*h.getDataTypeSize(l)*s,c=t.pixels.resultMask;if(r===Uint8Array)i=new Uint8Array(e,a,u);else{var d=new ArrayBuffer(u);new Uint8Array(d).set(new Uint8Array(e,a,u)),i=new r(d)}if(i.length===f*s)t.pixels.resultPixels=n?h.swapDimensionOrder(i,f,s,r,!0):i;else{t.pixels.resultPixels=new r(f*s);var p=0,m=0,v=0,y=0;if(s>1){if(n){for(m=0;m<f;m++)if(c[m])for(y=m,v=0;v<s;v++,y+=f)t.pixels.resultPixels[y]=i[p++]}else for(m=0;m<f;m++)if(c[m])for(y=m*s,v=0;v<s;v++)t.pixels.resultPixels[y+v]=i[p++]}else for(m=0;m<f;m++)c[m]&&(t.pixels.resultPixels[m]=i[p++])}return a+=u,t.ptr=a,!0},readHuffmanTree:function(e,t){var r=this.HUFFMAN_LUT_BITS_MAX,n=new DataView(e,t.ptr,16);if(t.ptr+=16,n.getInt32(0,!0)<2)throw"unsupported Huffman version";var i=n.getInt32(4,!0),a=n.getInt32(8,!0),o=n.getInt32(12,!0);if(a>=o)return!1;var s=new Uint32Array(o-a);h.decodeBits(e,t,s);var f,l,u,c,p=[];for(f=a;f<o;f++)p[l=f-(f<i?0:i)]={first:s[f-a],second:null};var m=e.byteLength-t.ptr,v=Math.ceil(m/4),y=new ArrayBuffer(4*v);new Uint8Array(y).set(new Uint8Array(e,t.ptr,m));var w,g=new Uint32Array(y),b=0,k=0;for(w=g[0],f=a;f<o;f++)(c=p[l=f-(f<i?0:i)].first)>0&&(p[l].second=w<<b>>>32-c,32-b>=c?32===(b+=c)&&(b=0,w=g[++k]):(b+=c-32,w=g[++k],p[l].second|=w>>>32-b));var x=0,_=0,A=new d;for(f=0;f<p.length;f++)void 0!==p[f]&&(x=Math.max(x,p[f].first));_=x>=r?r:x;var P,I,U,S,T,D=[];for(f=a;f<o;f++)if((c=p[l=f-(f<i?0:i)].first)>0)if(P=[c,l],c<=_)for(I=p[l].second<<_-c,U=1<<_-c,u=0;u<U;u++)D[I|u]=P;else for(I=p[l].second,T=A,S=c-1;S>=0;S--)I>>>S&1?(T.right||(T.right=new d),T=T.right):(T.left||(T.left=new d),T=T.left),0!==S||T.val||(T.val=P[1]);return{decodeLut:D,numBitsLUTQick:_,numBitsLUT:x,tree:A,stuffedData:g,srcPtr:k,bitPos:b}},readHuffman:function(e,t,r,n){var i,a,o,s,f,l,u,c,d,p=t.headerInfo.numDims,m=t.headerInfo.height,v=t.headerInfo.width,y=v*m,w=this.readHuffmanTree(e,t),g=w.decodeLut,b=w.tree,k=w.stuffedData,x=w.srcPtr,_=w.bitPos,A=w.numBitsLUTQick,P=w.numBitsLUT,I=0===t.headerInfo.imageType?128:0,U=t.pixels.resultMask,S=0;_>0&&(x++,_=0);var T,D=k[x],E=1===t.encodeMode,B=new r(y*p),O=B;if(p<2||E){for(T=0;T<p;T++)if(p>1&&(O=new r(B.buffer,y*T,y),S=0),t.headerInfo.numValidPixel===v*m)for(c=0,l=0;l<m;l++)for(u=0;u<v;u++,c++){if(a=0,f=s=D<<_>>>32-A,32-_<A&&(f=s|=k[x+1]>>>64-_-A),g[f])a=g[f][1],_+=g[f][0];else for(f=s=D<<_>>>32-P,32-_<P&&(f=s|=k[x+1]>>>64-_-P),i=b,d=0;d<P;d++)if(!(i=s>>>P-d-1&1?i.right:i.left).left&&!i.right){a=i.val,_=_+d+1;break}_>=32&&(_-=32,D=k[++x]),o=a-I,E?(o+=u>0?S:l>0?O[c-v]:S,o&=255,O[c]=o,S=o):O[c]=o}else for(c=0,l=0;l<m;l++)for(u=0;u<v;u++,c++)if(U[c]){if(a=0,f=s=D<<_>>>32-A,32-_<A&&(f=s|=k[x+1]>>>64-_-A),g[f])a=g[f][1],_+=g[f][0];else for(f=s=D<<_>>>32-P,32-_<P&&(f=s|=k[x+1]>>>64-_-P),i=b,d=0;d<P;d++)if(!(i=s>>>P-d-1&1?i.right:i.left).left&&!i.right){a=i.val,_=_+d+1;break}_>=32&&(_-=32,D=k[++x]),o=a-I,E?(u>0&&U[c-1]?o+=S:l>0&&U[c-v]?o+=O[c-v]:o+=S,o&=255,O[c]=o,S=o):O[c]=o}}else for(c=0,l=0;l<m;l++)for(u=0;u<v;u++)if(c=l*v+u,!U||U[c])for(T=0;T<p;T++,c+=y){if(a=0,f=s=D<<_>>>32-A,32-_<A&&(f=s|=k[x+1]>>>64-_-A),g[f])a=g[f][1],_+=g[f][0];else for(f=s=D<<_>>>32-P,32-_<P&&(f=s|=k[x+1]>>>64-_-P),i=b,d=0;d<P;d++)if(!(i=s>>>P-d-1&1?i.right:i.left).left&&!i.right){a=i.val,_=_+d+1;break}_>=32&&(_-=32,D=k[++x]),o=a-I,O[c]=o}t.ptr=t.ptr+4*(x+1)+(_>0?4:0),t.pixels.resultPixels=B,p>1&&!n&&(t.pixels.resultPixels=h.swapDimensionOrder(B,y,p,r))},decodeBits:function(e,t,r,n,i){var a=t.headerInfo,h=a.fileVersion,d=0,p=e.byteLength-t.ptr>=5?5:e.byteLength-t.ptr,m=new DataView(e,t.ptr,p),v=m.getUint8(0);d++;var y=v>>6,w=0===y?4:3-y,g=(32&v)>0,b=31&v,k=0;if(1===w)k=m.getUint8(d),d++;else if(2===w)k=m.getUint16(d,!0),d+=2;else{if(4!==w)throw"Invalid valid pixel count type";k=m.getUint32(d,!0),d+=4}var x,_,A,P,I,U,S,T,D,E=2*a.maxZError,B=a.numDims>1?a.maxValues[i]:a.zMax;if(g){for(t.counter.lut++,T=m.getUint8(d),d++,P=Math.ceil((T-1)*b/8),I=Math.ceil(P/4),_=new ArrayBuffer(4*I),A=new Uint8Array(_),t.ptr+=d,A.set(new Uint8Array(e,t.ptr,P)),S=new Uint32Array(_),t.ptr+=P,D=0;T-1>>>D;)D++;P=Math.ceil(k*D/8),I=Math.ceil(P/4),_=new ArrayBuffer(4*I),(A=new Uint8Array(_)).set(new Uint8Array(e,t.ptr,P)),x=new Uint32Array(_),t.ptr+=P,U=h>=3?l(S,b,T-1,n,E,B):s(S,b,T-1,n,E,B),h>=3?f(x,r,D,k,U):o(x,r,D,k,U)}else t.counter.bitstuffer++,D=b,t.ptr+=d,D>0&&(P=Math.ceil(k*D/8),I=Math.ceil(P/4),_=new ArrayBuffer(4*I),(A=new Uint8Array(_)).set(new Uint8Array(e,t.ptr,P)),x=new Uint32Array(_),t.ptr+=P,h>=3?null==n?c(x,r,D,k):f(x,r,D,k,!1,n,E,B):null==n?u(x,r,D,k):o(x,r,D,k,!1,n,E,B))},readTiles:function(e,t,r,n){var i=t.headerInfo,a=i.width,o=i.height,s=a*o,f=i.microBlockSize,l=i.imageType,u=h.getDataTypeSize(l),c=Math.ceil(a/f),d=Math.ceil(o/f);t.pixels.numBlocksY=d,t.pixels.numBlocksX=c,t.pixels.ptr=0;var p,m,v,y,w,g,b,k,x,_,A=0,P=0,I=0,U=0,S=0,T=0,D=0,E=0,B=0,O=0,M=0,C=0,L=0,R=0,V=0,G=new r(f*f),F=o%f||f,z=a%f||f,j=i.numDims,N=t.pixels.resultMask,Z=t.pixels.resultPixels,K=i.fileVersion>=5?14:15,H=i.zMax;for(I=0;I<d;I++)for(S=I!==d-1?f:F,U=0;U<c;U++)for(O=I*a*f+U*f,M=a-(T=U!==c-1?f:z),k=0;k<j;k++){if(j>1?(_=Z,O=I*a*f+U*f,Z=new r(t.pixels.resultPixels.buffer,s*k*u,s),H=i.maxValues[k]):_=null,D=e.byteLength-t.ptr,m={},V=0,E=(p=new DataView(e,t.ptr,Math.min(10,D))).getUint8(0),V++,x=i.fileVersion>=5?4&E:0,B=E>>6&255,(E>>2&K)!=(U*f>>3&K))throw"integrity issue";if(x&&0===k)throw"integrity issue";if((w=3&E)>3)throw t.ptr+=V,"Invalid block encoding ("+w+")";if(2!==w)if(0===w){if(x)throw"integrity issue";if(t.counter.uncompressed++,t.ptr+=V,C=(C=S*T*u)<(L=e.byteLength-t.ptr)?C:L,v=new ArrayBuffer(C%u==0?C:C+u-C%u),new Uint8Array(v).set(new Uint8Array(e,t.ptr,C)),y=new r(v),R=0,N)for(A=0;A<S;A++){for(P=0;P<T;P++)N[O]&&(Z[O]=y[R++]),O++;O+=M}else for(A=0;A<S;A++){for(P=0;P<T;P++)Z[O++]=y[R++];O+=M}t.ptr+=R*u}else if(g=h.getDataTypeUsed(x&&l<6?4:l,B),b=h.getOnePixel(m,V,g,p),V+=h.getDataTypeSize(g),3===w)if(t.ptr+=V,t.counter.constantoffset++,N)for(A=0;A<S;A++){for(P=0;P<T;P++)N[O]&&(Z[O]=x?Math.min(H,_[O]+b):b),O++;O+=M}else for(A=0;A<S;A++){for(P=0;P<T;P++)Z[O]=x?Math.min(H,_[O]+b):b,O++;O+=M}else if(t.ptr+=V,h.decodeBits(e,t,G,b,k),V=0,x)if(N)for(A=0;A<S;A++){for(P=0;P<T;P++)N[O]&&(Z[O]=G[V++]+_[O]),O++;O+=M}else for(A=0;A<S;A++){for(P=0;P<T;P++)Z[O]=G[V++]+_[O],O++;O+=M}else if(N)for(A=0;A<S;A++){for(P=0;P<T;P++)N[O]&&(Z[O]=G[V++]),O++;O+=M}else for(A=0;A<S;A++){for(P=0;P<T;P++)Z[O++]=G[V++];O+=M}else{if(x)if(N)for(A=0;A<S;A++)for(P=0;P<T;P++)N[O]&&(Z[O]=_[O]),O++;else for(A=0;A<S;A++)for(P=0;P<T;P++)Z[O]=_[O],O++;t.counter.constant++,t.ptr+=V}}j>1&&!n&&(t.pixels.resultPixels=h.swapDimensionOrder(t.pixels.resultPixels,s,j,r))},formatFileInfo:function(e){return{fileIdentifierString:e.headerInfo.fileIdentifierString,fileVersion:e.headerInfo.fileVersion,imageType:e.headerInfo.imageType,height:e.headerInfo.height,width:e.headerInfo.width,numValidPixel:e.headerInfo.numValidPixel,microBlockSize:e.headerInfo.microBlockSize,blobSize:e.headerInfo.blobSize,maxZError:e.headerInfo.maxZError,pixelType:h.getPixelType(e.headerInfo.imageType),eofOffset:e.eofOffset,mask:e.mask?{numBytes:e.mask.numBytes}:null,pixels:{numBlocksX:e.pixels.numBlocksX,numBlocksY:e.pixels.numBlocksY,maxValue:e.headerInfo.zMax,minValue:e.headerInfo.zMin,noDataValue:e.noDataValue}}},constructConstantSurface:function(e,t){var r=e.headerInfo.zMax,n=e.headerInfo.zMin,i=e.headerInfo.maxValues,a=e.headerInfo.numDims,o=e.headerInfo.height*e.headerInfo.width,s=0,f=0,l=0,u=e.pixels.resultMask,c=e.pixels.resultPixels;if(u)if(a>1){if(t)for(s=0;s<a;s++)for(l=s*o,r=i[s],f=0;f<o;f++)u[f]&&(c[l+f]=r);else for(f=0;f<o;f++)if(u[f])for(l=f*a,s=0;s<a;s++)c[l+a]=i[s]}else for(f=0;f<o;f++)u[f]&&(c[f]=r);else if(a>1&&n!==r)if(t)for(s=0;s<a;s++)for(l=s*o,r=i[s],f=0;f<o;f++)c[l+f]=r;else for(f=0;f<o;f++)for(l=f*a,s=0;s<a;s++)c[l+s]=i[s];else for(f=0;f<o*a;f++)c[f]=r},getDataTypeArray:function(e){var t;switch(e){case 0:t=Int8Array;break;case 1:t=Uint8Array;break;case 2:t=Int16Array;break;case 3:t=Uint16Array;break;case 4:t=Int32Array;break;case 5:t=Uint32Array;break;case 6:default:t=Float32Array;break;case 7:t=Float64Array}return t},getPixelType:function(e){var t;switch(e){case 0:t="S8";break;case 1:t="U8";break;case 2:t="S16";break;case 3:t="U16";break;case 4:t="S32";break;case 5:t="U32";break;case 6:default:t="F32";break;case 7:t="F64"}return t},isValidPixelValue:function(e,t){if(null==t)return!1;var r;switch(e){case 0:r=t>=-128&&t<=127;break;case 1:r=t>=0&&t<=255;break;case 2:r=t>=-32768&&t<=32767;break;case 3:r=t>=0&&t<=65536;break;case 4:r=t>=-2147483648&&t<=2147483647;break;case 5:r=t>=0&&t<=4294967296;break;case 6:r=t>=-34027999387901484e22&&t<=34027999387901484e22;break;case 7:r=t>=-17976931348623157e292&&t<=17976931348623157e292;break;default:r=!1}return r},getDataTypeSize:function(e){var t=0;switch(e){case 0:case 1:t=1;break;case 2:case 3:t=2;break;case 4:case 5:case 6:t=4;break;case 7:t=8;break;default:t=e}return t},getDataTypeUsed:function(e,t){var r=e;switch(e){case 2:case 4:r=e-t;break;case 3:case 5:r=e-2*t;break;case 6:r=0===t?e:1===t?2:1;break;case 7:r=0===t?e:e-2*t+1;break;default:r=e}return r},getOnePixel:function(e,t,r,n){var i=0;switch(r){case 0:i=n.getInt8(t);break;case 1:i=n.getUint8(t);break;case 2:i=n.getInt16(t,!0);break;case 3:i=n.getUint16(t,!0);break;case 4:i=n.getInt32(t,!0);break;case 5:i=n.getUInt32(t,!0);break;case 6:i=n.getFloat32(t,!0);break;case 7:i=n.getFloat64(t,!0);break;default:throw"the decoder does not understand this pixel type"}return i},swapDimensionOrder:function(e,t,r,n,i){var a=0,o=0,s=0,f=0,l=e;if(r>1)if(l=new n(t*r),i)for(a=0;a<t;a++)for(f=a,s=0;s<r;s++,f+=t)l[f]=e[o++];else for(a=0;a<t;a++)for(f=a,s=0;s<r;s++,f+=t)l[o++]=e[f];return l}},d=function(e,t,r){this.val=e,this.left=t,this.right=r},{decode:function(e,t){var r=(t=t||{}).noDataValue,n=0,i={};i.ptr=t.inputOffset||0,i.pixels={},h.readHeaderInfo(e,i);var a=i.headerInfo,o=a.fileVersion,s=h.getDataTypeArray(a.imageType);if(o>5)throw"unsupported lerc version 2."+o;h.readMask(e,i),a.numValidPixel===a.width*a.height||i.pixels.resultMask||(i.pixels.resultMask=t.maskData);var f=a.width*a.height;i.pixels.resultPixels=new s(f*a.numDims),i.counter={onesweep:0,uncompressed:0,lut:0,bitstuffer:0,constant:0,constantoffset:0};var l,u=!t.returnPixelInterleavedDims;if(0!==a.numValidPixel)if(a.zMax===a.zMin)h.constructConstantSurface(i,u);else if(o>=4&&h.checkMinMaxRanges(e,i))h.constructConstantSurface(i,u);else{var c=new DataView(e,i.ptr,2),d=c.getUint8(0);if(i.ptr++,d)h.readDataOneSweep(e,i,s,u);else if(o>1&&a.imageType<=1&&Math.abs(a.maxZError-.5)<1e-5){var p=c.getUint8(1);if(i.ptr++,i.encodeMode=p,p>2||o<4&&p>1)throw"Invalid Huffman flag "+p;p?h.readHuffman(e,i,s,u):h.readTiles(e,i,s,u)}else h.readTiles(e,i,s,u)}i.eofOffset=i.ptr,t.inputOffset?(l=i.headerInfo.blobSize+t.inputOffset-i.ptr,Math.abs(l)>=1&&(i.eofOffset=t.inputOffset+i.headerInfo.blobSize)):(l=i.headerInfo.blobSize-i.ptr,Math.abs(l)>=1&&(i.eofOffset=i.headerInfo.blobSize));var m={width:a.width,height:a.height,pixelData:i.pixels.resultPixels,minValue:a.zMin,maxValue:a.zMax,validPixelCount:a.numValidPixel,dimCount:a.numDims,dimStats:{minValues:a.minValues,maxValues:a.maxValues},maskData:i.pixels.resultMask};if(i.pixels.resultMask&&h.isValidPixelValue(a.imageType,r)){var v=i.pixels.resultMask;for(n=0;n<f;n++)v[n]||(m.pixelData[n]=r);m.noDataValue=r}return i.noDataValue=r,t.returnFileInfo&&(m.fileInfo=h.formatFileInfo(i)),m},getBandCount:function(e){for(var t=0,r=0,n={ptr:0,pixels:{}};r<e.byteLength-58;)h.readHeaderInfo(e,n),r+=n.headerInfo.blobSize,t++,n.ptr=r;return t}}),w=(p=new ArrayBuffer(4),m=new Uint8Array(p),new Uint32Array(p)[0]=1,1===m[0]),g={decode:function(e,t){if(!w)throw"Big endian system is not supported.";var r,n,i=(t=t||{}).inputOffset||0,a=new Uint8Array(e,i,10),o=String.fromCharCode.apply(null,a);if("CntZImage"===o.trim())r=v,n=1;else{if("Lerc2"!==o.substring(0,5))throw"Unexpected file identifier string: "+o;r=y,n=2}for(var s,f,l,u,c,h,d=0,p=e.byteLength-10,m=[],g={width:0,height:0,pixels:[],pixelType:t.pixelType,mask:null,statistics:[]},b=0;i<p;){var k=r.decode(e,{inputOffset:i,encodedMaskData:s,maskData:l,returnMask:0===d,returnEncodedMask:0===d,returnFileInfo:!0,returnPixelInterleavedDims:t.returnPixelInterleavedDims,pixelType:t.pixelType||null,noDataValue:t.noDataValue||null});i=k.fileInfo.eofOffset,l=k.maskData,0===d&&(s=k.encodedMaskData,g.width=k.width,g.height=k.height,g.dimCount=k.dimCount||1,g.pixelType=k.pixelType||k.fileInfo.pixelType,g.mask=l),n>1&&(l&&m.push(l),k.fileInfo.mask&&k.fileInfo.mask.numBytes>0&&b++),d++,g.pixels.push(k.pixelData),g.statistics.push({minValue:k.minValue,maxValue:k.maxValue,noDataValue:k.noDataValue,dimStats:k.dimStats})}if(n>1&&b>1){for(h=g.width*g.height,g.bandMasks=m,(l=new Uint8Array(h)).set(m[0]),u=1;u<m.length;u++)for(f=m[u],c=0;c<h;c++)l[c]=l[c]&f[c];g.maskData=l}return g}};Ke.exports?Ke.exports=g:this.Lerc=g}();var We=Xe.exports,qe={315:"Artist",258:"BitsPerSample",265:"CellLength",264:"CellWidth",320:"ColorMap",259:"Compression",33432:"Copyright",306:"DateTime",338:"ExtraSamples",266:"FillOrder",289:"FreeByteCounts",288:"FreeOffsets",291:"GrayResponseCurve",290:"GrayResponseUnit",316:"HostComputer",270:"ImageDescription",257:"ImageLength",256:"ImageWidth",271:"Make",281:"MaxSampleValue",280:"MinSampleValue",272:"Model",254:"NewSubfileType",274:"Orientation",262:"PhotometricInterpretation",284:"PlanarConfiguration",296:"ResolutionUnit",278:"RowsPerStrip",277:"SamplesPerPixel",305:"Software",279:"StripByteCounts",273:"StripOffsets",255:"SubfileType",263:"Threshholding",282:"XResolution",283:"YResolution",326:"BadFaxLines",327:"CleanFaxData",343:"ClipPath",328:"ConsecutiveBadFaxLines",433:"Decode",434:"DefaultImageColor",269:"DocumentName",336:"DotRange",321:"HalftoneHints",346:"Indexed",347:"JPEGTables",285:"PageName",297:"PageNumber",317:"Predictor",319:"PrimaryChromaticities",532:"ReferenceBlackWhite",339:"SampleFormat",340:"SMinSampleValue",341:"SMaxSampleValue",559:"StripRowCounts",330:"SubIFDs",292:"T4Options",293:"T6Options",325:"TileByteCounts",323:"TileLength",324:"TileOffsets",322:"TileWidth",301:"TransferFunction",318:"WhitePoint",344:"XClipPathUnits",286:"XPosition",529:"YCbCrCoefficients",531:"YCbCrPositioning",530:"YCbCrSubSampling",345:"YClipPathUnits",287:"YPosition",37378:"ApertureValue",40961:"ColorSpace",36868:"DateTimeDigitized",36867:"DateTimeOriginal",34665:"Exif IFD",36864:"ExifVersion",33434:"ExposureTime",41728:"FileSource",37385:"Flash",40960:"FlashpixVersion",33437:"FNumber",42016:"ImageUniqueID",37384:"LightSource",37500:"MakerNote",37377:"ShutterSpeedValue",37510:"UserComment",33723:"IPTC",34675:"ICC Profile",700:"XMP",42112:"GDAL_METADATA",42113:"GDAL_NODATA",34377:"Photoshop",33550:"ModelPixelScale",33922:"ModelTiepoint",34264:"ModelTransformation",34735:"GeoKeyDirectory",34736:"GeoDoubleParams",34737:"GeoAsciiParams",50674:"LercParameters"},Je={};for(var Qe in qe)qe.hasOwnProperty(Qe)&&(Je[qe[Qe]]=parseInt(Qe,10));Je.BitsPerSample,Je.ExtraSamples,Je.SampleFormat,Je.StripByteCounts,Je.StripOffsets,Je.StripRowCounts,Je.TileByteCounts,Je.TileOffsets,Je.SubIFDs;var $e={1:"BYTE",2:"ASCII",3:"SHORT",4:"LONG",5:"RATIONAL",6:"SBYTE",7:"UNDEFINED",8:"SSHORT",9:"SLONG",10:"SRATIONAL",11:"FLOAT",12:"DOUBLE",13:"IFD",16:"LONG8",17:"SLONG8",18:"IFD8"},et={};for(var tt in $e)$e.hasOwnProperty(tt)&&(et[$e[tt]]=parseInt(tt,10));var rt=1,nt=0,it=1,at={1024:"GTModelTypeGeoKey",1025:"GTRasterTypeGeoKey",1026:"GTCitationGeoKey",2048:"GeographicTypeGeoKey",2049:"GeogCitationGeoKey",2050:"GeogGeodeticDatumGeoKey",2051:"GeogPrimeMeridianGeoKey",2052:"GeogLinearUnitsGeoKey",2053:"GeogLinearUnitSizeGeoKey",2054:"GeogAngularUnitsGeoKey",2055:"GeogAngularUnitSizeGeoKey",2056:"GeogEllipsoidGeoKey",2057:"GeogSemiMajorAxisGeoKey",2058:"GeogSemiMinorAxisGeoKey",2059:"GeogInvFlatteningGeoKey",2060:"GeogAzimuthUnitsGeoKey",2061:"GeogPrimeMeridianLongGeoKey",2062:"GeogTOWGS84GeoKey",3072:"ProjectedCSTypeGeoKey",3073:"PCSCitationGeoKey",3074:"ProjectionGeoKey",3075:"ProjCoordTransGeoKey",3076:"ProjLinearUnitsGeoKey",3077:"ProjLinearUnitSizeGeoKey",3078:"ProjStdParallel1GeoKey",3079:"ProjStdParallel2GeoKey",3080:"ProjNatOriginLongGeoKey",3081:"ProjNatOriginLatGeoKey",3082:"ProjFalseEastingGeoKey",3083:"ProjFalseNorthingGeoKey",3084:"ProjFalseOriginLongGeoKey",3085:"ProjFalseOriginLatGeoKey",3086:"ProjFalseOriginEastingGeoKey",3087:"ProjFalseOriginNorthingGeoKey",3088:"ProjCenterLongGeoKey",3089:"ProjCenterLatGeoKey",3090:"ProjCenterEastingGeoKey",3091:"ProjCenterNorthingGeoKey",3092:"ProjScaleAtNatOriginGeoKey",3093:"ProjScaleAtCenterGeoKey",3094:"ProjAzimuthAngleGeoKey",3095:"ProjStraightVertPoleLongGeoKey",3096:"ProjRectifiedGridAngleGeoKey",4096:"VerticalCSTypeGeoKey",4097:"VerticalCitationGeoKey",4098:"VerticalDatumGeoKey",4099:"VerticalUnitsGeoKey"},ot={};for(var st in at)at.hasOwnProperty(st)&&(ot[at[st]]=parseInt(st,10));function ft(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}();return function(){var r,n=v(e);if(t){var i=v(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return m(this,r)}}var lt=function(e){p(r,b);var t=ft(r);function r(e){var n;return u(this,r),(n=t.call(this)).planarConfiguration=void 0!==e.PlanarConfiguration?e.PlanarConfiguration:1,n.samplesPerPixel=void 0!==e.SamplesPerPixel?e.SamplesPerPixel:1,n.addCompression=e.LercParameters[rt],n}return h(r,[{key:"decodeBlock",value:function(e){switch(this.addCompression){case nt:break;case it:e=Fe(new Uint8Array(e)).buffer;break;default:throw new Error("Unsupported LERC additional compression method identifier: ".concat(this.addCompression))}return We.decode(e,{returnPixelInterleavedDims:1===this.planarConfiguration}).pixels[0].buffer}}]),r}(),ut=Object.freeze({__proto__:null,default:lt});function ct(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}();return function(){var r,n=v(e);if(t){var i=v(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return m(this,r)}}var ht=function(e){p(a,b);var r,n=ct(a);function a(){var e;if(u(this,a),e=n.call(this),"undefined"==typeof createImageBitmap)throw new Error("Cannot decode WebImage as `createImageBitmap` is not available");if("undefined"==typeof document&&"undefined"==typeof OffscreenCanvas)throw new Error("Cannot decode WebImage as neither `document` nor `OffscreenCanvas` is not available");return e}return h(a,[{key:"decode",value:(r=t(i.mark((function e(t,r){var n,a,o,s;return i.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return n=new Blob([r]),e.next=3,createImageBitmap(n);case 3:return a=e.sent,"undefined"!=typeof document?((o=document.createElement("canvas")).width=a.width,o.height=a.height):o=new OffscreenCanvas(a.width,a.height),(s=o.getContext("2d")).drawImage(a,0,0),e.abrupt("return",s.getImageData(0,0,a.width,a.height).data.buffer);case 8:case"end":return e.stop()}}),e)}))),function(e,t){return r.apply(this,arguments)})}]),a}(),dt=Object.freeze({__proto__:null,default:ht});';
  return new browser(typeof Blob === "undefined" ? "data:application/javascript;base64," + Buffer.from(source, "binary").toString("base64") : URL.createObjectURL(new Blob([source], { type: "application/javascript" })));
}
var decoder = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  create: create$4
}, Symbol.toStringTag, { value: "Module" }));
/*!
 * html2canvas 1.4.1 <https://html2canvas.hertzen.com>
 * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
 * Released under MIT License
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p5 in b3)
      if (Object.prototype.hasOwnProperty.call(b3, p5))
        d3[p5] = b3[p5];
  };
  return extendStatics(d2, b2);
};
function __extends(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t3) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p5 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p5))
          t3[p5] = s2[p5];
    }
    return t3;
  };
  return __assign.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject2) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject2(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject2(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t3[0] & 1)
      throw t3[1];
    return t3[1];
  }, trys: [], ops: [] }, f2, y2, t3, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f2 = 1, y2 && (t3 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t3 = y2["return"]) && t3.call(y2), 0) : y2.next) && !(t3 = t3.call(y2, op[1])).done)
          return t3;
        if (y2 = 0, t3)
          op = [op[0] & 2, t3.value];
        switch (op[0]) {
          case 0:
          case 1:
            t3 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t3[1]) {
              _2.label = t3[1];
              t3 = op;
              break;
            }
            if (t3 && _2.label < t3[2]) {
              _2.label = t3[2];
              _2.ops.push(op);
              break;
            }
            if (t3[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t3 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __spreadArray(to, from, pack2) {
  if (pack2 || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || from);
}
var Bounds = function() {
  function Bounds2(left, top, width, height) {
    this.left = left;
    this.top = top;
    this.width = width;
    this.height = height;
  }
  Bounds2.prototype.add = function(x2, y2, w2, h2) {
    return new Bounds2(this.left + x2, this.top + y2, this.width + w2, this.height + h2);
  };
  Bounds2.fromClientRect = function(context2, clientRect) {
    return new Bounds2(clientRect.left + context2.windowBounds.left, clientRect.top + context2.windowBounds.top, clientRect.width, clientRect.height);
  };
  Bounds2.fromDOMRectList = function(context2, domRectList) {
    var domRect = Array.from(domRectList).find(function(rect) {
      return rect.width !== 0;
    });
    return domRect ? new Bounds2(domRect.left + context2.windowBounds.left, domRect.top + context2.windowBounds.top, domRect.width, domRect.height) : Bounds2.EMPTY;
  };
  Bounds2.EMPTY = new Bounds2(0, 0, 0, 0);
  return Bounds2;
}();
var parseBounds = function(context2, node2) {
  return Bounds.fromClientRect(context2, node2.getBoundingClientRect());
};
var parseDocumentSize = function(document2) {
  var body = document2.body;
  var documentElement = document2.documentElement;
  if (!body || !documentElement) {
    throw new Error("Unable to get document size");
  }
  var width = Math.max(Math.max(body.scrollWidth, documentElement.scrollWidth), Math.max(body.offsetWidth, documentElement.offsetWidth), Math.max(body.clientWidth, documentElement.clientWidth));
  var height = Math.max(Math.max(body.scrollHeight, documentElement.scrollHeight), Math.max(body.offsetHeight, documentElement.offsetHeight), Math.max(body.clientHeight, documentElement.clientHeight));
  return new Bounds(0, 0, width, height);
};
var toCodePoints$1 = function(str) {
  var codePoints = [];
  var i2 = 0;
  var length = str.length;
  while (i2 < length) {
    var value = str.charCodeAt(i2++);
    if (value >= 55296 && value <= 56319 && i2 < length) {
      var extra = str.charCodeAt(i2++);
      if ((extra & 64512) === 56320) {
        codePoints.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        codePoints.push(value);
        i2--;
      }
    } else {
      codePoints.push(value);
    }
  }
  return codePoints;
};
var fromCodePoint$1 = function() {
  var codePoints = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    codePoints[_i] = arguments[_i];
  }
  if (String.fromCodePoint) {
    return String.fromCodePoint.apply(String, codePoints);
  }
  var length = codePoints.length;
  if (!length) {
    return "";
  }
  var codeUnits = [];
  var index2 = -1;
  var result = "";
  while (++index2 < length) {
    var codePoint = codePoints[index2];
    if (codePoint <= 65535) {
      codeUnits.push(codePoint);
    } else {
      codePoint -= 65536;
      codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);
    }
    if (index2 + 1 === length || codeUnits.length > 16384) {
      result += String.fromCharCode.apply(String, codeUnits);
      codeUnits.length = 0;
    }
  }
  return result;
};
var chars$2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup$2 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i$2 = 0; i$2 < chars$2.length; i$2++) {
  lookup$2[chars$2.charCodeAt(i$2)] = i$2;
}
var chars$1$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup$1$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i$1$1 = 0; i$1$1 < chars$1$1.length; i$1$1++) {
  lookup$1$1[chars$1$1.charCodeAt(i$1$1)] = i$1$1;
}
var decode$1 = function(base642) {
  var bufferLength = base642.length * 0.75, len = base642.length, i2, p5 = 0, encoded1, encoded2, encoded3, encoded4;
  if (base642[base642.length - 1] === "=") {
    bufferLength--;
    if (base642[base642.length - 2] === "=") {
      bufferLength--;
    }
  }
  var buffer2 = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint8Array.prototype.slice !== "undefined" ? new ArrayBuffer(bufferLength) : new Array(bufferLength);
  var bytes = Array.isArray(buffer2) ? buffer2 : new Uint8Array(buffer2);
  for (i2 = 0; i2 < len; i2 += 4) {
    encoded1 = lookup$1$1[base642.charCodeAt(i2)];
    encoded2 = lookup$1$1[base642.charCodeAt(i2 + 1)];
    encoded3 = lookup$1$1[base642.charCodeAt(i2 + 2)];
    encoded4 = lookup$1$1[base642.charCodeAt(i2 + 3)];
    bytes[p5++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p5++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p5++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return buffer2;
};
var polyUint16Array$1 = function(buffer2) {
  var length = buffer2.length;
  var bytes = [];
  for (var i2 = 0; i2 < length; i2 += 2) {
    bytes.push(buffer2[i2 + 1] << 8 | buffer2[i2]);
  }
  return bytes;
};
var polyUint32Array$1 = function(buffer2) {
  var length = buffer2.length;
  var bytes = [];
  for (var i2 = 0; i2 < length; i2 += 4) {
    bytes.push(buffer2[i2 + 3] << 24 | buffer2[i2 + 2] << 16 | buffer2[i2 + 1] << 8 | buffer2[i2]);
  }
  return bytes;
};
var UTRIE2_SHIFT_2$1 = 5;
var UTRIE2_SHIFT_1$1 = 6 + 5;
var UTRIE2_INDEX_SHIFT$1 = 2;
var UTRIE2_SHIFT_1_2$1 = UTRIE2_SHIFT_1$1 - UTRIE2_SHIFT_2$1;
var UTRIE2_LSCP_INDEX_2_OFFSET$1 = 65536 >> UTRIE2_SHIFT_2$1;
var UTRIE2_DATA_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_2$1;
var UTRIE2_DATA_MASK$1 = UTRIE2_DATA_BLOCK_LENGTH$1 - 1;
var UTRIE2_LSCP_INDEX_2_LENGTH$1 = 1024 >> UTRIE2_SHIFT_2$1;
var UTRIE2_INDEX_2_BMP_LENGTH$1 = UTRIE2_LSCP_INDEX_2_OFFSET$1 + UTRIE2_LSCP_INDEX_2_LENGTH$1;
var UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 = UTRIE2_INDEX_2_BMP_LENGTH$1;
var UTRIE2_UTF8_2B_INDEX_2_LENGTH$1 = 2048 >> 6;
var UTRIE2_INDEX_1_OFFSET$1 = UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 + UTRIE2_UTF8_2B_INDEX_2_LENGTH$1;
var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 = 65536 >> UTRIE2_SHIFT_1$1;
var UTRIE2_INDEX_2_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_1_2$1;
var UTRIE2_INDEX_2_MASK$1 = UTRIE2_INDEX_2_BLOCK_LENGTH$1 - 1;
var slice16$1 = function(view, start2, end) {
  if (view.slice) {
    return view.slice(start2, end);
  }
  return new Uint16Array(Array.prototype.slice.call(view, start2, end));
};
var slice32$1 = function(view, start2, end) {
  if (view.slice) {
    return view.slice(start2, end);
  }
  return new Uint32Array(Array.prototype.slice.call(view, start2, end));
};
var createTrieFromBase64$1 = function(base642, _byteLength) {
  var buffer2 = decode$1(base642);
  var view32 = Array.isArray(buffer2) ? polyUint32Array$1(buffer2) : new Uint32Array(buffer2);
  var view16 = Array.isArray(buffer2) ? polyUint16Array$1(buffer2) : new Uint16Array(buffer2);
  var headerLength = 24;
  var index2 = slice16$1(view16, headerLength / 2, view32[4] / 2);
  var data2 = view32[5] === 2 ? slice16$1(view16, (headerLength + view32[4]) / 2) : slice32$1(view32, Math.ceil((headerLength + view32[4]) / 4));
  return new Trie$1(view32[0], view32[1], view32[2], view32[3], index2, data2);
};
var Trie$1 = function() {
  function Trie2(initialValue, errorValue, highStart, highValueIndex, index2, data2) {
    this.initialValue = initialValue;
    this.errorValue = errorValue;
    this.highStart = highStart;
    this.highValueIndex = highValueIndex;
    this.index = index2;
    this.data = data2;
  }
  Trie2.prototype.get = function(codePoint) {
    var ix;
    if (codePoint >= 0) {
      if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
        ix = this.index[codePoint >> UTRIE2_SHIFT_2$1];
        ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
        return this.data[ix];
      }
      if (codePoint <= 65535) {
        ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET$1 + (codePoint - 55296 >> UTRIE2_SHIFT_2$1)];
        ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
        return this.data[ix];
      }
      if (codePoint < this.highStart) {
        ix = UTRIE2_INDEX_1_OFFSET$1 - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 + (codePoint >> UTRIE2_SHIFT_1$1);
        ix = this.index[ix];
        ix += codePoint >> UTRIE2_SHIFT_2$1 & UTRIE2_INDEX_2_MASK$1;
        ix = this.index[ix];
        ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
        return this.data[ix];
      }
      if (codePoint <= 1114111) {
        return this.data[this.highValueIndex];
      }
    }
    return this.errorValue;
  };
  return Trie2;
}();
var chars$3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup$3 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i$3 = 0; i$3 < chars$3.length; i$3++) {
  lookup$3[chars$3.charCodeAt(i$3)] = i$3;
}
var base64$1 = "KwAAAAAAAAAACA4AUD0AADAgAAACAAAAAAAIABAAGABAAEgAUABYAGAAaABgAGgAYgBqAF8AZwBgAGgAcQB5AHUAfQCFAI0AlQCdAKIAqgCyALoAYABoAGAAaABgAGgAwgDKAGAAaADGAM4A0wDbAOEA6QDxAPkAAQEJAQ8BFwF1AH0AHAEkASwBNAE6AUIBQQFJAVEBWQFhAWgBcAF4ATAAgAGGAY4BlQGXAZ8BpwGvAbUBvQHFAc0B0wHbAeMB6wHxAfkBAQIJAvEBEQIZAiECKQIxAjgCQAJGAk4CVgJeAmQCbAJ0AnwCgQKJApECmQKgAqgCsAK4ArwCxAIwAMwC0wLbAjAA4wLrAvMC+AIAAwcDDwMwABcDHQMlAy0DNQN1AD0DQQNJA0kDSQNRA1EDVwNZA1kDdQB1AGEDdQBpA20DdQN1AHsDdQCBA4kDkQN1AHUAmQOhA3UAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AKYDrgN1AHUAtgO+A8YDzgPWAxcD3gPjA+sD8wN1AHUA+wMDBAkEdQANBBUEHQQlBCoEFwMyBDgEYABABBcDSARQBFgEYARoBDAAcAQzAXgEgASIBJAEdQCXBHUAnwSnBK4EtgS6BMIEyAR1AHUAdQB1AHUAdQCVANAEYABgAGAAYABgAGAAYABgANgEYADcBOQEYADsBPQE/AQEBQwFFAUcBSQFLAU0BWQEPAVEBUsFUwVbBWAAYgVgAGoFcgV6BYIFigWRBWAAmQWfBaYFYABgAGAAYABgAKoFYACxBbAFuQW6BcEFwQXHBcEFwQXPBdMF2wXjBeoF8gX6BQIGCgYSBhoGIgYqBjIGOgZgAD4GRgZMBmAAUwZaBmAAYABgAGAAYABgAGAAYABgAGAAYABgAGIGYABpBnAGYABgAGAAYABgAGAAYABgAGAAYAB4Bn8GhQZgAGAAYAB1AHcDFQSLBmAAYABgAJMGdQA9A3UAmwajBqsGqwaVALMGuwbDBjAAywbSBtIG1QbSBtIG0gbSBtIG0gbdBuMG6wbzBvsGAwcLBxMHAwcbByMHJwcsBywHMQcsB9IGOAdAB0gHTgfSBkgHVgfSBtIG0gbSBtIG0gbSBtIG0gbSBiwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdgAGAALAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdbB2MHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB2kH0gZwB64EdQB1AHUAdQB1AHUAdQB1AHUHfQdgAIUHjQd1AHUAlQedB2AAYAClB6sHYACzB7YHvgfGB3UAzgfWBzMB3gfmB1EB7gf1B/0HlQENAQUIDQh1ABUIHQglCBcDLQg1CD0IRQhNCEEDUwh1AHUAdQBbCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIcAh3CHoIMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIgggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAALAcsBywHLAcsBywHLAcsBywHLAcsB4oILAcsB44I0gaWCJ4Ipgh1AHUAqgiyCHUAdQB1AHUAdQB1AHUAdQB1AHUAtwh8AXUAvwh1AMUIyQjRCNkI4AjoCHUAdQB1AO4I9gj+CAYJDgkTCS0HGwkjCYIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiAAIAAAAFAAYABgAGIAXwBgAHEAdQBFAJUAogCyAKAAYABgAEIA4ABGANMA4QDxAMEBDwE1AFwBLAE6AQEBUQF4QkhCmEKoQrhCgAHIQsAB0MLAAcABwAHAAeDC6ABoAHDCwMMAAcABwAHAAdDDGMMAAcAB6MM4wwjDWMNow3jDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEjDqABWw6bDqABpg6gAaABoAHcDvwOPA+gAaABfA/8DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DpcPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB9cPKwkyCToJMAB1AHUAdQBCCUoJTQl1AFUJXAljCWcJawkwADAAMAAwAHMJdQB2CX4JdQCECYoJjgmWCXUAngkwAGAAYABxAHUApgn3A64JtAl1ALkJdQDACTAAMAAwADAAdQB1AHUAdQB1AHUAdQB1AHUAowYNBMUIMAAwADAAMADICcsJ0wnZCRUE4QkwAOkJ8An4CTAAMAB1AAAKvwh1AAgKDwoXCh8KdQAwACcKLgp1ADYKqAmICT4KRgowADAAdQB1AE4KMAB1AFYKdQBeCnUAZQowADAAMAAwADAAMAAwADAAMAAVBHUAbQowADAAdQC5CXUKMAAwAHwBxAijBogEMgF9CoQKiASMCpQKmgqIBKIKqgquCogEDQG2Cr4KxgrLCjAAMADTCtsKCgHjCusK8Qr5CgELMAAwADAAMAB1AIsECQsRC3UANAEZCzAAMAAwADAAMAB1ACELKQswAHUANAExCzkLdQBBC0kLMABRC1kLMAAwADAAMAAwADAAdQBhCzAAMAAwAGAAYABpC3ELdwt/CzAAMACHC4sLkwubC58Lpwt1AK4Ltgt1APsDMAAwADAAMAAwADAAMAAwAL4LwwvLC9IL1wvdCzAAMADlC+kL8Qv5C/8LSQswADAAMAAwADAAMAAwADAAMAAHDDAAMAAwADAAMAAODBYMHgx1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1ACYMMAAwADAAdQB1AHUALgx1AHUAdQB1AHUAdQA2DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AD4MdQBGDHUAdQB1AHUAdQB1AEkMdQB1AHUAdQB1AFAMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQBYDHUAdQB1AF8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUA+wMVBGcMMAAwAHwBbwx1AHcMfwyHDI8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAYABgAJcMMAAwADAAdQB1AJ8MlQClDDAAMACtDCwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB7UMLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AA0EMAC9DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAsBywHLAcsBywHLAcsBywHLQcwAMEMyAwsBywHLAcsBywHLAcsBywHLAcsBywHzAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1ANQM2QzhDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMABgAGAAYABgAGAAYABgAOkMYADxDGAA+AwADQYNYABhCWAAYAAODTAAMAAwADAAFg1gAGAAHg37AzAAMAAwADAAYABgACYNYAAsDTQNPA1gAEMNPg1LDWAAYABgAGAAYABgAGAAYABgAGAAUg1aDYsGVglhDV0NcQBnDW0NdQ15DWAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAlQCBDZUAiA2PDZcNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAnw2nDTAAMAAwADAAMAAwAHUArw23DTAAMAAwADAAMAAwADAAMAAwADAAMAB1AL8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQDHDTAAYABgAM8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA1w11ANwNMAAwAD0B5A0wADAAMAAwADAAMADsDfQN/A0EDgwOFA4wABsOMAAwADAAMAAwADAAMAAwANIG0gbSBtIG0gbSBtIG0gYjDigOwQUuDsEFMw7SBjoO0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGQg5KDlIOVg7SBtIGXg5lDm0OdQ7SBtIGfQ6EDooOjQ6UDtIGmg6hDtIG0gaoDqwO0ga0DrwO0gZgAGAAYADEDmAAYAAkBtIGzA5gANIOYADaDokO0gbSBt8O5w7SBu8O0gb1DvwO0gZgAGAAxA7SBtIG0gbSBtIGYABgAGAAYAAED2AAsAUMD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHJA8sBywHLAcsBywHLAccDywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywPLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAc0D9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHPA/SBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gYUD0QPlQCVAJUAMAAwADAAMACVAJUAlQCVAJUAlQCVAEwPMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA//8EAAQABAAEAAQABAAEAAQABAANAAMAAQABAAIABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQACgATABcAHgAbABoAHgAXABYAEgAeABsAGAAPABgAHABLAEsASwBLAEsASwBLAEsASwBLABgAGAAeAB4AHgATAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAGwASAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWAA0AEQAeAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAFAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJABYAGgAbABsAGwAeAB0AHQAeAE8AFwAeAA0AHgAeABoAGwBPAE8ADgBQAB0AHQAdAE8ATwAXAE8ATwBPABYAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwBWAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsABAAbABsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEAA0ADQBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABABQACsAKwArACsAKwArACsAKwAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUAAaABoAUABQAFAAUABQAEwAHgAbAFAAHgAEACsAKwAEAAQABAArAFAAUABQAFAAUABQACsAKwArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQACsAUABQACsAKwAEACsABAAEAAQABAAEACsAKwArACsABAAEACsAKwAEAAQABAArACsAKwAEACsAKwArACsAKwArACsAUABQAFAAUAArAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAAQABABQAFAAUAAEAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAArACsAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AGwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAKwArACsAKwArAAQABAAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAAQAUAArAFAAUABQAFAAUABQACsAKwArAFAAUABQACsAUABQAFAAUAArACsAKwBQAFAAKwBQACsAUABQACsAKwArAFAAUAArACsAKwBQAFAAUAArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAArACsAKwAEAAQABAArAAQABAAEAAQAKwArAFAAKwArACsAKwArACsABAArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAHgAeAB4AHgAeAB4AGwAeACsAKwArACsAKwAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAUABQAFAAKwArACsAKwArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwAOAFAAUABQAFAAUABQAFAAHgBQAAQABAAEAA4AUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAKwArAAQAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAKwArACsAKwArACsAUAArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAXABcAFwAXABcACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAXAArAFwAXABcAFwAXABcAFwAXABcAFwAKgBcAFwAKgAqACoAKgAqACoAKgAqACoAXAArACsAXABcAFwAXABcACsAXAArACoAKgAqACoAKgAqACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwBcAFwAXABcAFAADgAOAA4ADgAeAA4ADgAJAA4ADgANAAkAEwATABMAEwATAAkAHgATAB4AHgAeAAQABAAeAB4AHgAeAB4AHgBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAADQAEAB4ABAAeAAQAFgARABYAEQAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAAQABAAEAAQADQAEAAQAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAA0ADQAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeACsAHgAeAA4ADgANAA4AHgAeAB4AHgAeAAkACQArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgBcAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4AHgAeAB4AXABcAFwAXABcAFwAKgAqACoAKgBcAFwAXABcACoAKgAqAFwAKgAqACoAXABcACoAKgAqACoAKgAqACoAXABcAFwAKgAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwAKgBLAEsASwBLAEsASwBLAEsASwBLACoAKgAqACoAKgAqAFAAUABQAFAAUABQACsAUAArACsAKwArACsAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAKwBQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsABAAEAAQAHgANAB4AHgAeAB4AHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUAArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWABEAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAANAA0AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUAArAAQABAArACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAA0ADQAVAFwADQAeAA0AGwBcACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwAeAB4AEwATAA0ADQAOAB4AEwATAB4ABAAEAAQACQArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAHgArACsAKwATABMASwBLAEsASwBLAEsASwBLAEsASwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAXABcAFwAXABcACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXAArACsAKwAqACoAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsAHgAeAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKwArAAQASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACoAKgAqACoAKgAqACoAXAAqACoAKgAqACoAKgArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABABQAFAAUABQAFAAUABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgANAA0ADQANAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwAeAB4AHgAeAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArAA0ADQANAA0ADQBLAEsASwBLAEsASwBLAEsASwBLACsAKwArAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUAAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAAQAUABQAFAAUABQAFAABABQAFAABAAEAAQAUAArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQACsAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQACsAKwAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQACsAHgAeAB4AHgAeAB4AHgAOAB4AKwANAA0ADQANAA0ADQANAAkADQANAA0ACAAEAAsABAAEAA0ACQANAA0ADAAdAB0AHgAXABcAFgAXABcAFwAWABcAHQAdAB4AHgAUABQAFAANAAEAAQAEAAQABAAEAAQACQAaABoAGgAaABoAGgAaABoAHgAXABcAHQAVABUAHgAeAB4AHgAeAB4AGAAWABEAFQAVABUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ADQAeAA0ADQANAA0AHgANAA0ADQAHAB4AHgAeAB4AKwAEAAQABAAEAAQABAAEAAQABAAEAFAAUAArACsATwBQAFAAUABQAFAAHgAeAB4AFgARAE8AUABPAE8ATwBPAFAAUABQAFAAUAAeAB4AHgAWABEAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArABsAGwAbABsAGwAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGgAbABsAGwAbABoAGwAbABoAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAFAAGgAeAB0AHgBQAB4AGgAeAB4AHgAeAB4AHgAeAB4AHgBPAB4AUAAbAB4AHgBQAFAAUABQAFAAHgAeAB4AHQAdAB4AUAAeAFAAHgBQAB4AUABPAFAAUAAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgBQAFAAUABQAE8ATwBQAFAAUABQAFAATwBQAFAATwBQAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAUABQAFAATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABPAB4AHgArACsAKwArAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAdAB4AHgAeAB0AHQAeAB4AHQAeAB4AHgAdAB4AHQAbABsAHgAdAB4AHgAeAB4AHQAeAB4AHQAdAB0AHQAeAB4AHQAeAB0AHgAdAB0AHQAdAB0AHQAeAB0AHgAeAB4AHgAeAB0AHQAdAB0AHgAeAB4AHgAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB0AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAdAB0AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHQAdAB0AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHQAdAB4AHgAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AJQAlAB0AHQAlAB4AJQAlACUAIAAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAeAB0AJQAdAB0AHgAdAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAdAB0AHQAdACUAHgAlACUAJQAdACUAJQAdAB0AHQAlACUAHQAdACUAHQAdACUAJQAlAB4AHQAeAB4AHgAeAB0AHQAlAB0AHQAdAB0AHQAdACUAJQAlACUAJQAdACUAJQAgACUAHQAdACUAJQAlACUAJQAlACUAJQAeAB4AHgAlACUAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AFwAXABcAFwAXABcAHgATABMAJQAeAB4AHgAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARABYAEQAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANAA0AHgANAB4ADQANAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwAlACUAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACsAKwArACsAKwArACsAKwArACsAKwArAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBPAE8ATwBPAE8ATwBPAE8AJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeAAQAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUABQAAQAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAUABQAFAAUABQAAQABAAEACsABAAEACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAKwBQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAA0ADQANAA0ADQANAA0ADQAeACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAArACsAKwArAFAAUABQAFAAUAANAA0ADQANAA0ADQAUACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQANAA0ADQANAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAANACsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAB4AHgAeAB4AHgArACsAKwArACsAKwAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANAFAABAAEAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAEAAQABAAEAB4ABAAEAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsABAAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLAA0ADQArAB4ABABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUAAeAFAAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAAEAAQADgANAA0AEwATAB4AHgAeAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAFAAUABQAFAABAAEACsAKwAEAA0ADQAeAFAAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcAFwADQANAA0AKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQAKwAEAAQAKwArAAQABAAEAAQAUAAEAFAABAAEAA0ADQANACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABABQAA4AUAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANAFAADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAaABoAGgAaAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAJAAkACQAJAAkACQAJABYAEQArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AHgAeACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAARwBHABUARwAJACsAKwArACsAKwArACsAKwArACsAKwAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAKwArACsAKwArACsAKwArACsAKwArACsAKwBRAFEAUQBRACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAHgAEAAQADQAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAeAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQAHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAKwArAFAAKwArAFAAUAArACsAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAHgAeAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeACsAKwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4ABAAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAHgAeAA0ADQANAA0AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArAAQABAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwBQAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArABsAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAB4AHgAeAB4ABAAEAAQABAAEAAQABABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArABYAFgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAGgBQAFAAUAAaAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUAArACsAKwArACsAKwBQACsAKwArACsAUAArAFAAKwBQACsAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUAArAFAAKwBQACsAUAArAFAAUAArAFAAKwArAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAKwBQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeACUAJQAlAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAHgAlACUAJQAlACUAIAAgACAAJQAlACAAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACEAIQAhACEAIQAlACUAIAAgACUAJQAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAlACUAJQAlACAAIAAgACUAIAAgACAAJQAlACUAJQAlACUAJQAgACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAlAB4AJQAeACUAJQAlACUAJQAgACUAJQAlACUAHgAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACAAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABcAFwAXABUAFQAVAB4AHgAeAB4AJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAgACUAJQAgACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAIAAgACUAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACAAIAAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACAAIAAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAA==";
var LETTER_NUMBER_MODIFIER = 50;
var BK = 1;
var CR$1 = 2;
var LF$1 = 3;
var CM = 4;
var NL = 5;
var WJ = 7;
var ZW = 8;
var GL = 9;
var SP = 10;
var ZWJ$1 = 11;
var B2 = 12;
var BA = 13;
var BB = 14;
var HY = 15;
var CB = 16;
var CL = 17;
var CP = 18;
var EX = 19;
var IN = 20;
var NS = 21;
var OP = 22;
var QU = 23;
var IS = 24;
var NU = 25;
var PO = 26;
var PR = 27;
var SY = 28;
var AI = 29;
var AL = 30;
var CJ = 31;
var EB = 32;
var EM = 33;
var H2 = 34;
var H3 = 35;
var HL = 36;
var ID = 37;
var JL = 38;
var JV = 39;
var JT = 40;
var RI$1 = 41;
var SA = 42;
var XX = 43;
var ea_OP = [9001, 65288];
var BREAK_MANDATORY = "!";
var BREAK_NOT_ALLOWED$1 = "\xD7";
var BREAK_ALLOWED$1 = "\xF7";
var UnicodeTrie$1 = createTrieFromBase64$1(base64$1);
var ALPHABETICS = [AL, HL];
var HARD_LINE_BREAKS = [BK, CR$1, LF$1, NL];
var SPACE$1 = [SP, ZW];
var PREFIX_POSTFIX = [PR, PO];
var LINE_BREAKS = HARD_LINE_BREAKS.concat(SPACE$1);
var KOREAN_SYLLABLE_BLOCK = [JL, JV, JT, H2, H3];
var HYPHEN = [HY, BA];
var codePointsToCharacterClasses = function(codePoints, lineBreak2) {
  if (lineBreak2 === void 0) {
    lineBreak2 = "strict";
  }
  var types = [];
  var indices = [];
  var categories = [];
  codePoints.forEach(function(codePoint, index2) {
    var classType = UnicodeTrie$1.get(codePoint);
    if (classType > LETTER_NUMBER_MODIFIER) {
      categories.push(true);
      classType -= LETTER_NUMBER_MODIFIER;
    } else {
      categories.push(false);
    }
    if (["normal", "auto", "loose"].indexOf(lineBreak2) !== -1) {
      if ([8208, 8211, 12316, 12448].indexOf(codePoint) !== -1) {
        indices.push(index2);
        return types.push(CB);
      }
    }
    if (classType === CM || classType === ZWJ$1) {
      if (index2 === 0) {
        indices.push(index2);
        return types.push(AL);
      }
      var prev = types[index2 - 1];
      if (LINE_BREAKS.indexOf(prev) === -1) {
        indices.push(indices[index2 - 1]);
        return types.push(prev);
      }
      indices.push(index2);
      return types.push(AL);
    }
    indices.push(index2);
    if (classType === CJ) {
      return types.push(lineBreak2 === "strict" ? NS : ID);
    }
    if (classType === SA) {
      return types.push(AL);
    }
    if (classType === AI) {
      return types.push(AL);
    }
    if (classType === XX) {
      if (codePoint >= 131072 && codePoint <= 196605 || codePoint >= 196608 && codePoint <= 262141) {
        return types.push(ID);
      } else {
        return types.push(AL);
      }
    }
    types.push(classType);
  });
  return [indices, types, categories];
};
var isAdjacentWithSpaceIgnored = function(a2, b2, currentIndex, classTypes) {
  var current = classTypes[currentIndex];
  if (Array.isArray(a2) ? a2.indexOf(current) !== -1 : a2 === current) {
    var i2 = currentIndex;
    while (i2 <= classTypes.length) {
      i2++;
      var next3 = classTypes[i2];
      if (next3 === b2) {
        return true;
      }
      if (next3 !== SP) {
        break;
      }
    }
  }
  if (current === SP) {
    var i2 = currentIndex;
    while (i2 > 0) {
      i2--;
      var prev = classTypes[i2];
      if (Array.isArray(a2) ? a2.indexOf(prev) !== -1 : a2 === prev) {
        var n2 = currentIndex;
        while (n2 <= classTypes.length) {
          n2++;
          var next3 = classTypes[n2];
          if (next3 === b2) {
            return true;
          }
          if (next3 !== SP) {
            break;
          }
        }
      }
      if (prev !== SP) {
        break;
      }
    }
  }
  return false;
};
var previousNonSpaceClassType = function(currentIndex, classTypes) {
  var i2 = currentIndex;
  while (i2 >= 0) {
    var type = classTypes[i2];
    if (type === SP) {
      i2--;
    } else {
      return type;
    }
  }
  return 0;
};
var _lineBreakAtIndex = function(codePoints, classTypes, indicies, index2, forbiddenBreaks) {
  if (indicies[index2] === 0) {
    return BREAK_NOT_ALLOWED$1;
  }
  var currentIndex = index2 - 1;
  if (Array.isArray(forbiddenBreaks) && forbiddenBreaks[currentIndex] === true) {
    return BREAK_NOT_ALLOWED$1;
  }
  var beforeIndex = currentIndex - 1;
  var afterIndex = currentIndex + 1;
  var current = classTypes[currentIndex];
  var before = beforeIndex >= 0 ? classTypes[beforeIndex] : 0;
  var next3 = classTypes[afterIndex];
  if (current === CR$1 && next3 === LF$1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (HARD_LINE_BREAKS.indexOf(current) !== -1) {
    return BREAK_MANDATORY;
  }
  if (HARD_LINE_BREAKS.indexOf(next3) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (SPACE$1.indexOf(next3) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (previousNonSpaceClassType(currentIndex, classTypes) === ZW) {
    return BREAK_ALLOWED$1;
  }
  if (UnicodeTrie$1.get(codePoints[currentIndex]) === ZWJ$1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if ((current === EB || current === EM) && UnicodeTrie$1.get(codePoints[afterIndex]) === ZWJ$1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === WJ || next3 === WJ) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === GL) {
    return BREAK_NOT_ALLOWED$1;
  }
  if ([SP, BA, HY].indexOf(current) === -1 && next3 === GL) {
    return BREAK_NOT_ALLOWED$1;
  }
  if ([CL, CP, EX, IS, SY].indexOf(next3) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (previousNonSpaceClassType(currentIndex, classTypes) === OP) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (isAdjacentWithSpaceIgnored(QU, OP, currentIndex, classTypes)) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (isAdjacentWithSpaceIgnored([CL, CP], NS, currentIndex, classTypes)) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (isAdjacentWithSpaceIgnored(B2, B2, currentIndex, classTypes)) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === SP) {
    return BREAK_ALLOWED$1;
  }
  if (current === QU || next3 === QU) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (next3 === CB || current === CB) {
    return BREAK_ALLOWED$1;
  }
  if ([BA, HY, NS].indexOf(next3) !== -1 || current === BB) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (before === HL && HYPHEN.indexOf(current) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === SY && next3 === HL) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (next3 === IN) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (ALPHABETICS.indexOf(next3) !== -1 && current === NU || ALPHABETICS.indexOf(current) !== -1 && next3 === NU) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === PR && [ID, EB, EM].indexOf(next3) !== -1 || [ID, EB, EM].indexOf(current) !== -1 && next3 === PO) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (ALPHABETICS.indexOf(current) !== -1 && PREFIX_POSTFIX.indexOf(next3) !== -1 || PREFIX_POSTFIX.indexOf(current) !== -1 && ALPHABETICS.indexOf(next3) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if ([PR, PO].indexOf(current) !== -1 && (next3 === NU || [OP, HY].indexOf(next3) !== -1 && classTypes[afterIndex + 1] === NU) || [OP, HY].indexOf(current) !== -1 && next3 === NU || current === NU && [NU, SY, IS].indexOf(next3) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if ([NU, SY, IS, CL, CP].indexOf(next3) !== -1) {
    var prevIndex = currentIndex;
    while (prevIndex >= 0) {
      var type = classTypes[prevIndex];
      if (type === NU) {
        return BREAK_NOT_ALLOWED$1;
      } else if ([SY, IS].indexOf(type) !== -1) {
        prevIndex--;
      } else {
        break;
      }
    }
  }
  if ([PR, PO].indexOf(next3) !== -1) {
    var prevIndex = [CL, CP].indexOf(current) !== -1 ? beforeIndex : currentIndex;
    while (prevIndex >= 0) {
      var type = classTypes[prevIndex];
      if (type === NU) {
        return BREAK_NOT_ALLOWED$1;
      } else if ([SY, IS].indexOf(type) !== -1) {
        prevIndex--;
      } else {
        break;
      }
    }
  }
  if (JL === current && [JL, JV, H2, H3].indexOf(next3) !== -1 || [JV, H2].indexOf(current) !== -1 && [JV, JT].indexOf(next3) !== -1 || [JT, H3].indexOf(current) !== -1 && next3 === JT) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (KOREAN_SYLLABLE_BLOCK.indexOf(current) !== -1 && [IN, PO].indexOf(next3) !== -1 || KOREAN_SYLLABLE_BLOCK.indexOf(next3) !== -1 && current === PR) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (ALPHABETICS.indexOf(current) !== -1 && ALPHABETICS.indexOf(next3) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === IS && ALPHABETICS.indexOf(next3) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (ALPHABETICS.concat(NU).indexOf(current) !== -1 && next3 === OP && ea_OP.indexOf(codePoints[afterIndex]) === -1 || ALPHABETICS.concat(NU).indexOf(next3) !== -1 && current === CP) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === RI$1 && next3 === RI$1) {
    var i2 = indicies[currentIndex];
    var count = 1;
    while (i2 > 0) {
      i2--;
      if (classTypes[i2] === RI$1) {
        count++;
      } else {
        break;
      }
    }
    if (count % 2 !== 0) {
      return BREAK_NOT_ALLOWED$1;
    }
  }
  if (current === EB && next3 === EM) {
    return BREAK_NOT_ALLOWED$1;
  }
  return BREAK_ALLOWED$1;
};
var cssFormattedClasses = function(codePoints, options) {
  if (!options) {
    options = { lineBreak: "normal", wordBreak: "normal" };
  }
  var _a2 = codePointsToCharacterClasses(codePoints, options.lineBreak), indicies = _a2[0], classTypes = _a2[1], isLetterNumber = _a2[2];
  if (options.wordBreak === "break-all" || options.wordBreak === "break-word") {
    classTypes = classTypes.map(function(type) {
      return [NU, AL, SA].indexOf(type) !== -1 ? ID : type;
    });
  }
  var forbiddenBreakpoints = options.wordBreak === "keep-all" ? isLetterNumber.map(function(letterNumber, i2) {
    return letterNumber && codePoints[i2] >= 19968 && codePoints[i2] <= 40959;
  }) : void 0;
  return [indicies, classTypes, forbiddenBreakpoints];
};
var Break = function() {
  function Break2(codePoints, lineBreak2, start2, end) {
    this.codePoints = codePoints;
    this.required = lineBreak2 === BREAK_MANDATORY;
    this.start = start2;
    this.end = end;
  }
  Break2.prototype.slice = function() {
    return fromCodePoint$1.apply(void 0, this.codePoints.slice(this.start, this.end));
  };
  return Break2;
}();
var LineBreaker = function(str, options) {
  var codePoints = toCodePoints$1(str);
  var _a2 = cssFormattedClasses(codePoints, options), indicies = _a2[0], classTypes = _a2[1], forbiddenBreakpoints = _a2[2];
  var length = codePoints.length;
  var lastEnd = 0;
  var nextIndex = 0;
  return {
    next: function() {
      if (nextIndex >= length) {
        return { done: true, value: null };
      }
      var lineBreak2 = BREAK_NOT_ALLOWED$1;
      while (nextIndex < length && (lineBreak2 = _lineBreakAtIndex(codePoints, classTypes, indicies, ++nextIndex, forbiddenBreakpoints)) === BREAK_NOT_ALLOWED$1) {
      }
      if (lineBreak2 !== BREAK_NOT_ALLOWED$1 || nextIndex === length) {
        var value = new Break(codePoints, lineBreak2, lastEnd, nextIndex);
        lastEnd = nextIndex;
        return { value, done: false };
      }
      return { done: true, value: null };
    }
  };
};
var FLAG_UNRESTRICTED = 1 << 0;
var FLAG_ID = 1 << 1;
var FLAG_INTEGER = 1 << 2;
var FLAG_NUMBER = 1 << 3;
var LINE_FEED = 10;
var SOLIDUS = 47;
var REVERSE_SOLIDUS = 92;
var CHARACTER_TABULATION = 9;
var SPACE = 32;
var QUOTATION_MARK = 34;
var EQUALS_SIGN = 61;
var NUMBER_SIGN = 35;
var DOLLAR_SIGN = 36;
var PERCENTAGE_SIGN = 37;
var APOSTROPHE = 39;
var LEFT_PARENTHESIS = 40;
var RIGHT_PARENTHESIS = 41;
var LOW_LINE = 95;
var HYPHEN_MINUS = 45;
var EXCLAMATION_MARK = 33;
var LESS_THAN_SIGN = 60;
var GREATER_THAN_SIGN = 62;
var COMMERCIAL_AT = 64;
var LEFT_SQUARE_BRACKET = 91;
var RIGHT_SQUARE_BRACKET = 93;
var CIRCUMFLEX_ACCENT = 61;
var LEFT_CURLY_BRACKET = 123;
var QUESTION_MARK = 63;
var RIGHT_CURLY_BRACKET = 125;
var VERTICAL_LINE = 124;
var TILDE = 126;
var CONTROL = 128;
var REPLACEMENT_CHARACTER = 65533;
var ASTERISK = 42;
var PLUS_SIGN = 43;
var COMMA = 44;
var COLON = 58;
var SEMICOLON = 59;
var FULL_STOP = 46;
var NULL = 0;
var BACKSPACE = 8;
var LINE_TABULATION = 11;
var SHIFT_OUT = 14;
var INFORMATION_SEPARATOR_ONE = 31;
var DELETE = 127;
var EOF = -1;
var ZERO = 48;
var a$1 = 97;
var e$1 = 101;
var f$1 = 102;
var u$1 = 117;
var z = 122;
var A = 65;
var E = 69;
var F = 70;
var U = 85;
var Z = 90;
var isDigit = function(codePoint) {
  return codePoint >= ZERO && codePoint <= 57;
};
var isSurrogateCodePoint = function(codePoint) {
  return codePoint >= 55296 && codePoint <= 57343;
};
var isHex = function(codePoint) {
  return isDigit(codePoint) || codePoint >= A && codePoint <= F || codePoint >= a$1 && codePoint <= f$1;
};
var isLowerCaseLetter = function(codePoint) {
  return codePoint >= a$1 && codePoint <= z;
};
var isUpperCaseLetter = function(codePoint) {
  return codePoint >= A && codePoint <= Z;
};
var isLetter = function(codePoint) {
  return isLowerCaseLetter(codePoint) || isUpperCaseLetter(codePoint);
};
var isNonASCIICodePoint = function(codePoint) {
  return codePoint >= CONTROL;
};
var isWhiteSpace = function(codePoint) {
  return codePoint === LINE_FEED || codePoint === CHARACTER_TABULATION || codePoint === SPACE;
};
var isNameStartCodePoint = function(codePoint) {
  return isLetter(codePoint) || isNonASCIICodePoint(codePoint) || codePoint === LOW_LINE;
};
var isNameCodePoint = function(codePoint) {
  return isNameStartCodePoint(codePoint) || isDigit(codePoint) || codePoint === HYPHEN_MINUS;
};
var isNonPrintableCodePoint = function(codePoint) {
  return codePoint >= NULL && codePoint <= BACKSPACE || codePoint === LINE_TABULATION || codePoint >= SHIFT_OUT && codePoint <= INFORMATION_SEPARATOR_ONE || codePoint === DELETE;
};
var isValidEscape = function(c1, c2) {
  if (c1 !== REVERSE_SOLIDUS) {
    return false;
  }
  return c2 !== LINE_FEED;
};
var isIdentifierStart = function(c1, c2, c3) {
  if (c1 === HYPHEN_MINUS) {
    return isNameStartCodePoint(c2) || isValidEscape(c2, c3);
  } else if (isNameStartCodePoint(c1)) {
    return true;
  } else if (c1 === REVERSE_SOLIDUS && isValidEscape(c1, c2)) {
    return true;
  }
  return false;
};
var isNumberStart = function(c1, c2, c3) {
  if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
    if (isDigit(c2)) {
      return true;
    }
    return c2 === FULL_STOP && isDigit(c3);
  }
  if (c1 === FULL_STOP) {
    return isDigit(c2);
  }
  return isDigit(c1);
};
var stringToNumber = function(codePoints) {
  var c2 = 0;
  var sign2 = 1;
  if (codePoints[c2] === PLUS_SIGN || codePoints[c2] === HYPHEN_MINUS) {
    if (codePoints[c2] === HYPHEN_MINUS) {
      sign2 = -1;
    }
    c2++;
  }
  var integers = [];
  while (isDigit(codePoints[c2])) {
    integers.push(codePoints[c2++]);
  }
  var int = integers.length ? parseInt(fromCodePoint$1.apply(void 0, integers), 10) : 0;
  if (codePoints[c2] === FULL_STOP) {
    c2++;
  }
  var fraction = [];
  while (isDigit(codePoints[c2])) {
    fraction.push(codePoints[c2++]);
  }
  var fracd = fraction.length;
  var frac = fracd ? parseInt(fromCodePoint$1.apply(void 0, fraction), 10) : 0;
  if (codePoints[c2] === E || codePoints[c2] === e$1) {
    c2++;
  }
  var expsign = 1;
  if (codePoints[c2] === PLUS_SIGN || codePoints[c2] === HYPHEN_MINUS) {
    if (codePoints[c2] === HYPHEN_MINUS) {
      expsign = -1;
    }
    c2++;
  }
  var exponent = [];
  while (isDigit(codePoints[c2])) {
    exponent.push(codePoints[c2++]);
  }
  var exp = exponent.length ? parseInt(fromCodePoint$1.apply(void 0, exponent), 10) : 0;
  return sign2 * (int + frac * Math.pow(10, -fracd)) * Math.pow(10, expsign * exp);
};
var LEFT_PARENTHESIS_TOKEN = {
  type: 2
};
var RIGHT_PARENTHESIS_TOKEN = {
  type: 3
};
var COMMA_TOKEN = { type: 4 };
var SUFFIX_MATCH_TOKEN = { type: 13 };
var PREFIX_MATCH_TOKEN = { type: 8 };
var COLUMN_TOKEN = { type: 21 };
var DASH_MATCH_TOKEN = { type: 9 };
var INCLUDE_MATCH_TOKEN = { type: 10 };
var LEFT_CURLY_BRACKET_TOKEN = {
  type: 11
};
var RIGHT_CURLY_BRACKET_TOKEN = {
  type: 12
};
var SUBSTRING_MATCH_TOKEN = { type: 14 };
var BAD_URL_TOKEN = { type: 23 };
var BAD_STRING_TOKEN = { type: 1 };
var CDO_TOKEN = { type: 25 };
var CDC_TOKEN = { type: 24 };
var COLON_TOKEN = { type: 26 };
var SEMICOLON_TOKEN = { type: 27 };
var LEFT_SQUARE_BRACKET_TOKEN = {
  type: 28
};
var RIGHT_SQUARE_BRACKET_TOKEN = {
  type: 29
};
var WHITESPACE_TOKEN = { type: 31 };
var EOF_TOKEN = { type: 32 };
var Tokenizer = function() {
  function Tokenizer2() {
    this._value = [];
  }
  Tokenizer2.prototype.write = function(chunk) {
    this._value = this._value.concat(toCodePoints$1(chunk));
  };
  Tokenizer2.prototype.read = function() {
    var tokens = [];
    var token = this.consumeToken();
    while (token !== EOF_TOKEN) {
      tokens.push(token);
      token = this.consumeToken();
    }
    return tokens;
  };
  Tokenizer2.prototype.consumeToken = function() {
    var codePoint = this.consumeCodePoint();
    switch (codePoint) {
      case QUOTATION_MARK:
        return this.consumeStringToken(QUOTATION_MARK);
      case NUMBER_SIGN:
        var c1 = this.peekCodePoint(0);
        var c2 = this.peekCodePoint(1);
        var c3 = this.peekCodePoint(2);
        if (isNameCodePoint(c1) || isValidEscape(c2, c3)) {
          var flags = isIdentifierStart(c1, c2, c3) ? FLAG_ID : FLAG_UNRESTRICTED;
          var value = this.consumeName();
          return { type: 5, value, flags };
        }
        break;
      case DOLLAR_SIGN:
        if (this.peekCodePoint(0) === EQUALS_SIGN) {
          this.consumeCodePoint();
          return SUFFIX_MATCH_TOKEN;
        }
        break;
      case APOSTROPHE:
        return this.consumeStringToken(APOSTROPHE);
      case LEFT_PARENTHESIS:
        return LEFT_PARENTHESIS_TOKEN;
      case RIGHT_PARENTHESIS:
        return RIGHT_PARENTHESIS_TOKEN;
      case ASTERISK:
        if (this.peekCodePoint(0) === EQUALS_SIGN) {
          this.consumeCodePoint();
          return SUBSTRING_MATCH_TOKEN;
        }
        break;
      case PLUS_SIGN:
        if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
          this.reconsumeCodePoint(codePoint);
          return this.consumeNumericToken();
        }
        break;
      case COMMA:
        return COMMA_TOKEN;
      case HYPHEN_MINUS:
        var e1 = codePoint;
        var e2 = this.peekCodePoint(0);
        var e3 = this.peekCodePoint(1);
        if (isNumberStart(e1, e2, e3)) {
          this.reconsumeCodePoint(codePoint);
          return this.consumeNumericToken();
        }
        if (isIdentifierStart(e1, e2, e3)) {
          this.reconsumeCodePoint(codePoint);
          return this.consumeIdentLikeToken();
        }
        if (e2 === HYPHEN_MINUS && e3 === GREATER_THAN_SIGN) {
          this.consumeCodePoint();
          this.consumeCodePoint();
          return CDC_TOKEN;
        }
        break;
      case FULL_STOP:
        if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
          this.reconsumeCodePoint(codePoint);
          return this.consumeNumericToken();
        }
        break;
      case SOLIDUS:
        if (this.peekCodePoint(0) === ASTERISK) {
          this.consumeCodePoint();
          while (true) {
            var c4 = this.consumeCodePoint();
            if (c4 === ASTERISK) {
              c4 = this.consumeCodePoint();
              if (c4 === SOLIDUS) {
                return this.consumeToken();
              }
            }
            if (c4 === EOF) {
              return this.consumeToken();
            }
          }
        }
        break;
      case COLON:
        return COLON_TOKEN;
      case SEMICOLON:
        return SEMICOLON_TOKEN;
      case LESS_THAN_SIGN:
        if (this.peekCodePoint(0) === EXCLAMATION_MARK && this.peekCodePoint(1) === HYPHEN_MINUS && this.peekCodePoint(2) === HYPHEN_MINUS) {
          this.consumeCodePoint();
          this.consumeCodePoint();
          return CDO_TOKEN;
        }
        break;
      case COMMERCIAL_AT:
        var a1 = this.peekCodePoint(0);
        var a2 = this.peekCodePoint(1);
        var a3 = this.peekCodePoint(2);
        if (isIdentifierStart(a1, a2, a3)) {
          var value = this.consumeName();
          return { type: 7, value };
        }
        break;
      case LEFT_SQUARE_BRACKET:
        return LEFT_SQUARE_BRACKET_TOKEN;
      case REVERSE_SOLIDUS:
        if (isValidEscape(codePoint, this.peekCodePoint(0))) {
          this.reconsumeCodePoint(codePoint);
          return this.consumeIdentLikeToken();
        }
        break;
      case RIGHT_SQUARE_BRACKET:
        return RIGHT_SQUARE_BRACKET_TOKEN;
      case CIRCUMFLEX_ACCENT:
        if (this.peekCodePoint(0) === EQUALS_SIGN) {
          this.consumeCodePoint();
          return PREFIX_MATCH_TOKEN;
        }
        break;
      case LEFT_CURLY_BRACKET:
        return LEFT_CURLY_BRACKET_TOKEN;
      case RIGHT_CURLY_BRACKET:
        return RIGHT_CURLY_BRACKET_TOKEN;
      case u$1:
      case U:
        var u1 = this.peekCodePoint(0);
        var u2 = this.peekCodePoint(1);
        if (u1 === PLUS_SIGN && (isHex(u2) || u2 === QUESTION_MARK)) {
          this.consumeCodePoint();
          this.consumeUnicodeRangeToken();
        }
        this.reconsumeCodePoint(codePoint);
        return this.consumeIdentLikeToken();
      case VERTICAL_LINE:
        if (this.peekCodePoint(0) === EQUALS_SIGN) {
          this.consumeCodePoint();
          return DASH_MATCH_TOKEN;
        }
        if (this.peekCodePoint(0) === VERTICAL_LINE) {
          this.consumeCodePoint();
          return COLUMN_TOKEN;
        }
        break;
      case TILDE:
        if (this.peekCodePoint(0) === EQUALS_SIGN) {
          this.consumeCodePoint();
          return INCLUDE_MATCH_TOKEN;
        }
        break;
      case EOF:
        return EOF_TOKEN;
    }
    if (isWhiteSpace(codePoint)) {
      this.consumeWhiteSpace();
      return WHITESPACE_TOKEN;
    }
    if (isDigit(codePoint)) {
      this.reconsumeCodePoint(codePoint);
      return this.consumeNumericToken();
    }
    if (isNameStartCodePoint(codePoint)) {
      this.reconsumeCodePoint(codePoint);
      return this.consumeIdentLikeToken();
    }
    return { type: 6, value: fromCodePoint$1(codePoint) };
  };
  Tokenizer2.prototype.consumeCodePoint = function() {
    var value = this._value.shift();
    return typeof value === "undefined" ? -1 : value;
  };
  Tokenizer2.prototype.reconsumeCodePoint = function(codePoint) {
    this._value.unshift(codePoint);
  };
  Tokenizer2.prototype.peekCodePoint = function(delta) {
    if (delta >= this._value.length) {
      return -1;
    }
    return this._value[delta];
  };
  Tokenizer2.prototype.consumeUnicodeRangeToken = function() {
    var digits = [];
    var codePoint = this.consumeCodePoint();
    while (isHex(codePoint) && digits.length < 6) {
      digits.push(codePoint);
      codePoint = this.consumeCodePoint();
    }
    var questionMarks = false;
    while (codePoint === QUESTION_MARK && digits.length < 6) {
      digits.push(codePoint);
      codePoint = this.consumeCodePoint();
      questionMarks = true;
    }
    if (questionMarks) {
      var start_1 = parseInt(fromCodePoint$1.apply(void 0, digits.map(function(digit) {
        return digit === QUESTION_MARK ? ZERO : digit;
      })), 16);
      var end = parseInt(fromCodePoint$1.apply(void 0, digits.map(function(digit) {
        return digit === QUESTION_MARK ? F : digit;
      })), 16);
      return { type: 30, start: start_1, end };
    }
    var start2 = parseInt(fromCodePoint$1.apply(void 0, digits), 16);
    if (this.peekCodePoint(0) === HYPHEN_MINUS && isHex(this.peekCodePoint(1))) {
      this.consumeCodePoint();
      codePoint = this.consumeCodePoint();
      var endDigits = [];
      while (isHex(codePoint) && endDigits.length < 6) {
        endDigits.push(codePoint);
        codePoint = this.consumeCodePoint();
      }
      var end = parseInt(fromCodePoint$1.apply(void 0, endDigits), 16);
      return { type: 30, start: start2, end };
    } else {
      return { type: 30, start: start2, end: start2 };
    }
  };
  Tokenizer2.prototype.consumeIdentLikeToken = function() {
    var value = this.consumeName();
    if (value.toLowerCase() === "url" && this.peekCodePoint(0) === LEFT_PARENTHESIS) {
      this.consumeCodePoint();
      return this.consumeUrlToken();
    } else if (this.peekCodePoint(0) === LEFT_PARENTHESIS) {
      this.consumeCodePoint();
      return { type: 19, value };
    }
    return { type: 20, value };
  };
  Tokenizer2.prototype.consumeUrlToken = function() {
    var value = [];
    this.consumeWhiteSpace();
    if (this.peekCodePoint(0) === EOF) {
      return { type: 22, value: "" };
    }
    var next3 = this.peekCodePoint(0);
    if (next3 === APOSTROPHE || next3 === QUOTATION_MARK) {
      var stringToken = this.consumeStringToken(this.consumeCodePoint());
      if (stringToken.type === 0) {
        this.consumeWhiteSpace();
        if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
          this.consumeCodePoint();
          return { type: 22, value: stringToken.value };
        }
      }
      this.consumeBadUrlRemnants();
      return BAD_URL_TOKEN;
    }
    while (true) {
      var codePoint = this.consumeCodePoint();
      if (codePoint === EOF || codePoint === RIGHT_PARENTHESIS) {
        return { type: 22, value: fromCodePoint$1.apply(void 0, value) };
      } else if (isWhiteSpace(codePoint)) {
        this.consumeWhiteSpace();
        if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
          this.consumeCodePoint();
          return { type: 22, value: fromCodePoint$1.apply(void 0, value) };
        }
        this.consumeBadUrlRemnants();
        return BAD_URL_TOKEN;
      } else if (codePoint === QUOTATION_MARK || codePoint === APOSTROPHE || codePoint === LEFT_PARENTHESIS || isNonPrintableCodePoint(codePoint)) {
        this.consumeBadUrlRemnants();
        return BAD_URL_TOKEN;
      } else if (codePoint === REVERSE_SOLIDUS) {
        if (isValidEscape(codePoint, this.peekCodePoint(0))) {
          value.push(this.consumeEscapedCodePoint());
        } else {
          this.consumeBadUrlRemnants();
          return BAD_URL_TOKEN;
        }
      } else {
        value.push(codePoint);
      }
    }
  };
  Tokenizer2.prototype.consumeWhiteSpace = function() {
    while (isWhiteSpace(this.peekCodePoint(0))) {
      this.consumeCodePoint();
    }
  };
  Tokenizer2.prototype.consumeBadUrlRemnants = function() {
    while (true) {
      var codePoint = this.consumeCodePoint();
      if (codePoint === RIGHT_PARENTHESIS || codePoint === EOF) {
        return;
      }
      if (isValidEscape(codePoint, this.peekCodePoint(0))) {
        this.consumeEscapedCodePoint();
      }
    }
  };
  Tokenizer2.prototype.consumeStringSlice = function(count) {
    var SLICE_STACK_SIZE = 5e4;
    var value = "";
    while (count > 0) {
      var amount = Math.min(SLICE_STACK_SIZE, count);
      value += fromCodePoint$1.apply(void 0, this._value.splice(0, amount));
      count -= amount;
    }
    this._value.shift();
    return value;
  };
  Tokenizer2.prototype.consumeStringToken = function(endingCodePoint) {
    var value = "";
    var i2 = 0;
    do {
      var codePoint = this._value[i2];
      if (codePoint === EOF || codePoint === void 0 || codePoint === endingCodePoint) {
        value += this.consumeStringSlice(i2);
        return { type: 0, value };
      }
      if (codePoint === LINE_FEED) {
        this._value.splice(0, i2);
        return BAD_STRING_TOKEN;
      }
      if (codePoint === REVERSE_SOLIDUS) {
        var next3 = this._value[i2 + 1];
        if (next3 !== EOF && next3 !== void 0) {
          if (next3 === LINE_FEED) {
            value += this.consumeStringSlice(i2);
            i2 = -1;
            this._value.shift();
          } else if (isValidEscape(codePoint, next3)) {
            value += this.consumeStringSlice(i2);
            value += fromCodePoint$1(this.consumeEscapedCodePoint());
            i2 = -1;
          }
        }
      }
      i2++;
    } while (true);
  };
  Tokenizer2.prototype.consumeNumber = function() {
    var repr = [];
    var type = FLAG_INTEGER;
    var c1 = this.peekCodePoint(0);
    if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
      repr.push(this.consumeCodePoint());
    }
    while (isDigit(this.peekCodePoint(0))) {
      repr.push(this.consumeCodePoint());
    }
    c1 = this.peekCodePoint(0);
    var c2 = this.peekCodePoint(1);
    if (c1 === FULL_STOP && isDigit(c2)) {
      repr.push(this.consumeCodePoint(), this.consumeCodePoint());
      type = FLAG_NUMBER;
      while (isDigit(this.peekCodePoint(0))) {
        repr.push(this.consumeCodePoint());
      }
    }
    c1 = this.peekCodePoint(0);
    c2 = this.peekCodePoint(1);
    var c3 = this.peekCodePoint(2);
    if ((c1 === E || c1 === e$1) && ((c2 === PLUS_SIGN || c2 === HYPHEN_MINUS) && isDigit(c3) || isDigit(c2))) {
      repr.push(this.consumeCodePoint(), this.consumeCodePoint());
      type = FLAG_NUMBER;
      while (isDigit(this.peekCodePoint(0))) {
        repr.push(this.consumeCodePoint());
      }
    }
    return [stringToNumber(repr), type];
  };
  Tokenizer2.prototype.consumeNumericToken = function() {
    var _a2 = this.consumeNumber(), number = _a2[0], flags = _a2[1];
    var c1 = this.peekCodePoint(0);
    var c2 = this.peekCodePoint(1);
    var c3 = this.peekCodePoint(2);
    if (isIdentifierStart(c1, c2, c3)) {
      var unit = this.consumeName();
      return { type: 15, number, flags, unit };
    }
    if (c1 === PERCENTAGE_SIGN) {
      this.consumeCodePoint();
      return { type: 16, number, flags };
    }
    return { type: 17, number, flags };
  };
  Tokenizer2.prototype.consumeEscapedCodePoint = function() {
    var codePoint = this.consumeCodePoint();
    if (isHex(codePoint)) {
      var hex = fromCodePoint$1(codePoint);
      while (isHex(this.peekCodePoint(0)) && hex.length < 6) {
        hex += fromCodePoint$1(this.consumeCodePoint());
      }
      if (isWhiteSpace(this.peekCodePoint(0))) {
        this.consumeCodePoint();
      }
      var hexCodePoint = parseInt(hex, 16);
      if (hexCodePoint === 0 || isSurrogateCodePoint(hexCodePoint) || hexCodePoint > 1114111) {
        return REPLACEMENT_CHARACTER;
      }
      return hexCodePoint;
    }
    if (codePoint === EOF) {
      return REPLACEMENT_CHARACTER;
    }
    return codePoint;
  };
  Tokenizer2.prototype.consumeName = function() {
    var result = "";
    while (true) {
      var codePoint = this.consumeCodePoint();
      if (isNameCodePoint(codePoint)) {
        result += fromCodePoint$1(codePoint);
      } else if (isValidEscape(codePoint, this.peekCodePoint(0))) {
        result += fromCodePoint$1(this.consumeEscapedCodePoint());
      } else {
        this.reconsumeCodePoint(codePoint);
        return result;
      }
    }
  };
  return Tokenizer2;
}();
var Parser$1 = function() {
  function Parser2(tokens) {
    this._tokens = tokens;
  }
  Parser2.create = function(value) {
    var tokenizer = new Tokenizer();
    tokenizer.write(value);
    return new Parser2(tokenizer.read());
  };
  Parser2.parseValue = function(value) {
    return Parser2.create(value).parseComponentValue();
  };
  Parser2.parseValues = function(value) {
    return Parser2.create(value).parseComponentValues();
  };
  Parser2.prototype.parseComponentValue = function() {
    var token = this.consumeToken();
    while (token.type === 31) {
      token = this.consumeToken();
    }
    if (token.type === 32) {
      throw new SyntaxError("Error parsing CSS component value, unexpected EOF");
    }
    this.reconsumeToken(token);
    var value = this.consumeComponentValue();
    do {
      token = this.consumeToken();
    } while (token.type === 31);
    if (token.type === 32) {
      return value;
    }
    throw new SyntaxError("Error parsing CSS component value, multiple values found when expecting only one");
  };
  Parser2.prototype.parseComponentValues = function() {
    var values3 = [];
    while (true) {
      var value = this.consumeComponentValue();
      if (value.type === 32) {
        return values3;
      }
      values3.push(value);
      values3.push();
    }
  };
  Parser2.prototype.consumeComponentValue = function() {
    var token = this.consumeToken();
    switch (token.type) {
      case 11:
      case 28:
      case 2:
        return this.consumeSimpleBlock(token.type);
      case 19:
        return this.consumeFunction(token);
    }
    return token;
  };
  Parser2.prototype.consumeSimpleBlock = function(type) {
    var block = { type, values: [] };
    var token = this.consumeToken();
    while (true) {
      if (token.type === 32 || isEndingTokenFor(token, type)) {
        return block;
      }
      this.reconsumeToken(token);
      block.values.push(this.consumeComponentValue());
      token = this.consumeToken();
    }
  };
  Parser2.prototype.consumeFunction = function(functionToken) {
    var cssFunction = {
      name: functionToken.value,
      values: [],
      type: 18
    };
    while (true) {
      var token = this.consumeToken();
      if (token.type === 32 || token.type === 3) {
        return cssFunction;
      }
      this.reconsumeToken(token);
      cssFunction.values.push(this.consumeComponentValue());
    }
  };
  Parser2.prototype.consumeToken = function() {
    var token = this._tokens.shift();
    return typeof token === "undefined" ? EOF_TOKEN : token;
  };
  Parser2.prototype.reconsumeToken = function(token) {
    this._tokens.unshift(token);
  };
  return Parser2;
}();
var isDimensionToken = function(token) {
  return token.type === 15;
};
var isNumberToken = function(token) {
  return token.type === 17;
};
var isIdentToken = function(token) {
  return token.type === 20;
};
var isStringToken = function(token) {
  return token.type === 0;
};
var isIdentWithValue = function(token, value) {
  return isIdentToken(token) && token.value === value;
};
var nonWhiteSpace = function(token) {
  return token.type !== 31;
};
var nonFunctionArgSeparator = function(token) {
  return token.type !== 31 && token.type !== 4;
};
var parseFunctionArgs = function(tokens) {
  var args = [];
  var arg = [];
  tokens.forEach(function(token) {
    if (token.type === 4) {
      if (arg.length === 0) {
        throw new Error("Error parsing function args, zero tokens for arg");
      }
      args.push(arg);
      arg = [];
      return;
    }
    if (token.type !== 31) {
      arg.push(token);
    }
  });
  if (arg.length) {
    args.push(arg);
  }
  return args;
};
var isEndingTokenFor = function(token, type) {
  if (type === 11 && token.type === 12) {
    return true;
  }
  if (type === 28 && token.type === 29) {
    return true;
  }
  return type === 2 && token.type === 3;
};
var isLength = function(token) {
  return token.type === 17 || token.type === 15;
};
var isLengthPercentage = function(token) {
  return token.type === 16 || isLength(token);
};
var parseLengthPercentageTuple = function(tokens) {
  return tokens.length > 1 ? [tokens[0], tokens[1]] : [tokens[0]];
};
var ZERO_LENGTH = {
  type: 17,
  number: 0,
  flags: FLAG_INTEGER
};
var FIFTY_PERCENT = {
  type: 16,
  number: 50,
  flags: FLAG_INTEGER
};
var HUNDRED_PERCENT = {
  type: 16,
  number: 100,
  flags: FLAG_INTEGER
};
var getAbsoluteValueForTuple = function(tuple, width, height) {
  var x2 = tuple[0], y2 = tuple[1];
  return [getAbsoluteValue(x2, width), getAbsoluteValue(typeof y2 !== "undefined" ? y2 : x2, height)];
};
var getAbsoluteValue = function(token, parent) {
  if (token.type === 16) {
    return token.number / 100 * parent;
  }
  if (isDimensionToken(token)) {
    switch (token.unit) {
      case "rem":
      case "em":
        return 16 * token.number;
      case "px":
      default:
        return token.number;
    }
  }
  return token.number;
};
var DEG = "deg";
var GRAD = "grad";
var RAD = "rad";
var TURN = "turn";
var angle = {
  name: "angle",
  parse: function(_context, value) {
    if (value.type === 15) {
      switch (value.unit) {
        case DEG:
          return Math.PI * value.number / 180;
        case GRAD:
          return Math.PI / 200 * value.number;
        case RAD:
          return value.number;
        case TURN:
          return Math.PI * 2 * value.number;
      }
    }
    throw new Error("Unsupported angle type");
  }
};
var isAngle = function(value) {
  if (value.type === 15) {
    if (value.unit === DEG || value.unit === GRAD || value.unit === RAD || value.unit === TURN) {
      return true;
    }
  }
  return false;
};
var parseNamedSide = function(tokens) {
  var sideOrCorner = tokens.filter(isIdentToken).map(function(ident) {
    return ident.value;
  }).join(" ");
  switch (sideOrCorner) {
    case "to bottom right":
    case "to right bottom":
    case "left top":
    case "top left":
      return [ZERO_LENGTH, ZERO_LENGTH];
    case "to top":
    case "bottom":
      return deg(0);
    case "to bottom left":
    case "to left bottom":
    case "right top":
    case "top right":
      return [ZERO_LENGTH, HUNDRED_PERCENT];
    case "to right":
    case "left":
      return deg(90);
    case "to top left":
    case "to left top":
    case "right bottom":
    case "bottom right":
      return [HUNDRED_PERCENT, HUNDRED_PERCENT];
    case "to bottom":
    case "top":
      return deg(180);
    case "to top right":
    case "to right top":
    case "left bottom":
    case "bottom left":
      return [HUNDRED_PERCENT, ZERO_LENGTH];
    case "to left":
    case "right":
      return deg(270);
  }
  return 0;
};
var deg = function(deg2) {
  return Math.PI * deg2 / 180;
};
var color$1 = {
  name: "color",
  parse: function(context2, value) {
    if (value.type === 18) {
      var colorFunction = SUPPORTED_COLOR_FUNCTIONS[value.name];
      if (typeof colorFunction === "undefined") {
        throw new Error('Attempting to parse an unsupported color function "' + value.name + '"');
      }
      return colorFunction(context2, value.values);
    }
    if (value.type === 5) {
      if (value.value.length === 3) {
        var r2 = value.value.substring(0, 1);
        var g2 = value.value.substring(1, 2);
        var b2 = value.value.substring(2, 3);
        return pack(parseInt(r2 + r2, 16), parseInt(g2 + g2, 16), parseInt(b2 + b2, 16), 1);
      }
      if (value.value.length === 4) {
        var r2 = value.value.substring(0, 1);
        var g2 = value.value.substring(1, 2);
        var b2 = value.value.substring(2, 3);
        var a2 = value.value.substring(3, 4);
        return pack(parseInt(r2 + r2, 16), parseInt(g2 + g2, 16), parseInt(b2 + b2, 16), parseInt(a2 + a2, 16) / 255);
      }
      if (value.value.length === 6) {
        var r2 = value.value.substring(0, 2);
        var g2 = value.value.substring(2, 4);
        var b2 = value.value.substring(4, 6);
        return pack(parseInt(r2, 16), parseInt(g2, 16), parseInt(b2, 16), 1);
      }
      if (value.value.length === 8) {
        var r2 = value.value.substring(0, 2);
        var g2 = value.value.substring(2, 4);
        var b2 = value.value.substring(4, 6);
        var a2 = value.value.substring(6, 8);
        return pack(parseInt(r2, 16), parseInt(g2, 16), parseInt(b2, 16), parseInt(a2, 16) / 255);
      }
    }
    if (value.type === 20) {
      var namedColor = COLORS[value.value.toUpperCase()];
      if (typeof namedColor !== "undefined") {
        return namedColor;
      }
    }
    return COLORS.TRANSPARENT;
  }
};
var isTransparent = function(color2) {
  return (255 & color2) === 0;
};
var asString = function(color2) {
  var alpha = 255 & color2;
  var blue = 255 & color2 >> 8;
  var green = 255 & color2 >> 16;
  var red = 255 & color2 >> 24;
  return alpha < 255 ? "rgba(" + red + "," + green + "," + blue + "," + alpha / 255 + ")" : "rgb(" + red + "," + green + "," + blue + ")";
};
var pack = function(r2, g2, b2, a2) {
  return (r2 << 24 | g2 << 16 | b2 << 8 | Math.round(a2 * 255) << 0) >>> 0;
};
var getTokenColorValue = function(token, i2) {
  if (token.type === 17) {
    return token.number;
  }
  if (token.type === 16) {
    var max2 = i2 === 3 ? 1 : 255;
    return i2 === 3 ? token.number / 100 * max2 : Math.round(token.number / 100 * max2);
  }
  return 0;
};
var rgb = function(_context, args) {
  var tokens = args.filter(nonFunctionArgSeparator);
  if (tokens.length === 3) {
    var _a2 = tokens.map(getTokenColorValue), r2 = _a2[0], g2 = _a2[1], b2 = _a2[2];
    return pack(r2, g2, b2, 1);
  }
  if (tokens.length === 4) {
    var _b2 = tokens.map(getTokenColorValue), r2 = _b2[0], g2 = _b2[1], b2 = _b2[2], a2 = _b2[3];
    return pack(r2, g2, b2, a2);
  }
  return 0;
};
function hue2rgb(t1, t22, hue) {
  if (hue < 0) {
    hue += 1;
  }
  if (hue >= 1) {
    hue -= 1;
  }
  if (hue < 1 / 6) {
    return (t22 - t1) * hue * 6 + t1;
  } else if (hue < 1 / 2) {
    return t22;
  } else if (hue < 2 / 3) {
    return (t22 - t1) * 6 * (2 / 3 - hue) + t1;
  } else {
    return t1;
  }
}
var hsl = function(context2, args) {
  var tokens = args.filter(nonFunctionArgSeparator);
  var hue = tokens[0], saturation = tokens[1], lightness = tokens[2], alpha = tokens[3];
  var h2 = (hue.type === 17 ? deg(hue.number) : angle.parse(context2, hue)) / (Math.PI * 2);
  var s2 = isLengthPercentage(saturation) ? saturation.number / 100 : 0;
  var l2 = isLengthPercentage(lightness) ? lightness.number / 100 : 0;
  var a2 = typeof alpha !== "undefined" && isLengthPercentage(alpha) ? getAbsoluteValue(alpha, 1) : 1;
  if (s2 === 0) {
    return pack(l2 * 255, l2 * 255, l2 * 255, 1);
  }
  var t22 = l2 <= 0.5 ? l2 * (s2 + 1) : l2 + s2 - l2 * s2;
  var t1 = l2 * 2 - t22;
  var r2 = hue2rgb(t1, t22, h2 + 1 / 3);
  var g2 = hue2rgb(t1, t22, h2);
  var b2 = hue2rgb(t1, t22, h2 - 1 / 3);
  return pack(r2 * 255, g2 * 255, b2 * 255, a2);
};
var SUPPORTED_COLOR_FUNCTIONS = {
  hsl,
  hsla: hsl,
  rgb,
  rgba: rgb
};
var parseColor = function(context2, value) {
  return color$1.parse(context2, Parser$1.create(value).parseComponentValue());
};
var COLORS = {
  ALICEBLUE: 4042850303,
  ANTIQUEWHITE: 4209760255,
  AQUA: 16777215,
  AQUAMARINE: 2147472639,
  AZURE: 4043309055,
  BEIGE: 4126530815,
  BISQUE: 4293182719,
  BLACK: 255,
  BLANCHEDALMOND: 4293643775,
  BLUE: 65535,
  BLUEVIOLET: 2318131967,
  BROWN: 2771004159,
  BURLYWOOD: 3736635391,
  CADETBLUE: 1604231423,
  CHARTREUSE: 2147418367,
  CHOCOLATE: 3530104575,
  CORAL: 4286533887,
  CORNFLOWERBLUE: 1687547391,
  CORNSILK: 4294499583,
  CRIMSON: 3692313855,
  CYAN: 16777215,
  DARKBLUE: 35839,
  DARKCYAN: 9145343,
  DARKGOLDENROD: 3095837695,
  DARKGRAY: 2846468607,
  DARKGREEN: 6553855,
  DARKGREY: 2846468607,
  DARKKHAKI: 3182914559,
  DARKMAGENTA: 2332068863,
  DARKOLIVEGREEN: 1433087999,
  DARKORANGE: 4287365375,
  DARKORCHID: 2570243327,
  DARKRED: 2332033279,
  DARKSALMON: 3918953215,
  DARKSEAGREEN: 2411499519,
  DARKSLATEBLUE: 1211993087,
  DARKSLATEGRAY: 793726975,
  DARKSLATEGREY: 793726975,
  DARKTURQUOISE: 13554175,
  DARKVIOLET: 2483082239,
  DEEPPINK: 4279538687,
  DEEPSKYBLUE: 12582911,
  DIMGRAY: 1768516095,
  DIMGREY: 1768516095,
  DODGERBLUE: 512819199,
  FIREBRICK: 2988581631,
  FLORALWHITE: 4294635775,
  FORESTGREEN: 579543807,
  FUCHSIA: 4278255615,
  GAINSBORO: 3705462015,
  GHOSTWHITE: 4177068031,
  GOLD: 4292280575,
  GOLDENROD: 3668254975,
  GRAY: 2155905279,
  GREEN: 8388863,
  GREENYELLOW: 2919182335,
  GREY: 2155905279,
  HONEYDEW: 4043305215,
  HOTPINK: 4285117695,
  INDIANRED: 3445382399,
  INDIGO: 1258324735,
  IVORY: 4294963455,
  KHAKI: 4041641215,
  LAVENDER: 3873897215,
  LAVENDERBLUSH: 4293981695,
  LAWNGREEN: 2096890111,
  LEMONCHIFFON: 4294626815,
  LIGHTBLUE: 2916673279,
  LIGHTCORAL: 4034953471,
  LIGHTCYAN: 3774873599,
  LIGHTGOLDENRODYELLOW: 4210742015,
  LIGHTGRAY: 3553874943,
  LIGHTGREEN: 2431553791,
  LIGHTGREY: 3553874943,
  LIGHTPINK: 4290167295,
  LIGHTSALMON: 4288707327,
  LIGHTSEAGREEN: 548580095,
  LIGHTSKYBLUE: 2278488831,
  LIGHTSLATEGRAY: 2005441023,
  LIGHTSLATEGREY: 2005441023,
  LIGHTSTEELBLUE: 2965692159,
  LIGHTYELLOW: 4294959359,
  LIME: 16711935,
  LIMEGREEN: 852308735,
  LINEN: 4210091775,
  MAGENTA: 4278255615,
  MAROON: 2147483903,
  MEDIUMAQUAMARINE: 1724754687,
  MEDIUMBLUE: 52735,
  MEDIUMORCHID: 3126187007,
  MEDIUMPURPLE: 2473647103,
  MEDIUMSEAGREEN: 1018393087,
  MEDIUMSLATEBLUE: 2070474495,
  MEDIUMSPRINGGREEN: 16423679,
  MEDIUMTURQUOISE: 1221709055,
  MEDIUMVIOLETRED: 3340076543,
  MIDNIGHTBLUE: 421097727,
  MINTCREAM: 4127193855,
  MISTYROSE: 4293190143,
  MOCCASIN: 4293178879,
  NAVAJOWHITE: 4292783615,
  NAVY: 33023,
  OLDLACE: 4260751103,
  OLIVE: 2155872511,
  OLIVEDRAB: 1804477439,
  ORANGE: 4289003775,
  ORANGERED: 4282712319,
  ORCHID: 3664828159,
  PALEGOLDENROD: 4008225535,
  PALEGREEN: 2566625535,
  PALETURQUOISE: 2951671551,
  PALEVIOLETRED: 3681588223,
  PAPAYAWHIP: 4293907967,
  PEACHPUFF: 4292524543,
  PERU: 3448061951,
  PINK: 4290825215,
  PLUM: 3718307327,
  POWDERBLUE: 2967529215,
  PURPLE: 2147516671,
  REBECCAPURPLE: 1714657791,
  RED: 4278190335,
  ROSYBROWN: 3163525119,
  ROYALBLUE: 1097458175,
  SADDLEBROWN: 2336560127,
  SALMON: 4202722047,
  SANDYBROWN: 4104413439,
  SEAGREEN: 780883967,
  SEASHELL: 4294307583,
  SIENNA: 2689740287,
  SILVER: 3233857791,
  SKYBLUE: 2278484991,
  SLATEBLUE: 1784335871,
  SLATEGRAY: 1887473919,
  SLATEGREY: 1887473919,
  SNOW: 4294638335,
  SPRINGGREEN: 16744447,
  STEELBLUE: 1182971135,
  TAN: 3535047935,
  TEAL: 8421631,
  THISTLE: 3636451583,
  TOMATO: 4284696575,
  TRANSPARENT: 0,
  TURQUOISE: 1088475391,
  VIOLET: 4001558271,
  WHEAT: 4125012991,
  WHITE: 4294967295,
  WHITESMOKE: 4126537215,
  YELLOW: 4294902015,
  YELLOWGREEN: 2597139199
};
var backgroundClip = {
  name: "background-clip",
  initialValue: "border-box",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return tokens.map(function(token) {
      if (isIdentToken(token)) {
        switch (token.value) {
          case "padding-box":
            return 1;
          case "content-box":
            return 2;
        }
      }
      return 0;
    });
  }
};
var backgroundColor = {
  name: "background-color",
  initialValue: "transparent",
  prefix: false,
  type: 3,
  format: "color"
};
var parseColorStop = function(context2, args) {
  var color2 = color$1.parse(context2, args[0]);
  var stop = args[1];
  return stop && isLengthPercentage(stop) ? { color: color2, stop } : { color: color2, stop: null };
};
var processColorStops = function(stops, lineLength) {
  var first = stops[0];
  var last = stops[stops.length - 1];
  if (first.stop === null) {
    first.stop = ZERO_LENGTH;
  }
  if (last.stop === null) {
    last.stop = HUNDRED_PERCENT;
  }
  var processStops = [];
  var previous = 0;
  for (var i2 = 0; i2 < stops.length; i2++) {
    var stop_1 = stops[i2].stop;
    if (stop_1 !== null) {
      var absoluteValue = getAbsoluteValue(stop_1, lineLength);
      if (absoluteValue > previous) {
        processStops.push(absoluteValue);
      } else {
        processStops.push(previous);
      }
      previous = absoluteValue;
    } else {
      processStops.push(null);
    }
  }
  var gapBegin = null;
  for (var i2 = 0; i2 < processStops.length; i2++) {
    var stop_2 = processStops[i2];
    if (stop_2 === null) {
      if (gapBegin === null) {
        gapBegin = i2;
      }
    } else if (gapBegin !== null) {
      var gapLength = i2 - gapBegin;
      var beforeGap = processStops[gapBegin - 1];
      var gapValue = (stop_2 - beforeGap) / (gapLength + 1);
      for (var g2 = 1; g2 <= gapLength; g2++) {
        processStops[gapBegin + g2 - 1] = gapValue * g2;
      }
      gapBegin = null;
    }
  }
  return stops.map(function(_a2, i3) {
    var color2 = _a2.color;
    return { color: color2, stop: Math.max(Math.min(1, processStops[i3] / lineLength), 0) };
  });
};
var getAngleFromCorner = function(corner, width, height) {
  var centerX = width / 2;
  var centerY = height / 2;
  var x2 = getAbsoluteValue(corner[0], width) - centerX;
  var y2 = centerY - getAbsoluteValue(corner[1], height);
  return (Math.atan2(y2, x2) + Math.PI * 2) % (Math.PI * 2);
};
var calculateGradientDirection = function(angle2, width, height) {
  var radian = typeof angle2 === "number" ? angle2 : getAngleFromCorner(angle2, width, height);
  var lineLength = Math.abs(width * Math.sin(radian)) + Math.abs(height * Math.cos(radian));
  var halfWidth = width / 2;
  var halfHeight = height / 2;
  var halfLineLength = lineLength / 2;
  var yDiff = Math.sin(radian - Math.PI / 2) * halfLineLength;
  var xDiff = Math.cos(radian - Math.PI / 2) * halfLineLength;
  return [lineLength, halfWidth - xDiff, halfWidth + xDiff, halfHeight - yDiff, halfHeight + yDiff];
};
var distance = function(a2, b2) {
  return Math.sqrt(a2 * a2 + b2 * b2);
};
var findCorner = function(width, height, x2, y2, closest) {
  var corners = [
    [0, 0],
    [0, height],
    [width, 0],
    [width, height]
  ];
  return corners.reduce(function(stat, corner) {
    var cx = corner[0], cy = corner[1];
    var d2 = distance(x2 - cx, y2 - cy);
    if (closest ? d2 < stat.optimumDistance : d2 > stat.optimumDistance) {
      return {
        optimumCorner: corner,
        optimumDistance: d2
      };
    }
    return stat;
  }, {
    optimumDistance: closest ? Infinity : -Infinity,
    optimumCorner: null
  }).optimumCorner;
};
var calculateRadius = function(gradient, x2, y2, width, height) {
  var rx = 0;
  var ry = 0;
  switch (gradient.size) {
    case 0:
      if (gradient.shape === 0) {
        rx = ry = Math.min(Math.abs(x2), Math.abs(x2 - width), Math.abs(y2), Math.abs(y2 - height));
      } else if (gradient.shape === 1) {
        rx = Math.min(Math.abs(x2), Math.abs(x2 - width));
        ry = Math.min(Math.abs(y2), Math.abs(y2 - height));
      }
      break;
    case 2:
      if (gradient.shape === 0) {
        rx = ry = Math.min(distance(x2, y2), distance(x2, y2 - height), distance(x2 - width, y2), distance(x2 - width, y2 - height));
      } else if (gradient.shape === 1) {
        var c2 = Math.min(Math.abs(y2), Math.abs(y2 - height)) / Math.min(Math.abs(x2), Math.abs(x2 - width));
        var _a2 = findCorner(width, height, x2, y2, true), cx = _a2[0], cy = _a2[1];
        rx = distance(cx - x2, (cy - y2) / c2);
        ry = c2 * rx;
      }
      break;
    case 1:
      if (gradient.shape === 0) {
        rx = ry = Math.max(Math.abs(x2), Math.abs(x2 - width), Math.abs(y2), Math.abs(y2 - height));
      } else if (gradient.shape === 1) {
        rx = Math.max(Math.abs(x2), Math.abs(x2 - width));
        ry = Math.max(Math.abs(y2), Math.abs(y2 - height));
      }
      break;
    case 3:
      if (gradient.shape === 0) {
        rx = ry = Math.max(distance(x2, y2), distance(x2, y2 - height), distance(x2 - width, y2), distance(x2 - width, y2 - height));
      } else if (gradient.shape === 1) {
        var c2 = Math.max(Math.abs(y2), Math.abs(y2 - height)) / Math.max(Math.abs(x2), Math.abs(x2 - width));
        var _b2 = findCorner(width, height, x2, y2, false), cx = _b2[0], cy = _b2[1];
        rx = distance(cx - x2, (cy - y2) / c2);
        ry = c2 * rx;
      }
      break;
  }
  if (Array.isArray(gradient.size)) {
    rx = getAbsoluteValue(gradient.size[0], width);
    ry = gradient.size.length === 2 ? getAbsoluteValue(gradient.size[1], height) : rx;
  }
  return [rx, ry];
};
var linearGradient = function(context2, tokens) {
  var angle$1 = deg(180);
  var stops = [];
  parseFunctionArgs(tokens).forEach(function(arg, i2) {
    if (i2 === 0) {
      var firstToken = arg[0];
      if (firstToken.type === 20 && firstToken.value === "to") {
        angle$1 = parseNamedSide(arg);
        return;
      } else if (isAngle(firstToken)) {
        angle$1 = angle.parse(context2, firstToken);
        return;
      }
    }
    var colorStop = parseColorStop(context2, arg);
    stops.push(colorStop);
  });
  return { angle: angle$1, stops, type: 1 };
};
var prefixLinearGradient = function(context2, tokens) {
  var angle$1 = deg(180);
  var stops = [];
  parseFunctionArgs(tokens).forEach(function(arg, i2) {
    if (i2 === 0) {
      var firstToken = arg[0];
      if (firstToken.type === 20 && ["top", "left", "right", "bottom"].indexOf(firstToken.value) !== -1) {
        angle$1 = parseNamedSide(arg);
        return;
      } else if (isAngle(firstToken)) {
        angle$1 = (angle.parse(context2, firstToken) + deg(270)) % deg(360);
        return;
      }
    }
    var colorStop = parseColorStop(context2, arg);
    stops.push(colorStop);
  });
  return {
    angle: angle$1,
    stops,
    type: 1
  };
};
var webkitGradient = function(context2, tokens) {
  var angle2 = deg(180);
  var stops = [];
  var type = 1;
  var shape = 0;
  var size = 3;
  var position2 = [];
  parseFunctionArgs(tokens).forEach(function(arg, i2) {
    var firstToken = arg[0];
    if (i2 === 0) {
      if (isIdentToken(firstToken) && firstToken.value === "linear") {
        type = 1;
        return;
      } else if (isIdentToken(firstToken) && firstToken.value === "radial") {
        type = 2;
        return;
      }
    }
    if (firstToken.type === 18) {
      if (firstToken.name === "from") {
        var color2 = color$1.parse(context2, firstToken.values[0]);
        stops.push({ stop: ZERO_LENGTH, color: color2 });
      } else if (firstToken.name === "to") {
        var color2 = color$1.parse(context2, firstToken.values[0]);
        stops.push({ stop: HUNDRED_PERCENT, color: color2 });
      } else if (firstToken.name === "color-stop") {
        var values3 = firstToken.values.filter(nonFunctionArgSeparator);
        if (values3.length === 2) {
          var color2 = color$1.parse(context2, values3[1]);
          var stop_1 = values3[0];
          if (isNumberToken(stop_1)) {
            stops.push({
              stop: { type: 16, number: stop_1.number * 100, flags: stop_1.flags },
              color: color2
            });
          }
        }
      }
    }
  });
  return type === 1 ? {
    angle: (angle2 + deg(180)) % deg(360),
    stops,
    type
  } : { size, shape, stops, position: position2, type };
};
var CLOSEST_SIDE = "closest-side";
var FARTHEST_SIDE = "farthest-side";
var CLOSEST_CORNER = "closest-corner";
var FARTHEST_CORNER = "farthest-corner";
var CIRCLE = "circle";
var ELLIPSE = "ellipse";
var COVER = "cover";
var CONTAIN = "contain";
var radialGradient = function(context2, tokens) {
  var shape = 0;
  var size = 3;
  var stops = [];
  var position2 = [];
  parseFunctionArgs(tokens).forEach(function(arg, i2) {
    var isColorStop = true;
    if (i2 === 0) {
      var isAtPosition_1 = false;
      isColorStop = arg.reduce(function(acc, token) {
        if (isAtPosition_1) {
          if (isIdentToken(token)) {
            switch (token.value) {
              case "center":
                position2.push(FIFTY_PERCENT);
                return acc;
              case "top":
              case "left":
                position2.push(ZERO_LENGTH);
                return acc;
              case "right":
              case "bottom":
                position2.push(HUNDRED_PERCENT);
                return acc;
            }
          } else if (isLengthPercentage(token) || isLength(token)) {
            position2.push(token);
          }
        } else if (isIdentToken(token)) {
          switch (token.value) {
            case CIRCLE:
              shape = 0;
              return false;
            case ELLIPSE:
              shape = 1;
              return false;
            case "at":
              isAtPosition_1 = true;
              return false;
            case CLOSEST_SIDE:
              size = 0;
              return false;
            case COVER:
            case FARTHEST_SIDE:
              size = 1;
              return false;
            case CONTAIN:
            case CLOSEST_CORNER:
              size = 2;
              return false;
            case FARTHEST_CORNER:
              size = 3;
              return false;
          }
        } else if (isLength(token) || isLengthPercentage(token)) {
          if (!Array.isArray(size)) {
            size = [];
          }
          size.push(token);
          return false;
        }
        return acc;
      }, isColorStop);
    }
    if (isColorStop) {
      var colorStop = parseColorStop(context2, arg);
      stops.push(colorStop);
    }
  });
  return { size, shape, stops, position: position2, type: 2 };
};
var prefixRadialGradient = function(context2, tokens) {
  var shape = 0;
  var size = 3;
  var stops = [];
  var position2 = [];
  parseFunctionArgs(tokens).forEach(function(arg, i2) {
    var isColorStop = true;
    if (i2 === 0) {
      isColorStop = arg.reduce(function(acc, token) {
        if (isIdentToken(token)) {
          switch (token.value) {
            case "center":
              position2.push(FIFTY_PERCENT);
              return false;
            case "top":
            case "left":
              position2.push(ZERO_LENGTH);
              return false;
            case "right":
            case "bottom":
              position2.push(HUNDRED_PERCENT);
              return false;
          }
        } else if (isLengthPercentage(token) || isLength(token)) {
          position2.push(token);
          return false;
        }
        return acc;
      }, isColorStop);
    } else if (i2 === 1) {
      isColorStop = arg.reduce(function(acc, token) {
        if (isIdentToken(token)) {
          switch (token.value) {
            case CIRCLE:
              shape = 0;
              return false;
            case ELLIPSE:
              shape = 1;
              return false;
            case CONTAIN:
            case CLOSEST_SIDE:
              size = 0;
              return false;
            case FARTHEST_SIDE:
              size = 1;
              return false;
            case CLOSEST_CORNER:
              size = 2;
              return false;
            case COVER:
            case FARTHEST_CORNER:
              size = 3;
              return false;
          }
        } else if (isLength(token) || isLengthPercentage(token)) {
          if (!Array.isArray(size)) {
            size = [];
          }
          size.push(token);
          return false;
        }
        return acc;
      }, isColorStop);
    }
    if (isColorStop) {
      var colorStop = parseColorStop(context2, arg);
      stops.push(colorStop);
    }
  });
  return { size, shape, stops, position: position2, type: 2 };
};
var isLinearGradient = function(background) {
  return background.type === 1;
};
var isRadialGradient = function(background) {
  return background.type === 2;
};
var image = {
  name: "image",
  parse: function(context2, value) {
    if (value.type === 22) {
      var image_1 = { url: value.value, type: 0 };
      context2.cache.addImage(value.value);
      return image_1;
    }
    if (value.type === 18) {
      var imageFunction = SUPPORTED_IMAGE_FUNCTIONS[value.name];
      if (typeof imageFunction === "undefined") {
        throw new Error('Attempting to parse an unsupported image function "' + value.name + '"');
      }
      return imageFunction(context2, value.values);
    }
    throw new Error("Unsupported image type " + value.type);
  }
};
function isSupportedImage(value) {
  return !(value.type === 20 && value.value === "none") && (value.type !== 18 || !!SUPPORTED_IMAGE_FUNCTIONS[value.name]);
}
var SUPPORTED_IMAGE_FUNCTIONS = {
  "linear-gradient": linearGradient,
  "-moz-linear-gradient": prefixLinearGradient,
  "-ms-linear-gradient": prefixLinearGradient,
  "-o-linear-gradient": prefixLinearGradient,
  "-webkit-linear-gradient": prefixLinearGradient,
  "radial-gradient": radialGradient,
  "-moz-radial-gradient": prefixRadialGradient,
  "-ms-radial-gradient": prefixRadialGradient,
  "-o-radial-gradient": prefixRadialGradient,
  "-webkit-radial-gradient": prefixRadialGradient,
  "-webkit-gradient": webkitGradient
};
var backgroundImage = {
  name: "background-image",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(context2, tokens) {
    if (tokens.length === 0) {
      return [];
    }
    var first = tokens[0];
    if (first.type === 20 && first.value === "none") {
      return [];
    }
    return tokens.filter(function(value) {
      return nonFunctionArgSeparator(value) && isSupportedImage(value);
    }).map(function(value) {
      return image.parse(context2, value);
    });
  }
};
var backgroundOrigin = {
  name: "background-origin",
  initialValue: "border-box",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return tokens.map(function(token) {
      if (isIdentToken(token)) {
        switch (token.value) {
          case "padding-box":
            return 1;
          case "content-box":
            return 2;
        }
      }
      return 0;
    });
  }
};
var backgroundPosition = {
  name: "background-position",
  initialValue: "0% 0%",
  type: 1,
  prefix: false,
  parse: function(_context, tokens) {
    return parseFunctionArgs(tokens).map(function(values3) {
      return values3.filter(isLengthPercentage);
    }).map(parseLengthPercentageTuple);
  }
};
var backgroundRepeat = {
  name: "background-repeat",
  initialValue: "repeat",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return parseFunctionArgs(tokens).map(function(values3) {
      return values3.filter(isIdentToken).map(function(token) {
        return token.value;
      }).join(" ");
    }).map(parseBackgroundRepeat);
  }
};
var parseBackgroundRepeat = function(value) {
  switch (value) {
    case "no-repeat":
      return 1;
    case "repeat-x":
    case "repeat no-repeat":
      return 2;
    case "repeat-y":
    case "no-repeat repeat":
      return 3;
    case "repeat":
    default:
      return 0;
  }
};
var BACKGROUND_SIZE;
(function(BACKGROUND_SIZE2) {
  BACKGROUND_SIZE2["AUTO"] = "auto";
  BACKGROUND_SIZE2["CONTAIN"] = "contain";
  BACKGROUND_SIZE2["COVER"] = "cover";
})(BACKGROUND_SIZE || (BACKGROUND_SIZE = {}));
var backgroundSize = {
  name: "background-size",
  initialValue: "0",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return parseFunctionArgs(tokens).map(function(values3) {
      return values3.filter(isBackgroundSizeInfoToken);
    });
  }
};
var isBackgroundSizeInfoToken = function(value) {
  return isIdentToken(value) || isLengthPercentage(value);
};
var borderColorForSide = function(side) {
  return {
    name: "border-" + side + "-color",
    initialValue: "transparent",
    prefix: false,
    type: 3,
    format: "color"
  };
};
var borderTopColor = borderColorForSide("top");
var borderRightColor = borderColorForSide("right");
var borderBottomColor = borderColorForSide("bottom");
var borderLeftColor = borderColorForSide("left");
var borderRadiusForSide = function(side) {
  return {
    name: "border-radius-" + side,
    initialValue: "0 0",
    prefix: false,
    type: 1,
    parse: function(_context, tokens) {
      return parseLengthPercentageTuple(tokens.filter(isLengthPercentage));
    }
  };
};
var borderTopLeftRadius = borderRadiusForSide("top-left");
var borderTopRightRadius = borderRadiusForSide("top-right");
var borderBottomRightRadius = borderRadiusForSide("bottom-right");
var borderBottomLeftRadius = borderRadiusForSide("bottom-left");
var borderStyleForSide = function(side) {
  return {
    name: "border-" + side + "-style",
    initialValue: "solid",
    prefix: false,
    type: 2,
    parse: function(_context, style2) {
      switch (style2) {
        case "none":
          return 0;
        case "dashed":
          return 2;
        case "dotted":
          return 3;
        case "double":
          return 4;
      }
      return 1;
    }
  };
};
var borderTopStyle = borderStyleForSide("top");
var borderRightStyle = borderStyleForSide("right");
var borderBottomStyle = borderStyleForSide("bottom");
var borderLeftStyle = borderStyleForSide("left");
var borderWidthForSide = function(side) {
  return {
    name: "border-" + side + "-width",
    initialValue: "0",
    type: 0,
    prefix: false,
    parse: function(_context, token) {
      if (isDimensionToken(token)) {
        return token.number;
      }
      return 0;
    }
  };
};
var borderTopWidth = borderWidthForSide("top");
var borderRightWidth = borderWidthForSide("right");
var borderBottomWidth = borderWidthForSide("bottom");
var borderLeftWidth = borderWidthForSide("left");
var color = {
  name: "color",
  initialValue: "transparent",
  prefix: false,
  type: 3,
  format: "color"
};
var direction = {
  name: "direction",
  initialValue: "ltr",
  prefix: false,
  type: 2,
  parse: function(_context, direction2) {
    switch (direction2) {
      case "rtl":
        return 1;
      case "ltr":
      default:
        return 0;
    }
  }
};
var display = {
  name: "display",
  initialValue: "inline-block",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return tokens.filter(isIdentToken).reduce(function(bit, token) {
      return bit | parseDisplayValue(token.value);
    }, 0);
  }
};
var parseDisplayValue = function(display2) {
  switch (display2) {
    case "block":
    case "-webkit-box":
      return 2;
    case "inline":
      return 4;
    case "run-in":
      return 8;
    case "flow":
      return 16;
    case "flow-root":
      return 32;
    case "table":
      return 64;
    case "flex":
    case "-webkit-flex":
      return 128;
    case "grid":
    case "-ms-grid":
      return 256;
    case "ruby":
      return 512;
    case "subgrid":
      return 1024;
    case "list-item":
      return 2048;
    case "table-row-group":
      return 4096;
    case "table-header-group":
      return 8192;
    case "table-footer-group":
      return 16384;
    case "table-row":
      return 32768;
    case "table-cell":
      return 65536;
    case "table-column-group":
      return 131072;
    case "table-column":
      return 262144;
    case "table-caption":
      return 524288;
    case "ruby-base":
      return 1048576;
    case "ruby-text":
      return 2097152;
    case "ruby-base-container":
      return 4194304;
    case "ruby-text-container":
      return 8388608;
    case "contents":
      return 16777216;
    case "inline-block":
      return 33554432;
    case "inline-list-item":
      return 67108864;
    case "inline-table":
      return 134217728;
    case "inline-flex":
      return 268435456;
    case "inline-grid":
      return 536870912;
  }
  return 0;
};
var float = {
  name: "float",
  initialValue: "none",
  prefix: false,
  type: 2,
  parse: function(_context, float2) {
    switch (float2) {
      case "left":
        return 1;
      case "right":
        return 2;
      case "inline-start":
        return 3;
      case "inline-end":
        return 4;
    }
    return 0;
  }
};
var letterSpacing = {
  name: "letter-spacing",
  initialValue: "0",
  prefix: false,
  type: 0,
  parse: function(_context, token) {
    if (token.type === 20 && token.value === "normal") {
      return 0;
    }
    if (token.type === 17) {
      return token.number;
    }
    if (token.type === 15) {
      return token.number;
    }
    return 0;
  }
};
var LINE_BREAK;
(function(LINE_BREAK2) {
  LINE_BREAK2["NORMAL"] = "normal";
  LINE_BREAK2["STRICT"] = "strict";
})(LINE_BREAK || (LINE_BREAK = {}));
var lineBreak = {
  name: "line-break",
  initialValue: "normal",
  prefix: false,
  type: 2,
  parse: function(_context, lineBreak2) {
    switch (lineBreak2) {
      case "strict":
        return LINE_BREAK.STRICT;
      case "normal":
      default:
        return LINE_BREAK.NORMAL;
    }
  }
};
var lineHeight = {
  name: "line-height",
  initialValue: "normal",
  prefix: false,
  type: 4
};
var computeLineHeight = function(token, fontSize2) {
  if (isIdentToken(token) && token.value === "normal") {
    return 1.2 * fontSize2;
  } else if (token.type === 17) {
    return fontSize2 * token.number;
  } else if (isLengthPercentage(token)) {
    return getAbsoluteValue(token, fontSize2);
  }
  return fontSize2;
};
var listStyleImage = {
  name: "list-style-image",
  initialValue: "none",
  type: 0,
  prefix: false,
  parse: function(context2, token) {
    if (token.type === 20 && token.value === "none") {
      return null;
    }
    return image.parse(context2, token);
  }
};
var listStylePosition = {
  name: "list-style-position",
  initialValue: "outside",
  prefix: false,
  type: 2,
  parse: function(_context, position2) {
    switch (position2) {
      case "inside":
        return 0;
      case "outside":
      default:
        return 1;
    }
  }
};
var listStyleType = {
  name: "list-style-type",
  initialValue: "none",
  prefix: false,
  type: 2,
  parse: function(_context, type) {
    switch (type) {
      case "disc":
        return 0;
      case "circle":
        return 1;
      case "square":
        return 2;
      case "decimal":
        return 3;
      case "cjk-decimal":
        return 4;
      case "decimal-leading-zero":
        return 5;
      case "lower-roman":
        return 6;
      case "upper-roman":
        return 7;
      case "lower-greek":
        return 8;
      case "lower-alpha":
        return 9;
      case "upper-alpha":
        return 10;
      case "arabic-indic":
        return 11;
      case "armenian":
        return 12;
      case "bengali":
        return 13;
      case "cambodian":
        return 14;
      case "cjk-earthly-branch":
        return 15;
      case "cjk-heavenly-stem":
        return 16;
      case "cjk-ideographic":
        return 17;
      case "devanagari":
        return 18;
      case "ethiopic-numeric":
        return 19;
      case "georgian":
        return 20;
      case "gujarati":
        return 21;
      case "gurmukhi":
        return 22;
      case "hebrew":
        return 22;
      case "hiragana":
        return 23;
      case "hiragana-iroha":
        return 24;
      case "japanese-formal":
        return 25;
      case "japanese-informal":
        return 26;
      case "kannada":
        return 27;
      case "katakana":
        return 28;
      case "katakana-iroha":
        return 29;
      case "khmer":
        return 30;
      case "korean-hangul-formal":
        return 31;
      case "korean-hanja-formal":
        return 32;
      case "korean-hanja-informal":
        return 33;
      case "lao":
        return 34;
      case "lower-armenian":
        return 35;
      case "malayalam":
        return 36;
      case "mongolian":
        return 37;
      case "myanmar":
        return 38;
      case "oriya":
        return 39;
      case "persian":
        return 40;
      case "simp-chinese-formal":
        return 41;
      case "simp-chinese-informal":
        return 42;
      case "tamil":
        return 43;
      case "telugu":
        return 44;
      case "thai":
        return 45;
      case "tibetan":
        return 46;
      case "trad-chinese-formal":
        return 47;
      case "trad-chinese-informal":
        return 48;
      case "upper-armenian":
        return 49;
      case "disclosure-open":
        return 50;
      case "disclosure-closed":
        return 51;
      case "none":
      default:
        return -1;
    }
  }
};
var marginForSide = function(side) {
  return {
    name: "margin-" + side,
    initialValue: "0",
    prefix: false,
    type: 4
  };
};
var marginTop = marginForSide("top");
var marginRight = marginForSide("right");
var marginBottom = marginForSide("bottom");
var marginLeft = marginForSide("left");
var overflow = {
  name: "overflow",
  initialValue: "visible",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return tokens.filter(isIdentToken).map(function(overflow2) {
      switch (overflow2.value) {
        case "hidden":
          return 1;
        case "scroll":
          return 2;
        case "clip":
          return 3;
        case "auto":
          return 4;
        case "visible":
        default:
          return 0;
      }
    });
  }
};
var overflowWrap = {
  name: "overflow-wrap",
  initialValue: "normal",
  prefix: false,
  type: 2,
  parse: function(_context, overflow2) {
    switch (overflow2) {
      case "break-word":
        return "break-word";
      case "normal":
      default:
        return "normal";
    }
  }
};
var paddingForSide = function(side) {
  return {
    name: "padding-" + side,
    initialValue: "0",
    prefix: false,
    type: 3,
    format: "length-percentage"
  };
};
var paddingTop = paddingForSide("top");
var paddingRight = paddingForSide("right");
var paddingBottom = paddingForSide("bottom");
var paddingLeft = paddingForSide("left");
var textAlign = {
  name: "text-align",
  initialValue: "left",
  prefix: false,
  type: 2,
  parse: function(_context, textAlign2) {
    switch (textAlign2) {
      case "right":
        return 2;
      case "center":
      case "justify":
        return 1;
      case "left":
      default:
        return 0;
    }
  }
};
var position = {
  name: "position",
  initialValue: "static",
  prefix: false,
  type: 2,
  parse: function(_context, position2) {
    switch (position2) {
      case "relative":
        return 1;
      case "absolute":
        return 2;
      case "fixed":
        return 3;
      case "sticky":
        return 4;
    }
    return 0;
  }
};
var textShadow = {
  name: "text-shadow",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(context2, tokens) {
    if (tokens.length === 1 && isIdentWithValue(tokens[0], "none")) {
      return [];
    }
    return parseFunctionArgs(tokens).map(function(values3) {
      var shadow = {
        color: COLORS.TRANSPARENT,
        offsetX: ZERO_LENGTH,
        offsetY: ZERO_LENGTH,
        blur: ZERO_LENGTH
      };
      var c2 = 0;
      for (var i2 = 0; i2 < values3.length; i2++) {
        var token = values3[i2];
        if (isLength(token)) {
          if (c2 === 0) {
            shadow.offsetX = token;
          } else if (c2 === 1) {
            shadow.offsetY = token;
          } else {
            shadow.blur = token;
          }
          c2++;
        } else {
          shadow.color = color$1.parse(context2, token);
        }
      }
      return shadow;
    });
  }
};
var textTransform = {
  name: "text-transform",
  initialValue: "none",
  prefix: false,
  type: 2,
  parse: function(_context, textTransform2) {
    switch (textTransform2) {
      case "uppercase":
        return 2;
      case "lowercase":
        return 1;
      case "capitalize":
        return 3;
    }
    return 0;
  }
};
var transform$1 = {
  name: "transform",
  initialValue: "none",
  prefix: true,
  type: 0,
  parse: function(_context, token) {
    if (token.type === 20 && token.value === "none") {
      return null;
    }
    if (token.type === 18) {
      var transformFunction = SUPPORTED_TRANSFORM_FUNCTIONS[token.name];
      if (typeof transformFunction === "undefined") {
        throw new Error('Attempting to parse an unsupported transform function "' + token.name + '"');
      }
      return transformFunction(token.values);
    }
    return null;
  }
};
var matrix = function(args) {
  var values3 = args.filter(function(arg) {
    return arg.type === 17;
  }).map(function(arg) {
    return arg.number;
  });
  return values3.length === 6 ? values3 : null;
};
var matrix3d = function(args) {
  var values3 = args.filter(function(arg) {
    return arg.type === 17;
  }).map(function(arg) {
    return arg.number;
  });
  var a1 = values3[0], b1 = values3[1];
  values3[2];
  values3[3];
  var a2 = values3[4], b2 = values3[5];
  values3[6];
  values3[7];
  values3[8];
  values3[9];
  values3[10];
  values3[11];
  var a4 = values3[12], b4 = values3[13];
  values3[14];
  values3[15];
  return values3.length === 16 ? [a1, b1, a2, b2, a4, b4] : null;
};
var SUPPORTED_TRANSFORM_FUNCTIONS = {
  matrix,
  matrix3d
};
var DEFAULT_VALUE = {
  type: 16,
  number: 50,
  flags: FLAG_INTEGER
};
var DEFAULT = [DEFAULT_VALUE, DEFAULT_VALUE];
var transformOrigin = {
  name: "transform-origin",
  initialValue: "50% 50%",
  prefix: true,
  type: 1,
  parse: function(_context, tokens) {
    var origins = tokens.filter(isLengthPercentage);
    if (origins.length !== 2) {
      return DEFAULT;
    }
    return [origins[0], origins[1]];
  }
};
var visibility = {
  name: "visible",
  initialValue: "none",
  prefix: false,
  type: 2,
  parse: function(_context, visibility2) {
    switch (visibility2) {
      case "hidden":
        return 1;
      case "collapse":
        return 2;
      case "visible":
      default:
        return 0;
    }
  }
};
var WORD_BREAK;
(function(WORD_BREAK2) {
  WORD_BREAK2["NORMAL"] = "normal";
  WORD_BREAK2["BREAK_ALL"] = "break-all";
  WORD_BREAK2["KEEP_ALL"] = "keep-all";
})(WORD_BREAK || (WORD_BREAK = {}));
var wordBreak = {
  name: "word-break",
  initialValue: "normal",
  prefix: false,
  type: 2,
  parse: function(_context, wordBreak2) {
    switch (wordBreak2) {
      case "break-all":
        return WORD_BREAK.BREAK_ALL;
      case "keep-all":
        return WORD_BREAK.KEEP_ALL;
      case "normal":
      default:
        return WORD_BREAK.NORMAL;
    }
  }
};
var zIndex = {
  name: "z-index",
  initialValue: "auto",
  prefix: false,
  type: 0,
  parse: function(_context, token) {
    if (token.type === 20) {
      return { auto: true, order: 0 };
    }
    if (isNumberToken(token)) {
      return { auto: false, order: token.number };
    }
    throw new Error("Invalid z-index number parsed");
  }
};
var time = {
  name: "time",
  parse: function(_context, value) {
    if (value.type === 15) {
      switch (value.unit.toLowerCase()) {
        case "s":
          return 1e3 * value.number;
        case "ms":
          return value.number;
      }
    }
    throw new Error("Unsupported time type");
  }
};
var opacity = {
  name: "opacity",
  initialValue: "1",
  type: 0,
  prefix: false,
  parse: function(_context, token) {
    if (isNumberToken(token)) {
      return token.number;
    }
    return 1;
  }
};
var textDecorationColor = {
  name: "text-decoration-color",
  initialValue: "transparent",
  prefix: false,
  type: 3,
  format: "color"
};
var textDecorationLine = {
  name: "text-decoration-line",
  initialValue: "none",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return tokens.filter(isIdentToken).map(function(token) {
      switch (token.value) {
        case "underline":
          return 1;
        case "overline":
          return 2;
        case "line-through":
          return 3;
        case "none":
          return 4;
      }
      return 0;
    }).filter(function(line) {
      return line !== 0;
    });
  }
};
var fontFamily = {
  name: "font-family",
  initialValue: "",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    var accumulator = [];
    var results = [];
    tokens.forEach(function(token) {
      switch (token.type) {
        case 20:
        case 0:
          accumulator.push(token.value);
          break;
        case 17:
          accumulator.push(token.number.toString());
          break;
        case 4:
          results.push(accumulator.join(" "));
          accumulator.length = 0;
          break;
      }
    });
    if (accumulator.length) {
      results.push(accumulator.join(" "));
    }
    return results.map(function(result) {
      return result.indexOf(" ") === -1 ? result : "'" + result + "'";
    });
  }
};
var fontSize = {
  name: "font-size",
  initialValue: "0",
  prefix: false,
  type: 3,
  format: "length"
};
var fontWeight = {
  name: "font-weight",
  initialValue: "normal",
  type: 0,
  prefix: false,
  parse: function(_context, token) {
    if (isNumberToken(token)) {
      return token.number;
    }
    if (isIdentToken(token)) {
      switch (token.value) {
        case "bold":
          return 700;
        case "normal":
        default:
          return 400;
      }
    }
    return 400;
  }
};
var fontVariant = {
  name: "font-variant",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(_context, tokens) {
    return tokens.filter(isIdentToken).map(function(token) {
      return token.value;
    });
  }
};
var fontStyle = {
  name: "font-style",
  initialValue: "normal",
  prefix: false,
  type: 2,
  parse: function(_context, overflow2) {
    switch (overflow2) {
      case "oblique":
        return "oblique";
      case "italic":
        return "italic";
      case "normal":
      default:
        return "normal";
    }
  }
};
var contains = function(bit, value) {
  return (bit & value) !== 0;
};
var content = {
  name: "content",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(_context, tokens) {
    if (tokens.length === 0) {
      return [];
    }
    var first = tokens[0];
    if (first.type === 20 && first.value === "none") {
      return [];
    }
    return tokens;
  }
};
var counterIncrement = {
  name: "counter-increment",
  initialValue: "none",
  prefix: true,
  type: 1,
  parse: function(_context, tokens) {
    if (tokens.length === 0) {
      return null;
    }
    var first = tokens[0];
    if (first.type === 20 && first.value === "none") {
      return null;
    }
    var increments = [];
    var filtered = tokens.filter(nonWhiteSpace);
    for (var i2 = 0; i2 < filtered.length; i2++) {
      var counter2 = filtered[i2];
      var next3 = filtered[i2 + 1];
      if (counter2.type === 20) {
        var increment = next3 && isNumberToken(next3) ? next3.number : 1;
        increments.push({ counter: counter2.value, increment });
      }
    }
    return increments;
  }
};
var counterReset = {
  name: "counter-reset",
  initialValue: "none",
  prefix: true,
  type: 1,
  parse: function(_context, tokens) {
    if (tokens.length === 0) {
      return [];
    }
    var resets = [];
    var filtered = tokens.filter(nonWhiteSpace);
    for (var i2 = 0; i2 < filtered.length; i2++) {
      var counter2 = filtered[i2];
      var next3 = filtered[i2 + 1];
      if (isIdentToken(counter2) && counter2.value !== "none") {
        var reset2 = next3 && isNumberToken(next3) ? next3.number : 0;
        resets.push({ counter: counter2.value, reset: reset2 });
      }
    }
    return resets;
  }
};
var duration = {
  name: "duration",
  initialValue: "0s",
  prefix: false,
  type: 1,
  parse: function(context2, tokens) {
    return tokens.filter(isDimensionToken).map(function(token) {
      return time.parse(context2, token);
    });
  }
};
var quotes = {
  name: "quotes",
  initialValue: "none",
  prefix: true,
  type: 1,
  parse: function(_context, tokens) {
    if (tokens.length === 0) {
      return null;
    }
    var first = tokens[0];
    if (first.type === 20 && first.value === "none") {
      return null;
    }
    var quotes2 = [];
    var filtered = tokens.filter(isStringToken);
    if (filtered.length % 2 !== 0) {
      return null;
    }
    for (var i2 = 0; i2 < filtered.length; i2 += 2) {
      var open_1 = filtered[i2].value;
      var close_1 = filtered[i2 + 1].value;
      quotes2.push({ open: open_1, close: close_1 });
    }
    return quotes2;
  }
};
var getQuote = function(quotes2, depth, open2) {
  if (!quotes2) {
    return "";
  }
  var quote = quotes2[Math.min(depth, quotes2.length - 1)];
  if (!quote) {
    return "";
  }
  return open2 ? quote.open : quote.close;
};
var boxShadow = {
  name: "box-shadow",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(context2, tokens) {
    if (tokens.length === 1 && isIdentWithValue(tokens[0], "none")) {
      return [];
    }
    return parseFunctionArgs(tokens).map(function(values3) {
      var shadow = {
        color: 255,
        offsetX: ZERO_LENGTH,
        offsetY: ZERO_LENGTH,
        blur: ZERO_LENGTH,
        spread: ZERO_LENGTH,
        inset: false
      };
      var c2 = 0;
      for (var i2 = 0; i2 < values3.length; i2++) {
        var token = values3[i2];
        if (isIdentWithValue(token, "inset")) {
          shadow.inset = true;
        } else if (isLength(token)) {
          if (c2 === 0) {
            shadow.offsetX = token;
          } else if (c2 === 1) {
            shadow.offsetY = token;
          } else if (c2 === 2) {
            shadow.blur = token;
          } else {
            shadow.spread = token;
          }
          c2++;
        } else {
          shadow.color = color$1.parse(context2, token);
        }
      }
      return shadow;
    });
  }
};
var paintOrder = {
  name: "paint-order",
  initialValue: "normal",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    var DEFAULT_VALUE2 = [0, 1, 2];
    var layers = [];
    tokens.filter(isIdentToken).forEach(function(token) {
      switch (token.value) {
        case "stroke":
          layers.push(1);
          break;
        case "fill":
          layers.push(0);
          break;
        case "markers":
          layers.push(2);
          break;
      }
    });
    DEFAULT_VALUE2.forEach(function(value) {
      if (layers.indexOf(value) === -1) {
        layers.push(value);
      }
    });
    return layers;
  }
};
var webkitTextStrokeColor = {
  name: "-webkit-text-stroke-color",
  initialValue: "currentcolor",
  prefix: false,
  type: 3,
  format: "color"
};
var webkitTextStrokeWidth = {
  name: "-webkit-text-stroke-width",
  initialValue: "0",
  type: 0,
  prefix: false,
  parse: function(_context, token) {
    if (isDimensionToken(token)) {
      return token.number;
    }
    return 0;
  }
};
var CSSParsedDeclaration = function() {
  function CSSParsedDeclaration2(context2, declaration) {
    var _a2, _b2;
    this.animationDuration = parse(context2, duration, declaration.animationDuration);
    this.backgroundClip = parse(context2, backgroundClip, declaration.backgroundClip);
    this.backgroundColor = parse(context2, backgroundColor, declaration.backgroundColor);
    this.backgroundImage = parse(context2, backgroundImage, declaration.backgroundImage);
    this.backgroundOrigin = parse(context2, backgroundOrigin, declaration.backgroundOrigin);
    this.backgroundPosition = parse(context2, backgroundPosition, declaration.backgroundPosition);
    this.backgroundRepeat = parse(context2, backgroundRepeat, declaration.backgroundRepeat);
    this.backgroundSize = parse(context2, backgroundSize, declaration.backgroundSize);
    this.borderTopColor = parse(context2, borderTopColor, declaration.borderTopColor);
    this.borderRightColor = parse(context2, borderRightColor, declaration.borderRightColor);
    this.borderBottomColor = parse(context2, borderBottomColor, declaration.borderBottomColor);
    this.borderLeftColor = parse(context2, borderLeftColor, declaration.borderLeftColor);
    this.borderTopLeftRadius = parse(context2, borderTopLeftRadius, declaration.borderTopLeftRadius);
    this.borderTopRightRadius = parse(context2, borderTopRightRadius, declaration.borderTopRightRadius);
    this.borderBottomRightRadius = parse(context2, borderBottomRightRadius, declaration.borderBottomRightRadius);
    this.borderBottomLeftRadius = parse(context2, borderBottomLeftRadius, declaration.borderBottomLeftRadius);
    this.borderTopStyle = parse(context2, borderTopStyle, declaration.borderTopStyle);
    this.borderRightStyle = parse(context2, borderRightStyle, declaration.borderRightStyle);
    this.borderBottomStyle = parse(context2, borderBottomStyle, declaration.borderBottomStyle);
    this.borderLeftStyle = parse(context2, borderLeftStyle, declaration.borderLeftStyle);
    this.borderTopWidth = parse(context2, borderTopWidth, declaration.borderTopWidth);
    this.borderRightWidth = parse(context2, borderRightWidth, declaration.borderRightWidth);
    this.borderBottomWidth = parse(context2, borderBottomWidth, declaration.borderBottomWidth);
    this.borderLeftWidth = parse(context2, borderLeftWidth, declaration.borderLeftWidth);
    this.boxShadow = parse(context2, boxShadow, declaration.boxShadow);
    this.color = parse(context2, color, declaration.color);
    this.direction = parse(context2, direction, declaration.direction);
    this.display = parse(context2, display, declaration.display);
    this.float = parse(context2, float, declaration.cssFloat);
    this.fontFamily = parse(context2, fontFamily, declaration.fontFamily);
    this.fontSize = parse(context2, fontSize, declaration.fontSize);
    this.fontStyle = parse(context2, fontStyle, declaration.fontStyle);
    this.fontVariant = parse(context2, fontVariant, declaration.fontVariant);
    this.fontWeight = parse(context2, fontWeight, declaration.fontWeight);
    this.letterSpacing = parse(context2, letterSpacing, declaration.letterSpacing);
    this.lineBreak = parse(context2, lineBreak, declaration.lineBreak);
    this.lineHeight = parse(context2, lineHeight, declaration.lineHeight);
    this.listStyleImage = parse(context2, listStyleImage, declaration.listStyleImage);
    this.listStylePosition = parse(context2, listStylePosition, declaration.listStylePosition);
    this.listStyleType = parse(context2, listStyleType, declaration.listStyleType);
    this.marginTop = parse(context2, marginTop, declaration.marginTop);
    this.marginRight = parse(context2, marginRight, declaration.marginRight);
    this.marginBottom = parse(context2, marginBottom, declaration.marginBottom);
    this.marginLeft = parse(context2, marginLeft, declaration.marginLeft);
    this.opacity = parse(context2, opacity, declaration.opacity);
    var overflowTuple = parse(context2, overflow, declaration.overflow);
    this.overflowX = overflowTuple[0];
    this.overflowY = overflowTuple[overflowTuple.length > 1 ? 1 : 0];
    this.overflowWrap = parse(context2, overflowWrap, declaration.overflowWrap);
    this.paddingTop = parse(context2, paddingTop, declaration.paddingTop);
    this.paddingRight = parse(context2, paddingRight, declaration.paddingRight);
    this.paddingBottom = parse(context2, paddingBottom, declaration.paddingBottom);
    this.paddingLeft = parse(context2, paddingLeft, declaration.paddingLeft);
    this.paintOrder = parse(context2, paintOrder, declaration.paintOrder);
    this.position = parse(context2, position, declaration.position);
    this.textAlign = parse(context2, textAlign, declaration.textAlign);
    this.textDecorationColor = parse(context2, textDecorationColor, (_a2 = declaration.textDecorationColor) !== null && _a2 !== void 0 ? _a2 : declaration.color);
    this.textDecorationLine = parse(context2, textDecorationLine, (_b2 = declaration.textDecorationLine) !== null && _b2 !== void 0 ? _b2 : declaration.textDecoration);
    this.textShadow = parse(context2, textShadow, declaration.textShadow);
    this.textTransform = parse(context2, textTransform, declaration.textTransform);
    this.transform = parse(context2, transform$1, declaration.transform);
    this.transformOrigin = parse(context2, transformOrigin, declaration.transformOrigin);
    this.visibility = parse(context2, visibility, declaration.visibility);
    this.webkitTextStrokeColor = parse(context2, webkitTextStrokeColor, declaration.webkitTextStrokeColor);
    this.webkitTextStrokeWidth = parse(context2, webkitTextStrokeWidth, declaration.webkitTextStrokeWidth);
    this.wordBreak = parse(context2, wordBreak, declaration.wordBreak);
    this.zIndex = parse(context2, zIndex, declaration.zIndex);
  }
  CSSParsedDeclaration2.prototype.isVisible = function() {
    return this.display > 0 && this.opacity > 0 && this.visibility === 0;
  };
  CSSParsedDeclaration2.prototype.isTransparent = function() {
    return isTransparent(this.backgroundColor);
  };
  CSSParsedDeclaration2.prototype.isTransformed = function() {
    return this.transform !== null;
  };
  CSSParsedDeclaration2.prototype.isPositioned = function() {
    return this.position !== 0;
  };
  CSSParsedDeclaration2.prototype.isPositionedWithZIndex = function() {
    return this.isPositioned() && !this.zIndex.auto;
  };
  CSSParsedDeclaration2.prototype.isFloating = function() {
    return this.float !== 0;
  };
  CSSParsedDeclaration2.prototype.isInlineLevel = function() {
    return contains(this.display, 4) || contains(this.display, 33554432) || contains(this.display, 268435456) || contains(this.display, 536870912) || contains(this.display, 67108864) || contains(this.display, 134217728);
  };
  return CSSParsedDeclaration2;
}();
var CSSParsedPseudoDeclaration = function() {
  function CSSParsedPseudoDeclaration2(context2, declaration) {
    this.content = parse(context2, content, declaration.content);
    this.quotes = parse(context2, quotes, declaration.quotes);
  }
  return CSSParsedPseudoDeclaration2;
}();
var CSSParsedCounterDeclaration = function() {
  function CSSParsedCounterDeclaration2(context2, declaration) {
    this.counterIncrement = parse(context2, counterIncrement, declaration.counterIncrement);
    this.counterReset = parse(context2, counterReset, declaration.counterReset);
  }
  return CSSParsedCounterDeclaration2;
}();
var parse = function(context2, descriptor, style2) {
  var tokenizer = new Tokenizer();
  var value = style2 !== null && typeof style2 !== "undefined" ? style2.toString() : descriptor.initialValue;
  tokenizer.write(value);
  var parser = new Parser$1(tokenizer.read());
  switch (descriptor.type) {
    case 2:
      var token = parser.parseComponentValue();
      return descriptor.parse(context2, isIdentToken(token) ? token.value : descriptor.initialValue);
    case 0:
      return descriptor.parse(context2, parser.parseComponentValue());
    case 1:
      return descriptor.parse(context2, parser.parseComponentValues());
    case 4:
      return parser.parseComponentValue();
    case 3:
      switch (descriptor.format) {
        case "angle":
          return angle.parse(context2, parser.parseComponentValue());
        case "color":
          return color$1.parse(context2, parser.parseComponentValue());
        case "image":
          return image.parse(context2, parser.parseComponentValue());
        case "length":
          var length_1 = parser.parseComponentValue();
          return isLength(length_1) ? length_1 : ZERO_LENGTH;
        case "length-percentage":
          var value_1 = parser.parseComponentValue();
          return isLengthPercentage(value_1) ? value_1 : ZERO_LENGTH;
        case "time":
          return time.parse(context2, parser.parseComponentValue());
      }
      break;
  }
};
var elementDebuggerAttribute = "data-html2canvas-debug";
var getElementDebugType = function(element) {
  var attribute = element.getAttribute(elementDebuggerAttribute);
  switch (attribute) {
    case "all":
      return 1;
    case "clone":
      return 2;
    case "parse":
      return 3;
    case "render":
      return 4;
    default:
      return 0;
  }
};
var isDebugging = function(element, type) {
  var elementType = getElementDebugType(element);
  return elementType === 1 || type === elementType;
};
var ElementContainer = function() {
  function ElementContainer2(context2, element) {
    this.context = context2;
    this.textNodes = [];
    this.elements = [];
    this.flags = 0;
    if (isDebugging(element, 3)) {
      debugger;
    }
    this.styles = new CSSParsedDeclaration(context2, window.getComputedStyle(element, null));
    if (isHTMLElementNode(element)) {
      if (this.styles.animationDuration.some(function(duration2) {
        return duration2 > 0;
      })) {
        element.style.animationDuration = "0s";
      }
      if (this.styles.transform !== null) {
        element.style.transform = "none";
      }
    }
    this.bounds = parseBounds(this.context, element);
    if (isDebugging(element, 4)) {
      this.flags |= 16;
    }
  }
  return ElementContainer2;
}();
var base64 = "AAAAAAAAAAAAEA4AGBkAAFAaAAACAAAAAAAIABAAGAAwADgACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAAQABIAEQATAAIABAACAAQAAgAEAAIABAAVABcAAgAEAAIABAACAAQAGAAaABwAHgAgACIAI4AlgAIABAAmwCjAKgAsAC2AL4AvQDFAMoA0gBPAVYBWgEIAAgACACMANoAYgFkAWwBdAF8AX0BhQGNAZUBlgGeAaMBlQGWAasBswF8AbsBwwF0AcsBYwHTAQgA2wG/AOMBdAF8AekB8QF0AfkB+wHiAHQBfAEIAAMC5gQIAAsCEgIIAAgAFgIeAggAIgIpAggAMQI5AkACygEIAAgASAJQAlgCYAIIAAgACAAKBQoFCgUTBRMFGQUrBSsFCAAIAAgACAAIAAgACAAIAAgACABdAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABoAmgCrwGvAQgAbgJ2AggAHgEIAAgACADnAXsCCAAIAAgAgwIIAAgACAAIAAgACACKAggAkQKZAggAPADJAAgAoQKkAqwCsgK6AsICCADJAggA0AIIAAgACAAIANYC3gIIAAgACAAIAAgACABAAOYCCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAkASoB+QIEAAgACAA8AEMCCABCBQgACABJBVAFCAAIAAgACAAIAAgACAAIAAgACABTBVoFCAAIAFoFCABfBWUFCAAIAAgACAAIAAgAbQUIAAgACAAIAAgACABzBXsFfQWFBYoFigWKBZEFigWKBYoFmAWfBaYFrgWxBbkFCAAIAAgACAAIAAgACAAIAAgACAAIAMEFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAMgFCADQBQgACAAIAAgACAAIAAgACAAIAAgACAAIAO4CCAAIAAgAiQAIAAgACABAAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAD0AggACAD8AggACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIANYFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAMDvwAIAAgAJAIIAAgACAAIAAgACAAIAAgACwMTAwgACAB9BOsEGwMjAwgAKwMyAwsFYgE3A/MEPwMIAEUDTQNRAwgAWQOsAGEDCAAIAAgACAAIAAgACABpAzQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFIQUoBSwFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABtAwgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABMAEwACAAIAAgACAAIABgACAAIAAgACAC/AAgACAAyAQgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACAAIAAwAAgACAAIAAgACAAIAAgACAAIAAAARABIAAgACAAIABQASAAIAAgAIABwAEAAjgCIABsAqAC2AL0AigDQAtwC+IJIQqVAZUBWQqVAZUBlQGVAZUBlQGrC5UBlQGVAZUBlQGVAZUBlQGVAXsKlQGVAbAK6wsrDGUMpQzlDJUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAfAKAAuZA64AtwCJALoC6ADwAAgAuACgA/oEpgO6AqsD+AAIAAgAswMIAAgACAAIAIkAuwP5AfsBwwPLAwgACAAIAAgACADRA9kDCAAIAOED6QMIAAgACAAIAAgACADuA/YDCAAIAP4DyQAIAAgABgQIAAgAXQAOBAgACAAIAAgACAAIABMECAAIAAgACAAIAAgACAD8AAQBCAAIAAgAGgQiBCoECAExBAgAEAEIAAgACAAIAAgACAAIAAgACAAIAAgACAA4BAgACABABEYECAAIAAgATAQYAQgAVAQIAAgACAAIAAgACAAIAAgACAAIAFoECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAOQEIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAB+BAcACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAEABhgSMBAgACAAIAAgAlAQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAwAEAAQABAADAAMAAwADAAQABAAEAAQABAAEAAQABHATAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAdQMIAAgACAAIAAgACAAIAMkACAAIAAgAfQMIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACFA4kDCAAIAAgACAAIAOcBCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAIcDCAAIAAgACAAIAAgACAAIAAgACAAIAJEDCAAIAAgACADFAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABgBAgAZgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAbAQCBXIECAAIAHkECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABAAJwEQACjBKoEsgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAC6BMIECAAIAAgACAAIAAgACABmBAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAxwQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAGYECAAIAAgAzgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBd0FXwUIAOIF6gXxBYoF3gT5BQAGCAaKBYoFigWKBYoFigWKBYoFigWKBYoFigXWBIoFigWKBYoFigWKBYoFigWKBYsFEAaKBYoFigWKBYoFigWKBRQGCACKBYoFigWKBQgACAAIANEECAAIABgGigUgBggAJgYIAC4GMwaKBYoF0wQ3Bj4GigWKBYoFigWKBYoFigWKBYoFigWKBYoFigUIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWLBf///////wQABAAEAAQABAAEAAQABAAEAAQAAwAEAAQAAgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAQADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUAAAAFAAUAAAAFAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAQAAAAUABQAFAAUABQAFAAAAAAAFAAUAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAFAAUAAQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAAABwAHAAcAAAAHAAcABwAFAAEAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAcABwAFAAUAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAQABAAAAAAAAAAAAAAAFAAUABQAFAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAHAAcAAAAHAAcAAAAAAAUABQAHAAUAAQAHAAEABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwABAAUABQAFAAUAAAAAAAAAAAAAAAEAAQABAAEAAQABAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABQANAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAABQAHAAUABQAFAAAAAAAAAAcABQAFAAUABQAFAAQABAAEAAQABAAEAAQABAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUAAAAFAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAUAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAcABwAFAAcABwAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUABwAHAAUABQAFAAUAAAAAAAcABwAAAAAABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAAAAAAAAAAABQAFAAAAAAAFAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAFAAUABQAFAAUAAAAFAAUABwAAAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABwAFAAUABQAFAAAAAAAHAAcAAAAAAAcABwAFAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAAAAAAAAAHAAcABwAAAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAUABQAFAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAHAAcABQAHAAcAAAAFAAcABwAAAAcABwAFAAUAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAFAAcABwAFAAUABQAAAAUAAAAHAAcABwAHAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAHAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUAAAAFAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAUAAAAFAAUAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABwAFAAUABQAFAAUABQAAAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABQAFAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAFAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAHAAUABQAFAAUABQAFAAUABwAHAAcABwAHAAcABwAHAAUABwAHAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABwAHAAcABwAFAAUABwAHAAcAAAAAAAAAAAAHAAcABQAHAAcABwAHAAcABwAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAUABQAFAAUABQAFAAUAAAAFAAAABQAAAAAABQAFAAUABQAFAAUABQAFAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAUABQAFAAUABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABwAFAAcABwAHAAcABwAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAUABQAFAAUABwAHAAUABQAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABQAFAAcABwAHAAUABwAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAcABQAFAAUABQAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAAAAAABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAAAAAAAAAFAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAUABQAHAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAFAAUABQAFAAcABwAFAAUABwAHAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAcABwAFAAUABwAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABQAAAAAABQAFAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAcABwAAAAAAAAAAAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAcABwAFAAcABwAAAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAFAAUABQAAAAUABQAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABwAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAHAAcABQAHAAUABQAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAAABwAHAAAAAAAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAFAAUABwAFAAcABwAFAAcABQAFAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAAAAAABwAHAAcABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAFAAcABwAFAAUABQAFAAUABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAUABQAFAAcABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABQAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAAAAAAFAAUABwAHAAcABwAFAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAHAAUABQAFAAUABQAFAAUABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAABQAAAAUABQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAHAAcAAAAFAAUAAAAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABQAFAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAABQAFAAUABQAFAAUABQAAAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAFAAUABQAFAAUADgAOAA4ADgAOAA4ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAMAAwADAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAAAAAAAAAAAAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAAAAAAAAAAAAsADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwACwAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAADgAOAA4AAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAAAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4AAAAOAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAAAAAAAAAAAA4AAAAOAAAAAAAAAAAADgAOAA4AAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAA=";
var chars$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i$1$2 = 0; i$1$2 < chars$1.length; i$1$2++) {
  lookup$1[chars$1.charCodeAt(i$1$2)] = i$1$2;
}
var decode = function(base642) {
  var bufferLength = base642.length * 0.75, len = base642.length, i2, p5 = 0, encoded1, encoded2, encoded3, encoded4;
  if (base642[base642.length - 1] === "=") {
    bufferLength--;
    if (base642[base642.length - 2] === "=") {
      bufferLength--;
    }
  }
  var buffer2 = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint8Array.prototype.slice !== "undefined" ? new ArrayBuffer(bufferLength) : new Array(bufferLength);
  var bytes = Array.isArray(buffer2) ? buffer2 : new Uint8Array(buffer2);
  for (i2 = 0; i2 < len; i2 += 4) {
    encoded1 = lookup$1[base642.charCodeAt(i2)];
    encoded2 = lookup$1[base642.charCodeAt(i2 + 1)];
    encoded3 = lookup$1[base642.charCodeAt(i2 + 2)];
    encoded4 = lookup$1[base642.charCodeAt(i2 + 3)];
    bytes[p5++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p5++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p5++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return buffer2;
};
var polyUint16Array = function(buffer2) {
  var length = buffer2.length;
  var bytes = [];
  for (var i2 = 0; i2 < length; i2 += 2) {
    bytes.push(buffer2[i2 + 1] << 8 | buffer2[i2]);
  }
  return bytes;
};
var polyUint32Array = function(buffer2) {
  var length = buffer2.length;
  var bytes = [];
  for (var i2 = 0; i2 < length; i2 += 4) {
    bytes.push(buffer2[i2 + 3] << 24 | buffer2[i2 + 2] << 16 | buffer2[i2 + 1] << 8 | buffer2[i2]);
  }
  return bytes;
};
var UTRIE2_SHIFT_2 = 5;
var UTRIE2_SHIFT_1 = 6 + 5;
var UTRIE2_INDEX_SHIFT = 2;
var UTRIE2_SHIFT_1_2 = UTRIE2_SHIFT_1 - UTRIE2_SHIFT_2;
var UTRIE2_LSCP_INDEX_2_OFFSET = 65536 >> UTRIE2_SHIFT_2;
var UTRIE2_DATA_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_2;
var UTRIE2_DATA_MASK = UTRIE2_DATA_BLOCK_LENGTH - 1;
var UTRIE2_LSCP_INDEX_2_LENGTH = 1024 >> UTRIE2_SHIFT_2;
var UTRIE2_INDEX_2_BMP_LENGTH = UTRIE2_LSCP_INDEX_2_OFFSET + UTRIE2_LSCP_INDEX_2_LENGTH;
var UTRIE2_UTF8_2B_INDEX_2_OFFSET = UTRIE2_INDEX_2_BMP_LENGTH;
var UTRIE2_UTF8_2B_INDEX_2_LENGTH = 2048 >> 6;
var UTRIE2_INDEX_1_OFFSET = UTRIE2_UTF8_2B_INDEX_2_OFFSET + UTRIE2_UTF8_2B_INDEX_2_LENGTH;
var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH = 65536 >> UTRIE2_SHIFT_1;
var UTRIE2_INDEX_2_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_1_2;
var UTRIE2_INDEX_2_MASK = UTRIE2_INDEX_2_BLOCK_LENGTH - 1;
var slice16 = function(view, start2, end) {
  if (view.slice) {
    return view.slice(start2, end);
  }
  return new Uint16Array(Array.prototype.slice.call(view, start2, end));
};
var slice32 = function(view, start2, end) {
  if (view.slice) {
    return view.slice(start2, end);
  }
  return new Uint32Array(Array.prototype.slice.call(view, start2, end));
};
var createTrieFromBase64 = function(base642, _byteLength) {
  var buffer2 = decode(base642);
  var view32 = Array.isArray(buffer2) ? polyUint32Array(buffer2) : new Uint32Array(buffer2);
  var view16 = Array.isArray(buffer2) ? polyUint16Array(buffer2) : new Uint16Array(buffer2);
  var headerLength = 24;
  var index2 = slice16(view16, headerLength / 2, view32[4] / 2);
  var data2 = view32[5] === 2 ? slice16(view16, (headerLength + view32[4]) / 2) : slice32(view32, Math.ceil((headerLength + view32[4]) / 4));
  return new Trie(view32[0], view32[1], view32[2], view32[3], index2, data2);
};
var Trie = function() {
  function Trie2(initialValue, errorValue, highStart, highValueIndex, index2, data2) {
    this.initialValue = initialValue;
    this.errorValue = errorValue;
    this.highStart = highStart;
    this.highValueIndex = highValueIndex;
    this.index = index2;
    this.data = data2;
  }
  Trie2.prototype.get = function(codePoint) {
    var ix;
    if (codePoint >= 0) {
      if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
        ix = this.index[codePoint >> UTRIE2_SHIFT_2];
        ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
        return this.data[ix];
      }
      if (codePoint <= 65535) {
        ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET + (codePoint - 55296 >> UTRIE2_SHIFT_2)];
        ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
        return this.data[ix];
      }
      if (codePoint < this.highStart) {
        ix = UTRIE2_INDEX_1_OFFSET - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> UTRIE2_SHIFT_1);
        ix = this.index[ix];
        ix += codePoint >> UTRIE2_SHIFT_2 & UTRIE2_INDEX_2_MASK;
        ix = this.index[ix];
        ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
        return this.data[ix];
      }
      if (codePoint <= 1114111) {
        return this.data[this.highValueIndex];
      }
    }
    return this.errorValue;
  };
  return Trie2;
}();
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i$4 = 0; i$4 < chars.length; i$4++) {
  lookup[chars.charCodeAt(i$4)] = i$4;
}
var Prepend = 1;
var CR = 2;
var LF = 3;
var Control = 4;
var Extend = 5;
var SpacingMark = 7;
var L = 8;
var V = 9;
var T$1 = 10;
var LV = 11;
var LVT = 12;
var ZWJ = 13;
var Extended_Pictographic = 14;
var RI = 15;
var toCodePoints = function(str) {
  var codePoints = [];
  var i2 = 0;
  var length = str.length;
  while (i2 < length) {
    var value = str.charCodeAt(i2++);
    if (value >= 55296 && value <= 56319 && i2 < length) {
      var extra = str.charCodeAt(i2++);
      if ((extra & 64512) === 56320) {
        codePoints.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        codePoints.push(value);
        i2--;
      }
    } else {
      codePoints.push(value);
    }
  }
  return codePoints;
};
var fromCodePoint = function() {
  var codePoints = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    codePoints[_i] = arguments[_i];
  }
  if (String.fromCodePoint) {
    return String.fromCodePoint.apply(String, codePoints);
  }
  var length = codePoints.length;
  if (!length) {
    return "";
  }
  var codeUnits = [];
  var index2 = -1;
  var result = "";
  while (++index2 < length) {
    var codePoint = codePoints[index2];
    if (codePoint <= 65535) {
      codeUnits.push(codePoint);
    } else {
      codePoint -= 65536;
      codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);
    }
    if (index2 + 1 === length || codeUnits.length > 16384) {
      result += String.fromCharCode.apply(String, codeUnits);
      codeUnits.length = 0;
    }
  }
  return result;
};
var UnicodeTrie = createTrieFromBase64(base64);
var BREAK_NOT_ALLOWED = "\xD7";
var BREAK_ALLOWED = "\xF7";
var codePointToClass = function(codePoint) {
  return UnicodeTrie.get(codePoint);
};
var _graphemeBreakAtIndex = function(_codePoints, classTypes, index2) {
  var prevIndex = index2 - 2;
  var prev = classTypes[prevIndex];
  var current = classTypes[index2 - 1];
  var next3 = classTypes[index2];
  if (current === CR && next3 === LF) {
    return BREAK_NOT_ALLOWED;
  }
  if (current === CR || current === LF || current === Control) {
    return BREAK_ALLOWED;
  }
  if (next3 === CR || next3 === LF || next3 === Control) {
    return BREAK_ALLOWED;
  }
  if (current === L && [L, V, LV, LVT].indexOf(next3) !== -1) {
    return BREAK_NOT_ALLOWED;
  }
  if ((current === LV || current === V) && (next3 === V || next3 === T$1)) {
    return BREAK_NOT_ALLOWED;
  }
  if ((current === LVT || current === T$1) && next3 === T$1) {
    return BREAK_NOT_ALLOWED;
  }
  if (next3 === ZWJ || next3 === Extend) {
    return BREAK_NOT_ALLOWED;
  }
  if (next3 === SpacingMark) {
    return BREAK_NOT_ALLOWED;
  }
  if (current === Prepend) {
    return BREAK_NOT_ALLOWED;
  }
  if (current === ZWJ && next3 === Extended_Pictographic) {
    while (prev === Extend) {
      prev = classTypes[--prevIndex];
    }
    if (prev === Extended_Pictographic) {
      return BREAK_NOT_ALLOWED;
    }
  }
  if (current === RI && next3 === RI) {
    var countRI = 0;
    while (prev === RI) {
      countRI++;
      prev = classTypes[--prevIndex];
    }
    if (countRI % 2 === 0) {
      return BREAK_NOT_ALLOWED;
    }
  }
  return BREAK_ALLOWED;
};
var GraphemeBreaker = function(str) {
  var codePoints = toCodePoints(str);
  var length = codePoints.length;
  var index2 = 0;
  var lastEnd = 0;
  var classTypes = codePoints.map(codePointToClass);
  return {
    next: function() {
      if (index2 >= length) {
        return { done: true, value: null };
      }
      var graphemeBreak = BREAK_NOT_ALLOWED;
      while (index2 < length && (graphemeBreak = _graphemeBreakAtIndex(codePoints, classTypes, ++index2)) === BREAK_NOT_ALLOWED) {
      }
      if (graphemeBreak !== BREAK_NOT_ALLOWED || index2 === length) {
        var value = fromCodePoint.apply(null, codePoints.slice(lastEnd, index2));
        lastEnd = index2;
        return { value, done: false };
      }
      return { done: true, value: null };
    }
  };
};
var splitGraphemes = function(str) {
  var breaker = GraphemeBreaker(str);
  var graphemes = [];
  var bk;
  while (!(bk = breaker.next()).done) {
    if (bk.value) {
      graphemes.push(bk.value.slice());
    }
  }
  return graphemes;
};
var testRangeBounds = function(document2) {
  var TEST_HEIGHT = 123;
  if (document2.createRange) {
    var range = document2.createRange();
    if (range.getBoundingClientRect) {
      var testElement = document2.createElement("boundtest");
      testElement.style.height = TEST_HEIGHT + "px";
      testElement.style.display = "block";
      document2.body.appendChild(testElement);
      range.selectNode(testElement);
      var rangeBounds = range.getBoundingClientRect();
      var rangeHeight = Math.round(rangeBounds.height);
      document2.body.removeChild(testElement);
      if (rangeHeight === TEST_HEIGHT) {
        return true;
      }
    }
  }
  return false;
};
var testIOSLineBreak = function(document2) {
  var testElement = document2.createElement("boundtest");
  testElement.style.width = "50px";
  testElement.style.display = "block";
  testElement.style.fontSize = "12px";
  testElement.style.letterSpacing = "0px";
  testElement.style.wordSpacing = "0px";
  document2.body.appendChild(testElement);
  var range = document2.createRange();
  testElement.innerHTML = typeof "".repeat === "function" ? "&#128104;".repeat(10) : "";
  var node2 = testElement.firstChild;
  var textList = toCodePoints$1(node2.data).map(function(i2) {
    return fromCodePoint$1(i2);
  });
  var offset2 = 0;
  var prev = {};
  var supports = textList.every(function(text2, i2) {
    range.setStart(node2, offset2);
    range.setEnd(node2, offset2 + text2.length);
    var rect = range.getBoundingClientRect();
    offset2 += text2.length;
    var boundAhead = rect.x > prev.x || rect.y > prev.y;
    prev = rect;
    if (i2 === 0) {
      return true;
    }
    return boundAhead;
  });
  document2.body.removeChild(testElement);
  return supports;
};
var testCORS = function() {
  return typeof new Image().crossOrigin !== "undefined";
};
var testResponseType = function() {
  return typeof new XMLHttpRequest().responseType === "string";
};
var testSVG = function(document2) {
  var img = new Image();
  var canvas = document2.createElement("canvas");
  var ctx = canvas.getContext("2d");
  if (!ctx) {
    return false;
  }
  img.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
  try {
    ctx.drawImage(img, 0, 0);
    canvas.toDataURL();
  } catch (e2) {
    return false;
  }
  return true;
};
var isGreenPixel = function(data2) {
  return data2[0] === 0 && data2[1] === 255 && data2[2] === 0 && data2[3] === 255;
};
var testForeignObject = function(document2) {
  var canvas = document2.createElement("canvas");
  var size = 100;
  canvas.width = size;
  canvas.height = size;
  var ctx = canvas.getContext("2d");
  if (!ctx) {
    return Promise.reject(false);
  }
  ctx.fillStyle = "rgb(0, 255, 0)";
  ctx.fillRect(0, 0, size, size);
  var img = new Image();
  var greenImageSrc = canvas.toDataURL();
  img.src = greenImageSrc;
  var svg2 = createForeignObjectSVG(size, size, 0, 0, img);
  ctx.fillStyle = "red";
  ctx.fillRect(0, 0, size, size);
  return loadSerializedSVG$1(svg2).then(function(img2) {
    ctx.drawImage(img2, 0, 0);
    var data2 = ctx.getImageData(0, 0, size, size).data;
    ctx.fillStyle = "red";
    ctx.fillRect(0, 0, size, size);
    var node2 = document2.createElement("div");
    node2.style.backgroundImage = "url(" + greenImageSrc + ")";
    node2.style.height = size + "px";
    return isGreenPixel(data2) ? loadSerializedSVG$1(createForeignObjectSVG(size, size, 0, 0, node2)) : Promise.reject(false);
  }).then(function(img2) {
    ctx.drawImage(img2, 0, 0);
    return isGreenPixel(ctx.getImageData(0, 0, size, size).data);
  }).catch(function() {
    return false;
  });
};
var createForeignObjectSVG = function(width, height, x2, y2, node2) {
  var xmlns = "http://www.w3.org/2000/svg";
  var svg2 = document.createElementNS(xmlns, "svg");
  var foreignObject = document.createElementNS(xmlns, "foreignObject");
  svg2.setAttributeNS(null, "width", width.toString());
  svg2.setAttributeNS(null, "height", height.toString());
  foreignObject.setAttributeNS(null, "width", "100%");
  foreignObject.setAttributeNS(null, "height", "100%");
  foreignObject.setAttributeNS(null, "x", x2.toString());
  foreignObject.setAttributeNS(null, "y", y2.toString());
  foreignObject.setAttributeNS(null, "externalResourcesRequired", "true");
  svg2.appendChild(foreignObject);
  foreignObject.appendChild(node2);
  return svg2;
};
var loadSerializedSVG$1 = function(svg2) {
  return new Promise(function(resolve2, reject2) {
    var img = new Image();
    img.onload = function() {
      return resolve2(img);
    };
    img.onerror = reject2;
    img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg2));
  });
};
var FEATURES = {
  get SUPPORT_RANGE_BOUNDS() {
    var value = testRangeBounds(document);
    Object.defineProperty(FEATURES, "SUPPORT_RANGE_BOUNDS", { value });
    return value;
  },
  get SUPPORT_WORD_BREAKING() {
    var value = FEATURES.SUPPORT_RANGE_BOUNDS && testIOSLineBreak(document);
    Object.defineProperty(FEATURES, "SUPPORT_WORD_BREAKING", { value });
    return value;
  },
  get SUPPORT_SVG_DRAWING() {
    var value = testSVG(document);
    Object.defineProperty(FEATURES, "SUPPORT_SVG_DRAWING", { value });
    return value;
  },
  get SUPPORT_FOREIGNOBJECT_DRAWING() {
    var value = typeof Array.from === "function" && typeof window.fetch === "function" ? testForeignObject(document) : Promise.resolve(false);
    Object.defineProperty(FEATURES, "SUPPORT_FOREIGNOBJECT_DRAWING", { value });
    return value;
  },
  get SUPPORT_CORS_IMAGES() {
    var value = testCORS();
    Object.defineProperty(FEATURES, "SUPPORT_CORS_IMAGES", { value });
    return value;
  },
  get SUPPORT_RESPONSE_TYPE() {
    var value = testResponseType();
    Object.defineProperty(FEATURES, "SUPPORT_RESPONSE_TYPE", { value });
    return value;
  },
  get SUPPORT_CORS_XHR() {
    var value = "withCredentials" in new XMLHttpRequest();
    Object.defineProperty(FEATURES, "SUPPORT_CORS_XHR", { value });
    return value;
  },
  get SUPPORT_NATIVE_TEXT_SEGMENTATION() {
    var value = !!(typeof Intl !== "undefined" && Intl.Segmenter);
    Object.defineProperty(FEATURES, "SUPPORT_NATIVE_TEXT_SEGMENTATION", { value });
    return value;
  }
};
var TextBounds = function() {
  function TextBounds2(text2, bounds) {
    this.text = text2;
    this.bounds = bounds;
  }
  return TextBounds2;
}();
var parseTextBounds = function(context2, value, styles, node2) {
  var textList = breakText(value, styles);
  var textBounds = [];
  var offset2 = 0;
  textList.forEach(function(text2) {
    if (styles.textDecorationLine.length || text2.trim().length > 0) {
      if (FEATURES.SUPPORT_RANGE_BOUNDS) {
        var clientRects = createRange(node2, offset2, text2.length).getClientRects();
        if (clientRects.length > 1) {
          var subSegments = segmentGraphemes(text2);
          var subOffset_1 = 0;
          subSegments.forEach(function(subSegment) {
            textBounds.push(new TextBounds(subSegment, Bounds.fromDOMRectList(context2, createRange(node2, subOffset_1 + offset2, subSegment.length).getClientRects())));
            subOffset_1 += subSegment.length;
          });
        } else {
          textBounds.push(new TextBounds(text2, Bounds.fromDOMRectList(context2, clientRects)));
        }
      } else {
        var replacementNode = node2.splitText(text2.length);
        textBounds.push(new TextBounds(text2, getWrapperBounds(context2, node2)));
        node2 = replacementNode;
      }
    } else if (!FEATURES.SUPPORT_RANGE_BOUNDS) {
      node2 = node2.splitText(text2.length);
    }
    offset2 += text2.length;
  });
  return textBounds;
};
var getWrapperBounds = function(context2, node2) {
  var ownerDocument = node2.ownerDocument;
  if (ownerDocument) {
    var wrapper = ownerDocument.createElement("html2canvaswrapper");
    wrapper.appendChild(node2.cloneNode(true));
    var parentNode = node2.parentNode;
    if (parentNode) {
      parentNode.replaceChild(wrapper, node2);
      var bounds = parseBounds(context2, wrapper);
      if (wrapper.firstChild) {
        parentNode.replaceChild(wrapper.firstChild, wrapper);
      }
      return bounds;
    }
  }
  return Bounds.EMPTY;
};
var createRange = function(node2, offset2, length) {
  var ownerDocument = node2.ownerDocument;
  if (!ownerDocument) {
    throw new Error("Node has no owner document");
  }
  var range = ownerDocument.createRange();
  range.setStart(node2, offset2);
  range.setEnd(node2, offset2 + length);
  return range;
};
var segmentGraphemes = function(value) {
  if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
    var segmenter = new Intl.Segmenter(void 0, { granularity: "grapheme" });
    return Array.from(segmenter.segment(value)).map(function(segment) {
      return segment.segment;
    });
  }
  return splitGraphemes(value);
};
var segmentWords = function(value, styles) {
  if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
    var segmenter = new Intl.Segmenter(void 0, {
      granularity: "word"
    });
    return Array.from(segmenter.segment(value)).map(function(segment) {
      return segment.segment;
    });
  }
  return breakWords(value, styles);
};
var breakText = function(value, styles) {
  return styles.letterSpacing !== 0 ? segmentGraphemes(value) : segmentWords(value, styles);
};
var wordSeparators = [32, 160, 4961, 65792, 65793, 4153, 4241];
var breakWords = function(str, styles) {
  var breaker = LineBreaker(str, {
    lineBreak: styles.lineBreak,
    wordBreak: styles.overflowWrap === "break-word" ? "break-word" : styles.wordBreak
  });
  var words = [];
  var bk;
  var _loop_1 = function() {
    if (bk.value) {
      var value = bk.value.slice();
      var codePoints = toCodePoints$1(value);
      var word_1 = "";
      codePoints.forEach(function(codePoint) {
        if (wordSeparators.indexOf(codePoint) === -1) {
          word_1 += fromCodePoint$1(codePoint);
        } else {
          if (word_1.length) {
            words.push(word_1);
          }
          words.push(fromCodePoint$1(codePoint));
          word_1 = "";
        }
      });
      if (word_1.length) {
        words.push(word_1);
      }
    }
  };
  while (!(bk = breaker.next()).done) {
    _loop_1();
  }
  return words;
};
var TextContainer = function() {
  function TextContainer2(context2, node2, styles) {
    this.text = transform(node2.data, styles.textTransform);
    this.textBounds = parseTextBounds(context2, this.text, styles, node2);
  }
  return TextContainer2;
}();
var transform = function(text2, transform2) {
  switch (transform2) {
    case 1:
      return text2.toLowerCase();
    case 3:
      return text2.replace(CAPITALIZE, capitalize);
    case 2:
      return text2.toUpperCase();
    default:
      return text2;
  }
};
var CAPITALIZE = /(^|\s|:|-|\(|\))([a-z])/g;
var capitalize = function(m2, p12, p22) {
  if (m2.length > 0) {
    return p12 + p22.toUpperCase();
  }
  return m2;
};
var ImageElementContainer = function(_super) {
  __extends(ImageElementContainer2, _super);
  function ImageElementContainer2(context2, img) {
    var _this = _super.call(this, context2, img) || this;
    _this.src = img.currentSrc || img.src;
    _this.intrinsicWidth = img.naturalWidth;
    _this.intrinsicHeight = img.naturalHeight;
    _this.context.cache.addImage(_this.src);
    return _this;
  }
  return ImageElementContainer2;
}(ElementContainer);
var CanvasElementContainer = function(_super) {
  __extends(CanvasElementContainer2, _super);
  function CanvasElementContainer2(context2, canvas) {
    var _this = _super.call(this, context2, canvas) || this;
    _this.canvas = canvas;
    _this.intrinsicWidth = canvas.width;
    _this.intrinsicHeight = canvas.height;
    return _this;
  }
  return CanvasElementContainer2;
}(ElementContainer);
var SVGElementContainer = function(_super) {
  __extends(SVGElementContainer2, _super);
  function SVGElementContainer2(context2, img) {
    var _this = _super.call(this, context2, img) || this;
    var s2 = new XMLSerializer();
    var bounds = parseBounds(context2, img);
    img.setAttribute("width", bounds.width + "px");
    img.setAttribute("height", bounds.height + "px");
    _this.svg = "data:image/svg+xml," + encodeURIComponent(s2.serializeToString(img));
    _this.intrinsicWidth = img.width.baseVal.value;
    _this.intrinsicHeight = img.height.baseVal.value;
    _this.context.cache.addImage(_this.svg);
    return _this;
  }
  return SVGElementContainer2;
}(ElementContainer);
var LIElementContainer = function(_super) {
  __extends(LIElementContainer2, _super);
  function LIElementContainer2(context2, element) {
    var _this = _super.call(this, context2, element) || this;
    _this.value = element.value;
    return _this;
  }
  return LIElementContainer2;
}(ElementContainer);
var OLElementContainer = function(_super) {
  __extends(OLElementContainer2, _super);
  function OLElementContainer2(context2, element) {
    var _this = _super.call(this, context2, element) || this;
    _this.start = element.start;
    _this.reversed = typeof element.reversed === "boolean" && element.reversed === true;
    return _this;
  }
  return OLElementContainer2;
}(ElementContainer);
var CHECKBOX_BORDER_RADIUS = [
  {
    type: 15,
    flags: 0,
    unit: "px",
    number: 3
  }
];
var RADIO_BORDER_RADIUS = [
  {
    type: 16,
    flags: 0,
    number: 50
  }
];
var reformatInputBounds = function(bounds) {
  if (bounds.width > bounds.height) {
    return new Bounds(bounds.left + (bounds.width - bounds.height) / 2, bounds.top, bounds.height, bounds.height);
  } else if (bounds.width < bounds.height) {
    return new Bounds(bounds.left, bounds.top + (bounds.height - bounds.width) / 2, bounds.width, bounds.width);
  }
  return bounds;
};
var getInputValue = function(node2) {
  var value = node2.type === PASSWORD ? new Array(node2.value.length + 1).join("\u2022") : node2.value;
  return value.length === 0 ? node2.placeholder || "" : value;
};
var CHECKBOX = "checkbox";
var RADIO = "radio";
var PASSWORD = "password";
var INPUT_COLOR = 707406591;
var InputElementContainer = function(_super) {
  __extends(InputElementContainer2, _super);
  function InputElementContainer2(context2, input) {
    var _this = _super.call(this, context2, input) || this;
    _this.type = input.type.toLowerCase();
    _this.checked = input.checked;
    _this.value = getInputValue(input);
    if (_this.type === CHECKBOX || _this.type === RADIO) {
      _this.styles.backgroundColor = 3739148031;
      _this.styles.borderTopColor = _this.styles.borderRightColor = _this.styles.borderBottomColor = _this.styles.borderLeftColor = 2779096575;
      _this.styles.borderTopWidth = _this.styles.borderRightWidth = _this.styles.borderBottomWidth = _this.styles.borderLeftWidth = 1;
      _this.styles.borderTopStyle = _this.styles.borderRightStyle = _this.styles.borderBottomStyle = _this.styles.borderLeftStyle = 1;
      _this.styles.backgroundClip = [0];
      _this.styles.backgroundOrigin = [0];
      _this.bounds = reformatInputBounds(_this.bounds);
    }
    switch (_this.type) {
      case CHECKBOX:
        _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = CHECKBOX_BORDER_RADIUS;
        break;
      case RADIO:
        _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = RADIO_BORDER_RADIUS;
        break;
    }
    return _this;
  }
  return InputElementContainer2;
}(ElementContainer);
var SelectElementContainer = function(_super) {
  __extends(SelectElementContainer2, _super);
  function SelectElementContainer2(context2, element) {
    var _this = _super.call(this, context2, element) || this;
    var option = element.options[element.selectedIndex || 0];
    _this.value = option ? option.text || "" : "";
    return _this;
  }
  return SelectElementContainer2;
}(ElementContainer);
var TextareaElementContainer = function(_super) {
  __extends(TextareaElementContainer2, _super);
  function TextareaElementContainer2(context2, element) {
    var _this = _super.call(this, context2, element) || this;
    _this.value = element.value;
    return _this;
  }
  return TextareaElementContainer2;
}(ElementContainer);
var IFrameElementContainer = function(_super) {
  __extends(IFrameElementContainer2, _super);
  function IFrameElementContainer2(context2, iframe) {
    var _this = _super.call(this, context2, iframe) || this;
    _this.src = iframe.src;
    _this.width = parseInt(iframe.width, 10) || 0;
    _this.height = parseInt(iframe.height, 10) || 0;
    _this.backgroundColor = _this.styles.backgroundColor;
    try {
      if (iframe.contentWindow && iframe.contentWindow.document && iframe.contentWindow.document.documentElement) {
        _this.tree = parseTree(context2, iframe.contentWindow.document.documentElement);
        var documentBackgroundColor = iframe.contentWindow.document.documentElement ? parseColor(context2, getComputedStyle(iframe.contentWindow.document.documentElement).backgroundColor) : COLORS.TRANSPARENT;
        var bodyBackgroundColor = iframe.contentWindow.document.body ? parseColor(context2, getComputedStyle(iframe.contentWindow.document.body).backgroundColor) : COLORS.TRANSPARENT;
        _this.backgroundColor = isTransparent(documentBackgroundColor) ? isTransparent(bodyBackgroundColor) ? _this.styles.backgroundColor : bodyBackgroundColor : documentBackgroundColor;
      }
    } catch (e2) {
    }
    return _this;
  }
  return IFrameElementContainer2;
}(ElementContainer);
var LIST_OWNERS = ["OL", "UL", "MENU"];
var parseNodeTree = function(context2, node2, parent, root2) {
  for (var childNode = node2.firstChild, nextNode = void 0; childNode; childNode = nextNode) {
    nextNode = childNode.nextSibling;
    if (isTextNode(childNode) && childNode.data.trim().length > 0) {
      parent.textNodes.push(new TextContainer(context2, childNode, parent.styles));
    } else if (isElementNode(childNode)) {
      if (isSlotElement(childNode) && childNode.assignedNodes) {
        childNode.assignedNodes().forEach(function(childNode2) {
          return parseNodeTree(context2, childNode2, parent, root2);
        });
      } else {
        var container = createContainer(context2, childNode);
        if (container.styles.isVisible()) {
          if (createsRealStackingContext(childNode, container, root2)) {
            container.flags |= 4;
          } else if (createsStackingContext(container.styles)) {
            container.flags |= 2;
          }
          if (LIST_OWNERS.indexOf(childNode.tagName) !== -1) {
            container.flags |= 8;
          }
          parent.elements.push(container);
          childNode.slot;
          if (childNode.shadowRoot) {
            parseNodeTree(context2, childNode.shadowRoot, container, root2);
          } else if (!isTextareaElement(childNode) && !isSVGElement(childNode) && !isSelectElement(childNode)) {
            parseNodeTree(context2, childNode, container, root2);
          }
        }
      }
    }
  }
};
var createContainer = function(context2, element) {
  if (isImageElement(element)) {
    return new ImageElementContainer(context2, element);
  }
  if (isCanvasElement(element)) {
    return new CanvasElementContainer(context2, element);
  }
  if (isSVGElement(element)) {
    return new SVGElementContainer(context2, element);
  }
  if (isLIElement(element)) {
    return new LIElementContainer(context2, element);
  }
  if (isOLElement(element)) {
    return new OLElementContainer(context2, element);
  }
  if (isInputElement(element)) {
    return new InputElementContainer(context2, element);
  }
  if (isSelectElement(element)) {
    return new SelectElementContainer(context2, element);
  }
  if (isTextareaElement(element)) {
    return new TextareaElementContainer(context2, element);
  }
  if (isIFrameElement(element)) {
    return new IFrameElementContainer(context2, element);
  }
  return new ElementContainer(context2, element);
};
var parseTree = function(context2, element) {
  var container = createContainer(context2, element);
  container.flags |= 4;
  parseNodeTree(context2, element, container, container);
  return container;
};
var createsRealStackingContext = function(node2, container, root2) {
  return container.styles.isPositionedWithZIndex() || container.styles.opacity < 1 || container.styles.isTransformed() || isBodyElement(node2) && root2.styles.isTransparent();
};
var createsStackingContext = function(styles) {
  return styles.isPositioned() || styles.isFloating();
};
var isTextNode = function(node2) {
  return node2.nodeType === Node.TEXT_NODE;
};
var isElementNode = function(node2) {
  return node2.nodeType === Node.ELEMENT_NODE;
};
var isHTMLElementNode = function(node2) {
  return isElementNode(node2) && typeof node2.style !== "undefined" && !isSVGElementNode(node2);
};
var isSVGElementNode = function(element) {
  return typeof element.className === "object";
};
var isLIElement = function(node2) {
  return node2.tagName === "LI";
};
var isOLElement = function(node2) {
  return node2.tagName === "OL";
};
var isInputElement = function(node2) {
  return node2.tagName === "INPUT";
};
var isHTMLElement = function(node2) {
  return node2.tagName === "HTML";
};
var isSVGElement = function(node2) {
  return node2.tagName === "svg";
};
var isBodyElement = function(node2) {
  return node2.tagName === "BODY";
};
var isCanvasElement = function(node2) {
  return node2.tagName === "CANVAS";
};
var isVideoElement = function(node2) {
  return node2.tagName === "VIDEO";
};
var isImageElement = function(node2) {
  return node2.tagName === "IMG";
};
var isIFrameElement = function(node2) {
  return node2.tagName === "IFRAME";
};
var isStyleElement = function(node2) {
  return node2.tagName === "STYLE";
};
var isScriptElement = function(node2) {
  return node2.tagName === "SCRIPT";
};
var isTextareaElement = function(node2) {
  return node2.tagName === "TEXTAREA";
};
var isSelectElement = function(node2) {
  return node2.tagName === "SELECT";
};
var isSlotElement = function(node2) {
  return node2.tagName === "SLOT";
};
var isCustomElement = function(node2) {
  return node2.tagName.indexOf("-") > 0;
};
var CounterState = function() {
  function CounterState2() {
    this.counters = {};
  }
  CounterState2.prototype.getCounterValue = function(name) {
    var counter2 = this.counters[name];
    if (counter2 && counter2.length) {
      return counter2[counter2.length - 1];
    }
    return 1;
  };
  CounterState2.prototype.getCounterValues = function(name) {
    var counter2 = this.counters[name];
    return counter2 ? counter2 : [];
  };
  CounterState2.prototype.pop = function(counters) {
    var _this = this;
    counters.forEach(function(counter2) {
      return _this.counters[counter2].pop();
    });
  };
  CounterState2.prototype.parse = function(style2) {
    var _this = this;
    var counterIncrement2 = style2.counterIncrement;
    var counterReset2 = style2.counterReset;
    var canReset = true;
    if (counterIncrement2 !== null) {
      counterIncrement2.forEach(function(entry) {
        var counter2 = _this.counters[entry.counter];
        if (counter2 && entry.increment !== 0) {
          canReset = false;
          if (!counter2.length) {
            counter2.push(1);
          }
          counter2[Math.max(0, counter2.length - 1)] += entry.increment;
        }
      });
    }
    var counterNames = [];
    if (canReset) {
      counterReset2.forEach(function(entry) {
        var counter2 = _this.counters[entry.counter];
        counterNames.push(entry.counter);
        if (!counter2) {
          counter2 = _this.counters[entry.counter] = [];
        }
        counter2.push(entry.reset);
      });
    }
    return counterNames;
  };
  return CounterState2;
}();
var ROMAN_UPPER = {
  integers: [1e3, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
  values: ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"]
};
var ARMENIAN = {
  integers: [
    9e3,
    8e3,
    7e3,
    6e3,
    5e3,
    4e3,
    3e3,
    2e3,
    1e3,
    900,
    800,
    700,
    600,
    500,
    400,
    300,
    200,
    100,
    90,
    80,
    70,
    60,
    50,
    40,
    30,
    20,
    10,
    9,
    8,
    7,
    6,
    5,
    4,
    3,
    2,
    1
  ],
  values: [
    "\u0554",
    "\u0553",
    "\u0552",
    "\u0551",
    "\u0550",
    "\u054F",
    "\u054E",
    "\u054D",
    "\u054C",
    "\u054B",
    "\u054A",
    "\u0549",
    "\u0548",
    "\u0547",
    "\u0546",
    "\u0545",
    "\u0544",
    "\u0543",
    "\u0542",
    "\u0541",
    "\u0540",
    "\u053F",
    "\u053E",
    "\u053D",
    "\u053C",
    "\u053B",
    "\u053A",
    "\u0539",
    "\u0538",
    "\u0537",
    "\u0536",
    "\u0535",
    "\u0534",
    "\u0533",
    "\u0532",
    "\u0531"
  ]
};
var HEBREW = {
  integers: [
    1e4,
    9e3,
    8e3,
    7e3,
    6e3,
    5e3,
    4e3,
    3e3,
    2e3,
    1e3,
    400,
    300,
    200,
    100,
    90,
    80,
    70,
    60,
    50,
    40,
    30,
    20,
    19,
    18,
    17,
    16,
    15,
    10,
    9,
    8,
    7,
    6,
    5,
    4,
    3,
    2,
    1
  ],
  values: [
    "\u05D9\u05F3",
    "\u05D8\u05F3",
    "\u05D7\u05F3",
    "\u05D6\u05F3",
    "\u05D5\u05F3",
    "\u05D4\u05F3",
    "\u05D3\u05F3",
    "\u05D2\u05F3",
    "\u05D1\u05F3",
    "\u05D0\u05F3",
    "\u05EA",
    "\u05E9",
    "\u05E8",
    "\u05E7",
    "\u05E6",
    "\u05E4",
    "\u05E2",
    "\u05E1",
    "\u05E0",
    "\u05DE",
    "\u05DC",
    "\u05DB",
    "\u05D9\u05D8",
    "\u05D9\u05D7",
    "\u05D9\u05D6",
    "\u05D8\u05D6",
    "\u05D8\u05D5",
    "\u05D9",
    "\u05D8",
    "\u05D7",
    "\u05D6",
    "\u05D5",
    "\u05D4",
    "\u05D3",
    "\u05D2",
    "\u05D1",
    "\u05D0"
  ]
};
var GEORGIAN = {
  integers: [
    1e4,
    9e3,
    8e3,
    7e3,
    6e3,
    5e3,
    4e3,
    3e3,
    2e3,
    1e3,
    900,
    800,
    700,
    600,
    500,
    400,
    300,
    200,
    100,
    90,
    80,
    70,
    60,
    50,
    40,
    30,
    20,
    10,
    9,
    8,
    7,
    6,
    5,
    4,
    3,
    2,
    1
  ],
  values: [
    "\u10F5",
    "\u10F0",
    "\u10EF",
    "\u10F4",
    "\u10EE",
    "\u10ED",
    "\u10EC",
    "\u10EB",
    "\u10EA",
    "\u10E9",
    "\u10E8",
    "\u10E7",
    "\u10E6",
    "\u10E5",
    "\u10E4",
    "\u10F3",
    "\u10E2",
    "\u10E1",
    "\u10E0",
    "\u10DF",
    "\u10DE",
    "\u10DD",
    "\u10F2",
    "\u10DC",
    "\u10DB",
    "\u10DA",
    "\u10D9",
    "\u10D8",
    "\u10D7",
    "\u10F1",
    "\u10D6",
    "\u10D5",
    "\u10D4",
    "\u10D3",
    "\u10D2",
    "\u10D1",
    "\u10D0"
  ]
};
var createAdditiveCounter = function(value, min2, max2, symbols, fallback, suffix2) {
  if (value < min2 || value > max2) {
    return createCounterText(value, fallback, suffix2.length > 0);
  }
  return symbols.integers.reduce(function(string, integer, index2) {
    while (value >= integer) {
      value -= integer;
      string += symbols.values[index2];
    }
    return string;
  }, "") + suffix2;
};
var createCounterStyleWithSymbolResolver = function(value, codePointRangeLength, isNumeric, resolver) {
  var string = "";
  do {
    if (!isNumeric) {
      value--;
    }
    string = resolver(value) + string;
    value /= codePointRangeLength;
  } while (value * codePointRangeLength >= codePointRangeLength);
  return string;
};
var createCounterStyleFromRange = function(value, codePointRangeStart, codePointRangeEnd, isNumeric, suffix2) {
  var codePointRangeLength = codePointRangeEnd - codePointRangeStart + 1;
  return (value < 0 ? "-" : "") + (createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, isNumeric, function(codePoint) {
    return fromCodePoint$1(Math.floor(codePoint % codePointRangeLength) + codePointRangeStart);
  }) + suffix2);
};
var createCounterStyleFromSymbols = function(value, symbols, suffix2) {
  if (suffix2 === void 0) {
    suffix2 = ". ";
  }
  var codePointRangeLength = symbols.length;
  return createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, false, function(codePoint) {
    return symbols[Math.floor(codePoint % codePointRangeLength)];
  }) + suffix2;
};
var CJK_ZEROS = 1 << 0;
var CJK_TEN_COEFFICIENTS = 1 << 1;
var CJK_TEN_HIGH_COEFFICIENTS = 1 << 2;
var CJK_HUNDRED_COEFFICIENTS = 1 << 3;
var createCJKCounter = function(value, numbers, multipliers, negativeSign, suffix2, flags) {
  if (value < -9999 || value > 9999) {
    return createCounterText(value, 4, suffix2.length > 0);
  }
  var tmp = Math.abs(value);
  var string = suffix2;
  if (tmp === 0) {
    return numbers[0] + string;
  }
  for (var digit = 0; tmp > 0 && digit <= 4; digit++) {
    var coefficient = tmp % 10;
    if (coefficient === 0 && contains(flags, CJK_ZEROS) && string !== "") {
      string = numbers[coefficient] + string;
    } else if (coefficient > 1 || coefficient === 1 && digit === 0 || coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_COEFFICIENTS) || coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_HIGH_COEFFICIENTS) && value > 100 || coefficient === 1 && digit > 1 && contains(flags, CJK_HUNDRED_COEFFICIENTS)) {
      string = numbers[coefficient] + (digit > 0 ? multipliers[digit - 1] : "") + string;
    } else if (coefficient === 1 && digit > 0) {
      string = multipliers[digit - 1] + string;
    }
    tmp = Math.floor(tmp / 10);
  }
  return (value < 0 ? negativeSign : "") + string;
};
var CHINESE_INFORMAL_MULTIPLIERS = "\u5341\u767E\u5343\u842C";
var CHINESE_FORMAL_MULTIPLIERS = "\u62FE\u4F70\u4EDF\u842C";
var JAPANESE_NEGATIVE = "\u30DE\u30A4\u30CA\u30B9";
var KOREAN_NEGATIVE = "\uB9C8\uC774\uB108\uC2A4";
var createCounterText = function(value, type, appendSuffix) {
  var defaultSuffix = appendSuffix ? ". " : "";
  var cjkSuffix = appendSuffix ? "\u3001" : "";
  var koreanSuffix = appendSuffix ? ", " : "";
  var spaceSuffix = appendSuffix ? " " : "";
  switch (type) {
    case 0:
      return "\u2022" + spaceSuffix;
    case 1:
      return "\u25E6" + spaceSuffix;
    case 2:
      return "\u25FE" + spaceSuffix;
    case 5:
      var string = createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
      return string.length < 4 ? "0" + string : string;
    case 4:
      return createCounterStyleFromSymbols(value, "\u3007\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", cjkSuffix);
    case 6:
      return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3, defaultSuffix).toLowerCase();
    case 7:
      return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3, defaultSuffix);
    case 8:
      return createCounterStyleFromRange(value, 945, 969, false, defaultSuffix);
    case 9:
      return createCounterStyleFromRange(value, 97, 122, false, defaultSuffix);
    case 10:
      return createCounterStyleFromRange(value, 65, 90, false, defaultSuffix);
    case 11:
      return createCounterStyleFromRange(value, 1632, 1641, true, defaultSuffix);
    case 12:
    case 49:
      return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3, defaultSuffix);
    case 35:
      return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3, defaultSuffix).toLowerCase();
    case 13:
      return createCounterStyleFromRange(value, 2534, 2543, true, defaultSuffix);
    case 14:
    case 30:
      return createCounterStyleFromRange(value, 6112, 6121, true, defaultSuffix);
    case 15:
      return createCounterStyleFromSymbols(value, "\u5B50\u4E11\u5BC5\u536F\u8FB0\u5DF3\u5348\u672A\u7533\u9149\u620C\u4EA5", cjkSuffix);
    case 16:
      return createCounterStyleFromSymbols(value, "\u7532\u4E59\u4E19\u4E01\u620A\u5DF1\u5E9A\u8F9B\u58EC\u7678", cjkSuffix);
    case 17:
    case 48:
      return createCJKCounter(value, "\u96F6\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", CHINESE_INFORMAL_MULTIPLIERS, "\u8CA0", cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
    case 47:
      return createCJKCounter(value, "\u96F6\u58F9\u8CB3\u53C3\u8086\u4F0D\u9678\u67D2\u634C\u7396", CHINESE_FORMAL_MULTIPLIERS, "\u8CA0", cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
    case 42:
      return createCJKCounter(value, "\u96F6\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", CHINESE_INFORMAL_MULTIPLIERS, "\u8D1F", cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
    case 41:
      return createCJKCounter(value, "\u96F6\u58F9\u8D30\u53C1\u8086\u4F0D\u9646\u67D2\u634C\u7396", CHINESE_FORMAL_MULTIPLIERS, "\u8D1F", cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
    case 26:
      return createCJKCounter(value, "\u3007\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", "\u5341\u767E\u5343\u4E07", JAPANESE_NEGATIVE, cjkSuffix, 0);
    case 25:
      return createCJKCounter(value, "\u96F6\u58F1\u5F10\u53C2\u56DB\u4F0D\u516D\u4E03\u516B\u4E5D", "\u62FE\u767E\u5343\u4E07", JAPANESE_NEGATIVE, cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
    case 31:
      return createCJKCounter(value, "\uC601\uC77C\uC774\uC0BC\uC0AC\uC624\uC721\uCE60\uD314\uAD6C", "\uC2ED\uBC31\uCC9C\uB9CC", KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
    case 33:
      return createCJKCounter(value, "\u96F6\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", "\u5341\u767E\u5343\u842C", KOREAN_NEGATIVE, koreanSuffix, 0);
    case 32:
      return createCJKCounter(value, "\u96F6\u58F9\u8CB3\u53C3\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", "\u62FE\u767E\u5343", KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
    case 18:
      return createCounterStyleFromRange(value, 2406, 2415, true, defaultSuffix);
    case 20:
      return createAdditiveCounter(value, 1, 19999, GEORGIAN, 3, defaultSuffix);
    case 21:
      return createCounterStyleFromRange(value, 2790, 2799, true, defaultSuffix);
    case 22:
      return createCounterStyleFromRange(value, 2662, 2671, true, defaultSuffix);
    case 22:
      return createAdditiveCounter(value, 1, 10999, HEBREW, 3, defaultSuffix);
    case 23:
      return createCounterStyleFromSymbols(value, "\u3042\u3044\u3046\u3048\u304A\u304B\u304D\u304F\u3051\u3053\u3055\u3057\u3059\u305B\u305D\u305F\u3061\u3064\u3066\u3068\u306A\u306B\u306C\u306D\u306E\u306F\u3072\u3075\u3078\u307B\u307E\u307F\u3080\u3081\u3082\u3084\u3086\u3088\u3089\u308A\u308B\u308C\u308D\u308F\u3090\u3091\u3092\u3093");
    case 24:
      return createCounterStyleFromSymbols(value, "\u3044\u308D\u306F\u306B\u307B\u3078\u3068\u3061\u308A\u306C\u308B\u3092\u308F\u304B\u3088\u305F\u308C\u305D\u3064\u306D\u306A\u3089\u3080\u3046\u3090\u306E\u304A\u304F\u3084\u307E\u3051\u3075\u3053\u3048\u3066\u3042\u3055\u304D\u3086\u3081\u307F\u3057\u3091\u3072\u3082\u305B\u3059");
    case 27:
      return createCounterStyleFromRange(value, 3302, 3311, true, defaultSuffix);
    case 28:
      return createCounterStyleFromSymbols(value, "\u30A2\u30A4\u30A6\u30A8\u30AA\u30AB\u30AD\u30AF\u30B1\u30B3\u30B5\u30B7\u30B9\u30BB\u30BD\u30BF\u30C1\u30C4\u30C6\u30C8\u30CA\u30CB\u30CC\u30CD\u30CE\u30CF\u30D2\u30D5\u30D8\u30DB\u30DE\u30DF\u30E0\u30E1\u30E2\u30E4\u30E6\u30E8\u30E9\u30EA\u30EB\u30EC\u30ED\u30EF\u30F0\u30F1\u30F2\u30F3", cjkSuffix);
    case 29:
      return createCounterStyleFromSymbols(value, "\u30A4\u30ED\u30CF\u30CB\u30DB\u30D8\u30C8\u30C1\u30EA\u30CC\u30EB\u30F2\u30EF\u30AB\u30E8\u30BF\u30EC\u30BD\u30C4\u30CD\u30CA\u30E9\u30E0\u30A6\u30F0\u30CE\u30AA\u30AF\u30E4\u30DE\u30B1\u30D5\u30B3\u30A8\u30C6\u30A2\u30B5\u30AD\u30E6\u30E1\u30DF\u30B7\u30F1\u30D2\u30E2\u30BB\u30B9", cjkSuffix);
    case 34:
      return createCounterStyleFromRange(value, 3792, 3801, true, defaultSuffix);
    case 37:
      return createCounterStyleFromRange(value, 6160, 6169, true, defaultSuffix);
    case 38:
      return createCounterStyleFromRange(value, 4160, 4169, true, defaultSuffix);
    case 39:
      return createCounterStyleFromRange(value, 2918, 2927, true, defaultSuffix);
    case 40:
      return createCounterStyleFromRange(value, 1776, 1785, true, defaultSuffix);
    case 43:
      return createCounterStyleFromRange(value, 3046, 3055, true, defaultSuffix);
    case 44:
      return createCounterStyleFromRange(value, 3174, 3183, true, defaultSuffix);
    case 45:
      return createCounterStyleFromRange(value, 3664, 3673, true, defaultSuffix);
    case 46:
      return createCounterStyleFromRange(value, 3872, 3881, true, defaultSuffix);
    case 3:
    default:
      return createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
  }
};
var IGNORE_ATTRIBUTE = "data-html2canvas-ignore";
var DocumentCloner = function() {
  function DocumentCloner2(context2, element, options) {
    this.context = context2;
    this.options = options;
    this.scrolledElements = [];
    this.referenceElement = element;
    this.counters = new CounterState();
    this.quoteDepth = 0;
    if (!element.ownerDocument) {
      throw new Error("Cloned element does not have an owner document");
    }
    this.documentElement = this.cloneNode(element.ownerDocument.documentElement, false);
  }
  DocumentCloner2.prototype.toIFrame = function(ownerDocument, windowSize) {
    var _this = this;
    var iframe = createIFrameContainer(ownerDocument, windowSize);
    if (!iframe.contentWindow) {
      return Promise.reject("Unable to find iframe window");
    }
    var scrollX = ownerDocument.defaultView.pageXOffset;
    var scrollY = ownerDocument.defaultView.pageYOffset;
    var cloneWindow = iframe.contentWindow;
    var documentClone = cloneWindow.document;
    var iframeLoad = iframeLoader(iframe).then(function() {
      return __awaiter(_this, void 0, void 0, function() {
        var onclone, referenceElement;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              this.scrolledElements.forEach(restoreNodeScroll);
              if (cloneWindow) {
                cloneWindow.scrollTo(windowSize.left, windowSize.top);
                if (/(iPad|iPhone|iPod)/g.test(navigator.userAgent) && (cloneWindow.scrollY !== windowSize.top || cloneWindow.scrollX !== windowSize.left)) {
                  this.context.logger.warn("Unable to restore scroll position for cloned document");
                  this.context.windowBounds = this.context.windowBounds.add(cloneWindow.scrollX - windowSize.left, cloneWindow.scrollY - windowSize.top, 0, 0);
                }
              }
              onclone = this.options.onclone;
              referenceElement = this.clonedReferenceElement;
              if (typeof referenceElement === "undefined") {
                return [2, Promise.reject("Error finding the " + this.referenceElement.nodeName + " in the cloned document")];
              }
              if (!(documentClone.fonts && documentClone.fonts.ready))
                return [3, 2];
              return [4, documentClone.fonts.ready];
            case 1:
              _a2.sent();
              _a2.label = 2;
            case 2:
              if (!/(AppleWebKit)/g.test(navigator.userAgent))
                return [3, 4];
              return [4, imagesReady(documentClone)];
            case 3:
              _a2.sent();
              _a2.label = 4;
            case 4:
              if (typeof onclone === "function") {
                return [2, Promise.resolve().then(function() {
                  return onclone(documentClone, referenceElement);
                }).then(function() {
                  return iframe;
                })];
              }
              return [2, iframe];
          }
        });
      });
    });
    documentClone.open();
    documentClone.write(serializeDoctype(document.doctype) + "<html></html>");
    restoreOwnerScroll(this.referenceElement.ownerDocument, scrollX, scrollY);
    documentClone.replaceChild(documentClone.adoptNode(this.documentElement), documentClone.documentElement);
    documentClone.close();
    return iframeLoad;
  };
  DocumentCloner2.prototype.createElementClone = function(node2) {
    if (isDebugging(node2, 2)) {
      debugger;
    }
    if (isCanvasElement(node2)) {
      return this.createCanvasClone(node2);
    }
    if (isVideoElement(node2)) {
      return this.createVideoClone(node2);
    }
    if (isStyleElement(node2)) {
      return this.createStyleClone(node2);
    }
    var clone2 = node2.cloneNode(false);
    if (isImageElement(clone2)) {
      if (isImageElement(node2) && node2.currentSrc && node2.currentSrc !== node2.src) {
        clone2.src = node2.currentSrc;
        clone2.srcset = "";
      }
      if (clone2.loading === "lazy") {
        clone2.loading = "eager";
      }
    }
    if (isCustomElement(clone2)) {
      return this.createCustomElementClone(clone2);
    }
    return clone2;
  };
  DocumentCloner2.prototype.createCustomElementClone = function(node2) {
    var clone2 = document.createElement("html2canvascustomelement");
    copyCSSStyles(node2.style, clone2);
    return clone2;
  };
  DocumentCloner2.prototype.createStyleClone = function(node2) {
    try {
      var sheet = node2.sheet;
      if (sheet && sheet.cssRules) {
        var css = [].slice.call(sheet.cssRules, 0).reduce(function(css2, rule) {
          if (rule && typeof rule.cssText === "string") {
            return css2 + rule.cssText;
          }
          return css2;
        }, "");
        var style2 = node2.cloneNode(false);
        style2.textContent = css;
        return style2;
      }
    } catch (e2) {
      this.context.logger.error("Unable to access cssRules property", e2);
      if (e2.name !== "SecurityError") {
        throw e2;
      }
    }
    return node2.cloneNode(false);
  };
  DocumentCloner2.prototype.createCanvasClone = function(canvas) {
    var _a2;
    if (this.options.inlineImages && canvas.ownerDocument) {
      var img = canvas.ownerDocument.createElement("img");
      try {
        img.src = canvas.toDataURL();
        return img;
      } catch (e2) {
        this.context.logger.info("Unable to inline canvas contents, canvas is tainted", canvas);
      }
    }
    var clonedCanvas = canvas.cloneNode(false);
    try {
      clonedCanvas.width = canvas.width;
      clonedCanvas.height = canvas.height;
      var ctx = canvas.getContext("2d");
      var clonedCtx = clonedCanvas.getContext("2d");
      if (clonedCtx) {
        if (!this.options.allowTaint && ctx) {
          clonedCtx.putImageData(ctx.getImageData(0, 0, canvas.width, canvas.height), 0, 0);
        } else {
          var gl = (_a2 = canvas.getContext("webgl2")) !== null && _a2 !== void 0 ? _a2 : canvas.getContext("webgl");
          if (gl) {
            var attribs = gl.getContextAttributes();
            if ((attribs === null || attribs === void 0 ? void 0 : attribs.preserveDrawingBuffer) === false) {
              this.context.logger.warn("Unable to clone WebGL context as it has preserveDrawingBuffer=false", canvas);
            }
          }
          clonedCtx.drawImage(canvas, 0, 0);
        }
      }
      return clonedCanvas;
    } catch (e2) {
      this.context.logger.info("Unable to clone canvas as it is tainted", canvas);
    }
    return clonedCanvas;
  };
  DocumentCloner2.prototype.createVideoClone = function(video) {
    var canvas = video.ownerDocument.createElement("canvas");
    canvas.width = video.offsetWidth;
    canvas.height = video.offsetHeight;
    var ctx = canvas.getContext("2d");
    try {
      if (ctx) {
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        if (!this.options.allowTaint) {
          ctx.getImageData(0, 0, canvas.width, canvas.height);
        }
      }
      return canvas;
    } catch (e2) {
      this.context.logger.info("Unable to clone video as it is tainted", video);
    }
    var blankCanvas = video.ownerDocument.createElement("canvas");
    blankCanvas.width = video.offsetWidth;
    blankCanvas.height = video.offsetHeight;
    return blankCanvas;
  };
  DocumentCloner2.prototype.appendChildNode = function(clone2, child, copyStyles) {
    if (!isElementNode(child) || !isScriptElement(child) && !child.hasAttribute(IGNORE_ATTRIBUTE) && (typeof this.options.ignoreElements !== "function" || !this.options.ignoreElements(child))) {
      if (!this.options.copyStyles || !isElementNode(child) || !isStyleElement(child)) {
        clone2.appendChild(this.cloneNode(child, copyStyles));
      }
    }
  };
  DocumentCloner2.prototype.cloneChildNodes = function(node2, clone2, copyStyles) {
    var _this = this;
    for (var child = node2.shadowRoot ? node2.shadowRoot.firstChild : node2.firstChild; child; child = child.nextSibling) {
      if (isElementNode(child) && isSlotElement(child) && typeof child.assignedNodes === "function") {
        var assignedNodes = child.assignedNodes();
        if (assignedNodes.length) {
          assignedNodes.forEach(function(assignedNode) {
            return _this.appendChildNode(clone2, assignedNode, copyStyles);
          });
        }
      } else {
        this.appendChildNode(clone2, child, copyStyles);
      }
    }
  };
  DocumentCloner2.prototype.cloneNode = function(node2, copyStyles) {
    if (isTextNode(node2)) {
      return document.createTextNode(node2.data);
    }
    if (!node2.ownerDocument) {
      return node2.cloneNode(false);
    }
    var window2 = node2.ownerDocument.defaultView;
    if (window2 && isElementNode(node2) && (isHTMLElementNode(node2) || isSVGElementNode(node2))) {
      var clone2 = this.createElementClone(node2);
      clone2.style.transitionProperty = "none";
      var style2 = window2.getComputedStyle(node2);
      var styleBefore = window2.getComputedStyle(node2, ":before");
      var styleAfter = window2.getComputedStyle(node2, ":after");
      if (this.referenceElement === node2 && isHTMLElementNode(clone2)) {
        this.clonedReferenceElement = clone2;
      }
      if (isBodyElement(clone2)) {
        createPseudoHideStyles(clone2);
      }
      var counters = this.counters.parse(new CSSParsedCounterDeclaration(this.context, style2));
      var before = this.resolvePseudoContent(node2, clone2, styleBefore, PseudoElementType.BEFORE);
      if (isCustomElement(node2)) {
        copyStyles = true;
      }
      if (!isVideoElement(node2)) {
        this.cloneChildNodes(node2, clone2, copyStyles);
      }
      if (before) {
        clone2.insertBefore(before, clone2.firstChild);
      }
      var after = this.resolvePseudoContent(node2, clone2, styleAfter, PseudoElementType.AFTER);
      if (after) {
        clone2.appendChild(after);
      }
      this.counters.pop(counters);
      if (style2 && (this.options.copyStyles || isSVGElementNode(node2)) && !isIFrameElement(node2) || copyStyles) {
        copyCSSStyles(style2, clone2);
      }
      if (node2.scrollTop !== 0 || node2.scrollLeft !== 0) {
        this.scrolledElements.push([clone2, node2.scrollLeft, node2.scrollTop]);
      }
      if ((isTextareaElement(node2) || isSelectElement(node2)) && (isTextareaElement(clone2) || isSelectElement(clone2))) {
        clone2.value = node2.value;
      }
      return clone2;
    }
    return node2.cloneNode(false);
  };
  DocumentCloner2.prototype.resolvePseudoContent = function(node2, clone2, style2, pseudoElt) {
    var _this = this;
    if (!style2) {
      return;
    }
    var value = style2.content;
    var document2 = clone2.ownerDocument;
    if (!document2 || !value || value === "none" || value === "-moz-alt-content" || style2.display === "none") {
      return;
    }
    this.counters.parse(new CSSParsedCounterDeclaration(this.context, style2));
    var declaration = new CSSParsedPseudoDeclaration(this.context, style2);
    var anonymousReplacedElement = document2.createElement("html2canvaspseudoelement");
    copyCSSStyles(style2, anonymousReplacedElement);
    declaration.content.forEach(function(token) {
      if (token.type === 0) {
        anonymousReplacedElement.appendChild(document2.createTextNode(token.value));
      } else if (token.type === 22) {
        var img = document2.createElement("img");
        img.src = token.value;
        img.style.opacity = "1";
        anonymousReplacedElement.appendChild(img);
      } else if (token.type === 18) {
        if (token.name === "attr") {
          var attr = token.values.filter(isIdentToken);
          if (attr.length) {
            anonymousReplacedElement.appendChild(document2.createTextNode(node2.getAttribute(attr[0].value) || ""));
          }
        } else if (token.name === "counter") {
          var _a2 = token.values.filter(nonFunctionArgSeparator), counter2 = _a2[0], counterStyle = _a2[1];
          if (counter2 && isIdentToken(counter2)) {
            var counterState = _this.counters.getCounterValue(counter2.value);
            var counterType = counterStyle && isIdentToken(counterStyle) ? listStyleType.parse(_this.context, counterStyle.value) : 3;
            anonymousReplacedElement.appendChild(document2.createTextNode(createCounterText(counterState, counterType, false)));
          }
        } else if (token.name === "counters") {
          var _b2 = token.values.filter(nonFunctionArgSeparator), counter2 = _b2[0], delim = _b2[1], counterStyle = _b2[2];
          if (counter2 && isIdentToken(counter2)) {
            var counterStates = _this.counters.getCounterValues(counter2.value);
            var counterType_1 = counterStyle && isIdentToken(counterStyle) ? listStyleType.parse(_this.context, counterStyle.value) : 3;
            var separator = delim && delim.type === 0 ? delim.value : "";
            var text2 = counterStates.map(function(value2) {
              return createCounterText(value2, counterType_1, false);
            }).join(separator);
            anonymousReplacedElement.appendChild(document2.createTextNode(text2));
          }
        } else
          ;
      } else if (token.type === 20) {
        switch (token.value) {
          case "open-quote":
            anonymousReplacedElement.appendChild(document2.createTextNode(getQuote(declaration.quotes, _this.quoteDepth++, true)));
            break;
          case "close-quote":
            anonymousReplacedElement.appendChild(document2.createTextNode(getQuote(declaration.quotes, --_this.quoteDepth, false)));
            break;
          default:
            anonymousReplacedElement.appendChild(document2.createTextNode(token.value));
        }
      }
    });
    anonymousReplacedElement.className = PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
    var newClassName = pseudoElt === PseudoElementType.BEFORE ? " " + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE : " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
    if (isSVGElementNode(clone2)) {
      clone2.className.baseValue += newClassName;
    } else {
      clone2.className += newClassName;
    }
    return anonymousReplacedElement;
  };
  DocumentCloner2.destroy = function(container) {
    if (container.parentNode) {
      container.parentNode.removeChild(container);
      return true;
    }
    return false;
  };
  return DocumentCloner2;
}();
var PseudoElementType;
(function(PseudoElementType2) {
  PseudoElementType2[PseudoElementType2["BEFORE"] = 0] = "BEFORE";
  PseudoElementType2[PseudoElementType2["AFTER"] = 1] = "AFTER";
})(PseudoElementType || (PseudoElementType = {}));
var createIFrameContainer = function(ownerDocument, bounds) {
  var cloneIframeContainer = ownerDocument.createElement("iframe");
  cloneIframeContainer.className = "html2canvas-container";
  cloneIframeContainer.style.visibility = "hidden";
  cloneIframeContainer.style.position = "fixed";
  cloneIframeContainer.style.left = "-10000px";
  cloneIframeContainer.style.top = "0px";
  cloneIframeContainer.style.border = "0";
  cloneIframeContainer.width = bounds.width.toString();
  cloneIframeContainer.height = bounds.height.toString();
  cloneIframeContainer.scrolling = "no";
  cloneIframeContainer.setAttribute(IGNORE_ATTRIBUTE, "true");
  ownerDocument.body.appendChild(cloneIframeContainer);
  return cloneIframeContainer;
};
var imageReady = function(img) {
  return new Promise(function(resolve2) {
    if (img.complete) {
      resolve2();
      return;
    }
    if (!img.src) {
      resolve2();
      return;
    }
    img.onload = resolve2;
    img.onerror = resolve2;
  });
};
var imagesReady = function(document2) {
  return Promise.all([].slice.call(document2.images, 0).map(imageReady));
};
var iframeLoader = function(iframe) {
  return new Promise(function(resolve2, reject2) {
    var cloneWindow = iframe.contentWindow;
    if (!cloneWindow) {
      return reject2("No window assigned for iframe");
    }
    var documentClone = cloneWindow.document;
    cloneWindow.onload = iframe.onload = function() {
      cloneWindow.onload = iframe.onload = null;
      var interval = setInterval(function() {
        if (documentClone.body.childNodes.length > 0 && documentClone.readyState === "complete") {
          clearInterval(interval);
          resolve2(iframe);
        }
      }, 50);
    };
  });
};
var ignoredStyleProperties = [
  "all",
  "d",
  "content"
];
var copyCSSStyles = function(style2, target) {
  for (var i2 = style2.length - 1; i2 >= 0; i2--) {
    var property = style2.item(i2);
    if (ignoredStyleProperties.indexOf(property) === -1) {
      target.style.setProperty(property, style2.getPropertyValue(property));
    }
  }
  return target;
};
var serializeDoctype = function(doctype) {
  var str = "";
  if (doctype) {
    str += "<!DOCTYPE ";
    if (doctype.name) {
      str += doctype.name;
    }
    if (doctype.internalSubset) {
      str += doctype.internalSubset;
    }
    if (doctype.publicId) {
      str += '"' + doctype.publicId + '"';
    }
    if (doctype.systemId) {
      str += '"' + doctype.systemId + '"';
    }
    str += ">";
  }
  return str;
};
var restoreOwnerScroll = function(ownerDocument, x2, y2) {
  if (ownerDocument && ownerDocument.defaultView && (x2 !== ownerDocument.defaultView.pageXOffset || y2 !== ownerDocument.defaultView.pageYOffset)) {
    ownerDocument.defaultView.scrollTo(x2, y2);
  }
};
var restoreNodeScroll = function(_a2) {
  var element = _a2[0], x2 = _a2[1], y2 = _a2[2];
  element.scrollLeft = x2;
  element.scrollTop = y2;
};
var PSEUDO_BEFORE = ":before";
var PSEUDO_AFTER = ":after";
var PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = "___html2canvas___pseudoelement_before";
var PSEUDO_HIDE_ELEMENT_CLASS_AFTER = "___html2canvas___pseudoelement_after";
var PSEUDO_HIDE_ELEMENT_STYLE = '{\n    content: "" !important;\n    display: none !important;\n}';
var createPseudoHideStyles = function(body) {
  createStyles(body, "." + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + PSEUDO_BEFORE + PSEUDO_HIDE_ELEMENT_STYLE + "\n         ." + PSEUDO_HIDE_ELEMENT_CLASS_AFTER + PSEUDO_AFTER + PSEUDO_HIDE_ELEMENT_STYLE);
};
var createStyles = function(body, styles) {
  var document2 = body.ownerDocument;
  if (document2) {
    var style2 = document2.createElement("style");
    style2.textContent = styles;
    body.appendChild(style2);
  }
};
var CacheStorage = function() {
  function CacheStorage2() {
  }
  CacheStorage2.getOrigin = function(url) {
    var link = CacheStorage2._link;
    if (!link) {
      return "about:blank";
    }
    link.href = url;
    link.href = link.href;
    return link.protocol + link.hostname + link.port;
  };
  CacheStorage2.isSameOrigin = function(src) {
    return CacheStorage2.getOrigin(src) === CacheStorage2._origin;
  };
  CacheStorage2.setContext = function(window2) {
    CacheStorage2._link = window2.document.createElement("a");
    CacheStorage2._origin = CacheStorage2.getOrigin(window2.location.href);
  };
  CacheStorage2._origin = "about:blank";
  return CacheStorage2;
}();
var Cache = function() {
  function Cache2(context2, _options) {
    this.context = context2;
    this._options = _options;
    this._cache = {};
  }
  Cache2.prototype.addImage = function(src) {
    var result = Promise.resolve();
    if (this.has(src)) {
      return result;
    }
    if (isBlobImage(src) || isRenderable(src)) {
      (this._cache[src] = this.loadImage(src)).catch(function() {
      });
      return result;
    }
    return result;
  };
  Cache2.prototype.match = function(src) {
    return this._cache[src];
  };
  Cache2.prototype.loadImage = function(key) {
    return __awaiter(this, void 0, void 0, function() {
      var isSameOrigin, useCORS, useProxy, src;
      var _this = this;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            isSameOrigin = CacheStorage.isSameOrigin(key);
            useCORS = !isInlineImage(key) && this._options.useCORS === true && FEATURES.SUPPORT_CORS_IMAGES && !isSameOrigin;
            useProxy = !isInlineImage(key) && !isSameOrigin && !isBlobImage(key) && typeof this._options.proxy === "string" && FEATURES.SUPPORT_CORS_XHR && !useCORS;
            if (!isSameOrigin && this._options.allowTaint === false && !isInlineImage(key) && !isBlobImage(key) && !useProxy && !useCORS) {
              return [2];
            }
            src = key;
            if (!useProxy)
              return [3, 2];
            return [4, this.proxy(src)];
          case 1:
            src = _a2.sent();
            _a2.label = 2;
          case 2:
            this.context.logger.debug("Added image " + key.substring(0, 256));
            return [4, new Promise(function(resolve2, reject2) {
              var img = new Image();
              img.onload = function() {
                return resolve2(img);
              };
              img.onerror = reject2;
              if (isInlineBase64Image(src) || useCORS) {
                img.crossOrigin = "anonymous";
              }
              img.src = src;
              if (img.complete === true) {
                setTimeout(function() {
                  return resolve2(img);
                }, 500);
              }
              if (_this._options.imageTimeout > 0) {
                setTimeout(function() {
                  return reject2("Timed out (" + _this._options.imageTimeout + "ms) loading image");
                }, _this._options.imageTimeout);
              }
            })];
          case 3:
            return [2, _a2.sent()];
        }
      });
    });
  };
  Cache2.prototype.has = function(key) {
    return typeof this._cache[key] !== "undefined";
  };
  Cache2.prototype.keys = function() {
    return Promise.resolve(Object.keys(this._cache));
  };
  Cache2.prototype.proxy = function(src) {
    var _this = this;
    var proxy = this._options.proxy;
    if (!proxy) {
      throw new Error("No proxy defined");
    }
    var key = src.substring(0, 256);
    return new Promise(function(resolve2, reject2) {
      var responseType = FEATURES.SUPPORT_RESPONSE_TYPE ? "blob" : "text";
      var xhr2 = new XMLHttpRequest();
      xhr2.onload = function() {
        if (xhr2.status === 200) {
          if (responseType === "text") {
            resolve2(xhr2.response);
          } else {
            var reader_1 = new FileReader();
            reader_1.addEventListener("load", function() {
              return resolve2(reader_1.result);
            }, false);
            reader_1.addEventListener("error", function(e2) {
              return reject2(e2);
            }, false);
            reader_1.readAsDataURL(xhr2.response);
          }
        } else {
          reject2("Failed to proxy resource " + key + " with status code " + xhr2.status);
        }
      };
      xhr2.onerror = reject2;
      var queryString = proxy.indexOf("?") > -1 ? "&" : "?";
      xhr2.open("GET", "" + proxy + queryString + "url=" + encodeURIComponent(src) + "&responseType=" + responseType);
      if (responseType !== "text" && xhr2 instanceof XMLHttpRequest) {
        xhr2.responseType = responseType;
      }
      if (_this._options.imageTimeout) {
        var timeout_1 = _this._options.imageTimeout;
        xhr2.timeout = timeout_1;
        xhr2.ontimeout = function() {
          return reject2("Timed out (" + timeout_1 + "ms) proxying " + key);
        };
      }
      xhr2.send();
    });
  };
  return Cache2;
}();
var INLINE_SVG = /^data:image\/svg\+xml/i;
var INLINE_BASE64 = /^data:image\/.*;base64,/i;
var INLINE_IMG = /^data:image\/.*/i;
var isRenderable = function(src) {
  return FEATURES.SUPPORT_SVG_DRAWING || !isSVG(src);
};
var isInlineImage = function(src) {
  return INLINE_IMG.test(src);
};
var isInlineBase64Image = function(src) {
  return INLINE_BASE64.test(src);
};
var isBlobImage = function(src) {
  return src.substr(0, 4) === "blob";
};
var isSVG = function(src) {
  return src.substr(-3).toLowerCase() === "svg" || INLINE_SVG.test(src);
};
var Vector = function() {
  function Vector2(x2, y2) {
    this.type = 0;
    this.x = x2;
    this.y = y2;
  }
  Vector2.prototype.add = function(deltaX, deltaY) {
    return new Vector2(this.x + deltaX, this.y + deltaY);
  };
  return Vector2;
}();
var lerp = function(a2, b2, t3) {
  return new Vector(a2.x + (b2.x - a2.x) * t3, a2.y + (b2.y - a2.y) * t3);
};
var BezierCurve = function() {
  function BezierCurve2(start2, startControl, endControl, end) {
    this.type = 1;
    this.start = start2;
    this.startControl = startControl;
    this.endControl = endControl;
    this.end = end;
  }
  BezierCurve2.prototype.subdivide = function(t3, firstHalf) {
    var ab = lerp(this.start, this.startControl, t3);
    var bc = lerp(this.startControl, this.endControl, t3);
    var cd = lerp(this.endControl, this.end, t3);
    var abbc = lerp(ab, bc, t3);
    var bccd = lerp(bc, cd, t3);
    var dest = lerp(abbc, bccd, t3);
    return firstHalf ? new BezierCurve2(this.start, ab, abbc, dest) : new BezierCurve2(dest, bccd, cd, this.end);
  };
  BezierCurve2.prototype.add = function(deltaX, deltaY) {
    return new BezierCurve2(this.start.add(deltaX, deltaY), this.startControl.add(deltaX, deltaY), this.endControl.add(deltaX, deltaY), this.end.add(deltaX, deltaY));
  };
  BezierCurve2.prototype.reverse = function() {
    return new BezierCurve2(this.end, this.endControl, this.startControl, this.start);
  };
  return BezierCurve2;
}();
var isBezierCurve = function(path) {
  return path.type === 1;
};
var BoundCurves = function() {
  function BoundCurves2(element) {
    var styles = element.styles;
    var bounds = element.bounds;
    var _a2 = getAbsoluteValueForTuple(styles.borderTopLeftRadius, bounds.width, bounds.height), tlh = _a2[0], tlv = _a2[1];
    var _b2 = getAbsoluteValueForTuple(styles.borderTopRightRadius, bounds.width, bounds.height), trh = _b2[0], trv = _b2[1];
    var _c = getAbsoluteValueForTuple(styles.borderBottomRightRadius, bounds.width, bounds.height), brh = _c[0], brv = _c[1];
    var _d = getAbsoluteValueForTuple(styles.borderBottomLeftRadius, bounds.width, bounds.height), blh = _d[0], blv = _d[1];
    var factors = [];
    factors.push((tlh + trh) / bounds.width);
    factors.push((blh + brh) / bounds.width);
    factors.push((tlv + blv) / bounds.height);
    factors.push((trv + brv) / bounds.height);
    var maxFactor = Math.max.apply(Math, factors);
    if (maxFactor > 1) {
      tlh /= maxFactor;
      tlv /= maxFactor;
      trh /= maxFactor;
      trv /= maxFactor;
      brh /= maxFactor;
      brv /= maxFactor;
      blh /= maxFactor;
      blv /= maxFactor;
    }
    var topWidth = bounds.width - trh;
    var rightHeight = bounds.height - brv;
    var bottomWidth = bounds.width - brh;
    var leftHeight = bounds.height - blv;
    var borderTopWidth2 = styles.borderTopWidth;
    var borderRightWidth2 = styles.borderRightWidth;
    var borderBottomWidth2 = styles.borderBottomWidth;
    var borderLeftWidth2 = styles.borderLeftWidth;
    var paddingTop2 = getAbsoluteValue(styles.paddingTop, element.bounds.width);
    var paddingRight2 = getAbsoluteValue(styles.paddingRight, element.bounds.width);
    var paddingBottom2 = getAbsoluteValue(styles.paddingBottom, element.bounds.width);
    var paddingLeft2 = getAbsoluteValue(styles.paddingLeft, element.bounds.width);
    this.topLeftBorderDoubleOuterBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 3, bounds.top + borderTopWidth2 / 3, tlh - borderLeftWidth2 / 3, tlv - borderTopWidth2 / 3, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 3, bounds.top + borderTopWidth2 / 3);
    this.topRightBorderDoubleOuterBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 / 3, trh - borderRightWidth2 / 3, trv - borderTopWidth2 / 3, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 3, bounds.top + borderTopWidth2 / 3);
    this.bottomRightBorderDoubleOuterBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 / 3, brv - borderBottomWidth2 / 3, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 3, bounds.top + bounds.height - borderBottomWidth2 / 3);
    this.bottomLeftBorderDoubleOuterBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 3, bounds.top + leftHeight, blh - borderLeftWidth2 / 3, blv - borderBottomWidth2 / 3, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 3, bounds.top + bounds.height - borderBottomWidth2 / 3);
    this.topLeftBorderDoubleInnerBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3, tlh - borderLeftWidth2 * 2 / 3, tlv - borderTopWidth2 * 2 / 3, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3);
    this.topRightBorderDoubleInnerBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 * 2 / 3, trh - borderRightWidth2 * 2 / 3, trv - borderTopWidth2 * 2 / 3, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3);
    this.bottomRightBorderDoubleInnerBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 * 2 / 3, brv - borderBottomWidth2 * 2 / 3, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 * 2 / 3, bounds.top + bounds.height - borderBottomWidth2 * 2 / 3);
    this.bottomLeftBorderDoubleInnerBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + leftHeight, blh - borderLeftWidth2 * 2 / 3, blv - borderBottomWidth2 * 2 / 3, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + bounds.height - borderBottomWidth2 * 2 / 3);
    this.topLeftBorderStroke = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 2, bounds.top + borderTopWidth2 / 2, tlh - borderLeftWidth2 / 2, tlv - borderTopWidth2 / 2, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 2, bounds.top + borderTopWidth2 / 2);
    this.topRightBorderStroke = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 / 2, trh - borderRightWidth2 / 2, trv - borderTopWidth2 / 2, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 2, bounds.top + borderTopWidth2 / 2);
    this.bottomRightBorderStroke = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 / 2, brv - borderBottomWidth2 / 2, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 2, bounds.top + bounds.height - borderBottomWidth2 / 2);
    this.bottomLeftBorderStroke = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 2, bounds.top + leftHeight, blh - borderLeftWidth2 / 2, blv - borderBottomWidth2 / 2, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 2, bounds.top + bounds.height - borderBottomWidth2 / 2);
    this.topLeftBorderBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left, bounds.top, tlh, tlv, CORNER.TOP_LEFT) : new Vector(bounds.left, bounds.top);
    this.topRightBorderBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top, trh, trv, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width, bounds.top);
    this.bottomRightBorderBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh, brv, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width, bounds.top + bounds.height);
    this.bottomLeftBorderBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left, bounds.top + leftHeight, blh, blv, CORNER.BOTTOM_LEFT) : new Vector(bounds.left, bounds.top + bounds.height);
    this.topLeftPaddingBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2, bounds.top + borderTopWidth2, Math.max(0, tlh - borderLeftWidth2), Math.max(0, tlv - borderTopWidth2), CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2, bounds.top + borderTopWidth2);
    this.topRightPaddingBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width - borderRightWidth2), bounds.top + borderTopWidth2, topWidth > bounds.width + borderRightWidth2 ? 0 : Math.max(0, trh - borderRightWidth2), Math.max(0, trv - borderTopWidth2), CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2, bounds.top + borderTopWidth2);
    this.bottomRightPaddingBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - borderLeftWidth2), bounds.top + Math.min(rightHeight, bounds.height - borderBottomWidth2), Math.max(0, brh - borderRightWidth2), Math.max(0, brv - borderBottomWidth2), CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2, bounds.top + bounds.height - borderBottomWidth2);
    this.bottomLeftPaddingBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2, bounds.top + Math.min(leftHeight, bounds.height - borderBottomWidth2), Math.max(0, blh - borderLeftWidth2), Math.max(0, blv - borderBottomWidth2), CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2, bounds.top + bounds.height - borderBottomWidth2);
    this.topLeftContentBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + borderTopWidth2 + paddingTop2, Math.max(0, tlh - (borderLeftWidth2 + paddingLeft2)), Math.max(0, tlv - (borderTopWidth2 + paddingTop2)), CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + borderTopWidth2 + paddingTop2);
    this.topRightContentBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width + borderLeftWidth2 + paddingLeft2), bounds.top + borderTopWidth2 + paddingTop2, topWidth > bounds.width + borderLeftWidth2 + paddingLeft2 ? 0 : trh - borderLeftWidth2 + paddingLeft2, trv - (borderTopWidth2 + paddingTop2), CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - (borderRightWidth2 + paddingRight2), bounds.top + borderTopWidth2 + paddingTop2);
    this.bottomRightContentBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - (borderLeftWidth2 + paddingLeft2)), bounds.top + Math.min(rightHeight, bounds.height + borderTopWidth2 + paddingTop2), Math.max(0, brh - (borderRightWidth2 + paddingRight2)), brv - (borderBottomWidth2 + paddingBottom2), CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - (borderRightWidth2 + paddingRight2), bounds.top + bounds.height - (borderBottomWidth2 + paddingBottom2));
    this.bottomLeftContentBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + leftHeight, Math.max(0, blh - (borderLeftWidth2 + paddingLeft2)), blv - (borderBottomWidth2 + paddingBottom2), CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + bounds.height - (borderBottomWidth2 + paddingBottom2));
  }
  return BoundCurves2;
}();
var CORNER;
(function(CORNER2) {
  CORNER2[CORNER2["TOP_LEFT"] = 0] = "TOP_LEFT";
  CORNER2[CORNER2["TOP_RIGHT"] = 1] = "TOP_RIGHT";
  CORNER2[CORNER2["BOTTOM_RIGHT"] = 2] = "BOTTOM_RIGHT";
  CORNER2[CORNER2["BOTTOM_LEFT"] = 3] = "BOTTOM_LEFT";
})(CORNER || (CORNER = {}));
var getCurvePoints = function(x2, y2, r1, r2, position2) {
  var kappa = 4 * ((Math.sqrt(2) - 1) / 3);
  var ox = r1 * kappa;
  var oy = r2 * kappa;
  var xm = x2 + r1;
  var ym = y2 + r2;
  switch (position2) {
    case CORNER.TOP_LEFT:
      return new BezierCurve(new Vector(x2, ym), new Vector(x2, ym - oy), new Vector(xm - ox, y2), new Vector(xm, y2));
    case CORNER.TOP_RIGHT:
      return new BezierCurve(new Vector(x2, y2), new Vector(x2 + ox, y2), new Vector(xm, ym - oy), new Vector(xm, ym));
    case CORNER.BOTTOM_RIGHT:
      return new BezierCurve(new Vector(xm, y2), new Vector(xm, y2 + oy), new Vector(x2 + ox, ym), new Vector(x2, ym));
    case CORNER.BOTTOM_LEFT:
    default:
      return new BezierCurve(new Vector(xm, ym), new Vector(xm - ox, ym), new Vector(x2, y2 + oy), new Vector(x2, y2));
  }
};
var calculateBorderBoxPath = function(curves) {
  return [curves.topLeftBorderBox, curves.topRightBorderBox, curves.bottomRightBorderBox, curves.bottomLeftBorderBox];
};
var calculateContentBoxPath = function(curves) {
  return [
    curves.topLeftContentBox,
    curves.topRightContentBox,
    curves.bottomRightContentBox,
    curves.bottomLeftContentBox
  ];
};
var calculatePaddingBoxPath = function(curves) {
  return [
    curves.topLeftPaddingBox,
    curves.topRightPaddingBox,
    curves.bottomRightPaddingBox,
    curves.bottomLeftPaddingBox
  ];
};
var TransformEffect = function() {
  function TransformEffect2(offsetX, offsetY, matrix2) {
    this.offsetX = offsetX;
    this.offsetY = offsetY;
    this.matrix = matrix2;
    this.type = 0;
    this.target = 2 | 4;
  }
  return TransformEffect2;
}();
var ClipEffect = function() {
  function ClipEffect2(path, target) {
    this.path = path;
    this.target = target;
    this.type = 1;
  }
  return ClipEffect2;
}();
var OpacityEffect = function() {
  function OpacityEffect2(opacity2) {
    this.opacity = opacity2;
    this.type = 2;
    this.target = 2 | 4;
  }
  return OpacityEffect2;
}();
var isTransformEffect = function(effect) {
  return effect.type === 0;
};
var isClipEffect = function(effect) {
  return effect.type === 1;
};
var isOpacityEffect = function(effect) {
  return effect.type === 2;
};
var equalPath = function(a2, b2) {
  if (a2.length === b2.length) {
    return a2.some(function(v2, i2) {
      return v2 === b2[i2];
    });
  }
  return false;
};
var transformPath = function(path, deltaX, deltaY, deltaW, deltaH) {
  return path.map(function(point, index2) {
    switch (index2) {
      case 0:
        return point.add(deltaX, deltaY);
      case 1:
        return point.add(deltaX + deltaW, deltaY);
      case 2:
        return point.add(deltaX + deltaW, deltaY + deltaH);
      case 3:
        return point.add(deltaX, deltaY + deltaH);
    }
    return point;
  });
};
var StackingContext = function() {
  function StackingContext2(container) {
    this.element = container;
    this.inlineLevel = [];
    this.nonInlineLevel = [];
    this.negativeZIndex = [];
    this.zeroOrAutoZIndexOrTransformedOrOpacity = [];
    this.positiveZIndex = [];
    this.nonPositionedFloats = [];
    this.nonPositionedInlineLevel = [];
  }
  return StackingContext2;
}();
var ElementPaint = function() {
  function ElementPaint2(container, parent) {
    this.container = container;
    this.parent = parent;
    this.effects = [];
    this.curves = new BoundCurves(this.container);
    if (this.container.styles.opacity < 1) {
      this.effects.push(new OpacityEffect(this.container.styles.opacity));
    }
    if (this.container.styles.transform !== null) {
      var offsetX = this.container.bounds.left + this.container.styles.transformOrigin[0].number;
      var offsetY = this.container.bounds.top + this.container.styles.transformOrigin[1].number;
      var matrix2 = this.container.styles.transform;
      this.effects.push(new TransformEffect(offsetX, offsetY, matrix2));
    }
    if (this.container.styles.overflowX !== 0) {
      var borderBox = calculateBorderBoxPath(this.curves);
      var paddingBox2 = calculatePaddingBoxPath(this.curves);
      if (equalPath(borderBox, paddingBox2)) {
        this.effects.push(new ClipEffect(borderBox, 2 | 4));
      } else {
        this.effects.push(new ClipEffect(borderBox, 2));
        this.effects.push(new ClipEffect(paddingBox2, 4));
      }
    }
  }
  ElementPaint2.prototype.getEffects = function(target) {
    var inFlow = [2, 3].indexOf(this.container.styles.position) === -1;
    var parent = this.parent;
    var effects = this.effects.slice(0);
    while (parent) {
      var croplessEffects = parent.effects.filter(function(effect) {
        return !isClipEffect(effect);
      });
      if (inFlow || parent.container.styles.position !== 0 || !parent.parent) {
        effects.unshift.apply(effects, croplessEffects);
        inFlow = [2, 3].indexOf(parent.container.styles.position) === -1;
        if (parent.container.styles.overflowX !== 0) {
          var borderBox = calculateBorderBoxPath(parent.curves);
          var paddingBox2 = calculatePaddingBoxPath(parent.curves);
          if (!equalPath(borderBox, paddingBox2)) {
            effects.unshift(new ClipEffect(paddingBox2, 2 | 4));
          }
        }
      } else {
        effects.unshift.apply(effects, croplessEffects);
      }
      parent = parent.parent;
    }
    return effects.filter(function(effect) {
      return contains(effect.target, target);
    });
  };
  return ElementPaint2;
}();
var parseStackTree = function(parent, stackingContext, realStackingContext, listItems) {
  parent.container.elements.forEach(function(child) {
    var treatAsRealStackingContext = contains(child.flags, 4);
    var createsStackingContext2 = contains(child.flags, 2);
    var paintContainer = new ElementPaint(child, parent);
    if (contains(child.styles.display, 2048)) {
      listItems.push(paintContainer);
    }
    var listOwnerItems = contains(child.flags, 8) ? [] : listItems;
    if (treatAsRealStackingContext || createsStackingContext2) {
      var parentStack = treatAsRealStackingContext || child.styles.isPositioned() ? realStackingContext : stackingContext;
      var stack = new StackingContext(paintContainer);
      if (child.styles.isPositioned() || child.styles.opacity < 1 || child.styles.isTransformed()) {
        var order_1 = child.styles.zIndex.order;
        if (order_1 < 0) {
          var index_1 = 0;
          parentStack.negativeZIndex.some(function(current, i2) {
            if (order_1 > current.element.container.styles.zIndex.order) {
              index_1 = i2;
              return false;
            } else if (index_1 > 0) {
              return true;
            }
            return false;
          });
          parentStack.negativeZIndex.splice(index_1, 0, stack);
        } else if (order_1 > 0) {
          var index_2 = 0;
          parentStack.positiveZIndex.some(function(current, i2) {
            if (order_1 >= current.element.container.styles.zIndex.order) {
              index_2 = i2 + 1;
              return false;
            } else if (index_2 > 0) {
              return true;
            }
            return false;
          });
          parentStack.positiveZIndex.splice(index_2, 0, stack);
        } else {
          parentStack.zeroOrAutoZIndexOrTransformedOrOpacity.push(stack);
        }
      } else {
        if (child.styles.isFloating()) {
          parentStack.nonPositionedFloats.push(stack);
        } else {
          parentStack.nonPositionedInlineLevel.push(stack);
        }
      }
      parseStackTree(paintContainer, stack, treatAsRealStackingContext ? stack : realStackingContext, listOwnerItems);
    } else {
      if (child.styles.isInlineLevel()) {
        stackingContext.inlineLevel.push(paintContainer);
      } else {
        stackingContext.nonInlineLevel.push(paintContainer);
      }
      parseStackTree(paintContainer, stackingContext, realStackingContext, listOwnerItems);
    }
    if (contains(child.flags, 8)) {
      processListItems(child, listOwnerItems);
    }
  });
};
var processListItems = function(owner, elements2) {
  var numbering = owner instanceof OLElementContainer ? owner.start : 1;
  var reversed = owner instanceof OLElementContainer ? owner.reversed : false;
  for (var i2 = 0; i2 < elements2.length; i2++) {
    var item = elements2[i2];
    if (item.container instanceof LIElementContainer && typeof item.container.value === "number" && item.container.value !== 0) {
      numbering = item.container.value;
    }
    item.listValue = createCounterText(numbering, item.container.styles.listStyleType, true);
    numbering += reversed ? -1 : 1;
  }
};
var parseStackingContexts = function(container) {
  var paintContainer = new ElementPaint(container, null);
  var root2 = new StackingContext(paintContainer);
  var listItems = [];
  parseStackTree(paintContainer, root2, root2, listItems);
  processListItems(paintContainer.container, listItems);
  return root2;
};
var parsePathForBorder = function(curves, borderSide) {
  switch (borderSide) {
    case 0:
      return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftPaddingBox, curves.topRightBorderBox, curves.topRightPaddingBox);
    case 1:
      return createPathFromCurves(curves.topRightBorderBox, curves.topRightPaddingBox, curves.bottomRightBorderBox, curves.bottomRightPaddingBox);
    case 2:
      return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox);
    case 3:
    default:
      return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox, curves.topLeftBorderBox, curves.topLeftPaddingBox);
  }
};
var parsePathForBorderDoubleOuter = function(curves, borderSide) {
  switch (borderSide) {
    case 0:
      return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox, curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox);
    case 1:
      return createPathFromCurves(curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox, curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox);
    case 2:
      return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox, curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox);
    case 3:
    default:
      return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox, curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox);
  }
};
var parsePathForBorderDoubleInner = function(curves, borderSide) {
  switch (borderSide) {
    case 0:
      return createPathFromCurves(curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox, curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox);
    case 1:
      return createPathFromCurves(curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox, curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox);
    case 2:
      return createPathFromCurves(curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox);
    case 3:
    default:
      return createPathFromCurves(curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox, curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox);
  }
};
var parsePathForBorderStroke = function(curves, borderSide) {
  switch (borderSide) {
    case 0:
      return createStrokePathFromCurves(curves.topLeftBorderStroke, curves.topRightBorderStroke);
    case 1:
      return createStrokePathFromCurves(curves.topRightBorderStroke, curves.bottomRightBorderStroke);
    case 2:
      return createStrokePathFromCurves(curves.bottomRightBorderStroke, curves.bottomLeftBorderStroke);
    case 3:
    default:
      return createStrokePathFromCurves(curves.bottomLeftBorderStroke, curves.topLeftBorderStroke);
  }
};
var createStrokePathFromCurves = function(outer1, outer2) {
  var path = [];
  if (isBezierCurve(outer1)) {
    path.push(outer1.subdivide(0.5, false));
  } else {
    path.push(outer1);
  }
  if (isBezierCurve(outer2)) {
    path.push(outer2.subdivide(0.5, true));
  } else {
    path.push(outer2);
  }
  return path;
};
var createPathFromCurves = function(outer1, inner1, outer2, inner2) {
  var path = [];
  if (isBezierCurve(outer1)) {
    path.push(outer1.subdivide(0.5, false));
  } else {
    path.push(outer1);
  }
  if (isBezierCurve(outer2)) {
    path.push(outer2.subdivide(0.5, true));
  } else {
    path.push(outer2);
  }
  if (isBezierCurve(inner2)) {
    path.push(inner2.subdivide(0.5, true).reverse());
  } else {
    path.push(inner2);
  }
  if (isBezierCurve(inner1)) {
    path.push(inner1.subdivide(0.5, false).reverse());
  } else {
    path.push(inner1);
  }
  return path;
};
var paddingBox = function(element) {
  var bounds = element.bounds;
  var styles = element.styles;
  return bounds.add(styles.borderLeftWidth, styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth), -(styles.borderTopWidth + styles.borderBottomWidth));
};
var contentBox = function(element) {
  var styles = element.styles;
  var bounds = element.bounds;
  var paddingLeft2 = getAbsoluteValue(styles.paddingLeft, bounds.width);
  var paddingRight2 = getAbsoluteValue(styles.paddingRight, bounds.width);
  var paddingTop2 = getAbsoluteValue(styles.paddingTop, bounds.width);
  var paddingBottom2 = getAbsoluteValue(styles.paddingBottom, bounds.width);
  return bounds.add(paddingLeft2 + styles.borderLeftWidth, paddingTop2 + styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth + paddingLeft2 + paddingRight2), -(styles.borderTopWidth + styles.borderBottomWidth + paddingTop2 + paddingBottom2));
};
var calculateBackgroundPositioningArea = function(backgroundOrigin2, element) {
  if (backgroundOrigin2 === 0) {
    return element.bounds;
  }
  if (backgroundOrigin2 === 2) {
    return contentBox(element);
  }
  return paddingBox(element);
};
var calculateBackgroundPaintingArea = function(backgroundClip2, element) {
  if (backgroundClip2 === 0) {
    return element.bounds;
  }
  if (backgroundClip2 === 2) {
    return contentBox(element);
  }
  return paddingBox(element);
};
var calculateBackgroundRendering = function(container, index2, intrinsicSize) {
  var backgroundPositioningArea = calculateBackgroundPositioningArea(getBackgroundValueForIndex(container.styles.backgroundOrigin, index2), container);
  var backgroundPaintingArea = calculateBackgroundPaintingArea(getBackgroundValueForIndex(container.styles.backgroundClip, index2), container);
  var backgroundImageSize = calculateBackgroundSize(getBackgroundValueForIndex(container.styles.backgroundSize, index2), intrinsicSize, backgroundPositioningArea);
  var sizeWidth = backgroundImageSize[0], sizeHeight = backgroundImageSize[1];
  var position2 = getAbsoluteValueForTuple(getBackgroundValueForIndex(container.styles.backgroundPosition, index2), backgroundPositioningArea.width - sizeWidth, backgroundPositioningArea.height - sizeHeight);
  var path = calculateBackgroundRepeatPath(getBackgroundValueForIndex(container.styles.backgroundRepeat, index2), position2, backgroundImageSize, backgroundPositioningArea, backgroundPaintingArea);
  var offsetX = Math.round(backgroundPositioningArea.left + position2[0]);
  var offsetY = Math.round(backgroundPositioningArea.top + position2[1]);
  return [path, offsetX, offsetY, sizeWidth, sizeHeight];
};
var isAuto = function(token) {
  return isIdentToken(token) && token.value === BACKGROUND_SIZE.AUTO;
};
var hasIntrinsicValue = function(value) {
  return typeof value === "number";
};
var calculateBackgroundSize = function(size, _a2, bounds) {
  var intrinsicWidth = _a2[0], intrinsicHeight = _a2[1], intrinsicProportion = _a2[2];
  var first = size[0], second = size[1];
  if (!first) {
    return [0, 0];
  }
  if (isLengthPercentage(first) && second && isLengthPercentage(second)) {
    return [getAbsoluteValue(first, bounds.width), getAbsoluteValue(second, bounds.height)];
  }
  var hasIntrinsicProportion = hasIntrinsicValue(intrinsicProportion);
  if (isIdentToken(first) && (first.value === BACKGROUND_SIZE.CONTAIN || first.value === BACKGROUND_SIZE.COVER)) {
    if (hasIntrinsicValue(intrinsicProportion)) {
      var targetRatio = bounds.width / bounds.height;
      return targetRatio < intrinsicProportion !== (first.value === BACKGROUND_SIZE.COVER) ? [bounds.width, bounds.width / intrinsicProportion] : [bounds.height * intrinsicProportion, bounds.height];
    }
    return [bounds.width, bounds.height];
  }
  var hasIntrinsicWidth = hasIntrinsicValue(intrinsicWidth);
  var hasIntrinsicHeight = hasIntrinsicValue(intrinsicHeight);
  var hasIntrinsicDimensions = hasIntrinsicWidth || hasIntrinsicHeight;
  if (isAuto(first) && (!second || isAuto(second))) {
    if (hasIntrinsicWidth && hasIntrinsicHeight) {
      return [intrinsicWidth, intrinsicHeight];
    }
    if (!hasIntrinsicProportion && !hasIntrinsicDimensions) {
      return [bounds.width, bounds.height];
    }
    if (hasIntrinsicDimensions && hasIntrinsicProportion) {
      var width_1 = hasIntrinsicWidth ? intrinsicWidth : intrinsicHeight * intrinsicProportion;
      var height_1 = hasIntrinsicHeight ? intrinsicHeight : intrinsicWidth / intrinsicProportion;
      return [width_1, height_1];
    }
    var width_2 = hasIntrinsicWidth ? intrinsicWidth : bounds.width;
    var height_2 = hasIntrinsicHeight ? intrinsicHeight : bounds.height;
    return [width_2, height_2];
  }
  if (hasIntrinsicProportion) {
    var width_3 = 0;
    var height_3 = 0;
    if (isLengthPercentage(first)) {
      width_3 = getAbsoluteValue(first, bounds.width);
    } else if (isLengthPercentage(second)) {
      height_3 = getAbsoluteValue(second, bounds.height);
    }
    if (isAuto(first)) {
      width_3 = height_3 * intrinsicProportion;
    } else if (!second || isAuto(second)) {
      height_3 = width_3 / intrinsicProportion;
    }
    return [width_3, height_3];
  }
  var width = null;
  var height = null;
  if (isLengthPercentage(first)) {
    width = getAbsoluteValue(first, bounds.width);
  } else if (second && isLengthPercentage(second)) {
    height = getAbsoluteValue(second, bounds.height);
  }
  if (width !== null && (!second || isAuto(second))) {
    height = hasIntrinsicWidth && hasIntrinsicHeight ? width / intrinsicWidth * intrinsicHeight : bounds.height;
  }
  if (height !== null && isAuto(first)) {
    width = hasIntrinsicWidth && hasIntrinsicHeight ? height / intrinsicHeight * intrinsicWidth : bounds.width;
  }
  if (width !== null && height !== null) {
    return [width, height];
  }
  throw new Error("Unable to calculate background-size for element");
};
var getBackgroundValueForIndex = function(values3, index2) {
  var value = values3[index2];
  if (typeof value === "undefined") {
    return values3[0];
  }
  return value;
};
var calculateBackgroundRepeatPath = function(repeat, _a2, _b2, backgroundPositioningArea, backgroundPaintingArea) {
  var x2 = _a2[0], y2 = _a2[1];
  var width = _b2[0], height = _b2[1];
  switch (repeat) {
    case 2:
      return [
        new Vector(Math.round(backgroundPositioningArea.left), Math.round(backgroundPositioningArea.top + y2)),
        new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(backgroundPositioningArea.top + y2)),
        new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(height + backgroundPositioningArea.top + y2)),
        new Vector(Math.round(backgroundPositioningArea.left), Math.round(height + backgroundPositioningArea.top + y2))
      ];
    case 3:
      return [
        new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top)),
        new Vector(Math.round(backgroundPositioningArea.left + x2 + width), Math.round(backgroundPositioningArea.top)),
        new Vector(Math.round(backgroundPositioningArea.left + x2 + width), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top)),
        new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top))
      ];
    case 1:
      return [
        new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top + y2)),
        new Vector(Math.round(backgroundPositioningArea.left + x2 + width), Math.round(backgroundPositioningArea.top + y2)),
        new Vector(Math.round(backgroundPositioningArea.left + x2 + width), Math.round(backgroundPositioningArea.top + y2 + height)),
        new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top + y2 + height))
      ];
    default:
      return [
        new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.top)),
        new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.top)),
        new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top)),
        new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top))
      ];
  }
};
var SMALL_IMAGE = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
var SAMPLE_TEXT = "Hidden Text";
var FontMetrics = function() {
  function FontMetrics2(document2) {
    this._data = {};
    this._document = document2;
  }
  FontMetrics2.prototype.parseMetrics = function(fontFamily2, fontSize2) {
    var container = this._document.createElement("div");
    var img = this._document.createElement("img");
    var span = this._document.createElement("span");
    var body = this._document.body;
    container.style.visibility = "hidden";
    container.style.fontFamily = fontFamily2;
    container.style.fontSize = fontSize2;
    container.style.margin = "0";
    container.style.padding = "0";
    container.style.whiteSpace = "nowrap";
    body.appendChild(container);
    img.src = SMALL_IMAGE;
    img.width = 1;
    img.height = 1;
    img.style.margin = "0";
    img.style.padding = "0";
    img.style.verticalAlign = "baseline";
    span.style.fontFamily = fontFamily2;
    span.style.fontSize = fontSize2;
    span.style.margin = "0";
    span.style.padding = "0";
    span.appendChild(this._document.createTextNode(SAMPLE_TEXT));
    container.appendChild(span);
    container.appendChild(img);
    var baseline = img.offsetTop - span.offsetTop + 2;
    container.removeChild(span);
    container.appendChild(this._document.createTextNode(SAMPLE_TEXT));
    container.style.lineHeight = "normal";
    img.style.verticalAlign = "super";
    var middle = img.offsetTop - container.offsetTop + 2;
    body.removeChild(container);
    return { baseline, middle };
  };
  FontMetrics2.prototype.getMetrics = function(fontFamily2, fontSize2) {
    var key = fontFamily2 + " " + fontSize2;
    if (typeof this._data[key] === "undefined") {
      this._data[key] = this.parseMetrics(fontFamily2, fontSize2);
    }
    return this._data[key];
  };
  return FontMetrics2;
}();
var Renderer = function() {
  function Renderer2(context2, options) {
    this.context = context2;
    this.options = options;
  }
  return Renderer2;
}();
var MASK_OFFSET = 1e4;
var CanvasRenderer = function(_super) {
  __extends(CanvasRenderer2, _super);
  function CanvasRenderer2(context2, options) {
    var _this = _super.call(this, context2, options) || this;
    _this._activeEffects = [];
    _this.canvas = options.canvas ? options.canvas : document.createElement("canvas");
    _this.ctx = _this.canvas.getContext("2d");
    if (!options.canvas) {
      _this.canvas.width = Math.floor(options.width * options.scale);
      _this.canvas.height = Math.floor(options.height * options.scale);
      _this.canvas.style.width = options.width + "px";
      _this.canvas.style.height = options.height + "px";
    }
    _this.fontMetrics = new FontMetrics(document);
    _this.ctx.scale(_this.options.scale, _this.options.scale);
    _this.ctx.translate(-options.x, -options.y);
    _this.ctx.textBaseline = "bottom";
    _this._activeEffects = [];
    _this.context.logger.debug("Canvas renderer initialized (" + options.width + "x" + options.height + ") with scale " + options.scale);
    return _this;
  }
  CanvasRenderer2.prototype.applyEffects = function(effects) {
    var _this = this;
    while (this._activeEffects.length) {
      this.popEffect();
    }
    effects.forEach(function(effect) {
      return _this.applyEffect(effect);
    });
  };
  CanvasRenderer2.prototype.applyEffect = function(effect) {
    this.ctx.save();
    if (isOpacityEffect(effect)) {
      this.ctx.globalAlpha = effect.opacity;
    }
    if (isTransformEffect(effect)) {
      this.ctx.translate(effect.offsetX, effect.offsetY);
      this.ctx.transform(effect.matrix[0], effect.matrix[1], effect.matrix[2], effect.matrix[3], effect.matrix[4], effect.matrix[5]);
      this.ctx.translate(-effect.offsetX, -effect.offsetY);
    }
    if (isClipEffect(effect)) {
      this.path(effect.path);
      this.ctx.clip();
    }
    this._activeEffects.push(effect);
  };
  CanvasRenderer2.prototype.popEffect = function() {
    this._activeEffects.pop();
    this.ctx.restore();
  };
  CanvasRenderer2.prototype.renderStack = function(stack) {
    return __awaiter(this, void 0, void 0, function() {
      var styles;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            styles = stack.element.container.styles;
            if (!styles.isVisible())
              return [3, 2];
            return [4, this.renderStackContent(stack)];
          case 1:
            _a2.sent();
            _a2.label = 2;
          case 2:
            return [2];
        }
      });
    });
  };
  CanvasRenderer2.prototype.renderNode = function(paint) {
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            if (contains(paint.container.flags, 16)) {
              debugger;
            }
            if (!paint.container.styles.isVisible())
              return [3, 3];
            return [4, this.renderNodeBackgroundAndBorders(paint)];
          case 1:
            _a2.sent();
            return [4, this.renderNodeContent(paint)];
          case 2:
            _a2.sent();
            _a2.label = 3;
          case 3:
            return [2];
        }
      });
    });
  };
  CanvasRenderer2.prototype.renderTextWithLetterSpacing = function(text2, letterSpacing2, baseline) {
    var _this = this;
    if (letterSpacing2 === 0) {
      this.ctx.fillText(text2.text, text2.bounds.left, text2.bounds.top + baseline);
    } else {
      var letters = segmentGraphemes(text2.text);
      letters.reduce(function(left, letter) {
        _this.ctx.fillText(letter, left, text2.bounds.top + baseline);
        return left + _this.ctx.measureText(letter).width;
      }, text2.bounds.left);
    }
  };
  CanvasRenderer2.prototype.createFontStyle = function(styles) {
    var fontVariant2 = styles.fontVariant.filter(function(variant) {
      return variant === "normal" || variant === "small-caps";
    }).join("");
    var fontFamily2 = fixIOSSystemFonts(styles.fontFamily).join(", ");
    var fontSize2 = isDimensionToken(styles.fontSize) ? "" + styles.fontSize.number + styles.fontSize.unit : styles.fontSize.number + "px";
    return [
      [styles.fontStyle, fontVariant2, styles.fontWeight, fontSize2, fontFamily2].join(" "),
      fontFamily2,
      fontSize2
    ];
  };
  CanvasRenderer2.prototype.renderTextNode = function(text2, styles) {
    return __awaiter(this, void 0, void 0, function() {
      var _a2, font, fontFamily2, fontSize2, _b2, baseline, middle, paintOrder2;
      var _this = this;
      return __generator(this, function(_c) {
        _a2 = this.createFontStyle(styles), font = _a2[0], fontFamily2 = _a2[1], fontSize2 = _a2[2];
        this.ctx.font = font;
        this.ctx.direction = styles.direction === 1 ? "rtl" : "ltr";
        this.ctx.textAlign = "left";
        this.ctx.textBaseline = "alphabetic";
        _b2 = this.fontMetrics.getMetrics(fontFamily2, fontSize2), baseline = _b2.baseline, middle = _b2.middle;
        paintOrder2 = styles.paintOrder;
        text2.textBounds.forEach(function(text3) {
          paintOrder2.forEach(function(paintOrderLayer) {
            switch (paintOrderLayer) {
              case 0:
                _this.ctx.fillStyle = asString(styles.color);
                _this.renderTextWithLetterSpacing(text3, styles.letterSpacing, baseline);
                var textShadows = styles.textShadow;
                if (textShadows.length && text3.text.trim().length) {
                  textShadows.slice(0).reverse().forEach(function(textShadow2) {
                    _this.ctx.shadowColor = asString(textShadow2.color);
                    _this.ctx.shadowOffsetX = textShadow2.offsetX.number * _this.options.scale;
                    _this.ctx.shadowOffsetY = textShadow2.offsetY.number * _this.options.scale;
                    _this.ctx.shadowBlur = textShadow2.blur.number;
                    _this.renderTextWithLetterSpacing(text3, styles.letterSpacing, baseline);
                  });
                  _this.ctx.shadowColor = "";
                  _this.ctx.shadowOffsetX = 0;
                  _this.ctx.shadowOffsetY = 0;
                  _this.ctx.shadowBlur = 0;
                }
                if (styles.textDecorationLine.length) {
                  _this.ctx.fillStyle = asString(styles.textDecorationColor || styles.color);
                  styles.textDecorationLine.forEach(function(textDecorationLine2) {
                    switch (textDecorationLine2) {
                      case 1:
                        _this.ctx.fillRect(text3.bounds.left, Math.round(text3.bounds.top + baseline), text3.bounds.width, 1);
                        break;
                      case 2:
                        _this.ctx.fillRect(text3.bounds.left, Math.round(text3.bounds.top), text3.bounds.width, 1);
                        break;
                      case 3:
                        _this.ctx.fillRect(text3.bounds.left, Math.ceil(text3.bounds.top + middle), text3.bounds.width, 1);
                        break;
                    }
                  });
                }
                break;
              case 1:
                if (styles.webkitTextStrokeWidth && text3.text.trim().length) {
                  _this.ctx.strokeStyle = asString(styles.webkitTextStrokeColor);
                  _this.ctx.lineWidth = styles.webkitTextStrokeWidth;
                  _this.ctx.lineJoin = !!window.chrome ? "miter" : "round";
                  _this.ctx.strokeText(text3.text, text3.bounds.left, text3.bounds.top + baseline);
                }
                _this.ctx.strokeStyle = "";
                _this.ctx.lineWidth = 0;
                _this.ctx.lineJoin = "miter";
                break;
            }
          });
        });
        return [2];
      });
    });
  };
  CanvasRenderer2.prototype.renderReplacedElement = function(container, curves, image2) {
    if (image2 && container.intrinsicWidth > 0 && container.intrinsicHeight > 0) {
      var box = contentBox(container);
      var path = calculatePaddingBoxPath(curves);
      this.path(path);
      this.ctx.save();
      this.ctx.clip();
      this.ctx.drawImage(image2, 0, 0, container.intrinsicWidth, container.intrinsicHeight, box.left, box.top, box.width, box.height);
      this.ctx.restore();
    }
  };
  CanvasRenderer2.prototype.renderNodeContent = function(paint) {
    return __awaiter(this, void 0, void 0, function() {
      var container, curves, styles, _i, _a2, child, image2, image2, iframeRenderer, canvas, size, _b2, fontFamily2, fontSize2, baseline, bounds, x2, textBounds, img, image2, url, fontFamily2, bounds;
      return __generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            this.applyEffects(paint.getEffects(4));
            container = paint.container;
            curves = paint.curves;
            styles = container.styles;
            _i = 0, _a2 = container.textNodes;
            _c.label = 1;
          case 1:
            if (!(_i < _a2.length))
              return [3, 4];
            child = _a2[_i];
            return [4, this.renderTextNode(child, styles)];
          case 2:
            _c.sent();
            _c.label = 3;
          case 3:
            _i++;
            return [3, 1];
          case 4:
            if (!(container instanceof ImageElementContainer))
              return [3, 8];
            _c.label = 5;
          case 5:
            _c.trys.push([5, 7, , 8]);
            return [4, this.context.cache.match(container.src)];
          case 6:
            image2 = _c.sent();
            this.renderReplacedElement(container, curves, image2);
            return [3, 8];
          case 7:
            _c.sent();
            this.context.logger.error("Error loading image " + container.src);
            return [3, 8];
          case 8:
            if (container instanceof CanvasElementContainer) {
              this.renderReplacedElement(container, curves, container.canvas);
            }
            if (!(container instanceof SVGElementContainer))
              return [3, 12];
            _c.label = 9;
          case 9:
            _c.trys.push([9, 11, , 12]);
            return [4, this.context.cache.match(container.svg)];
          case 10:
            image2 = _c.sent();
            this.renderReplacedElement(container, curves, image2);
            return [3, 12];
          case 11:
            _c.sent();
            this.context.logger.error("Error loading svg " + container.svg.substring(0, 255));
            return [3, 12];
          case 12:
            if (!(container instanceof IFrameElementContainer && container.tree))
              return [3, 14];
            iframeRenderer = new CanvasRenderer2(this.context, {
              scale: this.options.scale,
              backgroundColor: container.backgroundColor,
              x: 0,
              y: 0,
              width: container.width,
              height: container.height
            });
            return [4, iframeRenderer.render(container.tree)];
          case 13:
            canvas = _c.sent();
            if (container.width && container.height) {
              this.ctx.drawImage(canvas, 0, 0, container.width, container.height, container.bounds.left, container.bounds.top, container.bounds.width, container.bounds.height);
            }
            _c.label = 14;
          case 14:
            if (container instanceof InputElementContainer) {
              size = Math.min(container.bounds.width, container.bounds.height);
              if (container.type === CHECKBOX) {
                if (container.checked) {
                  this.ctx.save();
                  this.path([
                    new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79),
                    new Vector(container.bounds.left + size * 0.16, container.bounds.top + size * 0.5549),
                    new Vector(container.bounds.left + size * 0.27347, container.bounds.top + size * 0.44071),
                    new Vector(container.bounds.left + size * 0.39694, container.bounds.top + size * 0.5649),
                    new Vector(container.bounds.left + size * 0.72983, container.bounds.top + size * 0.23),
                    new Vector(container.bounds.left + size * 0.84, container.bounds.top + size * 0.34085),
                    new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79)
                  ]);
                  this.ctx.fillStyle = asString(INPUT_COLOR);
                  this.ctx.fill();
                  this.ctx.restore();
                }
              } else if (container.type === RADIO) {
                if (container.checked) {
                  this.ctx.save();
                  this.ctx.beginPath();
                  this.ctx.arc(container.bounds.left + size / 2, container.bounds.top + size / 2, size / 4, 0, Math.PI * 2, true);
                  this.ctx.fillStyle = asString(INPUT_COLOR);
                  this.ctx.fill();
                  this.ctx.restore();
                }
              }
            }
            if (isTextInputElement(container) && container.value.length) {
              _b2 = this.createFontStyle(styles), fontFamily2 = _b2[0], fontSize2 = _b2[1];
              baseline = this.fontMetrics.getMetrics(fontFamily2, fontSize2).baseline;
              this.ctx.font = fontFamily2;
              this.ctx.fillStyle = asString(styles.color);
              this.ctx.textBaseline = "alphabetic";
              this.ctx.textAlign = canvasTextAlign(container.styles.textAlign);
              bounds = contentBox(container);
              x2 = 0;
              switch (container.styles.textAlign) {
                case 1:
                  x2 += bounds.width / 2;
                  break;
                case 2:
                  x2 += bounds.width;
                  break;
              }
              textBounds = bounds.add(x2, 0, 0, -bounds.height / 2 + 1);
              this.ctx.save();
              this.path([
                new Vector(bounds.left, bounds.top),
                new Vector(bounds.left + bounds.width, bounds.top),
                new Vector(bounds.left + bounds.width, bounds.top + bounds.height),
                new Vector(bounds.left, bounds.top + bounds.height)
              ]);
              this.ctx.clip();
              this.renderTextWithLetterSpacing(new TextBounds(container.value, textBounds), styles.letterSpacing, baseline);
              this.ctx.restore();
              this.ctx.textBaseline = "alphabetic";
              this.ctx.textAlign = "left";
            }
            if (!contains(container.styles.display, 2048))
              return [3, 20];
            if (!(container.styles.listStyleImage !== null))
              return [3, 19];
            img = container.styles.listStyleImage;
            if (!(img.type === 0))
              return [3, 18];
            image2 = void 0;
            url = img.url;
            _c.label = 15;
          case 15:
            _c.trys.push([15, 17, , 18]);
            return [4, this.context.cache.match(url)];
          case 16:
            image2 = _c.sent();
            this.ctx.drawImage(image2, container.bounds.left - (image2.width + 10), container.bounds.top);
            return [3, 18];
          case 17:
            _c.sent();
            this.context.logger.error("Error loading list-style-image " + url);
            return [3, 18];
          case 18:
            return [3, 20];
          case 19:
            if (paint.listValue && container.styles.listStyleType !== -1) {
              fontFamily2 = this.createFontStyle(styles)[0];
              this.ctx.font = fontFamily2;
              this.ctx.fillStyle = asString(styles.color);
              this.ctx.textBaseline = "middle";
              this.ctx.textAlign = "right";
              bounds = new Bounds(container.bounds.left, container.bounds.top + getAbsoluteValue(container.styles.paddingTop, container.bounds.width), container.bounds.width, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 1);
              this.renderTextWithLetterSpacing(new TextBounds(paint.listValue, bounds), styles.letterSpacing, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 2);
              this.ctx.textBaseline = "bottom";
              this.ctx.textAlign = "left";
            }
            _c.label = 20;
          case 20:
            return [2];
        }
      });
    });
  };
  CanvasRenderer2.prototype.renderStackContent = function(stack) {
    return __awaiter(this, void 0, void 0, function() {
      var _i, _a2, child, _b2, _c, child, _d, _e, child, _f, _g, child, _h, _j, child, _k, _l, child, _m, _o, child;
      return __generator(this, function(_p) {
        switch (_p.label) {
          case 0:
            if (contains(stack.element.container.flags, 16)) {
              debugger;
            }
            return [4, this.renderNodeBackgroundAndBorders(stack.element)];
          case 1:
            _p.sent();
            _i = 0, _a2 = stack.negativeZIndex;
            _p.label = 2;
          case 2:
            if (!(_i < _a2.length))
              return [3, 5];
            child = _a2[_i];
            return [4, this.renderStack(child)];
          case 3:
            _p.sent();
            _p.label = 4;
          case 4:
            _i++;
            return [3, 2];
          case 5:
            return [4, this.renderNodeContent(stack.element)];
          case 6:
            _p.sent();
            _b2 = 0, _c = stack.nonInlineLevel;
            _p.label = 7;
          case 7:
            if (!(_b2 < _c.length))
              return [3, 10];
            child = _c[_b2];
            return [4, this.renderNode(child)];
          case 8:
            _p.sent();
            _p.label = 9;
          case 9:
            _b2++;
            return [3, 7];
          case 10:
            _d = 0, _e = stack.nonPositionedFloats;
            _p.label = 11;
          case 11:
            if (!(_d < _e.length))
              return [3, 14];
            child = _e[_d];
            return [4, this.renderStack(child)];
          case 12:
            _p.sent();
            _p.label = 13;
          case 13:
            _d++;
            return [3, 11];
          case 14:
            _f = 0, _g = stack.nonPositionedInlineLevel;
            _p.label = 15;
          case 15:
            if (!(_f < _g.length))
              return [3, 18];
            child = _g[_f];
            return [4, this.renderStack(child)];
          case 16:
            _p.sent();
            _p.label = 17;
          case 17:
            _f++;
            return [3, 15];
          case 18:
            _h = 0, _j = stack.inlineLevel;
            _p.label = 19;
          case 19:
            if (!(_h < _j.length))
              return [3, 22];
            child = _j[_h];
            return [4, this.renderNode(child)];
          case 20:
            _p.sent();
            _p.label = 21;
          case 21:
            _h++;
            return [3, 19];
          case 22:
            _k = 0, _l = stack.zeroOrAutoZIndexOrTransformedOrOpacity;
            _p.label = 23;
          case 23:
            if (!(_k < _l.length))
              return [3, 26];
            child = _l[_k];
            return [4, this.renderStack(child)];
          case 24:
            _p.sent();
            _p.label = 25;
          case 25:
            _k++;
            return [3, 23];
          case 26:
            _m = 0, _o = stack.positiveZIndex;
            _p.label = 27;
          case 27:
            if (!(_m < _o.length))
              return [3, 30];
            child = _o[_m];
            return [4, this.renderStack(child)];
          case 28:
            _p.sent();
            _p.label = 29;
          case 29:
            _m++;
            return [3, 27];
          case 30:
            return [2];
        }
      });
    });
  };
  CanvasRenderer2.prototype.mask = function(paths) {
    this.ctx.beginPath();
    this.ctx.moveTo(0, 0);
    this.ctx.lineTo(this.canvas.width, 0);
    this.ctx.lineTo(this.canvas.width, this.canvas.height);
    this.ctx.lineTo(0, this.canvas.height);
    this.ctx.lineTo(0, 0);
    this.formatPath(paths.slice(0).reverse());
    this.ctx.closePath();
  };
  CanvasRenderer2.prototype.path = function(paths) {
    this.ctx.beginPath();
    this.formatPath(paths);
    this.ctx.closePath();
  };
  CanvasRenderer2.prototype.formatPath = function(paths) {
    var _this = this;
    paths.forEach(function(point, index2) {
      var start2 = isBezierCurve(point) ? point.start : point;
      if (index2 === 0) {
        _this.ctx.moveTo(start2.x, start2.y);
      } else {
        _this.ctx.lineTo(start2.x, start2.y);
      }
      if (isBezierCurve(point)) {
        _this.ctx.bezierCurveTo(point.startControl.x, point.startControl.y, point.endControl.x, point.endControl.y, point.end.x, point.end.y);
      }
    });
  };
  CanvasRenderer2.prototype.renderRepeat = function(path, pattern, offsetX, offsetY) {
    this.path(path);
    this.ctx.fillStyle = pattern;
    this.ctx.translate(offsetX, offsetY);
    this.ctx.fill();
    this.ctx.translate(-offsetX, -offsetY);
  };
  CanvasRenderer2.prototype.resizeImage = function(image2, width, height) {
    var _a2;
    if (image2.width === width && image2.height === height) {
      return image2;
    }
    var ownerDocument = (_a2 = this.canvas.ownerDocument) !== null && _a2 !== void 0 ? _a2 : document;
    var canvas = ownerDocument.createElement("canvas");
    canvas.width = Math.max(1, width);
    canvas.height = Math.max(1, height);
    var ctx = canvas.getContext("2d");
    ctx.drawImage(image2, 0, 0, image2.width, image2.height, 0, 0, width, height);
    return canvas;
  };
  CanvasRenderer2.prototype.renderBackgroundImage = function(container) {
    return __awaiter(this, void 0, void 0, function() {
      var index2, _loop_1, this_1, _i, _a2, backgroundImage2;
      return __generator(this, function(_b2) {
        switch (_b2.label) {
          case 0:
            index2 = container.styles.backgroundImage.length - 1;
            _loop_1 = function(backgroundImage3) {
              var image2, url, _c, path, x2, y2, width, height, pattern, _d, path, x2, y2, width, height, _e, lineLength, x0, x1, y0, y1, canvas, ctx, gradient_1, pattern, _f, path, left, top_1, width, height, position2, x2, y2, _g, rx, ry, radialGradient_1, midX, midY, f2, invF;
              return __generator(this, function(_h) {
                switch (_h.label) {
                  case 0:
                    if (!(backgroundImage3.type === 0))
                      return [3, 5];
                    image2 = void 0;
                    url = backgroundImage3.url;
                    _h.label = 1;
                  case 1:
                    _h.trys.push([1, 3, , 4]);
                    return [4, this_1.context.cache.match(url)];
                  case 2:
                    image2 = _h.sent();
                    return [3, 4];
                  case 3:
                    _h.sent();
                    this_1.context.logger.error("Error loading background-image " + url);
                    return [3, 4];
                  case 4:
                    if (image2) {
                      _c = calculateBackgroundRendering(container, index2, [
                        image2.width,
                        image2.height,
                        image2.width / image2.height
                      ]), path = _c[0], x2 = _c[1], y2 = _c[2], width = _c[3], height = _c[4];
                      pattern = this_1.ctx.createPattern(this_1.resizeImage(image2, width, height), "repeat");
                      this_1.renderRepeat(path, pattern, x2, y2);
                    }
                    return [3, 6];
                  case 5:
                    if (isLinearGradient(backgroundImage3)) {
                      _d = calculateBackgroundRendering(container, index2, [null, null, null]), path = _d[0], x2 = _d[1], y2 = _d[2], width = _d[3], height = _d[4];
                      _e = calculateGradientDirection(backgroundImage3.angle, width, height), lineLength = _e[0], x0 = _e[1], x1 = _e[2], y0 = _e[3], y1 = _e[4];
                      canvas = document.createElement("canvas");
                      canvas.width = width;
                      canvas.height = height;
                      ctx = canvas.getContext("2d");
                      gradient_1 = ctx.createLinearGradient(x0, y0, x1, y1);
                      processColorStops(backgroundImage3.stops, lineLength).forEach(function(colorStop) {
                        return gradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                      });
                      ctx.fillStyle = gradient_1;
                      ctx.fillRect(0, 0, width, height);
                      if (width > 0 && height > 0) {
                        pattern = this_1.ctx.createPattern(canvas, "repeat");
                        this_1.renderRepeat(path, pattern, x2, y2);
                      }
                    } else if (isRadialGradient(backgroundImage3)) {
                      _f = calculateBackgroundRendering(container, index2, [
                        null,
                        null,
                        null
                      ]), path = _f[0], left = _f[1], top_1 = _f[2], width = _f[3], height = _f[4];
                      position2 = backgroundImage3.position.length === 0 ? [FIFTY_PERCENT] : backgroundImage3.position;
                      x2 = getAbsoluteValue(position2[0], width);
                      y2 = getAbsoluteValue(position2[position2.length - 1], height);
                      _g = calculateRadius(backgroundImage3, x2, y2, width, height), rx = _g[0], ry = _g[1];
                      if (rx > 0 && ry > 0) {
                        radialGradient_1 = this_1.ctx.createRadialGradient(left + x2, top_1 + y2, 0, left + x2, top_1 + y2, rx);
                        processColorStops(backgroundImage3.stops, rx * 2).forEach(function(colorStop) {
                          return radialGradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                        });
                        this_1.path(path);
                        this_1.ctx.fillStyle = radialGradient_1;
                        if (rx !== ry) {
                          midX = container.bounds.left + 0.5 * container.bounds.width;
                          midY = container.bounds.top + 0.5 * container.bounds.height;
                          f2 = ry / rx;
                          invF = 1 / f2;
                          this_1.ctx.save();
                          this_1.ctx.translate(midX, midY);
                          this_1.ctx.transform(1, 0, 0, f2, 0, 0);
                          this_1.ctx.translate(-midX, -midY);
                          this_1.ctx.fillRect(left, invF * (top_1 - midY) + midY, width, height * invF);
                          this_1.ctx.restore();
                        } else {
                          this_1.ctx.fill();
                        }
                      }
                    }
                    _h.label = 6;
                  case 6:
                    index2--;
                    return [2];
                }
              });
            };
            this_1 = this;
            _i = 0, _a2 = container.styles.backgroundImage.slice(0).reverse();
            _b2.label = 1;
          case 1:
            if (!(_i < _a2.length))
              return [3, 4];
            backgroundImage2 = _a2[_i];
            return [5, _loop_1(backgroundImage2)];
          case 2:
            _b2.sent();
            _b2.label = 3;
          case 3:
            _i++;
            return [3, 1];
          case 4:
            return [2];
        }
      });
    });
  };
  CanvasRenderer2.prototype.renderSolidBorder = function(color2, side, curvePoints) {
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(_a2) {
        this.path(parsePathForBorder(curvePoints, side));
        this.ctx.fillStyle = asString(color2);
        this.ctx.fill();
        return [2];
      });
    });
  };
  CanvasRenderer2.prototype.renderDoubleBorder = function(color2, width, side, curvePoints) {
    return __awaiter(this, void 0, void 0, function() {
      var outerPaths, innerPaths;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            if (!(width < 3))
              return [3, 2];
            return [4, this.renderSolidBorder(color2, side, curvePoints)];
          case 1:
            _a2.sent();
            return [2];
          case 2:
            outerPaths = parsePathForBorderDoubleOuter(curvePoints, side);
            this.path(outerPaths);
            this.ctx.fillStyle = asString(color2);
            this.ctx.fill();
            innerPaths = parsePathForBorderDoubleInner(curvePoints, side);
            this.path(innerPaths);
            this.ctx.fill();
            return [2];
        }
      });
    });
  };
  CanvasRenderer2.prototype.renderNodeBackgroundAndBorders = function(paint) {
    return __awaiter(this, void 0, void 0, function() {
      var styles, hasBackground, borders, backgroundPaintingArea, side, _i, borders_1, border;
      var _this = this;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            this.applyEffects(paint.getEffects(2));
            styles = paint.container.styles;
            hasBackground = !isTransparent(styles.backgroundColor) || styles.backgroundImage.length;
            borders = [
              { style: styles.borderTopStyle, color: styles.borderTopColor, width: styles.borderTopWidth },
              { style: styles.borderRightStyle, color: styles.borderRightColor, width: styles.borderRightWidth },
              { style: styles.borderBottomStyle, color: styles.borderBottomColor, width: styles.borderBottomWidth },
              { style: styles.borderLeftStyle, color: styles.borderLeftColor, width: styles.borderLeftWidth }
            ];
            backgroundPaintingArea = calculateBackgroundCurvedPaintingArea(getBackgroundValueForIndex(styles.backgroundClip, 0), paint.curves);
            if (!(hasBackground || styles.boxShadow.length))
              return [3, 2];
            this.ctx.save();
            this.path(backgroundPaintingArea);
            this.ctx.clip();
            if (!isTransparent(styles.backgroundColor)) {
              this.ctx.fillStyle = asString(styles.backgroundColor);
              this.ctx.fill();
            }
            return [4, this.renderBackgroundImage(paint.container)];
          case 1:
            _a2.sent();
            this.ctx.restore();
            styles.boxShadow.slice(0).reverse().forEach(function(shadow) {
              _this.ctx.save();
              var borderBoxArea = calculateBorderBoxPath(paint.curves);
              var maskOffset = shadow.inset ? 0 : MASK_OFFSET;
              var shadowPaintingArea = transformPath(borderBoxArea, -maskOffset + (shadow.inset ? 1 : -1) * shadow.spread.number, (shadow.inset ? 1 : -1) * shadow.spread.number, shadow.spread.number * (shadow.inset ? -2 : 2), shadow.spread.number * (shadow.inset ? -2 : 2));
              if (shadow.inset) {
                _this.path(borderBoxArea);
                _this.ctx.clip();
                _this.mask(shadowPaintingArea);
              } else {
                _this.mask(borderBoxArea);
                _this.ctx.clip();
                _this.path(shadowPaintingArea);
              }
              _this.ctx.shadowOffsetX = shadow.offsetX.number + maskOffset;
              _this.ctx.shadowOffsetY = shadow.offsetY.number;
              _this.ctx.shadowColor = asString(shadow.color);
              _this.ctx.shadowBlur = shadow.blur.number;
              _this.ctx.fillStyle = shadow.inset ? asString(shadow.color) : "rgba(0,0,0,1)";
              _this.ctx.fill();
              _this.ctx.restore();
            });
            _a2.label = 2;
          case 2:
            side = 0;
            _i = 0, borders_1 = borders;
            _a2.label = 3;
          case 3:
            if (!(_i < borders_1.length))
              return [3, 13];
            border = borders_1[_i];
            if (!(border.style !== 0 && !isTransparent(border.color) && border.width > 0))
              return [3, 11];
            if (!(border.style === 2))
              return [3, 5];
            return [4, this.renderDashedDottedBorder(border.color, border.width, side, paint.curves, 2)];
          case 4:
            _a2.sent();
            return [3, 11];
          case 5:
            if (!(border.style === 3))
              return [3, 7];
            return [4, this.renderDashedDottedBorder(border.color, border.width, side, paint.curves, 3)];
          case 6:
            _a2.sent();
            return [3, 11];
          case 7:
            if (!(border.style === 4))
              return [3, 9];
            return [4, this.renderDoubleBorder(border.color, border.width, side, paint.curves)];
          case 8:
            _a2.sent();
            return [3, 11];
          case 9:
            return [4, this.renderSolidBorder(border.color, side, paint.curves)];
          case 10:
            _a2.sent();
            _a2.label = 11;
          case 11:
            side++;
            _a2.label = 12;
          case 12:
            _i++;
            return [3, 3];
          case 13:
            return [2];
        }
      });
    });
  };
  CanvasRenderer2.prototype.renderDashedDottedBorder = function(color2, width, side, curvePoints, style2) {
    return __awaiter(this, void 0, void 0, function() {
      var strokePaths, boxPaths, startX, startY, endX, endY, length, dashLength, spaceLength, useLineDash, multiplier, numberOfDashes, minSpace, maxSpace, path1, path2, path1, path2;
      return __generator(this, function(_a2) {
        this.ctx.save();
        strokePaths = parsePathForBorderStroke(curvePoints, side);
        boxPaths = parsePathForBorder(curvePoints, side);
        if (style2 === 2) {
          this.path(boxPaths);
          this.ctx.clip();
        }
        if (isBezierCurve(boxPaths[0])) {
          startX = boxPaths[0].start.x;
          startY = boxPaths[0].start.y;
        } else {
          startX = boxPaths[0].x;
          startY = boxPaths[0].y;
        }
        if (isBezierCurve(boxPaths[1])) {
          endX = boxPaths[1].end.x;
          endY = boxPaths[1].end.y;
        } else {
          endX = boxPaths[1].x;
          endY = boxPaths[1].y;
        }
        if (side === 0 || side === 2) {
          length = Math.abs(startX - endX);
        } else {
          length = Math.abs(startY - endY);
        }
        this.ctx.beginPath();
        if (style2 === 3) {
          this.formatPath(strokePaths);
        } else {
          this.formatPath(boxPaths.slice(0, 2));
        }
        dashLength = width < 3 ? width * 3 : width * 2;
        spaceLength = width < 3 ? width * 2 : width;
        if (style2 === 3) {
          dashLength = width;
          spaceLength = width;
        }
        useLineDash = true;
        if (length <= dashLength * 2) {
          useLineDash = false;
        } else if (length <= dashLength * 2 + spaceLength) {
          multiplier = length / (2 * dashLength + spaceLength);
          dashLength *= multiplier;
          spaceLength *= multiplier;
        } else {
          numberOfDashes = Math.floor((length + spaceLength) / (dashLength + spaceLength));
          minSpace = (length - numberOfDashes * dashLength) / (numberOfDashes - 1);
          maxSpace = (length - (numberOfDashes + 1) * dashLength) / numberOfDashes;
          spaceLength = maxSpace <= 0 || Math.abs(spaceLength - minSpace) < Math.abs(spaceLength - maxSpace) ? minSpace : maxSpace;
        }
        if (useLineDash) {
          if (style2 === 3) {
            this.ctx.setLineDash([0, dashLength + spaceLength]);
          } else {
            this.ctx.setLineDash([dashLength, spaceLength]);
          }
        }
        if (style2 === 3) {
          this.ctx.lineCap = "round";
          this.ctx.lineWidth = width;
        } else {
          this.ctx.lineWidth = width * 2 + 1.1;
        }
        this.ctx.strokeStyle = asString(color2);
        this.ctx.stroke();
        this.ctx.setLineDash([]);
        if (style2 === 2) {
          if (isBezierCurve(boxPaths[0])) {
            path1 = boxPaths[3];
            path2 = boxPaths[0];
            this.ctx.beginPath();
            this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
            this.ctx.stroke();
          }
          if (isBezierCurve(boxPaths[1])) {
            path1 = boxPaths[1];
            path2 = boxPaths[2];
            this.ctx.beginPath();
            this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
            this.ctx.stroke();
          }
        }
        this.ctx.restore();
        return [2];
      });
    });
  };
  CanvasRenderer2.prototype.render = function(element) {
    return __awaiter(this, void 0, void 0, function() {
      var stack;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            if (this.options.backgroundColor) {
              this.ctx.fillStyle = asString(this.options.backgroundColor);
              this.ctx.fillRect(this.options.x, this.options.y, this.options.width, this.options.height);
            }
            stack = parseStackingContexts(element);
            return [4, this.renderStack(stack)];
          case 1:
            _a2.sent();
            this.applyEffects([]);
            return [2, this.canvas];
        }
      });
    });
  };
  return CanvasRenderer2;
}(Renderer);
var isTextInputElement = function(container) {
  if (container instanceof TextareaElementContainer) {
    return true;
  } else if (container instanceof SelectElementContainer) {
    return true;
  } else if (container instanceof InputElementContainer && container.type !== RADIO && container.type !== CHECKBOX) {
    return true;
  }
  return false;
};
var calculateBackgroundCurvedPaintingArea = function(clip, curves) {
  switch (clip) {
    case 0:
      return calculateBorderBoxPath(curves);
    case 2:
      return calculateContentBoxPath(curves);
    case 1:
    default:
      return calculatePaddingBoxPath(curves);
  }
};
var canvasTextAlign = function(textAlign2) {
  switch (textAlign2) {
    case 1:
      return "center";
    case 2:
      return "right";
    case 0:
    default:
      return "left";
  }
};
var iOSBrokenFonts = ["-apple-system", "system-ui"];
var fixIOSSystemFonts = function(fontFamilies) {
  return /iPhone OS 15_(0|1)/.test(window.navigator.userAgent) ? fontFamilies.filter(function(fontFamily2) {
    return iOSBrokenFonts.indexOf(fontFamily2) === -1;
  }) : fontFamilies;
};
var ForeignObjectRenderer = function(_super) {
  __extends(ForeignObjectRenderer2, _super);
  function ForeignObjectRenderer2(context2, options) {
    var _this = _super.call(this, context2, options) || this;
    _this.canvas = options.canvas ? options.canvas : document.createElement("canvas");
    _this.ctx = _this.canvas.getContext("2d");
    _this.options = options;
    _this.canvas.width = Math.floor(options.width * options.scale);
    _this.canvas.height = Math.floor(options.height * options.scale);
    _this.canvas.style.width = options.width + "px";
    _this.canvas.style.height = options.height + "px";
    _this.ctx.scale(_this.options.scale, _this.options.scale);
    _this.ctx.translate(-options.x, -options.y);
    _this.context.logger.debug("EXPERIMENTAL ForeignObject renderer initialized (" + options.width + "x" + options.height + " at " + options.x + "," + options.y + ") with scale " + options.scale);
    return _this;
  }
  ForeignObjectRenderer2.prototype.render = function(element) {
    return __awaiter(this, void 0, void 0, function() {
      var svg2, img;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            svg2 = createForeignObjectSVG(this.options.width * this.options.scale, this.options.height * this.options.scale, this.options.scale, this.options.scale, element);
            return [4, loadSerializedSVG(svg2)];
          case 1:
            img = _a2.sent();
            if (this.options.backgroundColor) {
              this.ctx.fillStyle = asString(this.options.backgroundColor);
              this.ctx.fillRect(0, 0, this.options.width * this.options.scale, this.options.height * this.options.scale);
            }
            this.ctx.drawImage(img, -this.options.x * this.options.scale, -this.options.y * this.options.scale);
            return [2, this.canvas];
        }
      });
    });
  };
  return ForeignObjectRenderer2;
}(Renderer);
var loadSerializedSVG = function(svg2) {
  return new Promise(function(resolve2, reject2) {
    var img = new Image();
    img.onload = function() {
      resolve2(img);
    };
    img.onerror = reject2;
    img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg2));
  });
};
var Logger = function() {
  function Logger2(_a2) {
    var id = _a2.id, enabled = _a2.enabled;
    this.id = id;
    this.enabled = enabled;
    this.start = Date.now();
  }
  Logger2.prototype.debug = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (this.enabled) {
      if (typeof window !== "undefined" && window.console && typeof console.debug === "function") {
        console.debug.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
      } else {
        this.info.apply(this, args);
      }
    }
  };
  Logger2.prototype.getTime = function() {
    return Date.now() - this.start;
  };
  Logger2.prototype.info = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (this.enabled) {
      if (typeof window !== "undefined" && window.console && typeof console.info === "function") {
        console.info.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
      }
    }
  };
  Logger2.prototype.warn = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (this.enabled) {
      if (typeof window !== "undefined" && window.console && typeof console.warn === "function") {
        console.warn.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
      } else {
        this.info.apply(this, args);
      }
    }
  };
  Logger2.prototype.error = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (this.enabled) {
      if (typeof window !== "undefined" && window.console && typeof console.error === "function") {
        console.error.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
      } else {
        this.info.apply(this, args);
      }
    }
  };
  Logger2.instances = {};
  return Logger2;
}();
var Context = function() {
  function Context2(options, windowBounds) {
    var _a2;
    this.windowBounds = windowBounds;
    this.instanceName = "#" + Context2.instanceCount++;
    this.logger = new Logger({ id: this.instanceName, enabled: options.logging });
    this.cache = (_a2 = options.cache) !== null && _a2 !== void 0 ? _a2 : new Cache(this, options);
  }
  Context2.instanceCount = 1;
  return Context2;
}();
var html2canvas = function(element, options) {
  if (options === void 0) {
    options = {};
  }
  return renderElement(element, options);
};
if (typeof window !== "undefined") {
  CacheStorage.setContext(window);
}
var renderElement = function(element, opts) {
  return __awaiter(void 0, void 0, void 0, function() {
    var ownerDocument, defaultView, resourceOptions, contextOptions, windowOptions, windowBounds, context2, foreignObjectRendering, cloneOptions, documentCloner, clonedElement, container, _a2, width, height, left, top, backgroundColor2, renderOptions, canvas, renderer, root2, renderer;
    var _b2, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t2;
    return __generator(this, function(_u) {
      switch (_u.label) {
        case 0:
          if (!element || typeof element !== "object") {
            return [2, Promise.reject("Invalid element provided as first argument")];
          }
          ownerDocument = element.ownerDocument;
          if (!ownerDocument) {
            throw new Error("Element is not attached to a Document");
          }
          defaultView = ownerDocument.defaultView;
          if (!defaultView) {
            throw new Error("Document is not attached to a Window");
          }
          resourceOptions = {
            allowTaint: (_b2 = opts.allowTaint) !== null && _b2 !== void 0 ? _b2 : false,
            imageTimeout: (_c = opts.imageTimeout) !== null && _c !== void 0 ? _c : 15e3,
            proxy: opts.proxy,
            useCORS: (_d = opts.useCORS) !== null && _d !== void 0 ? _d : false
          };
          contextOptions = __assign({ logging: (_e = opts.logging) !== null && _e !== void 0 ? _e : true, cache: opts.cache }, resourceOptions);
          windowOptions = {
            windowWidth: (_f = opts.windowWidth) !== null && _f !== void 0 ? _f : defaultView.innerWidth,
            windowHeight: (_g = opts.windowHeight) !== null && _g !== void 0 ? _g : defaultView.innerHeight,
            scrollX: (_h = opts.scrollX) !== null && _h !== void 0 ? _h : defaultView.pageXOffset,
            scrollY: (_j = opts.scrollY) !== null && _j !== void 0 ? _j : defaultView.pageYOffset
          };
          windowBounds = new Bounds(windowOptions.scrollX, windowOptions.scrollY, windowOptions.windowWidth, windowOptions.windowHeight);
          context2 = new Context(contextOptions, windowBounds);
          foreignObjectRendering = (_k = opts.foreignObjectRendering) !== null && _k !== void 0 ? _k : false;
          cloneOptions = {
            allowTaint: (_l = opts.allowTaint) !== null && _l !== void 0 ? _l : false,
            onclone: opts.onclone,
            ignoreElements: opts.ignoreElements,
            inlineImages: foreignObjectRendering,
            copyStyles: foreignObjectRendering
          };
          context2.logger.debug("Starting document clone with size " + windowBounds.width + "x" + windowBounds.height + " scrolled to " + -windowBounds.left + "," + -windowBounds.top);
          documentCloner = new DocumentCloner(context2, element, cloneOptions);
          clonedElement = documentCloner.clonedReferenceElement;
          if (!clonedElement) {
            return [2, Promise.reject("Unable to find element in cloned iframe")];
          }
          return [4, documentCloner.toIFrame(ownerDocument, windowBounds)];
        case 1:
          container = _u.sent();
          _a2 = isBodyElement(clonedElement) || isHTMLElement(clonedElement) ? parseDocumentSize(clonedElement.ownerDocument) : parseBounds(context2, clonedElement), width = _a2.width, height = _a2.height, left = _a2.left, top = _a2.top;
          backgroundColor2 = parseBackgroundColor(context2, clonedElement, opts.backgroundColor);
          renderOptions = {
            canvas: opts.canvas,
            backgroundColor: backgroundColor2,
            scale: (_o = (_m = opts.scale) !== null && _m !== void 0 ? _m : defaultView.devicePixelRatio) !== null && _o !== void 0 ? _o : 1,
            x: ((_p = opts.x) !== null && _p !== void 0 ? _p : 0) + left,
            y: ((_q = opts.y) !== null && _q !== void 0 ? _q : 0) + top,
            width: (_r = opts.width) !== null && _r !== void 0 ? _r : Math.ceil(width),
            height: (_s = opts.height) !== null && _s !== void 0 ? _s : Math.ceil(height)
          };
          if (!foreignObjectRendering)
            return [3, 3];
          context2.logger.debug("Document cloned, using foreign object rendering");
          renderer = new ForeignObjectRenderer(context2, renderOptions);
          return [4, renderer.render(clonedElement)];
        case 2:
          canvas = _u.sent();
          return [3, 5];
        case 3:
          context2.logger.debug("Document cloned, element located at " + left + "," + top + " with size " + width + "x" + height + " using computed rendering");
          context2.logger.debug("Starting DOM parsing");
          root2 = parseTree(context2, clonedElement);
          if (backgroundColor2 === root2.styles.backgroundColor) {
            root2.styles.backgroundColor = COLORS.TRANSPARENT;
          }
          context2.logger.debug("Starting renderer for element at " + renderOptions.x + "," + renderOptions.y + " with size " + renderOptions.width + "x" + renderOptions.height);
          renderer = new CanvasRenderer(context2, renderOptions);
          return [4, renderer.render(root2)];
        case 4:
          canvas = _u.sent();
          _u.label = 5;
        case 5:
          if ((_t2 = opts.removeContainer) !== null && _t2 !== void 0 ? _t2 : true) {
            if (!DocumentCloner.destroy(container)) {
              context2.logger.error("Cannot detach cloned iframe as it is not in the DOM anymore");
            }
          }
          context2.logger.debug("Finished rendering");
          return [2, canvas];
      }
    });
  });
};
var parseBackgroundColor = function(context2, element, backgroundColorOverride) {
  var ownerDocument = element.ownerDocument;
  var documentBackgroundColor = ownerDocument.documentElement ? parseColor(context2, getComputedStyle(ownerDocument.documentElement).backgroundColor) : COLORS.TRANSPARENT;
  var bodyBackgroundColor = ownerDocument.body ? parseColor(context2, getComputedStyle(ownerDocument.body).backgroundColor) : COLORS.TRANSPARENT;
  var defaultBackgroundColor = typeof backgroundColorOverride === "string" ? parseColor(context2, backgroundColorOverride) : backgroundColorOverride === null ? COLORS.TRANSPARENT : 4294967295;
  return element === ownerDocument.documentElement ? isTransparent(documentBackgroundColor) ? isTransparent(bodyBackgroundColor) ? defaultBackgroundColor : bodyBackgroundColor : documentBackgroundColor : defaultBackgroundColor;
};
var html2canvas_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": html2canvas
}, Symbol.toStringTag, { value: "Module" }));
/*! @license DOMPurify 2.3.5 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.5/LICENSE */
function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i2 = 0, arr2 = Array(arr.length); i2 < arr.length; i2++) {
      arr2[i2] = arr[i2];
    }
    return arr2;
  } else {
    return Array.from(arr);
  }
}
var hasOwnProperty$1 = Object.hasOwnProperty, setPrototypeOf$2 = Object.setPrototypeOf, isFrozen = Object.isFrozen, getPrototypeOf$2 = Object.getPrototypeOf, getOwnPropertyDescriptor$5 = Object.getOwnPropertyDescriptor;
var freeze = Object.freeze, seal = Object.seal, create$3 = Object.create;
var _ref = typeof Reflect !== "undefined" && Reflect, apply$4 = _ref.apply, construct$1 = _ref.construct;
if (!apply$4) {
  apply$4 = function apply2(fun, thisValue, args) {
    return fun.apply(thisValue, args);
  };
}
if (!freeze) {
  freeze = function freeze2(x2) {
    return x2;
  };
}
if (!seal) {
  seal = function seal2(x2) {
    return x2;
  };
}
if (!construct$1) {
  construct$1 = function construct2(Func, args) {
    return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();
  };
}
var arrayForEach = unapply(Array.prototype.forEach);
var arrayPop = unapply(Array.prototype.pop);
var arrayPush = unapply(Array.prototype.push);
var stringToLowerCase = unapply(String.prototype.toLowerCase);
var stringMatch = unapply(String.prototype.match);
var stringReplace = unapply(String.prototype.replace);
var stringIndexOf$2 = unapply(String.prototype.indexOf);
var stringTrim$1 = unapply(String.prototype.trim);
var regExpTest = unapply(RegExp.prototype.test);
var typeErrorCreate = unconstruct(TypeError);
function unapply(func) {
  return function(thisArg) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return apply$4(func, thisArg, args);
  };
}
function unconstruct(func) {
  return function() {
    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return construct$1(func, args);
  };
}
function addToSet(set2, array) {
  if (setPrototypeOf$2) {
    setPrototypeOf$2(set2, null);
  }
  var l2 = array.length;
  while (l2--) {
    var element = array[l2];
    if (typeof element === "string") {
      var lcElement = stringToLowerCase(element);
      if (lcElement !== element) {
        if (!isFrozen(array)) {
          array[l2] = lcElement;
        }
        element = lcElement;
      }
    }
    set2[element] = true;
  }
  return set2;
}
function clone(object) {
  var newObject = create$3(null);
  var property = void 0;
  for (property in object) {
    if (apply$4(hasOwnProperty$1, object, [property])) {
      newObject[property] = object[property];
    }
  }
  return newObject;
}
function lookupGetter(object, prop) {
  while (object !== null) {
    var desc = getOwnPropertyDescriptor$5(object, prop);
    if (desc) {
      if (desc.get) {
        return unapply(desc.get);
      }
      if (typeof desc.value === "function") {
        return unapply(desc.value);
      }
    }
    object = getPrototypeOf$2(object);
  }
  function fallbackValue(element) {
    console.warn("fallback value for", element);
    return null;
  }
  return fallbackValue;
}
var html$3 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
var svg = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
var svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
var svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "fedropshadow", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
var mathMl = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]);
var mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
var text = freeze(["#text"]);
var html$1$1 = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]);
var svg$1 = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
var mathMl$1 = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
var xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
var MUSTACHE_EXPR = seal(/\{\{[\s\S]*|[\s\S]*\}\}/gm);
var ERB_EXPR = seal(/<%[\s\S]*|[\s\S]*%>/gm);
var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/);
var ARIA_ATTR = seal(/^aria-[\-\w]+$/);
var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i);
var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g);
var _typeof$1 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
  return typeof obj;
} : function(obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
function _toConsumableArray$1(arr) {
  if (Array.isArray(arr)) {
    for (var i2 = 0, arr2 = Array(arr.length); i2 < arr.length; i2++) {
      arr2[i2] = arr[i2];
    }
    return arr2;
  } else {
    return Array.from(arr);
  }
}
var getGlobal = function getGlobal2() {
  return typeof window === "undefined" ? null : window;
};
var _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, document2) {
  if ((typeof trustedTypes === "undefined" ? "undefined" : _typeof$1(trustedTypes)) !== "object" || typeof trustedTypes.createPolicy !== "function") {
    return null;
  }
  var suffix2 = null;
  var ATTR_NAME = "data-tt-policy-suffix";
  if (document2.currentScript && document2.currentScript.hasAttribute(ATTR_NAME)) {
    suffix2 = document2.currentScript.getAttribute(ATTR_NAME);
  }
  var policyName = "dompurify" + (suffix2 ? "#" + suffix2 : "");
  try {
    return trustedTypes.createPolicy(policyName, {
      createHTML: function createHTML(html$$1) {
        return html$$1;
      }
    });
  } catch (_2) {
    console.warn("TrustedTypes policy " + policyName + " could not be created.");
    return null;
  }
};
function createDOMPurify() {
  var window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
  var DOMPurify = function DOMPurify2(root2) {
    return createDOMPurify(root2);
  };
  DOMPurify.version = "2.3.5";
  DOMPurify.removed = [];
  if (!window2 || !window2.document || window2.document.nodeType !== 9) {
    DOMPurify.isSupported = false;
    return DOMPurify;
  }
  var originalDocument = window2.document;
  var document2 = window2.document;
  var DocumentFragment = window2.DocumentFragment, HTMLTemplateElement = window2.HTMLTemplateElement, Node2 = window2.Node, Element2 = window2.Element, NodeFilter = window2.NodeFilter, _window$NamedNodeMap = window2.NamedNodeMap, NamedNodeMap = _window$NamedNodeMap === void 0 ? window2.NamedNodeMap || window2.MozNamedAttrMap : _window$NamedNodeMap, HTMLFormElement = window2.HTMLFormElement, DOMParser2 = window2.DOMParser, trustedTypes = window2.trustedTypes;
  var ElementPrototype = Element2.prototype;
  var cloneNode = lookupGetter(ElementPrototype, "cloneNode");
  var getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
  var getChildNodes = lookupGetter(ElementPrototype, "childNodes");
  var getParentNode = lookupGetter(ElementPrototype, "parentNode");
  if (typeof HTMLTemplateElement === "function") {
    var template = document2.createElement("template");
    if (template.content && template.content.ownerDocument) {
      document2 = template.content.ownerDocument;
    }
  }
  var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
  var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML("") : "";
  var _document = document2, implementation = _document.implementation, createNodeIterator = _document.createNodeIterator, createDocumentFragment = _document.createDocumentFragment, getElementsByTagName = _document.getElementsByTagName;
  var importNode = originalDocument.importNode;
  var documentMode = {};
  try {
    documentMode = clone(document2).documentMode ? document2.documentMode : {};
  } catch (_2) {
  }
  var hooks = {};
  DOMPurify.isSupported = typeof getParentNode === "function" && implementation && typeof implementation.createHTMLDocument !== "undefined" && documentMode !== 9;
  var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR, ERB_EXPR$$1 = ERB_EXPR, DATA_ATTR$$1 = DATA_ATTR, ARIA_ATTR$$1 = ARIA_ATTR, IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA, ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;
  var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;
  var ALLOWED_TAGS = null;
  var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html$3), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text)));
  var ALLOWED_ATTR = null;
  var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));
  var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
    tagNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: false
    }
  }));
  var FORBID_TAGS = null;
  var FORBID_ATTR = null;
  var ALLOW_ARIA_ATTR = true;
  var ALLOW_DATA_ATTR = true;
  var ALLOW_UNKNOWN_PROTOCOLS = false;
  var SAFE_FOR_TEMPLATES = false;
  var WHOLE_DOCUMENT = false;
  var SET_CONFIG = false;
  var FORCE_BODY = false;
  var RETURN_DOM = false;
  var RETURN_DOM_FRAGMENT = false;
  var RETURN_TRUSTED_TYPE = false;
  var SANITIZE_DOM = true;
  var KEEP_CONTENT = true;
  var IN_PLACE = false;
  var USE_PROFILES = {};
  var FORBID_CONTENTS = null;
  var DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  var DATA_URI_TAGS = null;
  var DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
  var URI_SAFE_ATTRIBUTES = null;
  var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
  var MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
  var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
  var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
  var NAMESPACE = HTML_NAMESPACE;
  var IS_EMPTY_INPUT = false;
  var PARSER_MEDIA_TYPE = void 0;
  var SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
  var DEFAULT_PARSER_MEDIA_TYPE = "text/html";
  var transformCaseFunc = void 0;
  var CONFIG = null;
  var formElement = document2.createElement("form");
  var isRegexOrFunction = function isRegexOrFunction2(testValue) {
    return testValue instanceof RegExp || testValue instanceof Function;
  };
  var _parseConfig = function _parseConfig2(cfg) {
    if (CONFIG && CONFIG === cfg) {
      return;
    }
    if (!cfg || (typeof cfg === "undefined" ? "undefined" : _typeof$1(cfg)) !== "object") {
      cfg = {};
    }
    cfg = clone(cfg);
    ALLOWED_TAGS = "ALLOWED_TAGS" in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
    ALLOWED_ATTR = "ALLOWED_ATTR" in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
    URI_SAFE_ATTRIBUTES = "ADD_URI_SAFE_ATTR" in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;
    DATA_URI_TAGS = "ADD_DATA_URI_TAGS" in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;
    FORBID_CONTENTS = "FORBID_CONTENTS" in cfg ? addToSet({}, cfg.FORBID_CONTENTS) : DEFAULT_FORBID_CONTENTS;
    FORBID_TAGS = "FORBID_TAGS" in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};
    FORBID_ATTR = "FORBID_ATTR" in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};
    USE_PROFILES = "USE_PROFILES" in cfg ? cfg.USE_PROFILES : false;
    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
    RETURN_DOM = cfg.RETURN_DOM || false;
    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
    FORCE_BODY = cfg.FORCE_BODY || false;
    SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
    KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
    IN_PLACE = cfg.IN_PLACE || false;
    IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;
    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
      CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
    }
    PARSER_MEDIA_TYPE = SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;
    transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? function(x2) {
      return x2;
    } : stringToLowerCase;
    if (SAFE_FOR_TEMPLATES) {
      ALLOW_DATA_ATTR = false;
    }
    if (RETURN_DOM_FRAGMENT) {
      RETURN_DOM = true;
    }
    if (USE_PROFILES) {
      ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text)));
      ALLOWED_ATTR = [];
      if (USE_PROFILES.html === true) {
        addToSet(ALLOWED_TAGS, html$3);
        addToSet(ALLOWED_ATTR, html$1$1);
      }
      if (USE_PROFILES.svg === true) {
        addToSet(ALLOWED_TAGS, svg);
        addToSet(ALLOWED_ATTR, svg$1);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.svgFilters === true) {
        addToSet(ALLOWED_TAGS, svgFilters);
        addToSet(ALLOWED_ATTR, svg$1);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.mathMl === true) {
        addToSet(ALLOWED_TAGS, mathMl);
        addToSet(ALLOWED_ATTR, mathMl$1);
        addToSet(ALLOWED_ATTR, xml);
      }
    }
    if (cfg.ADD_TAGS) {
      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
        ALLOWED_TAGS = clone(ALLOWED_TAGS);
      }
      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);
    }
    if (cfg.ADD_ATTR) {
      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
        ALLOWED_ATTR = clone(ALLOWED_ATTR);
      }
      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);
    }
    if (cfg.ADD_URI_SAFE_ATTR) {
      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);
    }
    if (cfg.FORBID_CONTENTS) {
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
        FORBID_CONTENTS = clone(FORBID_CONTENTS);
      }
      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS);
    }
    if (KEEP_CONTENT) {
      ALLOWED_TAGS["#text"] = true;
    }
    if (WHOLE_DOCUMENT) {
      addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
    }
    if (ALLOWED_TAGS.table) {
      addToSet(ALLOWED_TAGS, ["tbody"]);
      delete FORBID_TAGS.tbody;
    }
    if (freeze) {
      freeze(cfg);
    }
    CONFIG = cfg;
  };
  var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
  var HTML_INTEGRATION_POINTS = addToSet({}, ["foreignobject", "desc", "title", "annotation-xml"]);
  var ALL_SVG_TAGS = addToSet({}, svg);
  addToSet(ALL_SVG_TAGS, svgFilters);
  addToSet(ALL_SVG_TAGS, svgDisallowed);
  var ALL_MATHML_TAGS = addToSet({}, mathMl);
  addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
  var _checkValidNamespace = function _checkValidNamespace2(element) {
    var parent = getParentNode(element);
    if (!parent || !parent.tagName) {
      parent = {
        namespaceURI: HTML_NAMESPACE,
        tagName: "template"
      };
    }
    var tagName = stringToLowerCase(element.tagName);
    var parentTagName = stringToLowerCase(parent.tagName);
    if (element.namespaceURI === SVG_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "svg";
      }
      if (parent.namespaceURI === MATHML_NAMESPACE) {
        return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
      }
      return Boolean(ALL_SVG_TAGS[tagName]);
    }
    if (element.namespaceURI === MATHML_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "math";
      }
      if (parent.namespaceURI === SVG_NAMESPACE) {
        return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
      }
      return Boolean(ALL_MATHML_TAGS[tagName]);
    }
    if (element.namespaceURI === HTML_NAMESPACE) {
      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      var commonSvgAndHTMLElements = addToSet({}, ["title", "style", "font", "a", "script"]);
      return !ALL_MATHML_TAGS[tagName] && (commonSvgAndHTMLElements[tagName] || !ALL_SVG_TAGS[tagName]);
    }
    return false;
  };
  var _forceRemove = function _forceRemove2(node2) {
    arrayPush(DOMPurify.removed, { element: node2 });
    try {
      node2.parentNode.removeChild(node2);
    } catch (_2) {
      try {
        node2.outerHTML = emptyHTML;
      } catch (_3) {
        node2.remove();
      }
    }
  };
  var _removeAttribute = function _removeAttribute2(name, node2) {
    try {
      arrayPush(DOMPurify.removed, {
        attribute: node2.getAttributeNode(name),
        from: node2
      });
    } catch (_2) {
      arrayPush(DOMPurify.removed, {
        attribute: null,
        from: node2
      });
    }
    node2.removeAttribute(name);
    if (name === "is" && !ALLOWED_ATTR[name]) {
      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
        try {
          _forceRemove(node2);
        } catch (_2) {
        }
      } else {
        try {
          node2.setAttribute(name, "");
        } catch (_2) {
        }
      }
    }
  };
  var _initDocument = function _initDocument2(dirty) {
    var doc = void 0;
    var leadingWhitespace = void 0;
    if (FORCE_BODY) {
      dirty = "<remove></remove>" + dirty;
    } else {
      var matches = stringMatch(dirty, /^[\r\n\t ]+/);
      leadingWhitespace = matches && matches[0];
    }
    if (PARSER_MEDIA_TYPE === "application/xhtml+xml") {
      dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
    }
    var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    if (NAMESPACE === HTML_NAMESPACE) {
      try {
        doc = new DOMParser2().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
      } catch (_2) {
      }
    }
    if (!doc || !doc.documentElement) {
      doc = implementation.createDocument(NAMESPACE, "template", null);
      try {
        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? "" : dirtyPayload;
      } catch (_2) {
      }
    }
    var body = doc.body || doc.documentElement;
    if (dirty && leadingWhitespace) {
      body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
    }
    if (NAMESPACE === HTML_NAMESPACE) {
      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
    }
    return WHOLE_DOCUMENT ? doc.documentElement : body;
  };
  var _createIterator = function _createIterator2(root2) {
    return createNodeIterator.call(root2.ownerDocument || root2, root2, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);
  };
  var _isClobbered = function _isClobbered2(elm) {
    return elm instanceof HTMLFormElement && (typeof elm.nodeName !== "string" || typeof elm.textContent !== "string" || typeof elm.removeChild !== "function" || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== "function" || typeof elm.setAttribute !== "function" || typeof elm.namespaceURI !== "string" || typeof elm.insertBefore !== "function");
  };
  var _isNode = function _isNode2(object) {
    return (typeof Node2 === "undefined" ? "undefined" : _typeof$1(Node2)) === "object" ? object instanceof Node2 : object && (typeof object === "undefined" ? "undefined" : _typeof$1(object)) === "object" && typeof object.nodeType === "number" && typeof object.nodeName === "string";
  };
  var _executeHook = function _executeHook2(entryPoint, currentNode, data2) {
    if (!hooks[entryPoint]) {
      return;
    }
    arrayForEach(hooks[entryPoint], function(hook) {
      hook.call(DOMPurify, currentNode, data2, CONFIG);
    });
  };
  var _sanitizeElements = function _sanitizeElements2(currentNode) {
    var content2 = void 0;
    _executeHook("beforeSanitizeElements", currentNode, null);
    if (_isClobbered(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    if (stringMatch(currentNode.nodeName, /[\u0080-\uFFFF]/)) {
      _forceRemove(currentNode);
      return true;
    }
    var tagName = transformCaseFunc(currentNode.nodeName);
    _executeHook("uponSanitizeElement", currentNode, {
      tagName,
      allowedTags: ALLOWED_TAGS
    });
    if (!_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
      _forceRemove(currentNode);
      return true;
    }
    if (tagName === "select" && regExpTest(/<template/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
        var parentNode = getParentNode(currentNode) || currentNode.parentNode;
        var childNodes = getChildNodes(currentNode) || currentNode.childNodes;
        if (childNodes && parentNode) {
          var childCount = childNodes.length;
          for (var i2 = childCount - 1; i2 >= 0; --i2) {
            parentNode.insertBefore(cloneNode(childNodes[i2], true), getNextSibling(currentNode));
          }
        }
      }
      if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName))
          return false;
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))
          return false;
      }
      _forceRemove(currentNode);
      return true;
    }
    if (currentNode instanceof Element2 && !_checkValidNamespace(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    if ((tagName === "noscript" || tagName === "noembed") && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
      content2 = currentNode.textContent;
      content2 = stringReplace(content2, MUSTACHE_EXPR$$1, " ");
      content2 = stringReplace(content2, ERB_EXPR$$1, " ");
      if (currentNode.textContent !== content2) {
        arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });
        currentNode.textContent = content2;
      }
    }
    _executeHook("afterSanitizeElements", currentNode, null);
    return false;
  };
  var _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
    if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
      return false;
    }
    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$$1, lcName))
      ;
    else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName))
      ;
    else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
      if (_basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value)))
        ;
      else {
        return false;
      }
    } else if (URI_SAFE_ATTRIBUTES[lcName])
      ;
    else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, "")))
      ;
    else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf$2(value, "data:") === 0 && DATA_URI_TAGS[lcTag])
      ;
    else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, "")))
      ;
    else if (!value)
      ;
    else {
      return false;
    }
    return true;
  };
  var _basicCustomElementTest = function _basicCustomElementTest2(tagName) {
    return tagName.indexOf("-") > 0;
  };
  var _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
    var attr = void 0;
    var value = void 0;
    var lcName = void 0;
    var l2 = void 0;
    _executeHook("beforeSanitizeAttributes", currentNode, null);
    var attributes = currentNode.attributes;
    if (!attributes) {
      return;
    }
    var hookEvent = {
      attrName: "",
      attrValue: "",
      keepAttr: true,
      allowedAttributes: ALLOWED_ATTR
    };
    l2 = attributes.length;
    while (l2--) {
      attr = attributes[l2];
      var _attr = attr, name = _attr.name, namespaceURI = _attr.namespaceURI;
      value = stringTrim$1(attr.value);
      lcName = transformCaseFunc(name);
      hookEvent.attrName = lcName;
      hookEvent.attrValue = value;
      hookEvent.keepAttr = true;
      hookEvent.forceKeepAttr = void 0;
      _executeHook("uponSanitizeAttribute", currentNode, hookEvent);
      value = hookEvent.attrValue;
      if (hookEvent.forceKeepAttr) {
        continue;
      }
      _removeAttribute(name, currentNode);
      if (!hookEvent.keepAttr) {
        continue;
      }
      if (regExpTest(/\/>/i, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }
      if (SAFE_FOR_TEMPLATES) {
        value = stringReplace(value, MUSTACHE_EXPR$$1, " ");
        value = stringReplace(value, ERB_EXPR$$1, " ");
      }
      var lcTag = transformCaseFunc(currentNode.nodeName);
      if (!_isValidAttribute(lcTag, lcName, value)) {
        continue;
      }
      try {
        if (namespaceURI) {
          currentNode.setAttributeNS(namespaceURI, name, value);
        } else {
          currentNode.setAttribute(name, value);
        }
        arrayPop(DOMPurify.removed);
      } catch (_2) {
      }
    }
    _executeHook("afterSanitizeAttributes", currentNode, null);
  };
  var _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
    var shadowNode = void 0;
    var shadowIterator = _createIterator(fragment);
    _executeHook("beforeSanitizeShadowDOM", fragment, null);
    while (shadowNode = shadowIterator.nextNode()) {
      _executeHook("uponSanitizeShadowNode", shadowNode, null);
      if (_sanitizeElements(shadowNode)) {
        continue;
      }
      if (shadowNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM2(shadowNode.content);
      }
      _sanitizeAttributes(shadowNode);
    }
    _executeHook("afterSanitizeShadowDOM", fragment, null);
  };
  DOMPurify.sanitize = function(dirty, cfg) {
    var body = void 0;
    var importedNode = void 0;
    var currentNode = void 0;
    var oldNode = void 0;
    var returnNode = void 0;
    IS_EMPTY_INPUT = !dirty;
    if (IS_EMPTY_INPUT) {
      dirty = "<!-->";
    }
    if (typeof dirty !== "string" && !_isNode(dirty)) {
      if (typeof dirty.toString !== "function") {
        throw typeErrorCreate("toString is not a function");
      } else {
        dirty = dirty.toString();
        if (typeof dirty !== "string") {
          throw typeErrorCreate("dirty is not a string, aborting");
        }
      }
    }
    if (!DOMPurify.isSupported) {
      if (_typeof$1(window2.toStaticHTML) === "object" || typeof window2.toStaticHTML === "function") {
        if (typeof dirty === "string") {
          return window2.toStaticHTML(dirty);
        }
        if (_isNode(dirty)) {
          return window2.toStaticHTML(dirty.outerHTML);
        }
      }
      return dirty;
    }
    if (!SET_CONFIG) {
      _parseConfig(cfg);
    }
    DOMPurify.removed = [];
    if (typeof dirty === "string") {
      IN_PLACE = false;
    }
    if (IN_PLACE) {
      if (dirty.nodeName) {
        var tagName = transformCaseFunc(dirty.nodeName);
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
        }
      }
    } else if (dirty instanceof Node2) {
      body = _initDocument("<!---->");
      importedNode = body.ownerDocument.importNode(dirty, true);
      if (importedNode.nodeType === 1 && importedNode.nodeName === "BODY") {
        body = importedNode;
      } else if (importedNode.nodeName === "HTML") {
        body = importedNode;
      } else {
        body.appendChild(importedNode);
      }
    } else {
      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && dirty.indexOf("<") === -1) {
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
      }
      body = _initDocument(dirty);
      if (!body) {
        return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
      }
    }
    if (body && FORCE_BODY) {
      _forceRemove(body.firstChild);
    }
    var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
    while (currentNode = nodeIterator.nextNode()) {
      if (currentNode.nodeType === 3 && currentNode === oldNode) {
        continue;
      }
      if (_sanitizeElements(currentNode)) {
        continue;
      }
      if (currentNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(currentNode.content);
      }
      _sanitizeAttributes(currentNode);
      oldNode = currentNode;
    }
    oldNode = null;
    if (IN_PLACE) {
      return dirty;
    }
    if (RETURN_DOM) {
      if (RETURN_DOM_FRAGMENT) {
        returnNode = createDocumentFragment.call(body.ownerDocument);
        while (body.firstChild) {
          returnNode.appendChild(body.firstChild);
        }
      } else {
        returnNode = body;
      }
      if (ALLOWED_ATTR.shadowroot) {
        returnNode = importNode.call(originalDocument, returnNode, true);
      }
      return returnNode;
    }
    var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
    if (SAFE_FOR_TEMPLATES) {
      serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, " ");
      serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, " ");
    }
    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
  };
  DOMPurify.setConfig = function(cfg) {
    _parseConfig(cfg);
    SET_CONFIG = true;
  };
  DOMPurify.clearConfig = function() {
    CONFIG = null;
    SET_CONFIG = false;
  };
  DOMPurify.isValidAttribute = function(tag, attr, value) {
    if (!CONFIG) {
      _parseConfig({});
    }
    var lcTag = transformCaseFunc(tag);
    var lcName = transformCaseFunc(attr);
    return _isValidAttribute(lcTag, lcName, value);
  };
  DOMPurify.addHook = function(entryPoint, hookFunction) {
    if (typeof hookFunction !== "function") {
      return;
    }
    hooks[entryPoint] = hooks[entryPoint] || [];
    arrayPush(hooks[entryPoint], hookFunction);
  };
  DOMPurify.removeHook = function(entryPoint) {
    if (hooks[entryPoint]) {
      arrayPop(hooks[entryPoint]);
    }
  };
  DOMPurify.removeHooks = function(entryPoint) {
    if (hooks[entryPoint]) {
      hooks[entryPoint] = [];
    }
  };
  DOMPurify.removeAllHooks = function() {
    hooks = {};
  };
  return DOMPurify;
}
var purify = createDOMPurify();
var purify_es = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": purify
}, Symbol.toStringTag, { value: "Module" }));
var check = function(it2) {
  return it2 && it2.Math == Math && it2;
};
var global$I = check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || check(typeof self == "object" && self) || check(typeof commonjsGlobal == "object" && commonjsGlobal) || function() {
  return this;
}() || Function("return this")();
var objectGetOwnPropertyDescriptor = {};
var fails$k = function(exec2) {
  try {
    return !!exec2();
  } catch (error) {
    return true;
  }
};
var fails$j = fails$k;
var descriptors = !fails$j(function() {
  return Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1] != 7;
});
var fails$i = fails$k;
var functionBindNative = !fails$i(function() {
  var test2 = function() {
  }.bind();
  return typeof test2 != "function" || test2.hasOwnProperty("prototype");
});
var NATIVE_BIND$3 = functionBindNative;
var call$f = Function.prototype.call;
var functionCall = NATIVE_BIND$3 ? call$f.bind(call$f) : function() {
  return call$f.apply(call$f, arguments);
};
var objectPropertyIsEnumerable = {};
var $propertyIsEnumerable = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor$4 = Object.getOwnPropertyDescriptor;
var NASHORN_BUG = getOwnPropertyDescriptor$4 && !$propertyIsEnumerable.call({ 1: 2 }, 1);
objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V2) {
  var descriptor = getOwnPropertyDescriptor$4(this, V2);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;
var createPropertyDescriptor$4 = function(bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value
  };
};
var NATIVE_BIND$2 = functionBindNative;
var FunctionPrototype$2 = Function.prototype;
var bind$5 = FunctionPrototype$2.bind;
var call$e = FunctionPrototype$2.call;
var uncurryThis$q = NATIVE_BIND$2 && bind$5.bind(call$e, call$e);
var functionUncurryThis = NATIVE_BIND$2 ? function(fn) {
  return fn && uncurryThis$q(fn);
} : function(fn) {
  return fn && function() {
    return call$e.apply(fn, arguments);
  };
};
var uncurryThis$p = functionUncurryThis;
var toString$b = uncurryThis$p({}.toString);
var stringSlice$6 = uncurryThis$p("".slice);
var classofRaw$1 = function(it2) {
  return stringSlice$6(toString$b(it2), 8, -1);
};
var global$H = global$I;
var uncurryThis$o = functionUncurryThis;
var fails$h = fails$k;
var classof$8 = classofRaw$1;
var Object$5 = global$H.Object;
var split = uncurryThis$o("".split);
var indexedObject = fails$h(function() {
  return !Object$5("z").propertyIsEnumerable(0);
}) ? function(it2) {
  return classof$8(it2) == "String" ? split(it2, "") : Object$5(it2);
} : Object$5;
var global$G = global$I;
var TypeError$g = global$G.TypeError;
var requireObjectCoercible$a = function(it2) {
  if (it2 == void 0)
    throw TypeError$g("Can't call method on " + it2);
  return it2;
};
var IndexedObject$1 = indexedObject;
var requireObjectCoercible$9 = requireObjectCoercible$a;
var toIndexedObject$5 = function(it2) {
  return IndexedObject$1(requireObjectCoercible$9(it2));
};
var isCallable$j = function(argument) {
  return typeof argument == "function";
};
var isCallable$i = isCallable$j;
var isObject$8 = function(it2) {
  return typeof it2 == "object" ? it2 !== null : isCallable$i(it2);
};
var global$F = global$I;
var isCallable$h = isCallable$j;
var aFunction = function(argument) {
  return isCallable$h(argument) ? argument : void 0;
};
var getBuiltIn$7 = function(namespace, method) {
  return arguments.length < 2 ? aFunction(global$F[namespace]) : global$F[namespace] && global$F[namespace][method];
};
var uncurryThis$n = functionUncurryThis;
var objectIsPrototypeOf = uncurryThis$n({}.isPrototypeOf);
var getBuiltIn$6 = getBuiltIn$7;
var engineUserAgent = getBuiltIn$6("navigator", "userAgent") || "";
var global$E = global$I;
var userAgent$3 = engineUserAgent;
var process$4 = global$E.process;
var Deno = global$E.Deno;
var versions = process$4 && process$4.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;
if (v8) {
  match = v8.split(".");
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}
if (!version && userAgent$3) {
  match = userAgent$3.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent$3.match(/Chrome\/(\d+)/);
    if (match)
      version = +match[1];
  }
}
var engineV8Version = version;
var V8_VERSION$1 = engineV8Version;
var fails$g = fails$k;
var nativeSymbol = !!Object.getOwnPropertySymbols && !fails$g(function() {
  var symbol = Symbol();
  return !String(symbol) || !(Object(symbol) instanceof Symbol) || !Symbol.sham && V8_VERSION$1 && V8_VERSION$1 < 41;
});
var NATIVE_SYMBOL$1 = nativeSymbol;
var useSymbolAsUid = NATIVE_SYMBOL$1 && !Symbol.sham && typeof Symbol.iterator == "symbol";
var global$D = global$I;
var getBuiltIn$5 = getBuiltIn$7;
var isCallable$g = isCallable$j;
var isPrototypeOf$3 = objectIsPrototypeOf;
var USE_SYMBOL_AS_UID$1 = useSymbolAsUid;
var Object$4 = global$D.Object;
var isSymbol$2 = USE_SYMBOL_AS_UID$1 ? function(it2) {
  return typeof it2 == "symbol";
} : function(it2) {
  var $Symbol = getBuiltIn$5("Symbol");
  return isCallable$g($Symbol) && isPrototypeOf$3($Symbol.prototype, Object$4(it2));
};
var global$C = global$I;
var String$5 = global$C.String;
var tryToString$4 = function(argument) {
  try {
    return String$5(argument);
  } catch (error) {
    return "Object";
  }
};
var global$B = global$I;
var isCallable$f = isCallable$j;
var tryToString$3 = tryToString$4;
var TypeError$f = global$B.TypeError;
var aCallable$6 = function(argument) {
  if (isCallable$f(argument))
    return argument;
  throw TypeError$f(tryToString$3(argument) + " is not a function");
};
var aCallable$5 = aCallable$6;
var getMethod$6 = function(V2, P2) {
  var func = V2[P2];
  return func == null ? void 0 : aCallable$5(func);
};
var global$A = global$I;
var call$d = functionCall;
var isCallable$e = isCallable$j;
var isObject$7 = isObject$8;
var TypeError$e = global$A.TypeError;
var ordinaryToPrimitive$1 = function(input, pref) {
  var fn, val;
  if (pref === "string" && isCallable$e(fn = input.toString) && !isObject$7(val = call$d(fn, input)))
    return val;
  if (isCallable$e(fn = input.valueOf) && !isObject$7(val = call$d(fn, input)))
    return val;
  if (pref !== "string" && isCallable$e(fn = input.toString) && !isObject$7(val = call$d(fn, input)))
    return val;
  throw TypeError$e("Can't convert object to primitive value");
};
var shared$4 = { exports: {} };
var global$z = global$I;
var defineProperty$2 = Object.defineProperty;
var setGlobal$3 = function(key, value) {
  try {
    defineProperty$2(global$z, key, { value, configurable: true, writable: true });
  } catch (error) {
    global$z[key] = value;
  }
  return value;
};
var global$y = global$I;
var setGlobal$2 = setGlobal$3;
var SHARED = "__core-js_shared__";
var store$3 = global$y[SHARED] || setGlobal$2(SHARED, {});
var sharedStore = store$3;
var store$2 = sharedStore;
(shared$4.exports = function(key, value) {
  return store$2[key] || (store$2[key] = value !== void 0 ? value : {});
})("versions", []).push({
  version: "3.20.3",
  mode: "global",
  copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)",
  license: "https://github.com/zloirock/core-js/blob/v3.20.3/LICENSE",
  source: "https://github.com/zloirock/core-js"
});
var global$x = global$I;
var requireObjectCoercible$8 = requireObjectCoercible$a;
var Object$3 = global$x.Object;
var toObject$4 = function(argument) {
  return Object$3(requireObjectCoercible$8(argument));
};
var uncurryThis$m = functionUncurryThis;
var toObject$3 = toObject$4;
var hasOwnProperty = uncurryThis$m({}.hasOwnProperty);
var hasOwnProperty_1 = Object.hasOwn || function hasOwn(it2, key) {
  return hasOwnProperty(toObject$3(it2), key);
};
var uncurryThis$l = functionUncurryThis;
var id$1 = 0;
var postfix = Math.random();
var toString$a = uncurryThis$l(1 .toString);
var uid$2 = function(key) {
  return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString$a(++id$1 + postfix, 36);
};
var global$w = global$I;
var shared$3 = shared$4.exports;
var hasOwn$9 = hasOwnProperty_1;
var uid$1 = uid$2;
var NATIVE_SYMBOL = nativeSymbol;
var USE_SYMBOL_AS_UID = useSymbolAsUid;
var WellKnownSymbolsStore = shared$3("wks");
var Symbol$1 = global$w.Symbol;
var symbolFor = Symbol$1 && Symbol$1["for"];
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$1;
var wellKnownSymbol$i = function(name) {
  if (!hasOwn$9(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == "string")) {
    var description = "Symbol." + name;
    if (NATIVE_SYMBOL && hasOwn$9(Symbol$1, name)) {
      WellKnownSymbolsStore[name] = Symbol$1[name];
    } else if (USE_SYMBOL_AS_UID && symbolFor) {
      WellKnownSymbolsStore[name] = symbolFor(description);
    } else {
      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);
    }
  }
  return WellKnownSymbolsStore[name];
};
var global$v = global$I;
var call$c = functionCall;
var isObject$6 = isObject$8;
var isSymbol$1 = isSymbol$2;
var getMethod$5 = getMethod$6;
var ordinaryToPrimitive = ordinaryToPrimitive$1;
var wellKnownSymbol$h = wellKnownSymbol$i;
var TypeError$d = global$v.TypeError;
var TO_PRIMITIVE = wellKnownSymbol$h("toPrimitive");
var toPrimitive$1 = function(input, pref) {
  if (!isObject$6(input) || isSymbol$1(input))
    return input;
  var exoticToPrim = getMethod$5(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === void 0)
      pref = "default";
    result = call$c(exoticToPrim, input, pref);
    if (!isObject$6(result) || isSymbol$1(result))
      return result;
    throw TypeError$d("Can't convert object to primitive value");
  }
  if (pref === void 0)
    pref = "number";
  return ordinaryToPrimitive(input, pref);
};
var toPrimitive = toPrimitive$1;
var isSymbol = isSymbol$2;
var toPropertyKey$3 = function(argument) {
  var key = toPrimitive(argument, "string");
  return isSymbol(key) ? key : key + "";
};
var global$u = global$I;
var isObject$5 = isObject$8;
var document$3 = global$u.document;
var EXISTS$1 = isObject$5(document$3) && isObject$5(document$3.createElement);
var documentCreateElement$2 = function(it2) {
  return EXISTS$1 ? document$3.createElement(it2) : {};
};
var DESCRIPTORS$8 = descriptors;
var fails$f = fails$k;
var createElement$1 = documentCreateElement$2;
var ie8DomDefine = !DESCRIPTORS$8 && !fails$f(function() {
  return Object.defineProperty(createElement$1("div"), "a", {
    get: function() {
      return 7;
    }
  }).a != 7;
});
var DESCRIPTORS$7 = descriptors;
var call$b = functionCall;
var propertyIsEnumerableModule = objectPropertyIsEnumerable;
var createPropertyDescriptor$3 = createPropertyDescriptor$4;
var toIndexedObject$4 = toIndexedObject$5;
var toPropertyKey$2 = toPropertyKey$3;
var hasOwn$8 = hasOwnProperty_1;
var IE8_DOM_DEFINE$1 = ie8DomDefine;
var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
objectGetOwnPropertyDescriptor.f = DESCRIPTORS$7 ? $getOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O2, P2) {
  O2 = toIndexedObject$4(O2);
  P2 = toPropertyKey$2(P2);
  if (IE8_DOM_DEFINE$1)
    try {
      return $getOwnPropertyDescriptor$1(O2, P2);
    } catch (error) {
    }
  if (hasOwn$8(O2, P2))
    return createPropertyDescriptor$3(!call$b(propertyIsEnumerableModule.f, O2, P2), O2[P2]);
};
var objectDefineProperty = {};
var DESCRIPTORS$6 = descriptors;
var fails$e = fails$k;
var v8PrototypeDefineBug = DESCRIPTORS$6 && fails$e(function() {
  return Object.defineProperty(function() {
  }, "prototype", {
    value: 42,
    writable: false
  }).prototype != 42;
});
var global$t = global$I;
var isObject$4 = isObject$8;
var String$4 = global$t.String;
var TypeError$c = global$t.TypeError;
var anObject$g = function(argument) {
  if (isObject$4(argument))
    return argument;
  throw TypeError$c(String$4(argument) + " is not an object");
};
var global$s = global$I;
var DESCRIPTORS$5 = descriptors;
var IE8_DOM_DEFINE = ie8DomDefine;
var V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;
var anObject$f = anObject$g;
var toPropertyKey$1 = toPropertyKey$3;
var TypeError$b = global$s.TypeError;
var $defineProperty = Object.defineProperty;
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = "enumerable";
var CONFIGURABLE$1 = "configurable";
var WRITABLE = "writable";
objectDefineProperty.f = DESCRIPTORS$5 ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O2, P2, Attributes2) {
  anObject$f(O2);
  P2 = toPropertyKey$1(P2);
  anObject$f(Attributes2);
  if (typeof O2 === "function" && P2 === "prototype" && "value" in Attributes2 && WRITABLE in Attributes2 && !Attributes2[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O2, P2);
    if (current && current[WRITABLE]) {
      O2[P2] = Attributes2.value;
      Attributes2 = {
        configurable: CONFIGURABLE$1 in Attributes2 ? Attributes2[CONFIGURABLE$1] : current[CONFIGURABLE$1],
        enumerable: ENUMERABLE in Attributes2 ? Attributes2[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  }
  return $defineProperty(O2, P2, Attributes2);
} : $defineProperty : function defineProperty2(O2, P2, Attributes2) {
  anObject$f(O2);
  P2 = toPropertyKey$1(P2);
  anObject$f(Attributes2);
  if (IE8_DOM_DEFINE)
    try {
      return $defineProperty(O2, P2, Attributes2);
    } catch (error) {
    }
  if ("get" in Attributes2 || "set" in Attributes2)
    throw TypeError$b("Accessors not supported");
  if ("value" in Attributes2)
    O2[P2] = Attributes2.value;
  return O2;
};
var DESCRIPTORS$4 = descriptors;
var definePropertyModule$5 = objectDefineProperty;
var createPropertyDescriptor$2 = createPropertyDescriptor$4;
var createNonEnumerableProperty$6 = DESCRIPTORS$4 ? function(object, key, value) {
  return definePropertyModule$5.f(object, key, createPropertyDescriptor$2(1, value));
} : function(object, key, value) {
  object[key] = value;
  return object;
};
var redefine$7 = { exports: {} };
var uncurryThis$k = functionUncurryThis;
var isCallable$d = isCallable$j;
var store$1 = sharedStore;
var functionToString = uncurryThis$k(Function.toString);
if (!isCallable$d(store$1.inspectSource)) {
  store$1.inspectSource = function(it2) {
    return functionToString(it2);
  };
}
var inspectSource$4 = store$1.inspectSource;
var global$r = global$I;
var isCallable$c = isCallable$j;
var inspectSource$3 = inspectSource$4;
var WeakMap$2 = global$r.WeakMap;
var nativeWeakMap = isCallable$c(WeakMap$2) && /native code/.test(inspectSource$3(WeakMap$2));
var shared$2 = shared$4.exports;
var uid = uid$2;
var keys = shared$2("keys");
var sharedKey$3 = function(key) {
  return keys[key] || (keys[key] = uid(key));
};
var hiddenKeys$4 = {};
var NATIVE_WEAK_MAP = nativeWeakMap;
var global$q = global$I;
var uncurryThis$j = functionUncurryThis;
var isObject$3 = isObject$8;
var createNonEnumerableProperty$5 = createNonEnumerableProperty$6;
var hasOwn$7 = hasOwnProperty_1;
var shared$1 = sharedStore;
var sharedKey$2 = sharedKey$3;
var hiddenKeys$3 = hiddenKeys$4;
var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
var TypeError$a = global$q.TypeError;
var WeakMap$1 = global$q.WeakMap;
var set$1, get, has;
var enforce = function(it2) {
  return has(it2) ? get(it2) : set$1(it2, {});
};
var getterFor = function(TYPE2) {
  return function(it2) {
    var state;
    if (!isObject$3(it2) || (state = get(it2)).type !== TYPE2) {
      throw TypeError$a("Incompatible receiver, " + TYPE2 + " required");
    }
    return state;
  };
};
if (NATIVE_WEAK_MAP || shared$1.state) {
  var store = shared$1.state || (shared$1.state = new WeakMap$1());
  var wmget = uncurryThis$j(store.get);
  var wmhas = uncurryThis$j(store.has);
  var wmset = uncurryThis$j(store.set);
  set$1 = function(it2, metadata) {
    if (wmhas(store, it2))
      throw new TypeError$a(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it2;
    wmset(store, it2, metadata);
    return metadata;
  };
  get = function(it2) {
    return wmget(store, it2) || {};
  };
  has = function(it2) {
    return wmhas(store, it2);
  };
} else {
  var STATE = sharedKey$2("state");
  hiddenKeys$3[STATE] = true;
  set$1 = function(it2, metadata) {
    if (hasOwn$7(it2, STATE))
      throw new TypeError$a(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it2;
    createNonEnumerableProperty$5(it2, STATE, metadata);
    return metadata;
  };
  get = function(it2) {
    return hasOwn$7(it2, STATE) ? it2[STATE] : {};
  };
  has = function(it2) {
    return hasOwn$7(it2, STATE);
  };
}
var internalState = {
  set: set$1,
  get,
  has,
  enforce,
  getterFor
};
var DESCRIPTORS$3 = descriptors;
var hasOwn$6 = hasOwnProperty_1;
var FunctionPrototype$1 = Function.prototype;
var getDescriptor = DESCRIPTORS$3 && Object.getOwnPropertyDescriptor;
var EXISTS = hasOwn$6(FunctionPrototype$1, "name");
var PROPER = EXISTS && function something() {
}.name === "something";
var CONFIGURABLE = EXISTS && (!DESCRIPTORS$3 || DESCRIPTORS$3 && getDescriptor(FunctionPrototype$1, "name").configurable);
var functionName = {
  EXISTS,
  PROPER,
  CONFIGURABLE
};
var global$p = global$I;
var isCallable$b = isCallable$j;
var hasOwn$5 = hasOwnProperty_1;
var createNonEnumerableProperty$4 = createNonEnumerableProperty$6;
var setGlobal$1 = setGlobal$3;
var inspectSource$2 = inspectSource$4;
var InternalStateModule$2 = internalState;
var CONFIGURABLE_FUNCTION_NAME$1 = functionName.CONFIGURABLE;
var getInternalState$3 = InternalStateModule$2.get;
var enforceInternalState = InternalStateModule$2.enforce;
var TEMPLATE = String(String).split("String");
(redefine$7.exports = function(O2, key, value, options) {
  var unsafe = options ? !!options.unsafe : false;
  var simple = options ? !!options.enumerable : false;
  var noTargetGet = options ? !!options.noTargetGet : false;
  var name = options && options.name !== void 0 ? options.name : key;
  var state;
  if (isCallable$b(value)) {
    if (String(name).slice(0, 7) === "Symbol(") {
      name = "[" + String(name).replace(/^Symbol\(([^)]*)\)/, "$1") + "]";
    }
    if (!hasOwn$5(value, "name") || CONFIGURABLE_FUNCTION_NAME$1 && value.name !== name) {
      createNonEnumerableProperty$4(value, "name", name);
    }
    state = enforceInternalState(value);
    if (!state.source) {
      state.source = TEMPLATE.join(typeof name == "string" ? name : "");
    }
  }
  if (O2 === global$p) {
    if (simple)
      O2[key] = value;
    else
      setGlobal$1(key, value);
    return;
  } else if (!unsafe) {
    delete O2[key];
  } else if (!noTargetGet && O2[key]) {
    simple = true;
  }
  if (simple)
    O2[key] = value;
  else
    createNonEnumerableProperty$4(O2, key, value);
})(Function.prototype, "toString", function toString() {
  return isCallable$b(this) && getInternalState$3(this).source || inspectSource$2(this);
});
var objectGetOwnPropertyNames = {};
var ceil = Math.ceil;
var floor$1 = Math.floor;
var toIntegerOrInfinity$4 = function(argument) {
  var number = +argument;
  return number !== number || number === 0 ? 0 : (number > 0 ? floor$1 : ceil)(number);
};
var toIntegerOrInfinity$3 = toIntegerOrInfinity$4;
var max$2 = Math.max;
var min$5 = Math.min;
var toAbsoluteIndex$2 = function(index2, length) {
  var integer = toIntegerOrInfinity$3(index2);
  return integer < 0 ? max$2(integer + length, 0) : min$5(integer, length);
};
var toIntegerOrInfinity$2 = toIntegerOrInfinity$4;
var min$4 = Math.min;
var toLength$6 = function(argument) {
  return argument > 0 ? min$4(toIntegerOrInfinity$2(argument), 9007199254740991) : 0;
};
var toLength$5 = toLength$6;
var lengthOfArrayLike$4 = function(obj) {
  return toLength$5(obj.length);
};
var toIndexedObject$3 = toIndexedObject$5;
var toAbsoluteIndex$1 = toAbsoluteIndex$2;
var lengthOfArrayLike$3 = lengthOfArrayLike$4;
var createMethod$3 = function(IS_INCLUDES) {
  return function($this, el, fromIndex) {
    var O2 = toIndexedObject$3($this);
    var length = lengthOfArrayLike$3(O2);
    var index2 = toAbsoluteIndex$1(fromIndex, length);
    var value;
    if (IS_INCLUDES && el != el)
      while (length > index2) {
        value = O2[index2++];
        if (value != value)
          return true;
      }
    else
      for (; length > index2; index2++) {
        if ((IS_INCLUDES || index2 in O2) && O2[index2] === el)
          return IS_INCLUDES || index2 || 0;
      }
    return !IS_INCLUDES && -1;
  };
};
var arrayIncludes = {
  includes: createMethod$3(true),
  indexOf: createMethod$3(false)
};
var uncurryThis$i = functionUncurryThis;
var hasOwn$4 = hasOwnProperty_1;
var toIndexedObject$2 = toIndexedObject$5;
var indexOf$1 = arrayIncludes.indexOf;
var hiddenKeys$2 = hiddenKeys$4;
var push$2 = uncurryThis$i([].push);
var objectKeysInternal = function(object, names2) {
  var O2 = toIndexedObject$2(object);
  var i2 = 0;
  var result = [];
  var key;
  for (key in O2)
    !hasOwn$4(hiddenKeys$2, key) && hasOwn$4(O2, key) && push$2(result, key);
  while (names2.length > i2)
    if (hasOwn$4(O2, key = names2[i2++])) {
      ~indexOf$1(result, key) || push$2(result, key);
    }
  return result;
};
var enumBugKeys$3 = [
  "constructor",
  "hasOwnProperty",
  "isPrototypeOf",
  "propertyIsEnumerable",
  "toLocaleString",
  "toString",
  "valueOf"
];
var internalObjectKeys$1 = objectKeysInternal;
var enumBugKeys$2 = enumBugKeys$3;
var hiddenKeys$1 = enumBugKeys$2.concat("length", "prototype");
objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O2) {
  return internalObjectKeys$1(O2, hiddenKeys$1);
};
var objectGetOwnPropertySymbols = {};
objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;
var getBuiltIn$4 = getBuiltIn$7;
var uncurryThis$h = functionUncurryThis;
var getOwnPropertyNamesModule = objectGetOwnPropertyNames;
var getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;
var anObject$e = anObject$g;
var concat$1 = uncurryThis$h([].concat);
var ownKeys$4 = getBuiltIn$4("Reflect", "ownKeys") || function ownKeys(it2) {
  var keys3 = getOwnPropertyNamesModule.f(anObject$e(it2));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? concat$1(keys3, getOwnPropertySymbols(it2)) : keys3;
};
var hasOwn$3 = hasOwnProperty_1;
var ownKeys$3 = ownKeys$4;
var getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;
var definePropertyModule$4 = objectDefineProperty;
var copyConstructorProperties$1 = function(target, source, exceptions) {
  var keys3 = ownKeys$3(source);
  var defineProperty4 = definePropertyModule$4.f;
  var getOwnPropertyDescriptor3 = getOwnPropertyDescriptorModule.f;
  for (var i2 = 0; i2 < keys3.length; i2++) {
    var key = keys3[i2];
    if (!hasOwn$3(target, key) && !(exceptions && hasOwn$3(exceptions, key))) {
      defineProperty4(target, key, getOwnPropertyDescriptor3(source, key));
    }
  }
};
var fails$d = fails$k;
var isCallable$a = isCallable$j;
var replacement = /#|\.prototype\./;
var isForced$2 = function(feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true : value == NATIVE ? false : isCallable$a(detection) ? fails$d(detection) : !!detection;
};
var normalize = isForced$2.normalize = function(string) {
  return String(string).replace(replacement, ".").toLowerCase();
};
var data = isForced$2.data = {};
var NATIVE = isForced$2.NATIVE = "N";
var POLYFILL = isForced$2.POLYFILL = "P";
var isForced_1 = isForced$2;
var global$o = global$I;
var getOwnPropertyDescriptor$3 = objectGetOwnPropertyDescriptor.f;
var createNonEnumerableProperty$3 = createNonEnumerableProperty$6;
var redefine$6 = redefine$7.exports;
var setGlobal = setGlobal$3;
var copyConstructorProperties = copyConstructorProperties$1;
var isForced$1 = isForced_1;
var _export = function(options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED2, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global$o;
  } else if (STATIC) {
    target = global$o[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global$o[TARGET] || {}).prototype;
  }
  if (target)
    for (key in source) {
      sourceProperty = source[key];
      if (options.noTargetGet) {
        descriptor = getOwnPropertyDescriptor$3(target, key);
        targetProperty = descriptor && descriptor.value;
      } else
        targetProperty = target[key];
      FORCED2 = isForced$1(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
      if (!FORCED2 && targetProperty !== void 0) {
        if (typeof sourceProperty == typeof targetProperty)
          continue;
        copyConstructorProperties(sourceProperty, targetProperty);
      }
      if (options.sham || targetProperty && targetProperty.sham) {
        createNonEnumerableProperty$3(sourceProperty, "sham", true);
      }
      redefine$6(target, key, sourceProperty, options);
    }
};
var global$n = global$I;
var nativePromiseConstructor = global$n.Promise;
var redefine$5 = redefine$7.exports;
var redefineAll$1 = function(target, src, options) {
  for (var key in src)
    redefine$5(target, key, src[key], options);
  return target;
};
var global$m = global$I;
var isCallable$9 = isCallable$j;
var String$3 = global$m.String;
var TypeError$9 = global$m.TypeError;
var aPossiblePrototype$1 = function(argument) {
  if (typeof argument == "object" || isCallable$9(argument))
    return argument;
  throw TypeError$9("Can't set " + String$3(argument) + " as a prototype");
};
var uncurryThis$g = functionUncurryThis;
var anObject$d = anObject$g;
var aPossiblePrototype = aPossiblePrototype$1;
var objectSetPrototypeOf = Object.setPrototypeOf || ("__proto__" in {} ? function() {
  var CORRECT_SETTER = false;
  var test2 = {};
  var setter;
  try {
    setter = uncurryThis$g(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set);
    setter(test2, []);
    CORRECT_SETTER = test2 instanceof Array;
  } catch (error) {
  }
  return function setPrototypeOf2(O2, proto) {
    anObject$d(O2);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER)
      setter(O2, proto);
    else
      O2.__proto__ = proto;
    return O2;
  };
}() : void 0);
var defineProperty$1 = objectDefineProperty.f;
var hasOwn$2 = hasOwnProperty_1;
var wellKnownSymbol$g = wellKnownSymbol$i;
var TO_STRING_TAG$3 = wellKnownSymbol$g("toStringTag");
var setToStringTag$3 = function(target, TAG, STATIC) {
  if (target && !STATIC)
    target = target.prototype;
  if (target && !hasOwn$2(target, TO_STRING_TAG$3)) {
    defineProperty$1(target, TO_STRING_TAG$3, { configurable: true, value: TAG });
  }
};
var getBuiltIn$3 = getBuiltIn$7;
var definePropertyModule$3 = objectDefineProperty;
var wellKnownSymbol$f = wellKnownSymbol$i;
var DESCRIPTORS$2 = descriptors;
var SPECIES$3 = wellKnownSymbol$f("species");
var setSpecies$1 = function(CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn$3(CONSTRUCTOR_NAME);
  var defineProperty4 = definePropertyModule$3.f;
  if (DESCRIPTORS$2 && Constructor && !Constructor[SPECIES$3]) {
    defineProperty4(Constructor, SPECIES$3, {
      configurable: true,
      get: function() {
        return this;
      }
    });
  }
};
var global$l = global$I;
var isPrototypeOf$2 = objectIsPrototypeOf;
var TypeError$8 = global$l.TypeError;
var anInstance$1 = function(it2, Prototype) {
  if (isPrototypeOf$2(Prototype, it2))
    return it2;
  throw TypeError$8("Incorrect invocation");
};
var uncurryThis$f = functionUncurryThis;
var aCallable$4 = aCallable$6;
var NATIVE_BIND$1 = functionBindNative;
var bind$4 = uncurryThis$f(uncurryThis$f.bind);
var functionBindContext = function(fn, that) {
  aCallable$4(fn);
  return that === void 0 ? fn : NATIVE_BIND$1 ? bind$4(fn, that) : function() {
    return fn.apply(that, arguments);
  };
};
var iterators = {};
var wellKnownSymbol$e = wellKnownSymbol$i;
var Iterators$4 = iterators;
var ITERATOR$5 = wellKnownSymbol$e("iterator");
var ArrayPrototype$1 = Array.prototype;
var isArrayIteratorMethod$1 = function(it2) {
  return it2 !== void 0 && (Iterators$4.Array === it2 || ArrayPrototype$1[ITERATOR$5] === it2);
};
var wellKnownSymbol$d = wellKnownSymbol$i;
var TO_STRING_TAG$2 = wellKnownSymbol$d("toStringTag");
var test$1 = {};
test$1[TO_STRING_TAG$2] = "z";
var toStringTagSupport = String(test$1) === "[object z]";
var global$k = global$I;
var TO_STRING_TAG_SUPPORT = toStringTagSupport;
var isCallable$8 = isCallable$j;
var classofRaw = classofRaw$1;
var wellKnownSymbol$c = wellKnownSymbol$i;
var TO_STRING_TAG$1 = wellKnownSymbol$c("toStringTag");
var Object$2 = global$k.Object;
var CORRECT_ARGUMENTS = classofRaw(function() {
  return arguments;
}()) == "Arguments";
var tryGet = function(it2, key) {
  try {
    return it2[key];
  } catch (error) {
  }
};
var classof$7 = TO_STRING_TAG_SUPPORT ? classofRaw : function(it2) {
  var O2, tag, result;
  return it2 === void 0 ? "Undefined" : it2 === null ? "Null" : typeof (tag = tryGet(O2 = Object$2(it2), TO_STRING_TAG$1)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O2) : (result = classofRaw(O2)) == "Object" && isCallable$8(O2.callee) ? "Arguments" : result;
};
var classof$6 = classof$7;
var getMethod$4 = getMethod$6;
var Iterators$3 = iterators;
var wellKnownSymbol$b = wellKnownSymbol$i;
var ITERATOR$4 = wellKnownSymbol$b("iterator");
var getIteratorMethod$2 = function(it2) {
  if (it2 != void 0)
    return getMethod$4(it2, ITERATOR$4) || getMethod$4(it2, "@@iterator") || Iterators$3[classof$6(it2)];
};
var global$j = global$I;
var call$a = functionCall;
var aCallable$3 = aCallable$6;
var anObject$c = anObject$g;
var tryToString$2 = tryToString$4;
var getIteratorMethod$1 = getIteratorMethod$2;
var TypeError$7 = global$j.TypeError;
var getIterator$1 = function(argument, usingIterator) {
  var iteratorMethod = arguments.length < 2 ? getIteratorMethod$1(argument) : usingIterator;
  if (aCallable$3(iteratorMethod))
    return anObject$c(call$a(iteratorMethod, argument));
  throw TypeError$7(tryToString$2(argument) + " is not iterable");
};
var call$9 = functionCall;
var anObject$b = anObject$g;
var getMethod$3 = getMethod$6;
var iteratorClose$1 = function(iterator, kind, value) {
  var innerResult, innerError;
  anObject$b(iterator);
  try {
    innerResult = getMethod$3(iterator, "return");
    if (!innerResult) {
      if (kind === "throw")
        throw value;
      return value;
    }
    innerResult = call$9(innerResult, iterator);
  } catch (error) {
    innerError = true;
    innerResult = error;
  }
  if (kind === "throw")
    throw value;
  if (innerError)
    throw innerResult;
  anObject$b(innerResult);
  return value;
};
var global$i = global$I;
var bind$3 = functionBindContext;
var call$8 = functionCall;
var anObject$a = anObject$g;
var tryToString$1 = tryToString$4;
var isArrayIteratorMethod = isArrayIteratorMethod$1;
var lengthOfArrayLike$2 = lengthOfArrayLike$4;
var isPrototypeOf$1 = objectIsPrototypeOf;
var getIterator = getIterator$1;
var getIteratorMethod = getIteratorMethod$2;
var iteratorClose = iteratorClose$1;
var TypeError$6 = global$i.TypeError;
var Result = function(stopped, result) {
  this.stopped = stopped;
  this.result = result;
};
var ResultPrototype = Result.prototype;
var iterate$1 = function(iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind$3(unboundFunction, that);
  var iterator, iterFn, index2, length, result, next3, step;
  var stop = function(condition) {
    if (iterator)
      iteratorClose(iterator, "normal", condition);
    return new Result(true, condition);
  };
  var callFn = function(value) {
    if (AS_ENTRIES) {
      anObject$a(value);
      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
    }
    return INTERRUPTED ? fn(value, stop) : fn(value);
  };
  if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (!iterFn)
      throw TypeError$6(tryToString$1(iterable) + " is not iterable");
    if (isArrayIteratorMethod(iterFn)) {
      for (index2 = 0, length = lengthOfArrayLike$2(iterable); length > index2; index2++) {
        result = callFn(iterable[index2]);
        if (result && isPrototypeOf$1(ResultPrototype, result))
          return result;
      }
      return new Result(false);
    }
    iterator = getIterator(iterable, iterFn);
  }
  next3 = iterator.next;
  while (!(step = call$8(next3, iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error) {
      iteratorClose(iterator, "throw", error);
    }
    if (typeof result == "object" && result && isPrototypeOf$1(ResultPrototype, result))
      return result;
  }
  return new Result(false);
};
var wellKnownSymbol$a = wellKnownSymbol$i;
var ITERATOR$3 = wellKnownSymbol$a("iterator");
var SAFE_CLOSING = false;
try {
  var called = 0;
  var iteratorWithReturn = {
    next: function() {
      return { done: !!called++ };
    },
    "return": function() {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR$3] = function() {
    return this;
  };
  Array.from(iteratorWithReturn, function() {
    throw 2;
  });
} catch (error) {
}
var checkCorrectnessOfIteration$1 = function(exec2, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING)
    return false;
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR$3] = function() {
      return {
        next: function() {
          return { done: ITERATION_SUPPORT = true };
        }
      };
    };
    exec2(object);
  } catch (error) {
  }
  return ITERATION_SUPPORT;
};
var uncurryThis$e = functionUncurryThis;
var fails$c = fails$k;
var isCallable$7 = isCallable$j;
var classof$5 = classof$7;
var getBuiltIn$2 = getBuiltIn$7;
var inspectSource$1 = inspectSource$4;
var noop$1 = function() {
};
var empty = [];
var construct = getBuiltIn$2("Reflect", "construct");
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec$2 = uncurryThis$e(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.exec(noop$1);
var isConstructorModern = function isConstructor(argument) {
  if (!isCallable$7(argument))
    return false;
  try {
    construct(noop$1, empty, argument);
    return true;
  } catch (error) {
    return false;
  }
};
var isConstructorLegacy = function isConstructor2(argument) {
  if (!isCallable$7(argument))
    return false;
  switch (classof$5(argument)) {
    case "AsyncFunction":
    case "GeneratorFunction":
    case "AsyncGeneratorFunction":
      return false;
  }
  try {
    return INCORRECT_TO_STRING || !!exec$2(constructorRegExp, inspectSource$1(argument));
  } catch (error) {
    return true;
  }
};
isConstructorLegacy.sham = true;
var isConstructor$1 = !construct || fails$c(function() {
  var called;
  return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
    called = true;
  }) || called;
}) ? isConstructorLegacy : isConstructorModern;
var global$h = global$I;
var isConstructor3 = isConstructor$1;
var tryToString = tryToString$4;
var TypeError$5 = global$h.TypeError;
var aConstructor$1 = function(argument) {
  if (isConstructor3(argument))
    return argument;
  throw TypeError$5(tryToString(argument) + " is not a constructor");
};
var anObject$9 = anObject$g;
var aConstructor = aConstructor$1;
var wellKnownSymbol$9 = wellKnownSymbol$i;
var SPECIES$2 = wellKnownSymbol$9("species");
var speciesConstructor$2 = function(O2, defaultConstructor) {
  var C2 = anObject$9(O2).constructor;
  var S2;
  return C2 === void 0 || (S2 = anObject$9(C2)[SPECIES$2]) == void 0 ? defaultConstructor : aConstructor(S2);
};
var NATIVE_BIND = functionBindNative;
var FunctionPrototype = Function.prototype;
var apply$3 = FunctionPrototype.apply;
var call$7 = FunctionPrototype.call;
var functionApply = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND ? call$7.bind(apply$3) : function() {
  return call$7.apply(apply$3, arguments);
});
var getBuiltIn$1 = getBuiltIn$7;
var html$2 = getBuiltIn$1("document", "documentElement");
var uncurryThis$d = functionUncurryThis;
var arraySlice$2 = uncurryThis$d([].slice);
var userAgent$2 = engineUserAgent;
var engineIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent$2);
var classof$4 = classofRaw$1;
var global$g = global$I;
var engineIsNode = classof$4(global$g.process) == "process";
var global$f = global$I;
var apply$2 = functionApply;
var bind$2 = functionBindContext;
var isCallable$6 = isCallable$j;
var hasOwn$1 = hasOwnProperty_1;
var fails$b = fails$k;
var html$1 = html$2;
var arraySlice$1 = arraySlice$2;
var createElement = documentCreateElement$2;
var IS_IOS$1 = engineIsIos;
var IS_NODE$3 = engineIsNode;
var set = global$f.setImmediate;
var clear = global$f.clearImmediate;
var process$3 = global$f.process;
var Dispatch = global$f.Dispatch;
var Function$1 = global$f.Function;
var MessageChannel = global$f.MessageChannel;
var String$2 = global$f.String;
var counter = 0;
var queue$2 = {};
var ONREADYSTATECHANGE = "onreadystatechange";
var location$1, defer, channel, port;
try {
  location$1 = global$f.location;
} catch (error) {
}
var run = function(id) {
  if (hasOwn$1(queue$2, id)) {
    var fn = queue$2[id];
    delete queue$2[id];
    fn();
  }
};
var runner = function(id) {
  return function() {
    run(id);
  };
};
var listener = function(event) {
  run(event.data);
};
var post = function(id) {
  global$f.postMessage(String$2(id), location$1.protocol + "//" + location$1.host);
};
if (!set || !clear) {
  set = function setImmediate(fn) {
    var args = arraySlice$1(arguments, 1);
    queue$2[++counter] = function() {
      apply$2(isCallable$6(fn) ? fn : Function$1(fn), void 0, args);
    };
    defer(counter);
    return counter;
  };
  clear = function clearImmediate(id) {
    delete queue$2[id];
  };
  if (IS_NODE$3) {
    defer = function(id) {
      process$3.nextTick(runner(id));
    };
  } else if (Dispatch && Dispatch.now) {
    defer = function(id) {
      Dispatch.now(runner(id));
    };
  } else if (MessageChannel && !IS_IOS$1) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = bind$2(port.postMessage, port);
  } else if (global$f.addEventListener && isCallable$6(global$f.postMessage) && !global$f.importScripts && location$1 && location$1.protocol !== "file:" && !fails$b(post)) {
    defer = post;
    global$f.addEventListener("message", listener, false);
  } else if (ONREADYSTATECHANGE in createElement("script")) {
    defer = function(id) {
      html$1.appendChild(createElement("script"))[ONREADYSTATECHANGE] = function() {
        html$1.removeChild(this);
        run(id);
      };
    };
  } else {
    defer = function(id) {
      setTimeout(runner(id), 0);
    };
  }
}
var task$1 = {
  set,
  clear
};
var userAgent$1 = engineUserAgent;
var global$e = global$I;
var engineIsIosPebble = /ipad|iphone|ipod/i.test(userAgent$1) && global$e.Pebble !== void 0;
var userAgent = engineUserAgent;
var engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(userAgent);
var global$d = global$I;
var bind$1 = functionBindContext;
var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;
var macrotask = task$1.set;
var IS_IOS = engineIsIos;
var IS_IOS_PEBBLE = engineIsIosPebble;
var IS_WEBOS_WEBKIT = engineIsWebosWebkit;
var IS_NODE$2 = engineIsNode;
var MutationObserver = global$d.MutationObserver || global$d.WebKitMutationObserver;
var document$2 = global$d.document;
var process$2 = global$d.process;
var Promise$1 = global$d.Promise;
var queueMicrotaskDescriptor = getOwnPropertyDescriptor$2(global$d, "queueMicrotask");
var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
var flush, head, last$1, notify$1, toggle, node$1, promise, then;
if (!queueMicrotask) {
  flush = function() {
    var parent, fn;
    if (IS_NODE$2 && (parent = process$2.domain))
      parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (error) {
        if (head)
          notify$1();
        else
          last$1 = void 0;
        throw error;
      }
    }
    last$1 = void 0;
    if (parent)
      parent.enter();
  };
  if (!IS_IOS && !IS_NODE$2 && !IS_WEBOS_WEBKIT && MutationObserver && document$2) {
    toggle = true;
    node$1 = document$2.createTextNode("");
    new MutationObserver(flush).observe(node$1, { characterData: true });
    notify$1 = function() {
      node$1.data = toggle = !toggle;
    };
  } else if (!IS_IOS_PEBBLE && Promise$1 && Promise$1.resolve) {
    promise = Promise$1.resolve(void 0);
    promise.constructor = Promise$1;
    then = bind$1(promise.then, promise);
    notify$1 = function() {
      then(flush);
    };
  } else if (IS_NODE$2) {
    notify$1 = function() {
      process$2.nextTick(flush);
    };
  } else {
    macrotask = bind$1(macrotask, global$d);
    notify$1 = function() {
      macrotask(flush);
    };
  }
}
var microtask$1 = queueMicrotask || function(fn) {
  var task2 = { fn, next: void 0 };
  if (last$1)
    last$1.next = task2;
  if (!head) {
    head = task2;
    notify$1();
  }
  last$1 = task2;
};
var newPromiseCapability$2 = {};
var aCallable$2 = aCallable$6;
var PromiseCapability = function(C2) {
  var resolve2, reject2;
  this.promise = new C2(function($$resolve, $$reject) {
    if (resolve2 !== void 0 || reject2 !== void 0)
      throw TypeError("Bad Promise constructor");
    resolve2 = $$resolve;
    reject2 = $$reject;
  });
  this.resolve = aCallable$2(resolve2);
  this.reject = aCallable$2(reject2);
};
newPromiseCapability$2.f = function(C2) {
  return new PromiseCapability(C2);
};
var anObject$8 = anObject$g;
var isObject$2 = isObject$8;
var newPromiseCapability$1 = newPromiseCapability$2;
var promiseResolve$1 = function(C2, x2) {
  anObject$8(C2);
  if (isObject$2(x2) && x2.constructor === C2)
    return x2;
  var promiseCapability = newPromiseCapability$1.f(C2);
  var resolve2 = promiseCapability.resolve;
  resolve2(x2);
  return promiseCapability.promise;
};
var global$c = global$I;
var hostReportErrors$1 = function(a2, b2) {
  var console2 = global$c.console;
  if (console2 && console2.error) {
    arguments.length == 1 ? console2.error(a2) : console2.error(a2, b2);
  }
};
var perform$1 = function(exec2) {
  try {
    return { error: false, value: exec2() };
  } catch (error) {
    return { error: true, value: error };
  }
};
var Queue$1 = function() {
  this.head = null;
  this.tail = null;
};
Queue$1.prototype = {
  add: function(item) {
    var entry = { item, next: null };
    if (this.head)
      this.tail.next = entry;
    else
      this.head = entry;
    this.tail = entry;
  },
  get: function() {
    var entry = this.head;
    if (entry) {
      this.head = entry.next;
      if (this.tail === entry)
        this.tail = null;
      return entry.item;
    }
  }
};
var queue$1 = Queue$1;
var engineIsBrowser = typeof window == "object";
var $$9 = _export;
var global$b = global$I;
var getBuiltIn = getBuiltIn$7;
var call$6 = functionCall;
var NativePromise = nativePromiseConstructor;
var redefine$4 = redefine$7.exports;
var redefineAll = redefineAll$1;
var setPrototypeOf$1 = objectSetPrototypeOf;
var setToStringTag$2 = setToStringTag$3;
var setSpecies = setSpecies$1;
var aCallable$1 = aCallable$6;
var isCallable$5 = isCallable$j;
var isObject$1 = isObject$8;
var anInstance = anInstance$1;
var inspectSource = inspectSource$4;
var iterate = iterate$1;
var checkCorrectnessOfIteration = checkCorrectnessOfIteration$1;
var speciesConstructor$1 = speciesConstructor$2;
var task = task$1.set;
var microtask = microtask$1;
var promiseResolve = promiseResolve$1;
var hostReportErrors = hostReportErrors$1;
var newPromiseCapabilityModule = newPromiseCapability$2;
var perform = perform$1;
var Queue = queue$1;
var InternalStateModule$1 = internalState;
var isForced = isForced_1;
var wellKnownSymbol$8 = wellKnownSymbol$i;
var IS_BROWSER = engineIsBrowser;
var IS_NODE$1 = engineIsNode;
var V8_VERSION = engineV8Version;
var SPECIES$1 = wellKnownSymbol$8("species");
var PROMISE = "Promise";
var getInternalState$2 = InternalStateModule$1.getterFor(PROMISE);
var setInternalState$1 = InternalStateModule$1.set;
var getInternalPromiseState = InternalStateModule$1.getterFor(PROMISE);
var NativePromisePrototype = NativePromise && NativePromise.prototype;
var PromiseConstructor = NativePromise;
var PromisePrototype = NativePromisePrototype;
var TypeError$4 = global$b.TypeError;
var document$1 = global$b.document;
var process$1 = global$b.process;
var newPromiseCapability = newPromiseCapabilityModule.f;
var newGenericPromiseCapability = newPromiseCapability;
var DISPATCH_EVENT = !!(document$1 && document$1.createEvent && global$b.dispatchEvent);
var NATIVE_REJECTION_EVENT = isCallable$5(global$b.PromiseRejectionEvent);
var UNHANDLED_REJECTION = "unhandledrejection";
var REJECTION_HANDLED = "rejectionhandled";
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;
var SUBCLASSING = false;
var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;
var FORCED = isForced(PROMISE, function() {
  var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(PromiseConstructor);
  var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(PromiseConstructor);
  if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66)
    return true;
  if (V8_VERSION >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE))
    return false;
  var promise2 = new PromiseConstructor(function(resolve2) {
    resolve2(1);
  });
  var FakePromise = function(exec2) {
    exec2(function() {
    }, function() {
    });
  };
  var constructor = promise2.constructor = {};
  constructor[SPECIES$1] = FakePromise;
  SUBCLASSING = promise2.then(function() {
  }) instanceof FakePromise;
  if (!SUBCLASSING)
    return true;
  return !GLOBAL_CORE_JS_PROMISE && IS_BROWSER && !NATIVE_REJECTION_EVENT;
});
var INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function(iterable) {
  PromiseConstructor.all(iterable)["catch"](function() {
  });
});
var isThenable = function(it2) {
  var then2;
  return isObject$1(it2) && isCallable$5(then2 = it2.then) ? then2 : false;
};
var callReaction = function(reaction, state) {
  var value = state.value;
  var ok = state.state == FULFILLED;
  var handler = ok ? reaction.ok : reaction.fail;
  var resolve2 = reaction.resolve;
  var reject2 = reaction.reject;
  var domain = reaction.domain;
  var result, then2, exited;
  try {
    if (handler) {
      if (!ok) {
        if (state.rejection === UNHANDLED)
          onHandleUnhandled(state);
        state.rejection = HANDLED;
      }
      if (handler === true)
        result = value;
      else {
        if (domain)
          domain.enter();
        result = handler(value);
        if (domain) {
          domain.exit();
          exited = true;
        }
      }
      if (result === reaction.promise) {
        reject2(TypeError$4("Promise-chain cycle"));
      } else if (then2 = isThenable(result)) {
        call$6(then2, result, resolve2, reject2);
      } else
        resolve2(result);
    } else
      reject2(value);
  } catch (error) {
    if (domain && !exited)
      domain.exit();
    reject2(error);
  }
};
var notify = function(state, isReject) {
  if (state.notified)
    return;
  state.notified = true;
  microtask(function() {
    var reactions = state.reactions;
    var reaction;
    while (reaction = reactions.get()) {
      callReaction(reaction, state);
    }
    state.notified = false;
    if (isReject && !state.rejection)
      onUnhandled(state);
  });
};
var dispatchEvent = function(name, promise2, reason) {
  var event, handler;
  if (DISPATCH_EVENT) {
    event = document$1.createEvent("Event");
    event.promise = promise2;
    event.reason = reason;
    event.initEvent(name, false, true);
    global$b.dispatchEvent(event);
  } else
    event = { promise: promise2, reason };
  if (!NATIVE_REJECTION_EVENT && (handler = global$b["on" + name]))
    handler(event);
  else if (name === UNHANDLED_REJECTION)
    hostReportErrors("Unhandled promise rejection", reason);
};
var onUnhandled = function(state) {
  call$6(task, global$b, function() {
    var promise2 = state.facade;
    var value = state.value;
    var IS_UNHANDLED = isUnhandled(state);
    var result;
    if (IS_UNHANDLED) {
      result = perform(function() {
        if (IS_NODE$1) {
          process$1.emit("unhandledRejection", value, promise2);
        } else
          dispatchEvent(UNHANDLED_REJECTION, promise2, value);
      });
      state.rejection = IS_NODE$1 || isUnhandled(state) ? UNHANDLED : HANDLED;
      if (result.error)
        throw result.value;
    }
  });
};
var isUnhandled = function(state) {
  return state.rejection !== HANDLED && !state.parent;
};
var onHandleUnhandled = function(state) {
  call$6(task, global$b, function() {
    var promise2 = state.facade;
    if (IS_NODE$1) {
      process$1.emit("rejectionHandled", promise2);
    } else
      dispatchEvent(REJECTION_HANDLED, promise2, state.value);
  });
};
var bind = function(fn, state, unwrap) {
  return function(value) {
    fn(state, value, unwrap);
  };
};
var internalReject = function(state, value, unwrap) {
  if (state.done)
    return;
  state.done = true;
  if (unwrap)
    state = unwrap;
  state.value = value;
  state.state = REJECTED;
  notify(state, true);
};
var internalResolve = function(state, value, unwrap) {
  if (state.done)
    return;
  state.done = true;
  if (unwrap)
    state = unwrap;
  try {
    if (state.facade === value)
      throw TypeError$4("Promise can't be resolved itself");
    var then2 = isThenable(value);
    if (then2) {
      microtask(function() {
        var wrapper = { done: false };
        try {
          call$6(then2, value, bind(internalResolve, wrapper, state), bind(internalReject, wrapper, state));
        } catch (error) {
          internalReject(wrapper, error, state);
        }
      });
    } else {
      state.value = value;
      state.state = FULFILLED;
      notify(state, false);
    }
  } catch (error) {
    internalReject({ done: false }, error, state);
  }
};
if (FORCED) {
  PromiseConstructor = function Promise2(executor) {
    anInstance(this, PromisePrototype);
    aCallable$1(executor);
    call$6(Internal, this);
    var state = getInternalState$2(this);
    try {
      executor(bind(internalResolve, state), bind(internalReject, state));
    } catch (error) {
      internalReject(state, error);
    }
  };
  PromisePrototype = PromiseConstructor.prototype;
  Internal = function Promise2(executor) {
    setInternalState$1(this, {
      type: PROMISE,
      done: false,
      notified: false,
      parent: false,
      reactions: new Queue(),
      rejection: false,
      state: PENDING,
      value: void 0
    });
  };
  Internal.prototype = redefineAll(PromisePrototype, {
    then: function then2(onFulfilled, onRejected) {
      var state = getInternalPromiseState(this);
      var reaction = newPromiseCapability(speciesConstructor$1(this, PromiseConstructor));
      state.parent = true;
      reaction.ok = isCallable$5(onFulfilled) ? onFulfilled : true;
      reaction.fail = isCallable$5(onRejected) && onRejected;
      reaction.domain = IS_NODE$1 ? process$1.domain : void 0;
      if (state.state == PENDING)
        state.reactions.add(reaction);
      else
        microtask(function() {
          callReaction(reaction, state);
        });
      return reaction.promise;
    },
    "catch": function(onRejected) {
      return this.then(void 0, onRejected);
    }
  });
  OwnPromiseCapability = function() {
    var promise2 = new Internal();
    var state = getInternalState$2(promise2);
    this.promise = promise2;
    this.resolve = bind(internalResolve, state);
    this.reject = bind(internalReject, state);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function(C2) {
    return C2 === PromiseConstructor || C2 === PromiseWrapper ? new OwnPromiseCapability(C2) : newGenericPromiseCapability(C2);
  };
  if (isCallable$5(NativePromise) && NativePromisePrototype !== Object.prototype) {
    nativeThen = NativePromisePrototype.then;
    if (!SUBCLASSING) {
      redefine$4(NativePromisePrototype, "then", function then2(onFulfilled, onRejected) {
        var that = this;
        return new PromiseConstructor(function(resolve2, reject2) {
          call$6(nativeThen, that, resolve2, reject2);
        }).then(onFulfilled, onRejected);
      }, { unsafe: true });
      redefine$4(NativePromisePrototype, "catch", PromisePrototype["catch"], { unsafe: true });
    }
    try {
      delete NativePromisePrototype.constructor;
    } catch (error) {
    }
    if (setPrototypeOf$1) {
      setPrototypeOf$1(NativePromisePrototype, PromisePrototype);
    }
  }
}
$$9({ global: true, wrap: true, forced: FORCED }, {
  Promise: PromiseConstructor
});
setToStringTag$2(PromiseConstructor, PROMISE, false);
setSpecies(PROMISE);
PromiseWrapper = getBuiltIn(PROMISE);
$$9({ target: PROMISE, stat: true, forced: FORCED }, {
  reject: function reject(r2) {
    var capability = newPromiseCapability(this);
    call$6(capability.reject, void 0, r2);
    return capability.promise;
  }
});
$$9({ target: PROMISE, stat: true, forced: FORCED }, {
  resolve: function resolve(x2) {
    return promiseResolve(this, x2);
  }
});
$$9({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, {
  all: function all2(iterable) {
    var C2 = this;
    var capability = newPromiseCapability(C2);
    var resolve2 = capability.resolve;
    var reject2 = capability.reject;
    var result = perform(function() {
      var $promiseResolve = aCallable$1(C2.resolve);
      var values3 = [];
      var counter2 = 0;
      var remaining = 1;
      iterate(iterable, function(promise2) {
        var index2 = counter2++;
        var alreadyCalled = false;
        remaining++;
        call$6($promiseResolve, C2, promise2).then(function(value) {
          if (alreadyCalled)
            return;
          alreadyCalled = true;
          values3[index2] = value;
          --remaining || resolve2(values3);
        }, reject2);
      });
      --remaining || resolve2(values3);
    });
    if (result.error)
      reject2(result.value);
    return capability.promise;
  },
  race: function race(iterable) {
    var C2 = this;
    var capability = newPromiseCapability(C2);
    var reject2 = capability.reject;
    var result = perform(function() {
      var $promiseResolve = aCallable$1(C2.resolve);
      iterate(iterable, function(promise2) {
        call$6($promiseResolve, C2, promise2).then(capability.resolve, reject2);
      });
    });
    if (result.error)
      reject2(result.value);
    return capability.promise;
  }
});
function asyncGeneratorStep(gen, resolve2, reject2, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject2(error);
    return;
  }
  if (info.done) {
    resolve2(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve2, reject2) {
      var gen = fn.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve2, reject2, _next, _throw, "next", value);
      }
      function _throw(err2) {
        asyncGeneratorStep(gen, resolve2, reject2, _next, _throw, "throw", err2);
      }
      _next(void 0);
    });
  };
}
var global$a = global$I;
var classof$3 = classof$7;
var String$1 = global$a.String;
var toString$9 = function(argument) {
  if (classof$3(argument) === "Symbol")
    throw TypeError("Cannot convert a Symbol value to a string");
  return String$1(argument);
};
var anObject$7 = anObject$g;
var regexpFlags$1 = function() {
  var that = anObject$7(this);
  var result = "";
  if (that.global)
    result += "g";
  if (that.ignoreCase)
    result += "i";
  if (that.multiline)
    result += "m";
  if (that.dotAll)
    result += "s";
  if (that.unicode)
    result += "u";
  if (that.sticky)
    result += "y";
  return result;
};
var fails$a = fails$k;
var global$9 = global$I;
var $RegExp$2 = global$9.RegExp;
var UNSUPPORTED_Y$2 = fails$a(function() {
  var re2 = $RegExp$2("a", "y");
  re2.lastIndex = 2;
  return re2.exec("abcd") != null;
});
var MISSED_STICKY = UNSUPPORTED_Y$2 || fails$a(function() {
  return !$RegExp$2("a", "y").sticky;
});
var BROKEN_CARET = UNSUPPORTED_Y$2 || fails$a(function() {
  var re2 = $RegExp$2("^r", "gy");
  re2.lastIndex = 2;
  return re2.exec("str") != null;
});
var regexpStickyHelpers = {
  BROKEN_CARET,
  MISSED_STICKY,
  UNSUPPORTED_Y: UNSUPPORTED_Y$2
};
var objectDefineProperties = {};
var internalObjectKeys = objectKeysInternal;
var enumBugKeys$1 = enumBugKeys$3;
var objectKeys$1 = Object.keys || function keys2(O2) {
  return internalObjectKeys(O2, enumBugKeys$1);
};
var DESCRIPTORS$1 = descriptors;
var V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;
var definePropertyModule$2 = objectDefineProperty;
var anObject$6 = anObject$g;
var toIndexedObject$1 = toIndexedObject$5;
var objectKeys = objectKeys$1;
objectDefineProperties.f = DESCRIPTORS$1 && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O2, Properties) {
  anObject$6(O2);
  var props = toIndexedObject$1(Properties);
  var keys3 = objectKeys(Properties);
  var length = keys3.length;
  var index2 = 0;
  var key;
  while (length > index2)
    definePropertyModule$2.f(O2, key = keys3[index2++], props[key]);
  return O2;
};
var anObject$5 = anObject$g;
var definePropertiesModule = objectDefineProperties;
var enumBugKeys = enumBugKeys$3;
var hiddenKeys = hiddenKeys$4;
var html = html$2;
var documentCreateElement$1 = documentCreateElement$2;
var sharedKey$1 = sharedKey$3;
var GT = ">";
var LT = "<";
var PROTOTYPE = "prototype";
var SCRIPT = "script";
var IE_PROTO$1 = sharedKey$1("IE_PROTO");
var EmptyConstructor = function() {
};
var scriptTag = function(content2) {
  return LT + SCRIPT + GT + content2 + LT + "/" + SCRIPT + GT;
};
var NullProtoObjectViaActiveX = function(activeXDocument2) {
  activeXDocument2.write(scriptTag(""));
  activeXDocument2.close();
  var temp = activeXDocument2.parentWindow.Object;
  activeXDocument2 = null;
  return temp;
};
var NullProtoObjectViaIFrame = function() {
  var iframe = documentCreateElement$1("iframe");
  var JS = "java" + SCRIPT + ":";
  var iframeDocument;
  iframe.style.display = "none";
  html.appendChild(iframe);
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag("document.F=Object"));
  iframeDocument.close();
  return iframeDocument.F;
};
var activeXDocument;
var NullProtoObject = function() {
  try {
    activeXDocument = new ActiveXObject("htmlfile");
  } catch (error) {
  }
  NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
  var length = enumBugKeys.length;
  while (length--)
    delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};
hiddenKeys[IE_PROTO$1] = true;
var objectCreate = Object.create || function create(O2, Properties) {
  var result;
  if (O2 !== null) {
    EmptyConstructor[PROTOTYPE] = anObject$5(O2);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    result[IE_PROTO$1] = O2;
  } else
    result = NullProtoObject();
  return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
};
var fails$9 = fails$k;
var global$8 = global$I;
var $RegExp$1 = global$8.RegExp;
var regexpUnsupportedDotAll = fails$9(function() {
  var re2 = $RegExp$1(".", "s");
  return !(re2.dotAll && re2.exec("\n") && re2.flags === "s");
});
var fails$8 = fails$k;
var global$7 = global$I;
var $RegExp = global$7.RegExp;
var regexpUnsupportedNcg = fails$8(function() {
  var re2 = $RegExp("(?<a>b)", "g");
  return re2.exec("b").groups.a !== "b" || "b".replace(re2, "$<a>c") !== "bc";
});
var call$5 = functionCall;
var uncurryThis$c = functionUncurryThis;
var toString$8 = toString$9;
var regexpFlags = regexpFlags$1;
var stickyHelpers$1 = regexpStickyHelpers;
var shared = shared$4.exports;
var create$2 = objectCreate;
var getInternalState$1 = internalState.get;
var UNSUPPORTED_DOT_ALL = regexpUnsupportedDotAll;
var UNSUPPORTED_NCG = regexpUnsupportedNcg;
var nativeReplace = shared("native-string-replace", String.prototype.replace);
var nativeExec = RegExp.prototype.exec;
var patchedExec = nativeExec;
var charAt$3 = uncurryThis$c("".charAt);
var indexOf = uncurryThis$c("".indexOf);
var replace$2 = uncurryThis$c("".replace);
var stringSlice$5 = uncurryThis$c("".slice);
var UPDATES_LAST_INDEX_WRONG = function() {
  var re1 = /a/;
  var re2 = /b*/g;
  call$5(nativeExec, re1, "a");
  call$5(nativeExec, re2, "a");
  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
}();
var UNSUPPORTED_Y$1 = stickyHelpers$1.BROKEN_CARET;
var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y$1 || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;
if (PATCH) {
  patchedExec = function exec2(string) {
    var re2 = this;
    var state = getInternalState$1(re2);
    var str = toString$8(string);
    var raw2 = state.raw;
    var result, reCopy, lastIndex, match2, i2, object, group;
    if (raw2) {
      raw2.lastIndex = re2.lastIndex;
      result = call$5(patchedExec, raw2, str);
      re2.lastIndex = raw2.lastIndex;
      return result;
    }
    var groups = state.groups;
    var sticky = UNSUPPORTED_Y$1 && re2.sticky;
    var flags = call$5(regexpFlags, re2);
    var source = re2.source;
    var charsAdded = 0;
    var strCopy = str;
    if (sticky) {
      flags = replace$2(flags, "y", "");
      if (indexOf(flags, "g") === -1) {
        flags += "g";
      }
      strCopy = stringSlice$5(str, re2.lastIndex);
      if (re2.lastIndex > 0 && (!re2.multiline || re2.multiline && charAt$3(str, re2.lastIndex - 1) !== "\n")) {
        source = "(?: " + source + ")";
        strCopy = " " + strCopy;
        charsAdded++;
      }
      reCopy = new RegExp("^(?:" + source + ")", flags);
    }
    if (NPCG_INCLUDED) {
      reCopy = new RegExp("^" + source + "$(?!\\s)", flags);
    }
    if (UPDATES_LAST_INDEX_WRONG)
      lastIndex = re2.lastIndex;
    match2 = call$5(nativeExec, sticky ? reCopy : re2, strCopy);
    if (sticky) {
      if (match2) {
        match2.input = stringSlice$5(match2.input, charsAdded);
        match2[0] = stringSlice$5(match2[0], charsAdded);
        match2.index = re2.lastIndex;
        re2.lastIndex += match2[0].length;
      } else
        re2.lastIndex = 0;
    } else if (UPDATES_LAST_INDEX_WRONG && match2) {
      re2.lastIndex = re2.global ? match2.index + match2[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match2 && match2.length > 1) {
      call$5(nativeReplace, match2[0], reCopy, function() {
        for (i2 = 1; i2 < arguments.length - 2; i2++) {
          if (arguments[i2] === void 0)
            match2[i2] = void 0;
        }
      });
    }
    if (match2 && groups) {
      match2.groups = object = create$2(null);
      for (i2 = 0; i2 < groups.length; i2++) {
        group = groups[i2];
        object[group[0]] = match2[group[1]];
      }
    }
    return match2;
  };
}
var regexpExec$3 = patchedExec;
var $$8 = _export;
var exec$1 = regexpExec$3;
$$8({ target: "RegExp", proto: true, forced: /./.exec !== exec$1 }, {
  exec: exec$1
});
var uncurryThis$b = functionUncurryThis;
var redefine$3 = redefine$7.exports;
var regexpExec$2 = regexpExec$3;
var fails$7 = fails$k;
var wellKnownSymbol$7 = wellKnownSymbol$i;
var createNonEnumerableProperty$2 = createNonEnumerableProperty$6;
var SPECIES = wellKnownSymbol$7("species");
var RegExpPrototype$1 = RegExp.prototype;
var fixRegexpWellKnownSymbolLogic = function(KEY, exec2, FORCED2, SHAM) {
  var SYMBOL = wellKnownSymbol$7(KEY);
  var DELEGATES_TO_SYMBOL = !fails$7(function() {
    var O2 = {};
    O2[SYMBOL] = function() {
      return 7;
    };
    return ""[KEY](O2) != 7;
  });
  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails$7(function() {
    var execCalled = false;
    var re2 = /a/;
    if (KEY === "split") {
      re2 = {};
      re2.constructor = {};
      re2.constructor[SPECIES] = function() {
        return re2;
      };
      re2.flags = "";
      re2[SYMBOL] = /./[SYMBOL];
    }
    re2.exec = function() {
      execCalled = true;
      return null;
    };
    re2[SYMBOL]("");
    return !execCalled;
  });
  if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || FORCED2) {
    var uncurriedNativeRegExpMethod = uncurryThis$b(/./[SYMBOL]);
    var methods = exec2(SYMBOL, ""[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
      var uncurriedNativeMethod = uncurryThis$b(nativeMethod);
      var $exec = regexp.exec;
      if ($exec === regexpExec$2 || $exec === RegExpPrototype$1.exec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          return { done: true, value: uncurriedNativeRegExpMethod(regexp, str, arg2) };
        }
        return { done: true, value: uncurriedNativeMethod(str, regexp, arg2) };
      }
      return { done: false };
    });
    redefine$3(String.prototype, KEY, methods[0]);
    redefine$3(RegExpPrototype$1, SYMBOL, methods[1]);
  }
  if (SHAM)
    createNonEnumerableProperty$2(RegExpPrototype$1[SYMBOL], "sham", true);
};
var uncurryThis$a = functionUncurryThis;
var toIntegerOrInfinity$1 = toIntegerOrInfinity$4;
var toString$7 = toString$9;
var requireObjectCoercible$7 = requireObjectCoercible$a;
var charAt$2 = uncurryThis$a("".charAt);
var charCodeAt = uncurryThis$a("".charCodeAt);
var stringSlice$4 = uncurryThis$a("".slice);
var createMethod$2 = function(CONVERT_TO_STRING) {
  return function($this, pos) {
    var S2 = toString$7(requireObjectCoercible$7($this));
    var position2 = toIntegerOrInfinity$1(pos);
    var size = S2.length;
    var first, second;
    if (position2 < 0 || position2 >= size)
      return CONVERT_TO_STRING ? "" : void 0;
    first = charCodeAt(S2, position2);
    return first < 55296 || first > 56319 || position2 + 1 === size || (second = charCodeAt(S2, position2 + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt$2(S2, position2) : first : CONVERT_TO_STRING ? stringSlice$4(S2, position2, position2 + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
  };
};
var stringMultibyte = {
  codeAt: createMethod$2(false),
  charAt: createMethod$2(true)
};
var charAt$1 = stringMultibyte.charAt;
var advanceStringIndex$3 = function(S2, index2, unicode) {
  return index2 + (unicode ? charAt$1(S2, index2).length : 1);
};
var global$6 = global$I;
var call$4 = functionCall;
var anObject$4 = anObject$g;
var isCallable$4 = isCallable$j;
var classof$2 = classofRaw$1;
var regexpExec$1 = regexpExec$3;
var TypeError$3 = global$6.TypeError;
var regexpExecAbstract = function(R2, S2) {
  var exec2 = R2.exec;
  if (isCallable$4(exec2)) {
    var result = call$4(exec2, R2, S2);
    if (result !== null)
      anObject$4(result);
    return result;
  }
  if (classof$2(R2) === "RegExp")
    return call$4(regexpExec$1, R2, S2);
  throw TypeError$3("RegExp#exec called on incompatible receiver");
};
var call$3 = functionCall;
var fixRegExpWellKnownSymbolLogic$2 = fixRegexpWellKnownSymbolLogic;
var anObject$3 = anObject$g;
var toLength$4 = toLength$6;
var toString$6 = toString$9;
var requireObjectCoercible$6 = requireObjectCoercible$a;
var getMethod$2 = getMethod$6;
var advanceStringIndex$2 = advanceStringIndex$3;
var regExpExec$1 = regexpExecAbstract;
fixRegExpWellKnownSymbolLogic$2("match", function(MATCH2, nativeMatch, maybeCallNative) {
  return [
    function match2(regexp) {
      var O2 = requireObjectCoercible$6(this);
      var matcher = regexp == void 0 ? void 0 : getMethod$2(regexp, MATCH2);
      return matcher ? call$3(matcher, regexp, O2) : new RegExp(regexp)[MATCH2](toString$6(O2));
    },
    function(string) {
      var rx = anObject$3(this);
      var S2 = toString$6(string);
      var res = maybeCallNative(nativeMatch, rx, S2);
      if (res.done)
        return res.value;
      if (!rx.global)
        return regExpExec$1(rx, S2);
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A2 = [];
      var n2 = 0;
      var result;
      while ((result = regExpExec$1(rx, S2)) !== null) {
        var matchStr = toString$6(result[0]);
        A2[n2] = matchStr;
        if (matchStr === "")
          rx.lastIndex = advanceStringIndex$2(S2, toLength$4(rx.lastIndex), fullUnicode);
        n2++;
      }
      return n2 === 0 ? null : A2;
    }
  ];
});
var uncurryThis$9 = functionUncurryThis;
var toObject$2 = toObject$4;
var floor = Math.floor;
var charAt = uncurryThis$9("".charAt);
var replace$1 = uncurryThis$9("".replace);
var stringSlice$3 = uncurryThis$9("".slice);
var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;
var getSubstitution$1 = function(matched, str, position2, captures, namedCaptures, replacement2) {
  var tailPos = position2 + matched.length;
  var m2 = captures.length;
  var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
  if (namedCaptures !== void 0) {
    namedCaptures = toObject$2(namedCaptures);
    symbols = SUBSTITUTION_SYMBOLS;
  }
  return replace$1(replacement2, symbols, function(match2, ch) {
    var capture;
    switch (charAt(ch, 0)) {
      case "$":
        return "$";
      case "&":
        return matched;
      case "`":
        return stringSlice$3(str, 0, position2);
      case "'":
        return stringSlice$3(str, tailPos);
      case "<":
        capture = namedCaptures[stringSlice$3(ch, 1, -1)];
        break;
      default:
        var n2 = +ch;
        if (n2 === 0)
          return match2;
        if (n2 > m2) {
          var f2 = floor(n2 / 10);
          if (f2 === 0)
            return match2;
          if (f2 <= m2)
            return captures[f2 - 1] === void 0 ? charAt(ch, 1) : captures[f2 - 1] + charAt(ch, 1);
          return match2;
        }
        capture = captures[n2 - 1];
    }
    return capture === void 0 ? "" : capture;
  });
};
var apply$1 = functionApply;
var call$2 = functionCall;
var uncurryThis$8 = functionUncurryThis;
var fixRegExpWellKnownSymbolLogic$1 = fixRegexpWellKnownSymbolLogic;
var fails$6 = fails$k;
var anObject$2 = anObject$g;
var isCallable$3 = isCallable$j;
var toIntegerOrInfinity = toIntegerOrInfinity$4;
var toLength$3 = toLength$6;
var toString$5 = toString$9;
var requireObjectCoercible$5 = requireObjectCoercible$a;
var advanceStringIndex$1 = advanceStringIndex$3;
var getMethod$1 = getMethod$6;
var getSubstitution = getSubstitution$1;
var regExpExec = regexpExecAbstract;
var wellKnownSymbol$6 = wellKnownSymbol$i;
var REPLACE = wellKnownSymbol$6("replace");
var max$1 = Math.max;
var min$3 = Math.min;
var concat = uncurryThis$8([].concat);
var push$1 = uncurryThis$8([].push);
var stringIndexOf$1 = uncurryThis$8("".indexOf);
var stringSlice$2 = uncurryThis$8("".slice);
var maybeToString = function(it2) {
  return it2 === void 0 ? it2 : String(it2);
};
var REPLACE_KEEPS_$0 = function() {
  return "a".replace(/./, "$0") === "$0";
}();
var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function() {
  if (/./[REPLACE]) {
    return /./[REPLACE]("a", "$0") === "";
  }
  return false;
}();
var REPLACE_SUPPORTS_NAMED_GROUPS = !fails$6(function() {
  var re2 = /./;
  re2.exec = function() {
    var result = [];
    result.groups = { a: "7" };
    return result;
  };
  return "".replace(re2, "$<a>") !== "7";
});
fixRegExpWellKnownSymbolLogic$1("replace", function(_2, nativeReplace2, maybeCallNative) {
  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? "$" : "$0";
  return [
    function replace2(searchValue, replaceValue) {
      var O2 = requireObjectCoercible$5(this);
      var replacer = searchValue == void 0 ? void 0 : getMethod$1(searchValue, REPLACE);
      return replacer ? call$2(replacer, searchValue, O2, replaceValue) : call$2(nativeReplace2, toString$5(O2), searchValue, replaceValue);
    },
    function(string, replaceValue) {
      var rx = anObject$2(this);
      var S2 = toString$5(string);
      if (typeof replaceValue == "string" && stringIndexOf$1(replaceValue, UNSAFE_SUBSTITUTE) === -1 && stringIndexOf$1(replaceValue, "$<") === -1) {
        var res = maybeCallNative(nativeReplace2, rx, S2, replaceValue);
        if (res.done)
          return res.value;
      }
      var functionalReplace = isCallable$3(replaceValue);
      if (!functionalReplace)
        replaceValue = toString$5(replaceValue);
      var global2 = rx.global;
      if (global2) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      while (true) {
        var result = regExpExec(rx, S2);
        if (result === null)
          break;
        push$1(results, result);
        if (!global2)
          break;
        var matchStr = toString$5(result[0]);
        if (matchStr === "")
          rx.lastIndex = advanceStringIndex$1(S2, toLength$3(rx.lastIndex), fullUnicode);
      }
      var accumulatedResult = "";
      var nextSourcePosition = 0;
      for (var i2 = 0; i2 < results.length; i2++) {
        result = results[i2];
        var matched = toString$5(result[0]);
        var position2 = max$1(min$3(toIntegerOrInfinity(result.index), S2.length), 0);
        var captures = [];
        for (var j2 = 1; j2 < result.length; j2++)
          push$1(captures, maybeToString(result[j2]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = concat([matched], captures, position2, S2);
          if (namedCaptures !== void 0)
            push$1(replacerArgs, namedCaptures);
          var replacement2 = toString$5(apply$1(replaceValue, void 0, replacerArgs));
        } else {
          replacement2 = getSubstitution(matched, S2, position2, captures, namedCaptures, replaceValue);
        }
        if (position2 >= nextSourcePosition) {
          accumulatedResult += stringSlice$2(S2, nextSourcePosition, position2) + replacement2;
          nextSourcePosition = position2 + matched.length;
        }
      }
      return accumulatedResult + stringSlice$2(S2, nextSourcePosition);
    }
  ];
}, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);
var isObject = isObject$8;
var classof$1 = classofRaw$1;
var wellKnownSymbol$5 = wellKnownSymbol$i;
var MATCH$1 = wellKnownSymbol$5("match");
var isRegexp = function(it2) {
  var isRegExp2;
  return isObject(it2) && ((isRegExp2 = it2[MATCH$1]) !== void 0 ? !!isRegExp2 : classof$1(it2) == "RegExp");
};
var global$5 = global$I;
var isRegExp$1 = isRegexp;
var TypeError$2 = global$5.TypeError;
var notARegexp = function(it2) {
  if (isRegExp$1(it2)) {
    throw TypeError$2("The method doesn't accept regular expressions");
  }
  return it2;
};
var wellKnownSymbol$4 = wellKnownSymbol$i;
var MATCH = wellKnownSymbol$4("match");
var correctIsRegexpLogic = function(METHOD_NAME) {
  var regexp = /./;
  try {
    "/./"[METHOD_NAME](regexp);
  } catch (error1) {
    try {
      regexp[MATCH] = false;
      return "/./"[METHOD_NAME](regexp);
    } catch (error2) {
    }
  }
  return false;
};
var $$7 = _export;
var uncurryThis$7 = functionUncurryThis;
var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
var toLength$2 = toLength$6;
var toString$4 = toString$9;
var notARegExp$2 = notARegexp;
var requireObjectCoercible$4 = requireObjectCoercible$a;
var correctIsRegExpLogic$2 = correctIsRegexpLogic;
var un$StartsWith = uncurryThis$7("".startsWith);
var stringSlice$1 = uncurryThis$7("".slice);
var min$2 = Math.min;
var CORRECT_IS_REGEXP_LOGIC$1 = correctIsRegExpLogic$2("startsWith");
var MDN_POLYFILL_BUG$1 = !CORRECT_IS_REGEXP_LOGIC$1 && !!function() {
  var descriptor = getOwnPropertyDescriptor$1(String.prototype, "startsWith");
  return descriptor && !descriptor.writable;
}();
$$7({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG$1 && !CORRECT_IS_REGEXP_LOGIC$1 }, {
  startsWith: function startsWith(searchString) {
    var that = toString$4(requireObjectCoercible$4(this));
    notARegExp$2(searchString);
    var index2 = toLength$2(min$2(arguments.length > 1 ? arguments[1] : void 0, that.length));
    var search = toString$4(searchString);
    return un$StartsWith ? un$StartsWith(that, search, index2) : stringSlice$1(that, index2, index2 + search.length) === search;
  }
});
var wellKnownSymbol$3 = wellKnownSymbol$i;
var create$1 = objectCreate;
var definePropertyModule$1 = objectDefineProperty;
var UNSCOPABLES = wellKnownSymbol$3("unscopables");
var ArrayPrototype = Array.prototype;
if (ArrayPrototype[UNSCOPABLES] == void 0) {
  definePropertyModule$1.f(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: create$1(null)
  });
}
var addToUnscopables$1 = function(key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};
var fails$5 = fails$k;
var correctPrototypeGetter = !fails$5(function() {
  function F2() {
  }
  F2.prototype.constructor = null;
  return Object.getPrototypeOf(new F2()) !== F2.prototype;
});
var global$4 = global$I;
var hasOwn2 = hasOwnProperty_1;
var isCallable$2 = isCallable$j;
var toObject$1 = toObject$4;
var sharedKey = sharedKey$3;
var CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;
var IE_PROTO = sharedKey("IE_PROTO");
var Object$1 = global$4.Object;
var ObjectPrototype = Object$1.prototype;
var objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? Object$1.getPrototypeOf : function(O2) {
  var object = toObject$1(O2);
  if (hasOwn2(object, IE_PROTO))
    return object[IE_PROTO];
  var constructor = object.constructor;
  if (isCallable$2(constructor) && object instanceof constructor) {
    return constructor.prototype;
  }
  return object instanceof Object$1 ? ObjectPrototype : null;
};
var fails$4 = fails$k;
var isCallable$1 = isCallable$j;
var getPrototypeOf$1 = objectGetPrototypeOf;
var redefine$2 = redefine$7.exports;
var wellKnownSymbol$2 = wellKnownSymbol$i;
var ITERATOR$2 = wellKnownSymbol$2("iterator");
var BUGGY_SAFARI_ITERATORS$1 = false;
var IteratorPrototype$2, PrototypeOfArrayIteratorPrototype, arrayIterator;
if ([].keys) {
  arrayIterator = [].keys();
  if (!("next" in arrayIterator))
    BUGGY_SAFARI_ITERATORS$1 = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf$1(getPrototypeOf$1(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
      IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;
  }
}
var NEW_ITERATOR_PROTOTYPE = IteratorPrototype$2 == void 0 || fails$4(function() {
  var test2 = {};
  return IteratorPrototype$2[ITERATOR$2].call(test2) !== test2;
});
if (NEW_ITERATOR_PROTOTYPE)
  IteratorPrototype$2 = {};
if (!isCallable$1(IteratorPrototype$2[ITERATOR$2])) {
  redefine$2(IteratorPrototype$2, ITERATOR$2, function() {
    return this;
  });
}
var iteratorsCore = {
  IteratorPrototype: IteratorPrototype$2,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
};
var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;
var create2 = objectCreate;
var createPropertyDescriptor$1 = createPropertyDescriptor$4;
var setToStringTag$1 = setToStringTag$3;
var Iterators$2 = iterators;
var returnThis$1 = function() {
  return this;
};
var createIteratorConstructor$1 = function(IteratorConstructor, NAME2, next3, ENUMERABLE_NEXT) {
  var TO_STRING_TAG2 = NAME2 + " Iterator";
  IteratorConstructor.prototype = create2(IteratorPrototype$1, { next: createPropertyDescriptor$1(+!ENUMERABLE_NEXT, next3) });
  setToStringTag$1(IteratorConstructor, TO_STRING_TAG2, false);
  Iterators$2[TO_STRING_TAG2] = returnThis$1;
  return IteratorConstructor;
};
var $$6 = _export;
var call$1 = functionCall;
var FunctionName = functionName;
var isCallable = isCallable$j;
var createIteratorConstructor = createIteratorConstructor$1;
var getPrototypeOf = objectGetPrototypeOf;
var setPrototypeOf = objectSetPrototypeOf;
var setToStringTag = setToStringTag$3;
var createNonEnumerableProperty$1 = createNonEnumerableProperty$6;
var redefine$1 = redefine$7.exports;
var wellKnownSymbol$1 = wellKnownSymbol$i;
var Iterators$1 = iterators;
var IteratorsCore = iteratorsCore;
var PROPER_FUNCTION_NAME$2 = FunctionName.PROPER;
var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR$1 = wellKnownSymbol$1("iterator");
var KEYS = "keys";
var VALUES = "values";
var ENTRIES = "entries";
var returnThis = function() {
  return this;
};
var defineIterator$1 = function(Iterable, NAME2, IteratorConstructor, next3, DEFAULT2, IS_SET, FORCED2) {
  createIteratorConstructor(IteratorConstructor, NAME2, next3);
  var getIterationMethod = function(KIND) {
    if (KIND === DEFAULT2 && defaultIterator)
      return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
      return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS:
        return function keys3() {
          return new IteratorConstructor(this, KIND);
        };
      case VALUES:
        return function values3() {
          return new IteratorConstructor(this, KIND);
        };
      case ENTRIES:
        return function entries() {
          return new IteratorConstructor(this, KIND);
        };
    }
    return function() {
      return new IteratorConstructor(this);
    };
  };
  var TO_STRING_TAG2 = NAME2 + " Iterator";
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR$1] || IterablePrototype["@@iterator"] || DEFAULT2 && IterablePrototype[DEFAULT2];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT2);
  var anyNativeIterator = NAME2 == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf) {
          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (!isCallable(CurrentIteratorPrototype[ITERATOR$1])) {
          redefine$1(CurrentIteratorPrototype, ITERATOR$1, returnThis);
        }
      }
      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG2, true);
    }
  }
  if (PROPER_FUNCTION_NAME$2 && DEFAULT2 == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    if (CONFIGURABLE_FUNCTION_NAME) {
      createNonEnumerableProperty$1(IterablePrototype, "name", VALUES);
    } else {
      INCORRECT_VALUES_NAME = true;
      defaultIterator = function values3() {
        return call$1(nativeIterator, this);
      };
    }
  }
  if (DEFAULT2) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED2)
      for (KEY in methods) {
        if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
          redefine$1(IterablePrototype, KEY, methods[KEY]);
        }
      }
    else
      $$6({ target: NAME2, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }
  if (IterablePrototype[ITERATOR$1] !== defaultIterator) {
    redefine$1(IterablePrototype, ITERATOR$1, defaultIterator, { name: DEFAULT2 });
  }
  Iterators$1[NAME2] = defaultIterator;
  return methods;
};
var toIndexedObject = toIndexedObject$5;
var addToUnscopables = addToUnscopables$1;
var Iterators = iterators;
var InternalStateModule = internalState;
var defineProperty3 = objectDefineProperty.f;
var defineIterator = defineIterator$1;
var DESCRIPTORS = descriptors;
var ARRAY_ITERATOR = "Array Iterator";
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
var es_array_iterator = defineIterator(Array, "Array", function(iterated, kind) {
  setInternalState(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated),
    index: 0,
    kind
  });
}, function() {
  var state = getInternalState(this);
  var target = state.target;
  var kind = state.kind;
  var index2 = state.index++;
  if (!target || index2 >= target.length) {
    state.target = void 0;
    return { value: void 0, done: true };
  }
  if (kind == "keys")
    return { value: index2, done: false };
  if (kind == "values")
    return { value: target[index2], done: false };
  return { value: [index2, target[index2]], done: false };
}, "values");
var values2 = Iterators.Arguments = Iterators.Array;
addToUnscopables("keys");
addToUnscopables("values");
addToUnscopables("entries");
if (DESCRIPTORS && values2.name !== "values")
  try {
    defineProperty3(values2, "name", { value: "values" });
  } catch (error) {
  }
var domIterables = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};
var documentCreateElement = documentCreateElement$2;
var classList = documentCreateElement("span").classList;
var DOMTokenListPrototype$1 = classList && classList.constructor && classList.constructor.prototype;
var domTokenListPrototype = DOMTokenListPrototype$1 === Object.prototype ? void 0 : DOMTokenListPrototype$1;
var global$3 = global$I;
var DOMIterables = domIterables;
var DOMTokenListPrototype = domTokenListPrototype;
var ArrayIteratorMethods = es_array_iterator;
var createNonEnumerableProperty = createNonEnumerableProperty$6;
var wellKnownSymbol = wellKnownSymbol$i;
var ITERATOR = wellKnownSymbol("iterator");
var TO_STRING_TAG = wellKnownSymbol("toStringTag");
var ArrayValues = ArrayIteratorMethods.values;
var handlePrototype = function(CollectionPrototype, COLLECTION_NAME) {
  if (CollectionPrototype) {
    if (CollectionPrototype[ITERATOR] !== ArrayValues)
      try {
        createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
      } catch (error) {
        CollectionPrototype[ITERATOR] = ArrayValues;
      }
    if (!CollectionPrototype[TO_STRING_TAG]) {
      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
    }
    if (DOMIterables[COLLECTION_NAME])
      for (var METHOD_NAME in ArrayIteratorMethods) {
        if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME])
          try {
            createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
          } catch (error) {
            CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
          }
      }
  }
};
for (var COLLECTION_NAME in DOMIterables) {
  handlePrototype(global$3[COLLECTION_NAME] && global$3[COLLECTION_NAME].prototype, COLLECTION_NAME);
}
handlePrototype(DOMTokenListPrototype, "DOMTokenList");
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var global$2 = global$I;
var aCallable = aCallable$6;
var toObject = toObject$4;
var IndexedObject = indexedObject;
var lengthOfArrayLike$1 = lengthOfArrayLike$4;
var TypeError$1 = global$2.TypeError;
var createMethod$1 = function(IS_RIGHT) {
  return function(that, callbackfn, argumentsLength, memo) {
    aCallable(callbackfn);
    var O2 = toObject(that);
    var self2 = IndexedObject(O2);
    var length = lengthOfArrayLike$1(O2);
    var index2 = IS_RIGHT ? length - 1 : 0;
    var i2 = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2)
      while (true) {
        if (index2 in self2) {
          memo = self2[index2];
          index2 += i2;
          break;
        }
        index2 += i2;
        if (IS_RIGHT ? index2 < 0 : length <= index2) {
          throw TypeError$1("Reduce of empty array with no initial value");
        }
      }
    for (; IS_RIGHT ? index2 >= 0 : length > index2; index2 += i2)
      if (index2 in self2) {
        memo = callbackfn(memo, self2[index2], index2, O2);
      }
    return memo;
  };
};
var arrayReduce = {
  left: createMethod$1(false),
  right: createMethod$1(true)
};
var fails$3 = fails$k;
var arrayMethodIsStrict$2 = function(METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails$3(function() {
    method.call(null, argument || function() {
      throw 1;
    }, 1);
  });
};
var $$5 = _export;
var $reduce = arrayReduce.left;
var arrayMethodIsStrict$1 = arrayMethodIsStrict$2;
var CHROME_VERSION = engineV8Version;
var IS_NODE = engineIsNode;
var STRICT_METHOD$1 = arrayMethodIsStrict$1("reduce");
var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;
$$5({ target: "Array", proto: true, forced: !STRICT_METHOD$1 || CHROME_BUG }, {
  reduce: function reduce(callbackfn) {
    var length = arguments.length;
    return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : void 0);
  }
});
var $$4 = _export;
var uncurryThis$6 = functionUncurryThis;
var getOwnPropertyDescriptor2 = objectGetOwnPropertyDescriptor.f;
var toLength$1 = toLength$6;
var toString$3 = toString$9;
var notARegExp$1 = notARegexp;
var requireObjectCoercible$3 = requireObjectCoercible$a;
var correctIsRegExpLogic$1 = correctIsRegexpLogic;
var un$EndsWith = uncurryThis$6("".endsWith);
var slice = uncurryThis$6("".slice);
var min$1 = Math.min;
var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic$1("endsWith");
var MDN_POLYFILL_BUG = !CORRECT_IS_REGEXP_LOGIC && !!function() {
  var descriptor = getOwnPropertyDescriptor2(String.prototype, "endsWith");
  return descriptor && !descriptor.writable;
}();
$$4({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
  endsWith: function endsWith(searchString) {
    var that = toString$3(requireObjectCoercible$3(this));
    notARegExp$1(searchString);
    var endPosition = arguments.length > 1 ? arguments[1] : void 0;
    var len = that.length;
    var end = endPosition === void 0 ? len : min$1(toLength$1(endPosition), len);
    var search = toString$3(searchString);
    return un$EndsWith ? un$EndsWith(that, search, end) : slice(that, end - search.length, end) === search;
  }
});
var toPropertyKey = toPropertyKey$3;
var definePropertyModule = objectDefineProperty;
var createPropertyDescriptor = createPropertyDescriptor$4;
var createProperty$1 = function(object, key, value) {
  var propertyKey = toPropertyKey(key);
  if (propertyKey in object)
    definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
  else
    object[propertyKey] = value;
};
var global$1 = global$I;
var toAbsoluteIndex = toAbsoluteIndex$2;
var lengthOfArrayLike = lengthOfArrayLike$4;
var createProperty = createProperty$1;
var Array$1 = global$1.Array;
var max = Math.max;
var arraySliceSimple = function(O2, start2, end) {
  var length = lengthOfArrayLike(O2);
  var k2 = toAbsoluteIndex(start2, length);
  var fin = toAbsoluteIndex(end === void 0 ? length : end, length);
  var result = Array$1(max(fin - k2, 0));
  for (var n2 = 0; k2 < fin; k2++, n2++)
    createProperty(result, n2, O2[k2]);
  result.length = n2;
  return result;
};
var apply = functionApply;
var call = functionCall;
var uncurryThis$5 = functionUncurryThis;
var fixRegExpWellKnownSymbolLogic = fixRegexpWellKnownSymbolLogic;
var isRegExp = isRegexp;
var anObject$1 = anObject$g;
var requireObjectCoercible$2 = requireObjectCoercible$a;
var speciesConstructor = speciesConstructor$2;
var advanceStringIndex = advanceStringIndex$3;
var toLength = toLength$6;
var toString$2 = toString$9;
var getMethod = getMethod$6;
var arraySlice = arraySliceSimple;
var callRegExpExec = regexpExecAbstract;
var regexpExec = regexpExec$3;
var stickyHelpers = regexpStickyHelpers;
var fails$2 = fails$k;
var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
var MAX_UINT32 = 4294967295;
var min = Math.min;
var $push = [].push;
var exec = uncurryThis$5(/./.exec);
var push = uncurryThis$5($push);
var stringSlice = uncurryThis$5("".slice);
var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails$2(function() {
  var re2 = /(?:)/;
  var originalExec = re2.exec;
  re2.exec = function() {
    return originalExec.apply(this, arguments);
  };
  var result = "ab".split(re2);
  return result.length !== 2 || result[0] !== "a" || result[1] !== "b";
});
fixRegExpWellKnownSymbolLogic("split", function(SPLIT, nativeSplit, maybeCallNative) {
  var internalSplit;
  if ("abbc".split(/(b)*/)[1] == "c" || "test".split(/(?:)/, -1).length != 4 || "ab".split(/(?:ab)*/).length != 2 || ".".split(/(.?)(.?)/).length != 4 || ".".split(/()()/).length > 1 || "".split(/.?/).length) {
    internalSplit = function(separator, limit) {
      var string = toString$2(requireObjectCoercible$2(this));
      var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
      if (lim === 0)
        return [];
      if (separator === void 0)
        return [string];
      if (!isRegExp(separator)) {
        return call(nativeSplit, string, separator, lim);
      }
      var output = [];
      var flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.unicode ? "u" : "") + (separator.sticky ? "y" : "");
      var lastLastIndex = 0;
      var separatorCopy = new RegExp(separator.source, flags + "g");
      var match2, lastIndex, lastLength;
      while (match2 = call(regexpExec, separatorCopy, string)) {
        lastIndex = separatorCopy.lastIndex;
        if (lastIndex > lastLastIndex) {
          push(output, stringSlice(string, lastLastIndex, match2.index));
          if (match2.length > 1 && match2.index < string.length)
            apply($push, output, arraySlice(match2, 1));
          lastLength = match2[0].length;
          lastLastIndex = lastIndex;
          if (output.length >= lim)
            break;
        }
        if (separatorCopy.lastIndex === match2.index)
          separatorCopy.lastIndex++;
      }
      if (lastLastIndex === string.length) {
        if (lastLength || !exec(separatorCopy, ""))
          push(output, "");
      } else
        push(output, stringSlice(string, lastLastIndex));
      return output.length > lim ? arraySlice(output, 0, lim) : output;
    };
  } else if ("0".split(void 0, 0).length) {
    internalSplit = function(separator, limit) {
      return separator === void 0 && limit === 0 ? [] : call(nativeSplit, this, separator, limit);
    };
  } else
    internalSplit = nativeSplit;
  return [
    function split2(separator, limit) {
      var O2 = requireObjectCoercible$2(this);
      var splitter = separator == void 0 ? void 0 : getMethod(separator, SPLIT);
      return splitter ? call(splitter, separator, O2, limit) : call(internalSplit, toString$2(O2), separator, limit);
    },
    function(string, limit) {
      var rx = anObject$1(this);
      var S2 = toString$2(string);
      var res = maybeCallNative(internalSplit, rx, S2, limit, internalSplit !== nativeSplit);
      if (res.done)
        return res.value;
      var C2 = speciesConstructor(rx, RegExp);
      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? "i" : "") + (rx.multiline ? "m" : "") + (rx.unicode ? "u" : "") + (UNSUPPORTED_Y ? "g" : "y");
      var splitter = new C2(UNSUPPORTED_Y ? "^(?:" + rx.source + ")" : rx, flags);
      var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
      if (lim === 0)
        return [];
      if (S2.length === 0)
        return callRegExpExec(splitter, S2) === null ? [S2] : [];
      var p5 = 0;
      var q2 = 0;
      var A2 = [];
      while (q2 < S2.length) {
        splitter.lastIndex = UNSUPPORTED_Y ? 0 : q2;
        var z2 = callRegExpExec(splitter, UNSUPPORTED_Y ? stringSlice(S2, q2) : S2);
        var e2;
        if (z2 === null || (e2 = min(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q2 : 0)), S2.length)) === p5) {
          q2 = advanceStringIndex(S2, q2, unicodeMatching);
        } else {
          push(A2, stringSlice(S2, p5, q2));
          if (A2.length === lim)
            return A2;
          for (var i2 = 1; i2 <= z2.length - 1; i2++) {
            push(A2, z2[i2]);
            if (A2.length === lim)
              return A2;
          }
          q2 = p5 = e2;
        }
      }
      push(A2, stringSlice(S2, p5));
      return A2;
    }
  ];
}, !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);
var raf$1 = { exports: {} };
var performanceNow = { exports: {} };
(function() {
  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;
  if (typeof performance !== "undefined" && performance !== null && performance.now) {
    performanceNow.exports = function() {
      return performance.now();
    };
  } else if (typeof process !== "undefined" && process !== null && process.hrtime) {
    performanceNow.exports = function() {
      return (getNanoSeconds() - nodeLoadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    moduleLoadTime = getNanoSeconds();
    upTime = process.uptime() * 1e9;
    nodeLoadTime = moduleLoadTime - upTime;
  } else if (Date.now) {
    performanceNow.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    performanceNow.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }
}).call(commonjsGlobal);
var now = performanceNow.exports, root = typeof window === "undefined" ? commonjsGlobal : window, vendors = ["moz", "webkit"], suffix = "AnimationFrame", raf = root["request" + suffix], caf = root["cancel" + suffix] || root["cancelRequest" + suffix];
for (var i$1 = 0; !raf && i$1 < vendors.length; i$1++) {
  raf = root[vendors[i$1] + "Request" + suffix];
  caf = root[vendors[i$1] + "Cancel" + suffix] || root[vendors[i$1] + "CancelRequest" + suffix];
}
if (!raf || !caf) {
  var last = 0, id = 0, queue = [], frameDuration = 1e3 / 60;
  raf = function(callback) {
    if (queue.length === 0) {
      var _now = now(), next3 = Math.max(0, frameDuration - (_now - last));
      last = next3 + _now;
      setTimeout(function() {
        var cp = queue.slice(0);
        queue.length = 0;
        for (var i2 = 0; i2 < cp.length; i2++) {
          if (!cp[i2].cancelled) {
            try {
              cp[i2].callback(last);
            } catch (e2) {
              setTimeout(function() {
                throw e2;
              }, 0);
            }
          }
        }
      }, Math.round(next3));
    }
    queue.push({
      handle: ++id,
      callback,
      cancelled: false
    });
    return id;
  };
  caf = function(handle) {
    for (var i2 = 0; i2 < queue.length; i2++) {
      if (queue[i2].handle === handle) {
        queue[i2].cancelled = true;
      }
    }
  };
}
raf$1.exports = function(fn) {
  return raf.call(root, fn);
};
raf$1.exports.cancel = function() {
  caf.apply(root, arguments);
};
raf$1.exports.polyfill = function(object) {
  if (!object) {
    object = root;
  }
  object.requestAnimationFrame = raf;
  object.cancelAnimationFrame = caf;
};
var requestAnimationFrame$1 = raf$1.exports;
var whitespaces$2 = "	\n\v\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";
var uncurryThis$4 = functionUncurryThis;
var requireObjectCoercible$1 = requireObjectCoercible$a;
var toString$1 = toString$9;
var whitespaces$1 = whitespaces$2;
var replace = uncurryThis$4("".replace);
var whitespace = "[" + whitespaces$1 + "]";
var ltrim = RegExp("^" + whitespace + whitespace + "*");
var rtrim = RegExp(whitespace + whitespace + "*$");
var createMethod = function(TYPE2) {
  return function($this) {
    var string = toString$1(requireObjectCoercible$1($this));
    if (TYPE2 & 1)
      string = replace(string, ltrim, "");
    if (TYPE2 & 2)
      string = replace(string, rtrim, "");
    return string;
  };
};
var stringTrim = {
  start: createMethod(1),
  end: createMethod(2),
  trim: createMethod(3)
};
var PROPER_FUNCTION_NAME$1 = functionName.PROPER;
var fails$1 = fails$k;
var whitespaces = whitespaces$2;
var non = "\u200B\x85\u180E";
var stringTrimForced = function(METHOD_NAME) {
  return fails$1(function() {
    return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() !== non || PROPER_FUNCTION_NAME$1 && whitespaces[METHOD_NAME].name !== METHOD_NAME;
  });
};
var $$3 = _export;
var $trim = stringTrim.trim;
var forcedStringTrimMethod = stringTrimForced;
$$3({ target: "String", proto: true, forced: forcedStringTrimMethod("trim") }, {
  trim: function trim2() {
    return $trim(this);
  }
});
var rgbcolor = function(color_string) {
  this.ok = false;
  this.alpha = 1;
  if (color_string.charAt(0) == "#") {
    color_string = color_string.substr(1, 6);
  }
  color_string = color_string.replace(/ /g, "");
  color_string = color_string.toLowerCase();
  var simple_colors = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "00ffff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000000",
    blanchedalmond: "ffebcd",
    blue: "0000ff",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "00ffff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dodgerblue: "1e90ff",
    feldspar: "d19275",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "ff00ff",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgrey: "d3d3d3",
    lightgreen: "90ee90",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslateblue: "8470ff",
    lightslategray: "778899",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "00ff00",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "ff00ff",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370d8",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "d87093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    rebeccapurple: "663399",
    red: "ff0000",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    violetred: "d02090",
    wheat: "f5deb3",
    white: "ffffff",
    whitesmoke: "f5f5f5",
    yellow: "ffff00",
    yellowgreen: "9acd32"
  };
  color_string = simple_colors[color_string] || color_string;
  var color_defs = [
    {
      re: /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*((?:\d?\.)?\d)\)$/,
      example: ["rgba(123, 234, 45, 0.8)", "rgba(255,234,245,1.0)"],
      process: function(bits3) {
        return [
          parseInt(bits3[1]),
          parseInt(bits3[2]),
          parseInt(bits3[3]),
          parseFloat(bits3[4])
        ];
      }
    },
    {
      re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
      example: ["rgb(123, 234, 45)", "rgb(255,234,245)"],
      process: function(bits3) {
        return [
          parseInt(bits3[1]),
          parseInt(bits3[2]),
          parseInt(bits3[3])
        ];
      }
    },
    {
      re: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
      example: ["#00ff00", "336699"],
      process: function(bits3) {
        return [
          parseInt(bits3[1], 16),
          parseInt(bits3[2], 16),
          parseInt(bits3[3], 16)
        ];
      }
    },
    {
      re: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      example: ["#fb0", "f0f"],
      process: function(bits3) {
        return [
          parseInt(bits3[1] + bits3[1], 16),
          parseInt(bits3[2] + bits3[2], 16),
          parseInt(bits3[3] + bits3[3], 16)
        ];
      }
    }
  ];
  for (var i2 = 0; i2 < color_defs.length; i2++) {
    var re2 = color_defs[i2].re;
    var processor = color_defs[i2].process;
    var bits2 = re2.exec(color_string);
    if (bits2) {
      var channels = processor(bits2);
      this.r = channels[0];
      this.g = channels[1];
      this.b = channels[2];
      if (channels.length > 3) {
        this.alpha = channels[3];
      }
      this.ok = true;
    }
  }
  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r;
  this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g;
  this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b;
  this.alpha = this.alpha < 0 ? 0 : this.alpha > 1 || isNaN(this.alpha) ? 1 : this.alpha;
  this.toRGB = function() {
    return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
  };
  this.toRGBA = function() {
    return "rgba(" + this.r + ", " + this.g + ", " + this.b + ", " + this.alpha + ")";
  };
  this.toHex = function() {
    var r2 = this.r.toString(16);
    var g2 = this.g.toString(16);
    var b2 = this.b.toString(16);
    if (r2.length == 1)
      r2 = "0" + r2;
    if (g2.length == 1)
      g2 = "0" + g2;
    if (b2.length == 1)
      b2 = "0" + b2;
    return "#" + r2 + g2 + b2;
  };
  this.getHelpXML = function() {
    var examples = new Array();
    for (var i3 = 0; i3 < color_defs.length; i3++) {
      var example = color_defs[i3].example;
      for (var j2 = 0; j2 < example.length; j2++) {
        examples[examples.length] = example[j2];
      }
    }
    for (var sc in simple_colors) {
      examples[examples.length] = sc;
    }
    var xml2 = document.createElement("ul");
    xml2.setAttribute("id", "rgbcolor-examples");
    for (var i3 = 0; i3 < examples.length; i3++) {
      try {
        var list_item = document.createElement("li");
        var list_color = new RGBColor(examples[i3]);
        var example_div = document.createElement("div");
        example_div.style.cssText = "margin: 3px; border: 1px solid black; background:" + list_color.toHex() + "; color:" + list_color.toHex();
        example_div.appendChild(document.createTextNode("test"));
        var list_item_value = document.createTextNode(" " + examples[i3] + " -> " + list_color.toRGB() + " -> " + list_color.toHex());
        list_item.appendChild(example_div);
        list_item.appendChild(list_item_value);
        xml2.appendChild(list_item);
      } catch (e2) {
      }
    }
    return xml2;
  };
};
var $$2 = _export;
var uncurryThis$3 = functionUncurryThis;
var notARegExp = notARegexp;
var requireObjectCoercible = requireObjectCoercible$a;
var toString2 = toString$9;
var correctIsRegExpLogic = correctIsRegexpLogic;
var stringIndexOf = uncurryThis$3("".indexOf);
$$2({ target: "String", proto: true, forced: !correctIsRegExpLogic("includes") }, {
  includes: function includes(searchString) {
    return !!~stringIndexOf(toString2(requireObjectCoercible(this)), toString2(notARegExp(searchString)), arguments.length > 1 ? arguments[1] : void 0);
  }
});
var $$1 = _export;
var uncurryThis$2 = functionUncurryThis;
var $IndexOf = arrayIncludes.indexOf;
var arrayMethodIsStrict = arrayMethodIsStrict$2;
var un$IndexOf = uncurryThis$2([].indexOf);
var NEGATIVE_ZERO = !!un$IndexOf && 1 / un$IndexOf([1], 1, -0) < 0;
var STRICT_METHOD = arrayMethodIsStrict("indexOf");
$$1({ target: "Array", proto: true, forced: NEGATIVE_ZERO || !STRICT_METHOD }, {
  indexOf: function indexOf2(searchElement) {
    var fromIndex = arguments.length > 1 ? arguments[1] : void 0;
    return NEGATIVE_ZERO ? un$IndexOf(this, searchElement, fromIndex) || 0 : $IndexOf(this, searchElement, fromIndex);
  }
});
var classof = classofRaw$1;
var isArray$1 = Array.isArray || function isArray(argument) {
  return classof(argument) == "Array";
};
var $ = _export;
var uncurryThis$1 = functionUncurryThis;
var isArray2 = isArray$1;
var un$Reverse = uncurryThis$1([].reverse);
var test = [1, 2];
$({ target: "Array", proto: true, forced: String(test) === String(test.reverse()) }, {
  reverse: function reverse() {
    if (isArray2(this))
      this.length = this.length;
    return un$Reverse(this);
  }
});
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var t2 = function(r2, e2) {
  return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, r3) {
    t3.__proto__ = r3;
  } || function(t3, r3) {
    for (var e3 in r3)
      Object.prototype.hasOwnProperty.call(r3, e3) && (t3[e3] = r3[e3]);
  })(r2, e2);
};
function r(r2, e2) {
  if (typeof e2 != "function" && e2 !== null)
    throw new TypeError("Class extends value " + String(e2) + " is not a constructor or null");
  function i2() {
    this.constructor = r2;
  }
  t2(r2, e2), r2.prototype = e2 === null ? Object.create(e2) : (i2.prototype = e2.prototype, new i2());
}
function e(t3) {
  var r2 = "";
  Array.isArray(t3) || (t3 = [t3]);
  for (var e2 = 0; e2 < t3.length; e2++) {
    var i2 = t3[e2];
    if (i2.type === _.CLOSE_PATH)
      r2 += "z";
    else if (i2.type === _.HORIZ_LINE_TO)
      r2 += (i2.relative ? "h" : "H") + i2.x;
    else if (i2.type === _.VERT_LINE_TO)
      r2 += (i2.relative ? "v" : "V") + i2.y;
    else if (i2.type === _.MOVE_TO)
      r2 += (i2.relative ? "m" : "M") + i2.x + " " + i2.y;
    else if (i2.type === _.LINE_TO)
      r2 += (i2.relative ? "l" : "L") + i2.x + " " + i2.y;
    else if (i2.type === _.CURVE_TO)
      r2 += (i2.relative ? "c" : "C") + i2.x1 + " " + i2.y1 + " " + i2.x2 + " " + i2.y2 + " " + i2.x + " " + i2.y;
    else if (i2.type === _.SMOOTH_CURVE_TO)
      r2 += (i2.relative ? "s" : "S") + i2.x2 + " " + i2.y2 + " " + i2.x + " " + i2.y;
    else if (i2.type === _.QUAD_TO)
      r2 += (i2.relative ? "q" : "Q") + i2.x1 + " " + i2.y1 + " " + i2.x + " " + i2.y;
    else if (i2.type === _.SMOOTH_QUAD_TO)
      r2 += (i2.relative ? "t" : "T") + i2.x + " " + i2.y;
    else {
      if (i2.type !== _.ARC)
        throw new Error('Unexpected command type "' + i2.type + '" at index ' + e2 + ".");
      r2 += (i2.relative ? "a" : "A") + i2.rX + " " + i2.rY + " " + i2.xRot + " " + +i2.lArcFlag + " " + +i2.sweepFlag + " " + i2.x + " " + i2.y;
    }
  }
  return r2;
}
function i(t3, r2) {
  var e2 = t3[0], i2 = t3[1];
  return [e2 * Math.cos(r2) - i2 * Math.sin(r2), e2 * Math.sin(r2) + i2 * Math.cos(r2)];
}
function a() {
  for (var t3 = [], r2 = 0; r2 < arguments.length; r2++)
    t3[r2] = arguments[r2];
  for (var e2 = 0; e2 < t3.length; e2++)
    if (typeof t3[e2] != "number")
      throw new Error("assertNumbers arguments[" + e2 + "] is not a number. " + typeof t3[e2] + " == typeof " + t3[e2]);
  return true;
}
var n = Math.PI;
function o(t3, r2, e2) {
  t3.lArcFlag = t3.lArcFlag === 0 ? 0 : 1, t3.sweepFlag = t3.sweepFlag === 0 ? 0 : 1;
  var a2 = t3.rX, o2 = t3.rY, s2 = t3.x, u2 = t3.y;
  a2 = Math.abs(t3.rX), o2 = Math.abs(t3.rY);
  var h2 = i([(r2 - s2) / 2, (e2 - u2) / 2], -t3.xRot / 180 * n), c2 = h2[0], y2 = h2[1], p5 = Math.pow(c2, 2) / Math.pow(a2, 2) + Math.pow(y2, 2) / Math.pow(o2, 2);
  1 < p5 && (a2 *= Math.sqrt(p5), o2 *= Math.sqrt(p5)), t3.rX = a2, t3.rY = o2;
  var m2 = Math.pow(a2, 2) * Math.pow(y2, 2) + Math.pow(o2, 2) * Math.pow(c2, 2), O2 = (t3.lArcFlag !== t3.sweepFlag ? 1 : -1) * Math.sqrt(Math.max(0, (Math.pow(a2, 2) * Math.pow(o2, 2) - m2) / m2)), l2 = a2 * y2 / o2 * O2, T2 = -o2 * c2 / a2 * O2, v2 = i([l2, T2], t3.xRot / 180 * n);
  t3.cX = v2[0] + (r2 + s2) / 2, t3.cY = v2[1] + (e2 + u2) / 2, t3.phi1 = Math.atan2((y2 - T2) / o2, (c2 - l2) / a2), t3.phi2 = Math.atan2((-y2 - T2) / o2, (-c2 - l2) / a2), t3.sweepFlag === 0 && t3.phi2 > t3.phi1 && (t3.phi2 -= 2 * n), t3.sweepFlag === 1 && t3.phi2 < t3.phi1 && (t3.phi2 += 2 * n), t3.phi1 *= 180 / n, t3.phi2 *= 180 / n;
}
function s(t3, r2, e2) {
  a(t3, r2, e2);
  var i2 = t3 * t3 + r2 * r2 - e2 * e2;
  if (0 > i2)
    return [];
  if (i2 === 0)
    return [[t3 * e2 / (t3 * t3 + r2 * r2), r2 * e2 / (t3 * t3 + r2 * r2)]];
  var n2 = Math.sqrt(i2);
  return [[(t3 * e2 + r2 * n2) / (t3 * t3 + r2 * r2), (r2 * e2 - t3 * n2) / (t3 * t3 + r2 * r2)], [(t3 * e2 - r2 * n2) / (t3 * t3 + r2 * r2), (r2 * e2 + t3 * n2) / (t3 * t3 + r2 * r2)]];
}
var u, h = Math.PI / 180;
function c$1(t3, r2, e2) {
  return (1 - e2) * t3 + e2 * r2;
}
function y(t3, r2, e2, i2) {
  return t3 + Math.cos(i2 / 180 * n) * r2 + Math.sin(i2 / 180 * n) * e2;
}
function p(t3, r2, e2, i2) {
  var a2 = 1e-6, n2 = r2 - t3, o2 = e2 - r2, s2 = 3 * n2 + 3 * (i2 - e2) - 6 * o2, u2 = 6 * (o2 - n2), h2 = 3 * n2;
  return Math.abs(s2) < a2 ? [-h2 / u2] : function(t4, r3, e3) {
    e3 === void 0 && (e3 = 1e-6);
    var i3 = t4 * t4 / 4 - r3;
    if (i3 < -e3)
      return [];
    if (i3 <= e3)
      return [-t4 / 2];
    var a3 = Math.sqrt(i3);
    return [-t4 / 2 - a3, -t4 / 2 + a3];
  }(u2 / s2, h2 / s2, a2);
}
function m$1(t3, r2, e2, i2, a2) {
  var n2 = 1 - a2;
  return t3 * (n2 * n2 * n2) + r2 * (3 * n2 * n2 * a2) + e2 * (3 * n2 * a2 * a2) + i2 * (a2 * a2 * a2);
}
!function(t3) {
  function r2() {
    return u2(function(t4, r3, e3) {
      return t4.relative && (t4.x1 !== void 0 && (t4.x1 += r3), t4.y1 !== void 0 && (t4.y1 += e3), t4.x2 !== void 0 && (t4.x2 += r3), t4.y2 !== void 0 && (t4.y2 += e3), t4.x !== void 0 && (t4.x += r3), t4.y !== void 0 && (t4.y += e3), t4.relative = false), t4;
    });
  }
  function e2() {
    var t4 = NaN, r3 = NaN, e3 = NaN, i2 = NaN;
    return u2(function(a2, n3, o2) {
      return a2.type & _.SMOOTH_CURVE_TO && (a2.type = _.CURVE_TO, t4 = isNaN(t4) ? n3 : t4, r3 = isNaN(r3) ? o2 : r3, a2.x1 = a2.relative ? n3 - t4 : 2 * n3 - t4, a2.y1 = a2.relative ? o2 - r3 : 2 * o2 - r3), a2.type & _.CURVE_TO ? (t4 = a2.relative ? n3 + a2.x2 : a2.x2, r3 = a2.relative ? o2 + a2.y2 : a2.y2) : (t4 = NaN, r3 = NaN), a2.type & _.SMOOTH_QUAD_TO && (a2.type = _.QUAD_TO, e3 = isNaN(e3) ? n3 : e3, i2 = isNaN(i2) ? o2 : i2, a2.x1 = a2.relative ? n3 - e3 : 2 * n3 - e3, a2.y1 = a2.relative ? o2 - i2 : 2 * o2 - i2), a2.type & _.QUAD_TO ? (e3 = a2.relative ? n3 + a2.x1 : a2.x1, i2 = a2.relative ? o2 + a2.y1 : a2.y1) : (e3 = NaN, i2 = NaN), a2;
    });
  }
  function n2() {
    var t4 = NaN, r3 = NaN;
    return u2(function(e3, i2, a2) {
      if (e3.type & _.SMOOTH_QUAD_TO && (e3.type = _.QUAD_TO, t4 = isNaN(t4) ? i2 : t4, r3 = isNaN(r3) ? a2 : r3, e3.x1 = e3.relative ? i2 - t4 : 2 * i2 - t4, e3.y1 = e3.relative ? a2 - r3 : 2 * a2 - r3), e3.type & _.QUAD_TO) {
        t4 = e3.relative ? i2 + e3.x1 : e3.x1, r3 = e3.relative ? a2 + e3.y1 : e3.y1;
        var n3 = e3.x1, o2 = e3.y1;
        e3.type = _.CURVE_TO, e3.x1 = ((e3.relative ? 0 : i2) + 2 * n3) / 3, e3.y1 = ((e3.relative ? 0 : a2) + 2 * o2) / 3, e3.x2 = (e3.x + 2 * n3) / 3, e3.y2 = (e3.y + 2 * o2) / 3;
      } else
        t4 = NaN, r3 = NaN;
      return e3;
    });
  }
  function u2(t4) {
    var r3 = 0, e3 = 0, i2 = NaN, a2 = NaN;
    return function(n3) {
      if (isNaN(i2) && !(n3.type & _.MOVE_TO))
        throw new Error("path must start with moveto");
      var o2 = t4(n3, r3, e3, i2, a2);
      return n3.type & _.CLOSE_PATH && (r3 = i2, e3 = a2), n3.x !== void 0 && (r3 = n3.relative ? r3 + n3.x : n3.x), n3.y !== void 0 && (e3 = n3.relative ? e3 + n3.y : n3.y), n3.type & _.MOVE_TO && (i2 = r3, a2 = e3), o2;
    };
  }
  function O2(t4, r3, e3, i2, n3, o2) {
    return a(t4, r3, e3, i2, n3, o2), u2(function(a2, s2, u3, h2) {
      var c2 = a2.x1, y2 = a2.x2, p5 = a2.relative && !isNaN(h2), m2 = a2.x !== void 0 ? a2.x : p5 ? 0 : s2, O3 = a2.y !== void 0 ? a2.y : p5 ? 0 : u3;
      function l3(t5) {
        return t5 * t5;
      }
      a2.type & _.HORIZ_LINE_TO && r3 !== 0 && (a2.type = _.LINE_TO, a2.y = a2.relative ? 0 : u3), a2.type & _.VERT_LINE_TO && e3 !== 0 && (a2.type = _.LINE_TO, a2.x = a2.relative ? 0 : s2), a2.x !== void 0 && (a2.x = a2.x * t4 + O3 * e3 + (p5 ? 0 : n3)), a2.y !== void 0 && (a2.y = m2 * r3 + a2.y * i2 + (p5 ? 0 : o2)), a2.x1 !== void 0 && (a2.x1 = a2.x1 * t4 + a2.y1 * e3 + (p5 ? 0 : n3)), a2.y1 !== void 0 && (a2.y1 = c2 * r3 + a2.y1 * i2 + (p5 ? 0 : o2)), a2.x2 !== void 0 && (a2.x2 = a2.x2 * t4 + a2.y2 * e3 + (p5 ? 0 : n3)), a2.y2 !== void 0 && (a2.y2 = y2 * r3 + a2.y2 * i2 + (p5 ? 0 : o2));
      var T2 = t4 * i2 - r3 * e3;
      if (a2.xRot !== void 0 && (t4 !== 1 || r3 !== 0 || e3 !== 0 || i2 !== 1))
        if (T2 === 0)
          delete a2.rX, delete a2.rY, delete a2.xRot, delete a2.lArcFlag, delete a2.sweepFlag, a2.type = _.LINE_TO;
        else {
          var v2 = a2.xRot * Math.PI / 180, f2 = Math.sin(v2), N2 = Math.cos(v2), x2 = 1 / l3(a2.rX), d2 = 1 / l3(a2.rY), E2 = l3(N2) * x2 + l3(f2) * d2, A2 = 2 * f2 * N2 * (x2 - d2), C2 = l3(f2) * x2 + l3(N2) * d2, M2 = E2 * i2 * i2 - A2 * r3 * i2 + C2 * r3 * r3, R2 = A2 * (t4 * i2 + r3 * e3) - 2 * (E2 * e3 * i2 + C2 * t4 * r3), g2 = E2 * e3 * e3 - A2 * t4 * e3 + C2 * t4 * t4, I2 = (Math.atan2(R2, M2 - g2) + Math.PI) % Math.PI / 2, S2 = Math.sin(I2), L2 = Math.cos(I2);
          a2.rX = Math.abs(T2) / Math.sqrt(M2 * l3(L2) + R2 * S2 * L2 + g2 * l3(S2)), a2.rY = Math.abs(T2) / Math.sqrt(M2 * l3(S2) - R2 * S2 * L2 + g2 * l3(L2)), a2.xRot = 180 * I2 / Math.PI;
        }
      return a2.sweepFlag !== void 0 && 0 > T2 && (a2.sweepFlag = +!a2.sweepFlag), a2;
    });
  }
  function l2() {
    return function(t4) {
      var r3 = {};
      for (var e3 in t4)
        r3[e3] = t4[e3];
      return r3;
    };
  }
  t3.ROUND = function(t4) {
    function r3(r4) {
      return Math.round(r4 * t4) / t4;
    }
    return t4 === void 0 && (t4 = 1e13), a(t4), function(t5) {
      return t5.x1 !== void 0 && (t5.x1 = r3(t5.x1)), t5.y1 !== void 0 && (t5.y1 = r3(t5.y1)), t5.x2 !== void 0 && (t5.x2 = r3(t5.x2)), t5.y2 !== void 0 && (t5.y2 = r3(t5.y2)), t5.x !== void 0 && (t5.x = r3(t5.x)), t5.y !== void 0 && (t5.y = r3(t5.y)), t5.rX !== void 0 && (t5.rX = r3(t5.rX)), t5.rY !== void 0 && (t5.rY = r3(t5.rY)), t5;
    };
  }, t3.TO_ABS = r2, t3.TO_REL = function() {
    return u2(function(t4, r3, e3) {
      return t4.relative || (t4.x1 !== void 0 && (t4.x1 -= r3), t4.y1 !== void 0 && (t4.y1 -= e3), t4.x2 !== void 0 && (t4.x2 -= r3), t4.y2 !== void 0 && (t4.y2 -= e3), t4.x !== void 0 && (t4.x -= r3), t4.y !== void 0 && (t4.y -= e3), t4.relative = true), t4;
    });
  }, t3.NORMALIZE_HVZ = function(t4, r3, e3) {
    return t4 === void 0 && (t4 = true), r3 === void 0 && (r3 = true), e3 === void 0 && (e3 = true), u2(function(i2, a2, n3, o2, s2) {
      if (isNaN(o2) && !(i2.type & _.MOVE_TO))
        throw new Error("path must start with moveto");
      return r3 && i2.type & _.HORIZ_LINE_TO && (i2.type = _.LINE_TO, i2.y = i2.relative ? 0 : n3), e3 && i2.type & _.VERT_LINE_TO && (i2.type = _.LINE_TO, i2.x = i2.relative ? 0 : a2), t4 && i2.type & _.CLOSE_PATH && (i2.type = _.LINE_TO, i2.x = i2.relative ? o2 - a2 : o2, i2.y = i2.relative ? s2 - n3 : s2), i2.type & _.ARC && (i2.rX === 0 || i2.rY === 0) && (i2.type = _.LINE_TO, delete i2.rX, delete i2.rY, delete i2.xRot, delete i2.lArcFlag, delete i2.sweepFlag), i2;
    });
  }, t3.NORMALIZE_ST = e2, t3.QT_TO_C = n2, t3.INFO = u2, t3.SANITIZE = function(t4) {
    t4 === void 0 && (t4 = 0), a(t4);
    var r3 = NaN, e3 = NaN, i2 = NaN, n3 = NaN;
    return u2(function(a2, o2, s2, u3, h2) {
      var c2 = Math.abs, y2 = false, p5 = 0, m2 = 0;
      if (a2.type & _.SMOOTH_CURVE_TO && (p5 = isNaN(r3) ? 0 : o2 - r3, m2 = isNaN(e3) ? 0 : s2 - e3), a2.type & (_.CURVE_TO | _.SMOOTH_CURVE_TO) ? (r3 = a2.relative ? o2 + a2.x2 : a2.x2, e3 = a2.relative ? s2 + a2.y2 : a2.y2) : (r3 = NaN, e3 = NaN), a2.type & _.SMOOTH_QUAD_TO ? (i2 = isNaN(i2) ? o2 : 2 * o2 - i2, n3 = isNaN(n3) ? s2 : 2 * s2 - n3) : a2.type & _.QUAD_TO ? (i2 = a2.relative ? o2 + a2.x1 : a2.x1, n3 = a2.relative ? s2 + a2.y1 : a2.y2) : (i2 = NaN, n3 = NaN), a2.type & _.LINE_COMMANDS || a2.type & _.ARC && (a2.rX === 0 || a2.rY === 0 || !a2.lArcFlag) || a2.type & _.CURVE_TO || a2.type & _.SMOOTH_CURVE_TO || a2.type & _.QUAD_TO || a2.type & _.SMOOTH_QUAD_TO) {
        var O3 = a2.x === void 0 ? 0 : a2.relative ? a2.x : a2.x - o2, l3 = a2.y === void 0 ? 0 : a2.relative ? a2.y : a2.y - s2;
        p5 = isNaN(i2) ? a2.x1 === void 0 ? p5 : a2.relative ? a2.x : a2.x1 - o2 : i2 - o2, m2 = isNaN(n3) ? a2.y1 === void 0 ? m2 : a2.relative ? a2.y : a2.y1 - s2 : n3 - s2;
        var T2 = a2.x2 === void 0 ? 0 : a2.relative ? a2.x : a2.x2 - o2, v2 = a2.y2 === void 0 ? 0 : a2.relative ? a2.y : a2.y2 - s2;
        c2(O3) <= t4 && c2(l3) <= t4 && c2(p5) <= t4 && c2(m2) <= t4 && c2(T2) <= t4 && c2(v2) <= t4 && (y2 = true);
      }
      return a2.type & _.CLOSE_PATH && c2(o2 - u3) <= t4 && c2(s2 - h2) <= t4 && (y2 = true), y2 ? [] : a2;
    });
  }, t3.MATRIX = O2, t3.ROTATE = function(t4, r3, e3) {
    r3 === void 0 && (r3 = 0), e3 === void 0 && (e3 = 0), a(t4, r3, e3);
    var i2 = Math.sin(t4), n3 = Math.cos(t4);
    return O2(n3, i2, -i2, n3, r3 - r3 * n3 + e3 * i2, e3 - r3 * i2 - e3 * n3);
  }, t3.TRANSLATE = function(t4, r3) {
    return r3 === void 0 && (r3 = 0), a(t4, r3), O2(1, 0, 0, 1, t4, r3);
  }, t3.SCALE = function(t4, r3) {
    return r3 === void 0 && (r3 = t4), a(t4, r3), O2(t4, 0, 0, r3, 0, 0);
  }, t3.SKEW_X = function(t4) {
    return a(t4), O2(1, 0, Math.atan(t4), 1, 0, 0);
  }, t3.SKEW_Y = function(t4) {
    return a(t4), O2(1, Math.atan(t4), 0, 1, 0, 0);
  }, t3.X_AXIS_SYMMETRY = function(t4) {
    return t4 === void 0 && (t4 = 0), a(t4), O2(-1, 0, 0, 1, t4, 0);
  }, t3.Y_AXIS_SYMMETRY = function(t4) {
    return t4 === void 0 && (t4 = 0), a(t4), O2(1, 0, 0, -1, 0, t4);
  }, t3.A_TO_C = function() {
    return u2(function(t4, r3, e3) {
      return _.ARC === t4.type ? function(t5, r4, e4) {
        var a2, n3, s2, u3;
        t5.cX || o(t5, r4, e4);
        for (var y2 = Math.min(t5.phi1, t5.phi2), p5 = Math.max(t5.phi1, t5.phi2) - y2, m2 = Math.ceil(p5 / 90), O3 = new Array(m2), l3 = r4, T2 = e4, v2 = 0; v2 < m2; v2++) {
          var f2 = c$1(t5.phi1, t5.phi2, v2 / m2), N2 = c$1(t5.phi1, t5.phi2, (v2 + 1) / m2), x2 = N2 - f2, d2 = 4 / 3 * Math.tan(x2 * h / 4), E2 = [Math.cos(f2 * h) - d2 * Math.sin(f2 * h), Math.sin(f2 * h) + d2 * Math.cos(f2 * h)], A2 = E2[0], C2 = E2[1], M2 = [Math.cos(N2 * h), Math.sin(N2 * h)], R2 = M2[0], g2 = M2[1], I2 = [R2 + d2 * Math.sin(N2 * h), g2 - d2 * Math.cos(N2 * h)], S2 = I2[0], L2 = I2[1];
          O3[v2] = { relative: t5.relative, type: _.CURVE_TO };
          var H4 = function(r5, e5) {
            var a3 = i([r5 * t5.rX, e5 * t5.rY], t5.xRot), n4 = a3[0], o2 = a3[1];
            return [t5.cX + n4, t5.cY + o2];
          };
          a2 = H4(A2, C2), O3[v2].x1 = a2[0], O3[v2].y1 = a2[1], n3 = H4(S2, L2), O3[v2].x2 = n3[0], O3[v2].y2 = n3[1], s2 = H4(R2, g2), O3[v2].x = s2[0], O3[v2].y = s2[1], t5.relative && (O3[v2].x1 -= l3, O3[v2].y1 -= T2, O3[v2].x2 -= l3, O3[v2].y2 -= T2, O3[v2].x -= l3, O3[v2].y -= T2), l3 = (u3 = [O3[v2].x, O3[v2].y])[0], T2 = u3[1];
        }
        return O3;
      }(t4, t4.relative ? 0 : r3, t4.relative ? 0 : e3) : t4;
    });
  }, t3.ANNOTATE_ARCS = function() {
    return u2(function(t4, r3, e3) {
      return t4.relative && (r3 = 0, e3 = 0), _.ARC === t4.type && o(t4, r3, e3), t4;
    });
  }, t3.CLONE = l2, t3.CALCULATE_BOUNDS = function() {
    var t4 = function(t5) {
      var r3 = {};
      for (var e3 in t5)
        r3[e3] = t5[e3];
      return r3;
    }, i2 = r2(), a2 = n2(), h2 = e2(), c2 = u2(function(r3, e3, n3) {
      var u3 = h2(a2(i2(t4(r3))));
      function O3(t5) {
        t5 > c2.maxX && (c2.maxX = t5), t5 < c2.minX && (c2.minX = t5);
      }
      function l3(t5) {
        t5 > c2.maxY && (c2.maxY = t5), t5 < c2.minY && (c2.minY = t5);
      }
      if (u3.type & _.DRAWING_COMMANDS && (O3(e3), l3(n3)), u3.type & _.HORIZ_LINE_TO && O3(u3.x), u3.type & _.VERT_LINE_TO && l3(u3.y), u3.type & _.LINE_TO && (O3(u3.x), l3(u3.y)), u3.type & _.CURVE_TO) {
        O3(u3.x), l3(u3.y);
        for (var T2 = 0, v2 = p(e3, u3.x1, u3.x2, u3.x); T2 < v2.length; T2++) {
          0 < (w2 = v2[T2]) && 1 > w2 && O3(m$1(e3, u3.x1, u3.x2, u3.x, w2));
        }
        for (var f2 = 0, N2 = p(n3, u3.y1, u3.y2, u3.y); f2 < N2.length; f2++) {
          0 < (w2 = N2[f2]) && 1 > w2 && l3(m$1(n3, u3.y1, u3.y2, u3.y, w2));
        }
      }
      if (u3.type & _.ARC) {
        O3(u3.x), l3(u3.y), o(u3, e3, n3);
        for (var x2 = u3.xRot / 180 * Math.PI, d2 = Math.cos(x2) * u3.rX, E2 = Math.sin(x2) * u3.rX, A2 = -Math.sin(x2) * u3.rY, C2 = Math.cos(x2) * u3.rY, M2 = u3.phi1 < u3.phi2 ? [u3.phi1, u3.phi2] : -180 > u3.phi2 ? [u3.phi2 + 360, u3.phi1 + 360] : [u3.phi2, u3.phi1], R2 = M2[0], g2 = M2[1], I2 = function(t5) {
          var r4 = t5[0], e4 = t5[1], i3 = 180 * Math.atan2(e4, r4) / Math.PI;
          return i3 < R2 ? i3 + 360 : i3;
        }, S2 = 0, L2 = s(A2, -d2, 0).map(I2); S2 < L2.length; S2++) {
          (w2 = L2[S2]) > R2 && w2 < g2 && O3(y(u3.cX, d2, A2, w2));
        }
        for (var H4 = 0, U2 = s(C2, -E2, 0).map(I2); H4 < U2.length; H4++) {
          var w2;
          (w2 = U2[H4]) > R2 && w2 < g2 && l3(y(u3.cY, E2, C2, w2));
        }
      }
      return r3;
    });
    return c2.minX = 1 / 0, c2.maxX = -1 / 0, c2.minY = 1 / 0, c2.maxY = -1 / 0, c2;
  };
}(u || (u = {}));
var O, l = function() {
  function t3() {
  }
  return t3.prototype.round = function(t4) {
    return this.transform(u.ROUND(t4));
  }, t3.prototype.toAbs = function() {
    return this.transform(u.TO_ABS());
  }, t3.prototype.toRel = function() {
    return this.transform(u.TO_REL());
  }, t3.prototype.normalizeHVZ = function(t4, r2, e2) {
    return this.transform(u.NORMALIZE_HVZ(t4, r2, e2));
  }, t3.prototype.normalizeST = function() {
    return this.transform(u.NORMALIZE_ST());
  }, t3.prototype.qtToC = function() {
    return this.transform(u.QT_TO_C());
  }, t3.prototype.aToC = function() {
    return this.transform(u.A_TO_C());
  }, t3.prototype.sanitize = function(t4) {
    return this.transform(u.SANITIZE(t4));
  }, t3.prototype.translate = function(t4, r2) {
    return this.transform(u.TRANSLATE(t4, r2));
  }, t3.prototype.scale = function(t4, r2) {
    return this.transform(u.SCALE(t4, r2));
  }, t3.prototype.rotate = function(t4, r2, e2) {
    return this.transform(u.ROTATE(t4, r2, e2));
  }, t3.prototype.matrix = function(t4, r2, e2, i2, a2, n2) {
    return this.transform(u.MATRIX(t4, r2, e2, i2, a2, n2));
  }, t3.prototype.skewX = function(t4) {
    return this.transform(u.SKEW_X(t4));
  }, t3.prototype.skewY = function(t4) {
    return this.transform(u.SKEW_Y(t4));
  }, t3.prototype.xSymmetry = function(t4) {
    return this.transform(u.X_AXIS_SYMMETRY(t4));
  }, t3.prototype.ySymmetry = function(t4) {
    return this.transform(u.Y_AXIS_SYMMETRY(t4));
  }, t3.prototype.annotateArcs = function() {
    return this.transform(u.ANNOTATE_ARCS());
  }, t3;
}(), T = function(t3) {
  return t3 === " " || t3 === "	" || t3 === "\r" || t3 === "\n";
}, v = function(t3) {
  return "0".charCodeAt(0) <= t3.charCodeAt(0) && t3.charCodeAt(0) <= "9".charCodeAt(0);
}, f = function(t3) {
  function e2() {
    var r2 = t3.call(this) || this;
    return r2.curNumber = "", r2.curCommandType = -1, r2.curCommandRelative = false, r2.canParseCommandOrComma = true, r2.curNumberHasExp = false, r2.curNumberHasExpDigits = false, r2.curNumberHasDecimal = false, r2.curArgs = [], r2;
  }
  return r(e2, t3), e2.prototype.finish = function(t4) {
    if (t4 === void 0 && (t4 = []), this.parse(" ", t4), this.curArgs.length !== 0 || !this.canParseCommandOrComma)
      throw new SyntaxError("Unterminated command at the path end.");
    return t4;
  }, e2.prototype.parse = function(t4, r2) {
    var e3 = this;
    r2 === void 0 && (r2 = []);
    for (var i2 = function(t5) {
      r2.push(t5), e3.curArgs.length = 0, e3.canParseCommandOrComma = true;
    }, a2 = 0; a2 < t4.length; a2++) {
      var n2 = t4[a2], o2 = !(this.curCommandType !== _.ARC || this.curArgs.length !== 3 && this.curArgs.length !== 4 || this.curNumber.length !== 1 || this.curNumber !== "0" && this.curNumber !== "1"), s2 = v(n2) && (this.curNumber === "0" && n2 === "0" || o2);
      if (!v(n2) || s2)
        if (n2 !== "e" && n2 !== "E")
          if (n2 !== "-" && n2 !== "+" || !this.curNumberHasExp || this.curNumberHasExpDigits)
            if (n2 !== "." || this.curNumberHasExp || this.curNumberHasDecimal || o2) {
              if (this.curNumber && this.curCommandType !== -1) {
                var u2 = Number(this.curNumber);
                if (isNaN(u2))
                  throw new SyntaxError("Invalid number ending at " + a2);
                if (this.curCommandType === _.ARC) {
                  if (this.curArgs.length === 0 || this.curArgs.length === 1) {
                    if (0 > u2)
                      throw new SyntaxError('Expected positive number, got "' + u2 + '" at index "' + a2 + '"');
                  } else if ((this.curArgs.length === 3 || this.curArgs.length === 4) && this.curNumber !== "0" && this.curNumber !== "1")
                    throw new SyntaxError('Expected a flag, got "' + this.curNumber + '" at index "' + a2 + '"');
                }
                this.curArgs.push(u2), this.curArgs.length === N[this.curCommandType] && (_.HORIZ_LINE_TO === this.curCommandType ? i2({ type: _.HORIZ_LINE_TO, relative: this.curCommandRelative, x: u2 }) : _.VERT_LINE_TO === this.curCommandType ? i2({ type: _.VERT_LINE_TO, relative: this.curCommandRelative, y: u2 }) : this.curCommandType === _.MOVE_TO || this.curCommandType === _.LINE_TO || this.curCommandType === _.SMOOTH_QUAD_TO ? (i2({ type: this.curCommandType, relative: this.curCommandRelative, x: this.curArgs[0], y: this.curArgs[1] }), _.MOVE_TO === this.curCommandType && (this.curCommandType = _.LINE_TO)) : this.curCommandType === _.CURVE_TO ? i2({ type: _.CURVE_TO, relative: this.curCommandRelative, x1: this.curArgs[0], y1: this.curArgs[1], x2: this.curArgs[2], y2: this.curArgs[3], x: this.curArgs[4], y: this.curArgs[5] }) : this.curCommandType === _.SMOOTH_CURVE_TO ? i2({ type: _.SMOOTH_CURVE_TO, relative: this.curCommandRelative, x2: this.curArgs[0], y2: this.curArgs[1], x: this.curArgs[2], y: this.curArgs[3] }) : this.curCommandType === _.QUAD_TO ? i2({ type: _.QUAD_TO, relative: this.curCommandRelative, x1: this.curArgs[0], y1: this.curArgs[1], x: this.curArgs[2], y: this.curArgs[3] }) : this.curCommandType === _.ARC && i2({ type: _.ARC, relative: this.curCommandRelative, rX: this.curArgs[0], rY: this.curArgs[1], xRot: this.curArgs[2], lArcFlag: this.curArgs[3], sweepFlag: this.curArgs[4], x: this.curArgs[5], y: this.curArgs[6] })), this.curNumber = "", this.curNumberHasExpDigits = false, this.curNumberHasExp = false, this.curNumberHasDecimal = false, this.canParseCommandOrComma = true;
              }
              if (!T(n2))
                if (n2 === "," && this.canParseCommandOrComma)
                  this.canParseCommandOrComma = false;
                else if (n2 !== "+" && n2 !== "-" && n2 !== ".")
                  if (s2)
                    this.curNumber = n2, this.curNumberHasDecimal = false;
                  else {
                    if (this.curArgs.length !== 0)
                      throw new SyntaxError("Unterminated command at index " + a2 + ".");
                    if (!this.canParseCommandOrComma)
                      throw new SyntaxError('Unexpected character "' + n2 + '" at index ' + a2 + ". Command cannot follow comma");
                    if (this.canParseCommandOrComma = false, n2 !== "z" && n2 !== "Z")
                      if (n2 === "h" || n2 === "H")
                        this.curCommandType = _.HORIZ_LINE_TO, this.curCommandRelative = n2 === "h";
                      else if (n2 === "v" || n2 === "V")
                        this.curCommandType = _.VERT_LINE_TO, this.curCommandRelative = n2 === "v";
                      else if (n2 === "m" || n2 === "M")
                        this.curCommandType = _.MOVE_TO, this.curCommandRelative = n2 === "m";
                      else if (n2 === "l" || n2 === "L")
                        this.curCommandType = _.LINE_TO, this.curCommandRelative = n2 === "l";
                      else if (n2 === "c" || n2 === "C")
                        this.curCommandType = _.CURVE_TO, this.curCommandRelative = n2 === "c";
                      else if (n2 === "s" || n2 === "S")
                        this.curCommandType = _.SMOOTH_CURVE_TO, this.curCommandRelative = n2 === "s";
                      else if (n2 === "q" || n2 === "Q")
                        this.curCommandType = _.QUAD_TO, this.curCommandRelative = n2 === "q";
                      else if (n2 === "t" || n2 === "T")
                        this.curCommandType = _.SMOOTH_QUAD_TO, this.curCommandRelative = n2 === "t";
                      else {
                        if (n2 !== "a" && n2 !== "A")
                          throw new SyntaxError('Unexpected character "' + n2 + '" at index ' + a2 + ".");
                        this.curCommandType = _.ARC, this.curCommandRelative = n2 === "a";
                      }
                    else
                      r2.push({ type: _.CLOSE_PATH }), this.canParseCommandOrComma = true, this.curCommandType = -1;
                  }
                else
                  this.curNumber = n2, this.curNumberHasDecimal = n2 === ".";
            } else
              this.curNumber += n2, this.curNumberHasDecimal = true;
          else
            this.curNumber += n2;
        else
          this.curNumber += n2, this.curNumberHasExp = true;
      else
        this.curNumber += n2, this.curNumberHasExpDigits = this.curNumberHasExp;
    }
    return r2;
  }, e2.prototype.transform = function(t4) {
    return Object.create(this, { parse: { value: function(r2, e3) {
      e3 === void 0 && (e3 = []);
      for (var i2 = 0, a2 = Object.getPrototypeOf(this).parse.call(this, r2); i2 < a2.length; i2++) {
        var n2 = a2[i2], o2 = t4(n2);
        Array.isArray(o2) ? e3.push.apply(e3, o2) : e3.push(o2);
      }
      return e3;
    } } });
  }, e2;
}(l), _ = function(t3) {
  function i2(r2) {
    var e2 = t3.call(this) || this;
    return e2.commands = typeof r2 == "string" ? i2.parse(r2) : r2, e2;
  }
  return r(i2, t3), i2.prototype.encode = function() {
    return i2.encode(this.commands);
  }, i2.prototype.getBounds = function() {
    var t4 = u.CALCULATE_BOUNDS();
    return this.transform(t4), t4;
  }, i2.prototype.transform = function(t4) {
    for (var r2 = [], e2 = 0, i3 = this.commands; e2 < i3.length; e2++) {
      var a2 = t4(i3[e2]);
      Array.isArray(a2) ? r2.push.apply(r2, a2) : r2.push(a2);
    }
    return this.commands = r2, this;
  }, i2.encode = function(t4) {
    return e(t4);
  }, i2.parse = function(t4) {
    var r2 = new f(), e2 = [];
    return r2.parse(t4, e2), r2.finish(e2), e2;
  }, i2.CLOSE_PATH = 1, i2.MOVE_TO = 2, i2.HORIZ_LINE_TO = 4, i2.VERT_LINE_TO = 8, i2.LINE_TO = 16, i2.CURVE_TO = 32, i2.SMOOTH_CURVE_TO = 64, i2.QUAD_TO = 128, i2.SMOOTH_QUAD_TO = 256, i2.ARC = 512, i2.LINE_COMMANDS = i2.LINE_TO | i2.HORIZ_LINE_TO | i2.VERT_LINE_TO, i2.DRAWING_COMMANDS = i2.HORIZ_LINE_TO | i2.VERT_LINE_TO | i2.LINE_TO | i2.CURVE_TO | i2.SMOOTH_CURVE_TO | i2.QUAD_TO | i2.SMOOTH_QUAD_TO | i2.ARC, i2;
}(l), N = ((O = {})[_.MOVE_TO] = 2, O[_.LINE_TO] = 2, O[_.HORIZ_LINE_TO] = 1, O[_.VERT_LINE_TO] = 1, O[_.CLOSE_PATH] = 0, O[_.QUAD_TO] = 4, O[_.SMOOTH_QUAD_TO] = 2, O[_.CURVE_TO] = 6, O[_.SMOOTH_CURVE_TO] = 4, O[_.ARC] = 7, O);
var uncurryThis = functionUncurryThis;
var PROPER_FUNCTION_NAME = functionName.PROPER;
var redefine = redefine$7.exports;
var anObject = anObject$g;
var isPrototypeOf = objectIsPrototypeOf;
var $toString = toString$9;
var fails = fails$k;
var regExpFlags = regexpFlags$1;
var TO_STRING = "toString";
var RegExpPrototype = RegExp.prototype;
var n$ToString = RegExpPrototype[TO_STRING];
var getFlags = uncurryThis(regExpFlags);
var NOT_GENERIC = fails(function() {
  return n$ToString.call({ source: "a", flags: "b" }) != "/a/b";
});
var INCORRECT_NAME = PROPER_FUNCTION_NAME && n$ToString.name != TO_STRING;
if (NOT_GENERIC || INCORRECT_NAME) {
  redefine(RegExp.prototype, TO_STRING, function toString3() {
    var R2 = anObject(this);
    var p5 = $toString(R2.source);
    var rf = R2.flags;
    var f2 = $toString(rf === void 0 && isPrototypeOf(RegExpPrototype, R2) && !("flags" in RegExpPrototype) ? getFlags(R2) : rf);
    return "/" + p5 + "/" + f2;
  }, { unsafe: true });
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var mulTable = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259];
var shgTable = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];
function getImageDataFromCanvas(canvas, topX, topY, width, height) {
  if (typeof canvas === "string") {
    canvas = document.getElementById(canvas);
  }
  if (!canvas || _typeof(canvas) !== "object" || !("getContext" in canvas)) {
    throw new TypeError("Expecting canvas with `getContext` method in processCanvasRGB(A) calls!");
  }
  var context2 = canvas.getContext("2d");
  try {
    return context2.getImageData(topX, topY, width, height);
  } catch (e2) {
    throw new Error("unable to access image data: " + e2);
  }
}
function processCanvasRGBA(canvas, topX, topY, width, height, radius) {
  if (isNaN(radius) || radius < 1) {
    return;
  }
  radius |= 0;
  var imageData = getImageDataFromCanvas(canvas, topX, topY, width, height);
  imageData = processImageDataRGBA(imageData, topX, topY, width, height, radius);
  canvas.getContext("2d").putImageData(imageData, topX, topY);
}
function processImageDataRGBA(imageData, topX, topY, width, height, radius) {
  var pixels = imageData.data;
  var div = 2 * radius + 1;
  var widthMinus1 = width - 1;
  var heightMinus1 = height - 1;
  var radiusPlus1 = radius + 1;
  var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;
  var stackStart = new BlurStack();
  var stack = stackStart;
  var stackEnd;
  for (var i2 = 1; i2 < div; i2++) {
    stack = stack.next = new BlurStack();
    if (i2 === radiusPlus1) {
      stackEnd = stack;
    }
  }
  stack.next = stackStart;
  var stackIn = null, stackOut = null, yw = 0, yi = 0;
  var mulSum = mulTable[radius];
  var shgSum = shgTable[radius];
  for (var y2 = 0; y2 < height; y2++) {
    stack = stackStart;
    var pr = pixels[yi], pg = pixels[yi + 1], pb = pixels[yi + 2], pa = pixels[yi + 3];
    for (var _i = 0; _i < radiusPlus1; _i++) {
      stack.r = pr;
      stack.g = pg;
      stack.b = pb;
      stack.a = pa;
      stack = stack.next;
    }
    var rInSum = 0, gInSum = 0, bInSum = 0, aInSum = 0, rOutSum = radiusPlus1 * pr, gOutSum = radiusPlus1 * pg, bOutSum = radiusPlus1 * pb, aOutSum = radiusPlus1 * pa, rSum = sumFactor * pr, gSum = sumFactor * pg, bSum = sumFactor * pb, aSum = sumFactor * pa;
    for (var _i2 = 1; _i2 < radiusPlus1; _i2++) {
      var p5 = yi + ((widthMinus1 < _i2 ? widthMinus1 : _i2) << 2);
      var r2 = pixels[p5], g2 = pixels[p5 + 1], b2 = pixels[p5 + 2], a2 = pixels[p5 + 3];
      var rbs = radiusPlus1 - _i2;
      rSum += (stack.r = r2) * rbs;
      gSum += (stack.g = g2) * rbs;
      bSum += (stack.b = b2) * rbs;
      aSum += (stack.a = a2) * rbs;
      rInSum += r2;
      gInSum += g2;
      bInSum += b2;
      aInSum += a2;
      stack = stack.next;
    }
    stackIn = stackStart;
    stackOut = stackEnd;
    for (var x2 = 0; x2 < width; x2++) {
      var paInitial = aSum * mulSum >> shgSum;
      pixels[yi + 3] = paInitial;
      if (paInitial !== 0) {
        var _a2 = 255 / paInitial;
        pixels[yi] = (rSum * mulSum >> shgSum) * _a2;
        pixels[yi + 1] = (gSum * mulSum >> shgSum) * _a2;
        pixels[yi + 2] = (bSum * mulSum >> shgSum) * _a2;
      } else {
        pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
      }
      rSum -= rOutSum;
      gSum -= gOutSum;
      bSum -= bOutSum;
      aSum -= aOutSum;
      rOutSum -= stackIn.r;
      gOutSum -= stackIn.g;
      bOutSum -= stackIn.b;
      aOutSum -= stackIn.a;
      var _p = x2 + radius + 1;
      _p = yw + (_p < widthMinus1 ? _p : widthMinus1) << 2;
      rInSum += stackIn.r = pixels[_p];
      gInSum += stackIn.g = pixels[_p + 1];
      bInSum += stackIn.b = pixels[_p + 2];
      aInSum += stackIn.a = pixels[_p + 3];
      rSum += rInSum;
      gSum += gInSum;
      bSum += bInSum;
      aSum += aInSum;
      stackIn = stackIn.next;
      var _stackOut = stackOut, _r = _stackOut.r, _g = _stackOut.g, _b2 = _stackOut.b, _a3 = _stackOut.a;
      rOutSum += _r;
      gOutSum += _g;
      bOutSum += _b2;
      aOutSum += _a3;
      rInSum -= _r;
      gInSum -= _g;
      bInSum -= _b2;
      aInSum -= _a3;
      stackOut = stackOut.next;
      yi += 4;
    }
    yw += width;
  }
  for (var _x = 0; _x < width; _x++) {
    yi = _x << 2;
    var _pr = pixels[yi], _pg = pixels[yi + 1], _pb = pixels[yi + 2], _pa = pixels[yi + 3], _rOutSum = radiusPlus1 * _pr, _gOutSum = radiusPlus1 * _pg, _bOutSum = radiusPlus1 * _pb, _aOutSum = radiusPlus1 * _pa, _rSum = sumFactor * _pr, _gSum = sumFactor * _pg, _bSum = sumFactor * _pb, _aSum = sumFactor * _pa;
    stack = stackStart;
    for (var _i3 = 0; _i3 < radiusPlus1; _i3++) {
      stack.r = _pr;
      stack.g = _pg;
      stack.b = _pb;
      stack.a = _pa;
      stack = stack.next;
    }
    var yp = width;
    var _gInSum = 0, _bInSum = 0, _aInSum = 0, _rInSum = 0;
    for (var _i4 = 1; _i4 <= radius; _i4++) {
      yi = yp + _x << 2;
      var _rbs = radiusPlus1 - _i4;
      _rSum += (stack.r = _pr = pixels[yi]) * _rbs;
      _gSum += (stack.g = _pg = pixels[yi + 1]) * _rbs;
      _bSum += (stack.b = _pb = pixels[yi + 2]) * _rbs;
      _aSum += (stack.a = _pa = pixels[yi + 3]) * _rbs;
      _rInSum += _pr;
      _gInSum += _pg;
      _bInSum += _pb;
      _aInSum += _pa;
      stack = stack.next;
      if (_i4 < heightMinus1) {
        yp += width;
      }
    }
    yi = _x;
    stackIn = stackStart;
    stackOut = stackEnd;
    for (var _y = 0; _y < height; _y++) {
      var _p2 = yi << 2;
      pixels[_p2 + 3] = _pa = _aSum * mulSum >> shgSum;
      if (_pa > 0) {
        _pa = 255 / _pa;
        pixels[_p2] = (_rSum * mulSum >> shgSum) * _pa;
        pixels[_p2 + 1] = (_gSum * mulSum >> shgSum) * _pa;
        pixels[_p2 + 2] = (_bSum * mulSum >> shgSum) * _pa;
      } else {
        pixels[_p2] = pixels[_p2 + 1] = pixels[_p2 + 2] = 0;
      }
      _rSum -= _rOutSum;
      _gSum -= _gOutSum;
      _bSum -= _bOutSum;
      _aSum -= _aOutSum;
      _rOutSum -= stackIn.r;
      _gOutSum -= stackIn.g;
      _bOutSum -= stackIn.b;
      _aOutSum -= stackIn.a;
      _p2 = _x + ((_p2 = _y + radiusPlus1) < heightMinus1 ? _p2 : heightMinus1) * width << 2;
      _rSum += _rInSum += stackIn.r = pixels[_p2];
      _gSum += _gInSum += stackIn.g = pixels[_p2 + 1];
      _bSum += _bInSum += stackIn.b = pixels[_p2 + 2];
      _aSum += _aInSum += stackIn.a = pixels[_p2 + 3];
      stackIn = stackIn.next;
      _rOutSum += _pr = stackOut.r;
      _gOutSum += _pg = stackOut.g;
      _bOutSum += _pb = stackOut.b;
      _aOutSum += _pa = stackOut.a;
      _rInSum -= _pr;
      _gInSum -= _pg;
      _bInSum -= _pb;
      _aInSum -= _pa;
      stackOut = stackOut.next;
      yi += width;
    }
  }
  return imageData;
}
var BlurStack = function BlurStack2() {
  _classCallCheck(this, BlurStack2);
  this.r = 0;
  this.g = 0;
  this.b = 0;
  this.a = 0;
  this.next = null;
};
function offscreen() {
  var {
    DOMParser: DOMParserFallback
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var preset = {
    window: null,
    ignoreAnimation: true,
    ignoreMouse: true,
    DOMParser: DOMParserFallback,
    createCanvas(width, height) {
      return new OffscreenCanvas(width, height);
    },
    createImage(url) {
      return _asyncToGenerator(function* () {
        var response = yield fetch(url);
        var blob = yield response.blob();
        var img = yield createImageBitmap(blob);
        return img;
      })();
    }
  };
  if (typeof DOMParser !== "undefined" || typeof DOMParserFallback === "undefined") {
    Reflect.deleteProperty(preset, "DOMParser");
  }
  return preset;
}
function node(_ref2) {
  var {
    DOMParser: DOMParser2,
    canvas,
    fetch: fetch2
  } = _ref2;
  return {
    window: null,
    ignoreAnimation: true,
    ignoreMouse: true,
    DOMParser: DOMParser2,
    fetch: fetch2,
    createCanvas: canvas.createCanvas,
    createImage: canvas.loadImage
  };
}
var index = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  offscreen,
  node
});
function compressSpaces(str) {
  return str.replace(/(?!\u3000)\s+/gm, " ");
}
function trimLeft(str) {
  return str.replace(/^[\n \t]+/, "");
}
function trimRight(str) {
  return str.replace(/[\n \t]+$/, "");
}
function toNumbers(str) {
  var matches = (str || "").match(/-?(\d+(?:\.\d*(?:[eE][+-]?\d+)?)?|\.\d+)(?=\D|$)/gm) || [];
  return matches.map(parseFloat);
}
var allUppercase = /^[A-Z-]+$/;
function normalizeAttributeName(name) {
  if (allUppercase.test(name)) {
    return name.toLowerCase();
  }
  return name;
}
function parseExternalUrl(url) {
  var urlMatch = /url\(('([^']+)'|"([^"]+)"|([^'")]+))\)/.exec(url) || [];
  return urlMatch[2] || urlMatch[3] || urlMatch[4];
}
function normalizeColor(color2) {
  if (!color2.startsWith("rgb")) {
    return color2;
  }
  var rgbParts = 3;
  var normalizedColor = color2.replace(/\d+(\.\d+)?/g, (num, isFloat) => rgbParts-- && isFloat ? String(Math.round(parseFloat(num))) : num);
  return normalizedColor;
}
var attributeRegex = /(\[[^\]]+\])/g;
var idRegex = /(#[^\s+>~.[:]+)/g;
var classRegex = /(\.[^\s+>~.[:]+)/g;
var pseudoElementRegex = /(::[^\s+>~.[:]+|:first-line|:first-letter|:before|:after)/gi;
var pseudoClassWithBracketsRegex = /(:[\w-]+\([^)]*\))/gi;
var pseudoClassRegex = /(:[^\s+>~.[:]+)/g;
var elementRegex = /([^\s+>~.[:]+)/g;
function findSelectorMatch(selector, regex) {
  var matches = regex.exec(selector);
  if (!matches) {
    return [selector, 0];
  }
  return [selector.replace(regex, " "), matches.length];
}
function getSelectorSpecificity(selector) {
  var specificity = [0, 0, 0];
  var currentSelector = selector.replace(/:not\(([^)]*)\)/g, "     $1 ").replace(/{[\s\S]*/gm, " ");
  var delta = 0;
  [currentSelector, delta] = findSelectorMatch(currentSelector, attributeRegex);
  specificity[1] += delta;
  [currentSelector, delta] = findSelectorMatch(currentSelector, idRegex);
  specificity[0] += delta;
  [currentSelector, delta] = findSelectorMatch(currentSelector, classRegex);
  specificity[1] += delta;
  [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoElementRegex);
  specificity[2] += delta;
  [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassWithBracketsRegex);
  specificity[1] += delta;
  [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassRegex);
  specificity[1] += delta;
  currentSelector = currentSelector.replace(/[*\s+>~]/g, " ").replace(/[#.]/g, " ");
  [currentSelector, delta] = findSelectorMatch(currentSelector, elementRegex);
  specificity[2] += delta;
  return specificity.join("");
}
var PSEUDO_ZERO = 1e-8;
function vectorMagnitude(v2) {
  return Math.sqrt(Math.pow(v2[0], 2) + Math.pow(v2[1], 2));
}
function vectorsRatio(u2, v2) {
  return (u2[0] * v2[0] + u2[1] * v2[1]) / (vectorMagnitude(u2) * vectorMagnitude(v2));
}
function vectorsAngle(u2, v2) {
  return (u2[0] * v2[1] < u2[1] * v2[0] ? -1 : 1) * Math.acos(vectorsRatio(u2, v2));
}
function CB1(t3) {
  return t3 * t3 * t3;
}
function CB2(t3) {
  return 3 * t3 * t3 * (1 - t3);
}
function CB3(t3) {
  return 3 * t3 * (1 - t3) * (1 - t3);
}
function CB4(t3) {
  return (1 - t3) * (1 - t3) * (1 - t3);
}
function QB1(t3) {
  return t3 * t3;
}
function QB2(t3) {
  return 2 * t3 * (1 - t3);
}
function QB3(t3) {
  return (1 - t3) * (1 - t3);
}
class Property {
  constructor(document2, name, value) {
    this.document = document2;
    this.name = name;
    this.value = value;
    this.isNormalizedColor = false;
  }
  static empty(document2) {
    return new Property(document2, "EMPTY", "");
  }
  split() {
    var separator = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : " ";
    var {
      document: document2,
      name
    } = this;
    return compressSpaces(this.getString()).trim().split(separator).map((value) => new Property(document2, name, value));
  }
  hasValue(zeroIsValue) {
    var {
      value
    } = this;
    return value !== null && value !== "" && (zeroIsValue || value !== 0) && typeof value !== "undefined";
  }
  isString(regexp) {
    var {
      value
    } = this;
    var result = typeof value === "string";
    if (!result || !regexp) {
      return result;
    }
    return regexp.test(value);
  }
  isUrlDefinition() {
    return this.isString(/^url\(/);
  }
  isPixels() {
    if (!this.hasValue()) {
      return false;
    }
    var asString2 = this.getString();
    switch (true) {
      case asString2.endsWith("px"):
      case /^[0-9]+$/.test(asString2):
        return true;
      default:
        return false;
    }
  }
  setValue(value) {
    this.value = value;
    return this;
  }
  getValue(def) {
    if (typeof def === "undefined" || this.hasValue()) {
      return this.value;
    }
    return def;
  }
  getNumber(def) {
    if (!this.hasValue()) {
      if (typeof def === "undefined") {
        return 0;
      }
      return parseFloat(def);
    }
    var {
      value
    } = this;
    var n2 = parseFloat(value);
    if (this.isString(/%$/)) {
      n2 /= 100;
    }
    return n2;
  }
  getString(def) {
    if (typeof def === "undefined" || this.hasValue()) {
      return typeof this.value === "undefined" ? "" : String(this.value);
    }
    return String(def);
  }
  getColor(def) {
    var color2 = this.getString(def);
    if (this.isNormalizedColor) {
      return color2;
    }
    this.isNormalizedColor = true;
    color2 = normalizeColor(color2);
    this.value = color2;
    return color2;
  }
  getDpi() {
    return 96;
  }
  getRem() {
    return this.document.rootEmSize;
  }
  getEm() {
    return this.document.emSize;
  }
  getUnits() {
    return this.getString().replace(/[0-9.-]/g, "");
  }
  getPixels(axisOrIsFontSize) {
    var processPercent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (!this.hasValue()) {
      return 0;
    }
    var [axis, isFontSize] = typeof axisOrIsFontSize === "boolean" ? [void 0, axisOrIsFontSize] : [axisOrIsFontSize];
    var {
      viewPort
    } = this.document.screen;
    switch (true) {
      case this.isString(/vmin$/):
        return this.getNumber() / 100 * Math.min(viewPort.computeSize("x"), viewPort.computeSize("y"));
      case this.isString(/vmax$/):
        return this.getNumber() / 100 * Math.max(viewPort.computeSize("x"), viewPort.computeSize("y"));
      case this.isString(/vw$/):
        return this.getNumber() / 100 * viewPort.computeSize("x");
      case this.isString(/vh$/):
        return this.getNumber() / 100 * viewPort.computeSize("y");
      case this.isString(/rem$/):
        return this.getNumber() * this.getRem();
      case this.isString(/em$/):
        return this.getNumber() * this.getEm();
      case this.isString(/ex$/):
        return this.getNumber() * this.getEm() / 2;
      case this.isString(/px$/):
        return this.getNumber();
      case this.isString(/pt$/):
        return this.getNumber() * this.getDpi() * (1 / 72);
      case this.isString(/pc$/):
        return this.getNumber() * 15;
      case this.isString(/cm$/):
        return this.getNumber() * this.getDpi() / 2.54;
      case this.isString(/mm$/):
        return this.getNumber() * this.getDpi() / 25.4;
      case this.isString(/in$/):
        return this.getNumber() * this.getDpi();
      case (this.isString(/%$/) && isFontSize):
        return this.getNumber() * this.getEm();
      case this.isString(/%$/):
        return this.getNumber() * viewPort.computeSize(axis);
      default: {
        var n2 = this.getNumber();
        if (processPercent && n2 < 1) {
          return n2 * viewPort.computeSize(axis);
        }
        return n2;
      }
    }
  }
  getMilliseconds() {
    if (!this.hasValue()) {
      return 0;
    }
    if (this.isString(/ms$/)) {
      return this.getNumber();
    }
    return this.getNumber() * 1e3;
  }
  getRadians() {
    if (!this.hasValue()) {
      return 0;
    }
    switch (true) {
      case this.isString(/deg$/):
        return this.getNumber() * (Math.PI / 180);
      case this.isString(/grad$/):
        return this.getNumber() * (Math.PI / 200);
      case this.isString(/rad$/):
        return this.getNumber();
      default:
        return this.getNumber() * (Math.PI / 180);
    }
  }
  getDefinition() {
    var asString2 = this.getString();
    var name = /#([^)'"]+)/.exec(asString2);
    if (name) {
      name = name[1];
    }
    if (!name) {
      name = asString2;
    }
    return this.document.definitions[name];
  }
  getFillStyleDefinition(element, opacity2) {
    var def = this.getDefinition();
    if (!def) {
      return null;
    }
    if (typeof def.createGradient === "function") {
      return def.createGradient(this.document.ctx, element, opacity2);
    }
    if (typeof def.createPattern === "function") {
      if (def.getHrefAttribute().hasValue()) {
        var patternTransform = def.getAttribute("patternTransform");
        def = def.getHrefAttribute().getDefinition();
        if (patternTransform.hasValue()) {
          def.getAttribute("patternTransform", true).setValue(patternTransform.value);
        }
      }
      return def.createPattern(this.document.ctx, element, opacity2);
    }
    return null;
  }
  getTextBaseline() {
    if (!this.hasValue()) {
      return null;
    }
    return Property.textBaselineMapping[this.getString()];
  }
  addOpacity(opacity2) {
    var value = this.getColor();
    var len = value.length;
    var commas = 0;
    for (var i2 = 0; i2 < len; i2++) {
      if (value[i2] === ",") {
        commas++;
      }
      if (commas === 3) {
        break;
      }
    }
    if (opacity2.hasValue() && this.isString() && commas !== 3) {
      var color2 = new rgbcolor(value);
      if (color2.ok) {
        color2.alpha = opacity2.getNumber();
        value = color2.toRGBA();
      }
    }
    return new Property(this.document, this.name, value);
  }
}
Property.textBaselineMapping = {
  "baseline": "alphabetic",
  "before-edge": "top",
  "text-before-edge": "top",
  "middle": "middle",
  "central": "middle",
  "after-edge": "bottom",
  "text-after-edge": "bottom",
  "ideographic": "ideographic",
  "alphabetic": "alphabetic",
  "hanging": "hanging",
  "mathematical": "alphabetic"
};
class ViewPort {
  constructor() {
    this.viewPorts = [];
  }
  clear() {
    this.viewPorts = [];
  }
  setCurrent(width, height) {
    this.viewPorts.push({
      width,
      height
    });
  }
  removeCurrent() {
    this.viewPorts.pop();
  }
  getCurrent() {
    var {
      viewPorts
    } = this;
    return viewPorts[viewPorts.length - 1];
  }
  get width() {
    return this.getCurrent().width;
  }
  get height() {
    return this.getCurrent().height;
  }
  computeSize(d2) {
    if (typeof d2 === "number") {
      return d2;
    }
    if (d2 === "x") {
      return this.width;
    }
    if (d2 === "y") {
      return this.height;
    }
    return Math.sqrt(Math.pow(this.width, 2) + Math.pow(this.height, 2)) / Math.sqrt(2);
  }
}
class Point {
  constructor(x2, y2) {
    this.x = x2;
    this.y = y2;
  }
  static parse(point) {
    var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var [x2 = defaultValue, y2 = defaultValue] = toNumbers(point);
    return new Point(x2, y2);
  }
  static parseScale(scale2) {
    var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    var [x2 = defaultValue, y2 = x2] = toNumbers(scale2);
    return new Point(x2, y2);
  }
  static parsePath(path) {
    var points = toNumbers(path);
    var len = points.length;
    var pathPoints = [];
    for (var i2 = 0; i2 < len; i2 += 2) {
      pathPoints.push(new Point(points[i2], points[i2 + 1]));
    }
    return pathPoints;
  }
  angleTo(point) {
    return Math.atan2(point.y - this.y, point.x - this.x);
  }
  applyTransform(transform2) {
    var {
      x: x2,
      y: y2
    } = this;
    var xp = x2 * transform2[0] + y2 * transform2[2] + transform2[4];
    var yp = x2 * transform2[1] + y2 * transform2[3] + transform2[5];
    this.x = xp;
    this.y = yp;
  }
}
class Mouse {
  constructor(screen) {
    this.screen = screen;
    this.working = false;
    this.events = [];
    this.eventElements = [];
    this.onClick = this.onClick.bind(this);
    this.onMouseMove = this.onMouseMove.bind(this);
  }
  isWorking() {
    return this.working;
  }
  start() {
    if (this.working) {
      return;
    }
    var {
      screen,
      onClick,
      onMouseMove
    } = this;
    var canvas = screen.ctx.canvas;
    canvas.onclick = onClick;
    canvas.onmousemove = onMouseMove;
    this.working = true;
  }
  stop() {
    if (!this.working) {
      return;
    }
    var canvas = this.screen.ctx.canvas;
    this.working = false;
    canvas.onclick = null;
    canvas.onmousemove = null;
  }
  hasEvents() {
    return this.working && this.events.length > 0;
  }
  runEvents() {
    if (!this.working) {
      return;
    }
    var {
      screen: document2,
      events: events2,
      eventElements
    } = this;
    var {
      style: style2
    } = document2.ctx.canvas;
    if (style2) {
      style2.cursor = "";
    }
    events2.forEach((_ref2, i2) => {
      var {
        run: run2
      } = _ref2;
      var element = eventElements[i2];
      while (element) {
        run2(element);
        element = element.parent;
      }
    });
    this.events = [];
    this.eventElements = [];
  }
  checkPath(element, ctx) {
    if (!this.working || !ctx) {
      return;
    }
    var {
      events: events2,
      eventElements
    } = this;
    events2.forEach((_ref2, i2) => {
      var {
        x: x2,
        y: y2
      } = _ref2;
      if (!eventElements[i2] && ctx.isPointInPath && ctx.isPointInPath(x2, y2)) {
        eventElements[i2] = element;
      }
    });
  }
  checkBoundingBox(element, boundingBox) {
    if (!this.working || !boundingBox) {
      return;
    }
    var {
      events: events2,
      eventElements
    } = this;
    events2.forEach((_ref3, i2) => {
      var {
        x: x2,
        y: y2
      } = _ref3;
      if (!eventElements[i2] && boundingBox.isPointInBox(x2, y2)) {
        eventElements[i2] = element;
      }
    });
  }
  mapXY(x2, y2) {
    var {
      window: window2,
      ctx
    } = this.screen;
    var point = new Point(x2, y2);
    var element = ctx.canvas;
    while (element) {
      point.x -= element.offsetLeft;
      point.y -= element.offsetTop;
      element = element.offsetParent;
    }
    if (window2.scrollX) {
      point.x += window2.scrollX;
    }
    if (window2.scrollY) {
      point.y += window2.scrollY;
    }
    return point;
  }
  onClick(event) {
    var {
      x: x2,
      y: y2
    } = this.mapXY(event.clientX, event.clientY);
    this.events.push({
      type: "onclick",
      x: x2,
      y: y2,
      run(eventTarget) {
        if (eventTarget.onClick) {
          eventTarget.onClick();
        }
      }
    });
  }
  onMouseMove(event) {
    var {
      x: x2,
      y: y2
    } = this.mapXY(event.clientX, event.clientY);
    this.events.push({
      type: "onmousemove",
      x: x2,
      y: y2,
      run(eventTarget) {
        if (eventTarget.onMouseMove) {
          eventTarget.onMouseMove();
        }
      }
    });
  }
}
var defaultWindow = typeof window !== "undefined" ? window : null;
var defaultFetch$1 = typeof fetch !== "undefined" ? fetch.bind(void 0) : null;
class Screen {
  constructor(ctx) {
    var {
      fetch: fetch2 = defaultFetch$1,
      window: window2 = defaultWindow
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.ctx = ctx;
    this.FRAMERATE = 30;
    this.MAX_VIRTUAL_PIXELS = 3e4;
    this.CLIENT_WIDTH = 800;
    this.CLIENT_HEIGHT = 600;
    this.viewPort = new ViewPort();
    this.mouse = new Mouse(this);
    this.animations = [];
    this.waits = [];
    this.frameDuration = 0;
    this.isReadyLock = false;
    this.isFirstRender = true;
    this.intervalId = null;
    this.window = window2;
    this.fetch = fetch2;
  }
  wait(checker) {
    this.waits.push(checker);
  }
  ready() {
    if (!this.readyPromise) {
      return Promise.resolve();
    }
    return this.readyPromise;
  }
  isReady() {
    if (this.isReadyLock) {
      return true;
    }
    var isReadyLock = this.waits.every((_2) => _2());
    if (isReadyLock) {
      this.waits = [];
      if (this.resolveReady) {
        this.resolveReady();
      }
    }
    this.isReadyLock = isReadyLock;
    return isReadyLock;
  }
  setDefaults(ctx) {
    ctx.strokeStyle = "rgba(0,0,0,0)";
    ctx.lineCap = "butt";
    ctx.lineJoin = "miter";
    ctx.miterLimit = 4;
  }
  setViewBox(_ref2) {
    var {
      document: document2,
      ctx,
      aspectRatio,
      width,
      desiredWidth,
      height,
      desiredHeight,
      minX = 0,
      minY = 0,
      refX,
      refY,
      clip = false,
      clipX = 0,
      clipY = 0
    } = _ref2;
    var cleanAspectRatio = compressSpaces(aspectRatio).replace(/^defer\s/, "");
    var [aspectRatioAlign, aspectRatioMeetOrSlice] = cleanAspectRatio.split(" ");
    var align = aspectRatioAlign || "xMidYMid";
    var meetOrSlice = aspectRatioMeetOrSlice || "meet";
    var scaleX = width / desiredWidth;
    var scaleY = height / desiredHeight;
    var scaleMin = Math.min(scaleX, scaleY);
    var scaleMax = Math.max(scaleX, scaleY);
    var finalDesiredWidth = desiredWidth;
    var finalDesiredHeight = desiredHeight;
    if (meetOrSlice === "meet") {
      finalDesiredWidth *= scaleMin;
      finalDesiredHeight *= scaleMin;
    }
    if (meetOrSlice === "slice") {
      finalDesiredWidth *= scaleMax;
      finalDesiredHeight *= scaleMax;
    }
    var refXProp = new Property(document2, "refX", refX);
    var refYProp = new Property(document2, "refY", refY);
    var hasRefs = refXProp.hasValue() && refYProp.hasValue();
    if (hasRefs) {
      ctx.translate(-scaleMin * refXProp.getPixels("x"), -scaleMin * refYProp.getPixels("y"));
    }
    if (clip) {
      var scaledClipX = scaleMin * clipX;
      var scaledClipY = scaleMin * clipY;
      ctx.beginPath();
      ctx.moveTo(scaledClipX, scaledClipY);
      ctx.lineTo(width, scaledClipY);
      ctx.lineTo(width, height);
      ctx.lineTo(scaledClipX, height);
      ctx.closePath();
      ctx.clip();
    }
    if (!hasRefs) {
      var isMeetMinY = meetOrSlice === "meet" && scaleMin === scaleY;
      var isSliceMaxY = meetOrSlice === "slice" && scaleMax === scaleY;
      var isMeetMinX = meetOrSlice === "meet" && scaleMin === scaleX;
      var isSliceMaxX = meetOrSlice === "slice" && scaleMax === scaleX;
      if (align.startsWith("xMid") && (isMeetMinY || isSliceMaxY)) {
        ctx.translate(width / 2 - finalDesiredWidth / 2, 0);
      }
      if (align.endsWith("YMid") && (isMeetMinX || isSliceMaxX)) {
        ctx.translate(0, height / 2 - finalDesiredHeight / 2);
      }
      if (align.startsWith("xMax") && (isMeetMinY || isSliceMaxY)) {
        ctx.translate(width - finalDesiredWidth, 0);
      }
      if (align.endsWith("YMax") && (isMeetMinX || isSliceMaxX)) {
        ctx.translate(0, height - finalDesiredHeight);
      }
    }
    switch (true) {
      case align === "none":
        ctx.scale(scaleX, scaleY);
        break;
      case meetOrSlice === "meet":
        ctx.scale(scaleMin, scaleMin);
        break;
      case meetOrSlice === "slice":
        ctx.scale(scaleMax, scaleMax);
        break;
    }
    ctx.translate(-minX, -minY);
  }
  start(element) {
    var {
      enableRedraw = false,
      ignoreMouse = false,
      ignoreAnimation = false,
      ignoreDimensions = false,
      ignoreClear = false,
      forceRedraw,
      scaleWidth,
      scaleHeight,
      offsetX,
      offsetY
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      FRAMERATE,
      mouse
    } = this;
    var frameDuration = 1e3 / FRAMERATE;
    this.frameDuration = frameDuration;
    this.readyPromise = new Promise((resolve2) => {
      this.resolveReady = resolve2;
    });
    if (this.isReady()) {
      this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);
    }
    if (!enableRedraw) {
      return;
    }
    var now2 = Date.now();
    var then2 = now2;
    var delta = 0;
    var tick = () => {
      now2 = Date.now();
      delta = now2 - then2;
      if (delta >= frameDuration) {
        then2 = now2 - delta % frameDuration;
        if (this.shouldUpdate(ignoreAnimation, forceRedraw)) {
          this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);
          mouse.runEvents();
        }
      }
      this.intervalId = requestAnimationFrame$1(tick);
    };
    if (!ignoreMouse) {
      mouse.start();
    }
    this.intervalId = requestAnimationFrame$1(tick);
  }
  stop() {
    if (this.intervalId) {
      requestAnimationFrame$1.cancel(this.intervalId);
      this.intervalId = null;
    }
    this.mouse.stop();
  }
  shouldUpdate(ignoreAnimation, forceRedraw) {
    if (!ignoreAnimation) {
      var {
        frameDuration
      } = this;
      var shouldUpdate = this.animations.reduce((shouldUpdate2, animation) => animation.update(frameDuration) || shouldUpdate2, false);
      if (shouldUpdate) {
        return true;
      }
    }
    if (typeof forceRedraw === "function" && forceRedraw()) {
      return true;
    }
    if (!this.isReadyLock && this.isReady()) {
      return true;
    }
    if (this.mouse.hasEvents()) {
      return true;
    }
    return false;
  }
  render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY) {
    var {
      CLIENT_WIDTH,
      CLIENT_HEIGHT,
      viewPort,
      ctx,
      isFirstRender
    } = this;
    var canvas = ctx.canvas;
    viewPort.clear();
    if (canvas.width && canvas.height) {
      viewPort.setCurrent(canvas.width, canvas.height);
    } else {
      viewPort.setCurrent(CLIENT_WIDTH, CLIENT_HEIGHT);
    }
    var widthStyle = element.getStyle("width");
    var heightStyle = element.getStyle("height");
    if (!ignoreDimensions && (isFirstRender || typeof scaleWidth !== "number" && typeof scaleHeight !== "number")) {
      if (widthStyle.hasValue()) {
        canvas.width = widthStyle.getPixels("x");
        if (canvas.style) {
          canvas.style.width = "".concat(canvas.width, "px");
        }
      }
      if (heightStyle.hasValue()) {
        canvas.height = heightStyle.getPixels("y");
        if (canvas.style) {
          canvas.style.height = "".concat(canvas.height, "px");
        }
      }
    }
    var cWidth = canvas.clientWidth || canvas.width;
    var cHeight = canvas.clientHeight || canvas.height;
    if (ignoreDimensions && widthStyle.hasValue() && heightStyle.hasValue()) {
      cWidth = widthStyle.getPixels("x");
      cHeight = heightStyle.getPixels("y");
    }
    viewPort.setCurrent(cWidth, cHeight);
    if (typeof offsetX === "number") {
      element.getAttribute("x", true).setValue(offsetX);
    }
    if (typeof offsetY === "number") {
      element.getAttribute("y", true).setValue(offsetY);
    }
    if (typeof scaleWidth === "number" || typeof scaleHeight === "number") {
      var viewBox = toNumbers(element.getAttribute("viewBox").getString());
      var xRatio = 0;
      var yRatio = 0;
      if (typeof scaleWidth === "number") {
        var _widthStyle = element.getStyle("width");
        if (_widthStyle.hasValue()) {
          xRatio = _widthStyle.getPixels("x") / scaleWidth;
        } else if (!isNaN(viewBox[2])) {
          xRatio = viewBox[2] / scaleWidth;
        }
      }
      if (typeof scaleHeight === "number") {
        var _heightStyle = element.getStyle("height");
        if (_heightStyle.hasValue()) {
          yRatio = _heightStyle.getPixels("y") / scaleHeight;
        } else if (!isNaN(viewBox[3])) {
          yRatio = viewBox[3] / scaleHeight;
        }
      }
      if (!xRatio) {
        xRatio = yRatio;
      }
      if (!yRatio) {
        yRatio = xRatio;
      }
      element.getAttribute("width", true).setValue(scaleWidth);
      element.getAttribute("height", true).setValue(scaleHeight);
      var transformStyle = element.getStyle("transform", true, true);
      transformStyle.setValue("".concat(transformStyle.getString(), " scale(").concat(1 / xRatio, ", ").concat(1 / yRatio, ")"));
    }
    if (!ignoreClear) {
      ctx.clearRect(0, 0, cWidth, cHeight);
    }
    element.render(ctx);
    if (isFirstRender) {
      this.isFirstRender = false;
    }
  }
}
Screen.defaultWindow = defaultWindow;
Screen.defaultFetch = defaultFetch$1;
var {
  defaultFetch
} = Screen;
var DefaultDOMParser = typeof DOMParser !== "undefined" ? DOMParser : null;
class Parser {
  constructor() {
    var {
      fetch: fetch2 = defaultFetch,
      DOMParser: DOMParser2 = DefaultDOMParser
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.fetch = fetch2;
    this.DOMParser = DOMParser2;
  }
  parse(resource) {
    var _this = this;
    return _asyncToGenerator(function* () {
      if (resource.startsWith("<")) {
        return _this.parseFromString(resource);
      }
      return _this.load(resource);
    })();
  }
  parseFromString(xml2) {
    var parser = new this.DOMParser();
    try {
      return this.checkDocument(parser.parseFromString(xml2, "image/svg+xml"));
    } catch (err2) {
      return this.checkDocument(parser.parseFromString(xml2, "text/xml"));
    }
  }
  checkDocument(document2) {
    var parserError = document2.getElementsByTagName("parsererror")[0];
    if (parserError) {
      throw new Error(parserError.textContent);
    }
    return document2;
  }
  load(url) {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      var response = yield _this2.fetch(url);
      var xml2 = yield response.text();
      return _this2.parseFromString(xml2);
    })();
  }
}
class Translate {
  constructor(_2, point) {
    this.type = "translate";
    this.point = null;
    this.point = Point.parse(point);
  }
  apply(ctx) {
    var {
      x: x2,
      y: y2
    } = this.point;
    ctx.translate(x2 || 0, y2 || 0);
  }
  unapply(ctx) {
    var {
      x: x2,
      y: y2
    } = this.point;
    ctx.translate(-1 * x2 || 0, -1 * y2 || 0);
  }
  applyToPoint(point) {
    var {
      x: x2,
      y: y2
    } = this.point;
    point.applyTransform([1, 0, 0, 1, x2 || 0, y2 || 0]);
  }
}
class Rotate {
  constructor(document2, rotate2, transformOrigin2) {
    this.type = "rotate";
    this.angle = null;
    this.originX = null;
    this.originY = null;
    this.cx = 0;
    this.cy = 0;
    var numbers = toNumbers(rotate2);
    this.angle = new Property(document2, "angle", numbers[0]);
    this.originX = transformOrigin2[0];
    this.originY = transformOrigin2[1];
    this.cx = numbers[1] || 0;
    this.cy = numbers[2] || 0;
  }
  apply(ctx) {
    var {
      cx,
      cy,
      originX,
      originY,
      angle: angle2
    } = this;
    var tx = cx + originX.getPixels("x");
    var ty = cy + originY.getPixels("y");
    ctx.translate(tx, ty);
    ctx.rotate(angle2.getRadians());
    ctx.translate(-tx, -ty);
  }
  unapply(ctx) {
    var {
      cx,
      cy,
      originX,
      originY,
      angle: angle2
    } = this;
    var tx = cx + originX.getPixels("x");
    var ty = cy + originY.getPixels("y");
    ctx.translate(tx, ty);
    ctx.rotate(-1 * angle2.getRadians());
    ctx.translate(-tx, -ty);
  }
  applyToPoint(point) {
    var {
      cx,
      cy,
      angle: angle2
    } = this;
    var rad = angle2.getRadians();
    point.applyTransform([
      1,
      0,
      0,
      1,
      cx || 0,
      cy || 0
    ]);
    point.applyTransform([Math.cos(rad), Math.sin(rad), -Math.sin(rad), Math.cos(rad), 0, 0]);
    point.applyTransform([
      1,
      0,
      0,
      1,
      -cx || 0,
      -cy || 0
    ]);
  }
}
class Scale {
  constructor(_2, scale2, transformOrigin2) {
    this.type = "scale";
    this.scale = null;
    this.originX = null;
    this.originY = null;
    var scaleSize = Point.parseScale(scale2);
    if (scaleSize.x === 0 || scaleSize.y === 0) {
      scaleSize.x = PSEUDO_ZERO;
      scaleSize.y = PSEUDO_ZERO;
    }
    this.scale = scaleSize;
    this.originX = transformOrigin2[0];
    this.originY = transformOrigin2[1];
  }
  apply(ctx) {
    var {
      scale: {
        x: x2,
        y: y2
      },
      originX,
      originY
    } = this;
    var tx = originX.getPixels("x");
    var ty = originY.getPixels("y");
    ctx.translate(tx, ty);
    ctx.scale(x2, y2 || x2);
    ctx.translate(-tx, -ty);
  }
  unapply(ctx) {
    var {
      scale: {
        x: x2,
        y: y2
      },
      originX,
      originY
    } = this;
    var tx = originX.getPixels("x");
    var ty = originY.getPixels("y");
    ctx.translate(tx, ty);
    ctx.scale(1 / x2, 1 / y2 || x2);
    ctx.translate(-tx, -ty);
  }
  applyToPoint(point) {
    var {
      x: x2,
      y: y2
    } = this.scale;
    point.applyTransform([x2 || 0, 0, 0, y2 || 0, 0, 0]);
  }
}
class Matrix {
  constructor(_2, matrix2, transformOrigin2) {
    this.type = "matrix";
    this.matrix = [];
    this.originX = null;
    this.originY = null;
    this.matrix = toNumbers(matrix2);
    this.originX = transformOrigin2[0];
    this.originY = transformOrigin2[1];
  }
  apply(ctx) {
    var {
      originX,
      originY,
      matrix: matrix2
    } = this;
    var tx = originX.getPixels("x");
    var ty = originY.getPixels("y");
    ctx.translate(tx, ty);
    ctx.transform(matrix2[0], matrix2[1], matrix2[2], matrix2[3], matrix2[4], matrix2[5]);
    ctx.translate(-tx, -ty);
  }
  unapply(ctx) {
    var {
      originX,
      originY,
      matrix: matrix2
    } = this;
    var a2 = matrix2[0];
    var b2 = matrix2[2];
    var c2 = matrix2[4];
    var d2 = matrix2[1];
    var e2 = matrix2[3];
    var f2 = matrix2[5];
    var g2 = 0;
    var h2 = 0;
    var i2 = 1;
    var det = 1 / (a2 * (e2 * i2 - f2 * h2) - b2 * (d2 * i2 - f2 * g2) + c2 * (d2 * h2 - e2 * g2));
    var tx = originX.getPixels("x");
    var ty = originY.getPixels("y");
    ctx.translate(tx, ty);
    ctx.transform(det * (e2 * i2 - f2 * h2), det * (f2 * g2 - d2 * i2), det * (c2 * h2 - b2 * i2), det * (a2 * i2 - c2 * g2), det * (b2 * f2 - c2 * e2), det * (c2 * d2 - a2 * f2));
    ctx.translate(-tx, -ty);
  }
  applyToPoint(point) {
    point.applyTransform(this.matrix);
  }
}
class Skew extends Matrix {
  constructor(document2, skew, transformOrigin2) {
    super(document2, skew, transformOrigin2);
    this.type = "skew";
    this.angle = null;
    this.angle = new Property(document2, "angle", skew);
  }
}
class SkewX extends Skew {
  constructor(document2, skew, transformOrigin2) {
    super(document2, skew, transformOrigin2);
    this.type = "skewX";
    this.matrix = [1, 0, Math.tan(this.angle.getRadians()), 1, 0, 0];
  }
}
class SkewY extends Skew {
  constructor(document2, skew, transformOrigin2) {
    super(document2, skew, transformOrigin2);
    this.type = "skewY";
    this.matrix = [1, Math.tan(this.angle.getRadians()), 0, 1, 0, 0];
  }
}
function parseTransforms(transform2) {
  return compressSpaces(transform2).trim().replace(/\)([a-zA-Z])/g, ") $1").replace(/\)(\s?,\s?)/g, ") ").split(/\s(?=[a-z])/);
}
function parseTransform(transform2) {
  var [type, value] = transform2.split("(");
  return [type.trim(), value.trim().replace(")", "")];
}
class Transform {
  constructor(document2, transform2, transformOrigin2) {
    this.document = document2;
    this.transforms = [];
    var data2 = parseTransforms(transform2);
    data2.forEach((transform3) => {
      if (transform3 === "none") {
        return;
      }
      var [type, value] = parseTransform(transform3);
      var TransformType = Transform.transformTypes[type];
      if (typeof TransformType !== "undefined") {
        this.transforms.push(new TransformType(this.document, value, transformOrigin2));
      }
    });
  }
  static fromElement(document2, element) {
    var transformStyle = element.getStyle("transform", false, true);
    var [transformOriginXProperty, transformOriginYProperty = transformOriginXProperty] = element.getStyle("transform-origin", false, true).split();
    var transformOrigin2 = [transformOriginXProperty, transformOriginYProperty];
    if (transformStyle.hasValue()) {
      return new Transform(document2, transformStyle.getString(), transformOrigin2);
    }
    return null;
  }
  apply(ctx) {
    var {
      transforms: transforms2
    } = this;
    var len = transforms2.length;
    for (var i2 = 0; i2 < len; i2++) {
      transforms2[i2].apply(ctx);
    }
  }
  unapply(ctx) {
    var {
      transforms: transforms2
    } = this;
    var len = transforms2.length;
    for (var i2 = len - 1; i2 >= 0; i2--) {
      transforms2[i2].unapply(ctx);
    }
  }
  applyToPoint(point) {
    var {
      transforms: transforms2
    } = this;
    var len = transforms2.length;
    for (var i2 = 0; i2 < len; i2++) {
      transforms2[i2].applyToPoint(point);
    }
  }
}
Transform.transformTypes = {
  translate: Translate,
  rotate: Rotate,
  scale: Scale,
  matrix: Matrix,
  skewX: SkewX,
  skewY: SkewY
};
class Element$1 {
  constructor(document2, node2) {
    var captureTextNodes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    this.document = document2;
    this.node = node2;
    this.captureTextNodes = captureTextNodes;
    this.attributes = {};
    this.styles = {};
    this.stylesSpecificity = {};
    this.animationFrozen = false;
    this.animationFrozenValue = "";
    this.parent = null;
    this.children = [];
    if (!node2 || node2.nodeType !== 1) {
      return;
    }
    Array.from(node2.attributes).forEach((attribute) => {
      var nodeName = normalizeAttributeName(attribute.nodeName);
      this.attributes[nodeName] = new Property(document2, nodeName, attribute.value);
    });
    this.addStylesFromStyleDefinition();
    if (this.getAttribute("style").hasValue()) {
      var styles = this.getAttribute("style").getString().split(";").map((_2) => _2.trim());
      styles.forEach((style2) => {
        if (!style2) {
          return;
        }
        var [name, value] = style2.split(":").map((_2) => _2.trim());
        this.styles[name] = new Property(document2, name, value);
      });
    }
    var {
      definitions
    } = document2;
    var id = this.getAttribute("id");
    if (id.hasValue()) {
      if (!definitions[id.getString()]) {
        definitions[id.getString()] = this;
      }
    }
    Array.from(node2.childNodes).forEach((childNode) => {
      if (childNode.nodeType === 1) {
        this.addChild(childNode);
      } else if (captureTextNodes && (childNode.nodeType === 3 || childNode.nodeType === 4)) {
        var textNode = document2.createTextNode(childNode);
        if (textNode.getText().length > 0) {
          this.addChild(textNode);
        }
      }
    });
  }
  getAttribute(name) {
    var createIfNotExists = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var attr = this.attributes[name];
    if (!attr && createIfNotExists) {
      var _attr = new Property(this.document, name, "");
      this.attributes[name] = _attr;
      return _attr;
    }
    return attr || Property.empty(this.document);
  }
  getHrefAttribute() {
    for (var key in this.attributes) {
      if (key === "href" || key.endsWith(":href")) {
        return this.attributes[key];
      }
    }
    return Property.empty(this.document);
  }
  getStyle(name) {
    var createIfNotExists = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var skipAncestors = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    var style2 = this.styles[name];
    if (style2) {
      return style2;
    }
    var attr = this.getAttribute(name);
    if (attr !== null && attr !== void 0 && attr.hasValue()) {
      this.styles[name] = attr;
      return attr;
    }
    if (!skipAncestors) {
      var {
        parent
      } = this;
      if (parent) {
        var parentStyle = parent.getStyle(name);
        if (parentStyle !== null && parentStyle !== void 0 && parentStyle.hasValue()) {
          return parentStyle;
        }
      }
    }
    if (createIfNotExists) {
      var _style = new Property(this.document, name, "");
      this.styles[name] = _style;
      return _style;
    }
    return style2 || Property.empty(this.document);
  }
  render(ctx) {
    if (this.getStyle("display").getString() === "none" || this.getStyle("visibility").getString() === "hidden") {
      return;
    }
    ctx.save();
    if (this.getStyle("mask").hasValue()) {
      var mask = this.getStyle("mask").getDefinition();
      if (mask) {
        this.applyEffects(ctx);
        mask.apply(ctx, this);
      }
    } else if (this.getStyle("filter").getValue("none") !== "none") {
      var filter = this.getStyle("filter").getDefinition();
      if (filter) {
        this.applyEffects(ctx);
        filter.apply(ctx, this);
      }
    } else {
      this.setContext(ctx);
      this.renderChildren(ctx);
      this.clearContext(ctx);
    }
    ctx.restore();
  }
  setContext(_2) {
  }
  applyEffects(ctx) {
    var transform2 = Transform.fromElement(this.document, this);
    if (transform2) {
      transform2.apply(ctx);
    }
    var clipPathStyleProp = this.getStyle("clip-path", false, true);
    if (clipPathStyleProp.hasValue()) {
      var clip = clipPathStyleProp.getDefinition();
      if (clip) {
        clip.apply(ctx);
      }
    }
  }
  clearContext(_2) {
  }
  renderChildren(ctx) {
    this.children.forEach((child) => {
      child.render(ctx);
    });
  }
  addChild(childNode) {
    var child = childNode instanceof Element$1 ? childNode : this.document.createElement(childNode);
    child.parent = this;
    if (!Element$1.ignoreChildTypes.includes(child.type)) {
      this.children.push(child);
    }
  }
  matchesSelector(selector) {
    var {
      node: node2
    } = this;
    if (typeof node2.matches === "function") {
      return node2.matches(selector);
    }
    var styleClasses = node2.getAttribute("class");
    if (!styleClasses || styleClasses === "") {
      return false;
    }
    return styleClasses.split(" ").some((styleClass) => ".".concat(styleClass) === selector);
  }
  addStylesFromStyleDefinition() {
    var {
      styles,
      stylesSpecificity
    } = this.document;
    for (var selector in styles) {
      if (!selector.startsWith("@") && this.matchesSelector(selector)) {
        var style2 = styles[selector];
        var specificity = stylesSpecificity[selector];
        if (style2) {
          for (var name in style2) {
            var existingSpecificity = this.stylesSpecificity[name];
            if (typeof existingSpecificity === "undefined") {
              existingSpecificity = "000";
            }
            if (specificity >= existingSpecificity) {
              this.styles[name] = style2[name];
              this.stylesSpecificity[name] = specificity;
            }
          }
        }
      }
    }
  }
  removeStyles(element, ignoreStyles) {
    var toRestore = ignoreStyles.reduce((toRestore2, name) => {
      var styleProp = element.getStyle(name);
      if (!styleProp.hasValue()) {
        return toRestore2;
      }
      var value = styleProp.getString();
      styleProp.setValue("");
      return [...toRestore2, [name, value]];
    }, []);
    return toRestore;
  }
  restoreStyles(element, styles) {
    styles.forEach((_ref2) => {
      var [name, value] = _ref2;
      element.getStyle(name, true).setValue(value);
    });
  }
}
Element$1.ignoreChildTypes = ["title"];
class UnknownElement extends Element$1 {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
  }
}
function wrapFontFamily(fontFamily2) {
  var trimmed = fontFamily2.trim();
  return /^('|")/.test(trimmed) ? trimmed : '"'.concat(trimmed, '"');
}
function prepareFontFamily(fontFamily2) {
  return typeof process === "undefined" ? fontFamily2 : fontFamily2.trim().split(",").map(wrapFontFamily).join(",");
}
function prepareFontStyle(fontStyle2) {
  if (!fontStyle2) {
    return "";
  }
  var targetFontStyle = fontStyle2.trim().toLowerCase();
  switch (targetFontStyle) {
    case "normal":
    case "italic":
    case "oblique":
    case "inherit":
    case "initial":
    case "unset":
      return targetFontStyle;
    default:
      if (/^oblique\s+(-|)\d+deg$/.test(targetFontStyle)) {
        return targetFontStyle;
      }
      return "";
  }
}
function prepareFontWeight(fontWeight2) {
  if (!fontWeight2) {
    return "";
  }
  var targetFontWeight = fontWeight2.trim().toLowerCase();
  switch (targetFontWeight) {
    case "normal":
    case "bold":
    case "lighter":
    case "bolder":
    case "inherit":
    case "initial":
    case "unset":
      return targetFontWeight;
    default:
      if (/^[\d.]+$/.test(targetFontWeight)) {
        return targetFontWeight;
      }
      return "";
  }
}
class Font {
  constructor(fontStyle2, fontVariant2, fontWeight2, fontSize2, fontFamily2, inherit) {
    var inheritFont = inherit ? typeof inherit === "string" ? Font.parse(inherit) : inherit : {};
    this.fontFamily = fontFamily2 || inheritFont.fontFamily;
    this.fontSize = fontSize2 || inheritFont.fontSize;
    this.fontStyle = fontStyle2 || inheritFont.fontStyle;
    this.fontWeight = fontWeight2 || inheritFont.fontWeight;
    this.fontVariant = fontVariant2 || inheritFont.fontVariant;
  }
  static parse() {
    var font = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    var inherit = arguments.length > 1 ? arguments[1] : void 0;
    var fontStyle2 = "";
    var fontVariant2 = "";
    var fontWeight2 = "";
    var fontSize2 = "";
    var fontFamily2 = "";
    var parts = compressSpaces(font).trim().split(" ");
    var set2 = {
      fontSize: false,
      fontStyle: false,
      fontWeight: false,
      fontVariant: false
    };
    parts.forEach((part) => {
      switch (true) {
        case (!set2.fontStyle && Font.styles.includes(part)):
          if (part !== "inherit") {
            fontStyle2 = part;
          }
          set2.fontStyle = true;
          break;
        case (!set2.fontVariant && Font.variants.includes(part)):
          if (part !== "inherit") {
            fontVariant2 = part;
          }
          set2.fontStyle = true;
          set2.fontVariant = true;
          break;
        case (!set2.fontWeight && Font.weights.includes(part)):
          if (part !== "inherit") {
            fontWeight2 = part;
          }
          set2.fontStyle = true;
          set2.fontVariant = true;
          set2.fontWeight = true;
          break;
        case !set2.fontSize:
          if (part !== "inherit") {
            [fontSize2] = part.split("/");
          }
          set2.fontStyle = true;
          set2.fontVariant = true;
          set2.fontWeight = true;
          set2.fontSize = true;
          break;
        default:
          if (part !== "inherit") {
            fontFamily2 += part;
          }
      }
    });
    return new Font(fontStyle2, fontVariant2, fontWeight2, fontSize2, fontFamily2, inherit);
  }
  toString() {
    return [
      prepareFontStyle(this.fontStyle),
      this.fontVariant,
      prepareFontWeight(this.fontWeight),
      this.fontSize,
      prepareFontFamily(this.fontFamily)
    ].join(" ").trim();
  }
}
Font.styles = "normal|italic|oblique|inherit";
Font.variants = "normal|small-caps|inherit";
Font.weights = "normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit";
class BoundingBox {
  constructor() {
    var x1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Number.NaN;
    var y1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.NaN;
    var x2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Number.NaN;
    var y2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Number.NaN;
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y2;
    this.addPoint(x1, y1);
    this.addPoint(x2, y2);
  }
  get x() {
    return this.x1;
  }
  get y() {
    return this.y1;
  }
  get width() {
    return this.x2 - this.x1;
  }
  get height() {
    return this.y2 - this.y1;
  }
  addPoint(x2, y2) {
    if (typeof x2 !== "undefined") {
      if (isNaN(this.x1) || isNaN(this.x2)) {
        this.x1 = x2;
        this.x2 = x2;
      }
      if (x2 < this.x1) {
        this.x1 = x2;
      }
      if (x2 > this.x2) {
        this.x2 = x2;
      }
    }
    if (typeof y2 !== "undefined") {
      if (isNaN(this.y1) || isNaN(this.y2)) {
        this.y1 = y2;
        this.y2 = y2;
      }
      if (y2 < this.y1) {
        this.y1 = y2;
      }
      if (y2 > this.y2) {
        this.y2 = y2;
      }
    }
  }
  addX(x2) {
    this.addPoint(x2, null);
  }
  addY(y2) {
    this.addPoint(null, y2);
  }
  addBoundingBox(boundingBox) {
    if (!boundingBox) {
      return;
    }
    var {
      x1,
      y1,
      x2,
      y2
    } = boundingBox;
    this.addPoint(x1, y1);
    this.addPoint(x2, y2);
  }
  sumCubic(t3, p0, p12, p22, p32) {
    return Math.pow(1 - t3, 3) * p0 + 3 * Math.pow(1 - t3, 2) * t3 * p12 + 3 * (1 - t3) * Math.pow(t3, 2) * p22 + Math.pow(t3, 3) * p32;
  }
  bezierCurveAdd(forX, p0, p12, p22, p32) {
    var b2 = 6 * p0 - 12 * p12 + 6 * p22;
    var a2 = -3 * p0 + 9 * p12 - 9 * p22 + 3 * p32;
    var c2 = 3 * p12 - 3 * p0;
    if (a2 === 0) {
      if (b2 === 0) {
        return;
      }
      var t3 = -c2 / b2;
      if (0 < t3 && t3 < 1) {
        if (forX) {
          this.addX(this.sumCubic(t3, p0, p12, p22, p32));
        } else {
          this.addY(this.sumCubic(t3, p0, p12, p22, p32));
        }
      }
      return;
    }
    var b2ac = Math.pow(b2, 2) - 4 * c2 * a2;
    if (b2ac < 0) {
      return;
    }
    var t1 = (-b2 + Math.sqrt(b2ac)) / (2 * a2);
    if (0 < t1 && t1 < 1) {
      if (forX) {
        this.addX(this.sumCubic(t1, p0, p12, p22, p32));
      } else {
        this.addY(this.sumCubic(t1, p0, p12, p22, p32));
      }
    }
    var t22 = (-b2 - Math.sqrt(b2ac)) / (2 * a2);
    if (0 < t22 && t22 < 1) {
      if (forX) {
        this.addX(this.sumCubic(t22, p0, p12, p22, p32));
      } else {
        this.addY(this.sumCubic(t22, p0, p12, p22, p32));
      }
    }
  }
  addBezierCurve(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {
    this.addPoint(p0x, p0y);
    this.addPoint(p3x, p3y);
    this.bezierCurveAdd(true, p0x, p1x, p2x, p3x);
    this.bezierCurveAdd(false, p0y, p1y, p2y, p3y);
  }
  addQuadraticCurve(p0x, p0y, p1x, p1y, p2x, p2y) {
    var cp1x = p0x + 2 / 3 * (p1x - p0x);
    var cp1y = p0y + 2 / 3 * (p1y - p0y);
    var cp2x = cp1x + 1 / 3 * (p2x - p0x);
    var cp2y = cp1y + 1 / 3 * (p2y - p0y);
    this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y, cp2y, p2x, p2y);
  }
  isPointInBox(x2, y2) {
    var {
      x1,
      y1,
      x2: x22,
      y2: y22
    } = this;
    return x1 <= x2 && x2 <= x22 && y1 <= y2 && y2 <= y22;
  }
}
class PathParser extends _ {
  constructor(path) {
    super(path.replace(/([+\-.])\s+/gm, "$1").replace(/[^MmZzLlHhVvCcSsQqTtAae\d\s.,+-].*/g, ""));
    this.control = null;
    this.start = null;
    this.current = null;
    this.command = null;
    this.commands = this.commands;
    this.i = -1;
    this.previousCommand = null;
    this.points = [];
    this.angles = [];
  }
  reset() {
    this.i = -1;
    this.command = null;
    this.previousCommand = null;
    this.start = new Point(0, 0);
    this.control = new Point(0, 0);
    this.current = new Point(0, 0);
    this.points = [];
    this.angles = [];
  }
  isEnd() {
    var {
      i: i2,
      commands
    } = this;
    return i2 >= commands.length - 1;
  }
  next() {
    var command = this.commands[++this.i];
    this.previousCommand = this.command;
    this.command = command;
    return command;
  }
  getPoint() {
    var xProp = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "x";
    var yProp = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "y";
    var point = new Point(this.command[xProp], this.command[yProp]);
    return this.makeAbsolute(point);
  }
  getAsControlPoint(xProp, yProp) {
    var point = this.getPoint(xProp, yProp);
    this.control = point;
    return point;
  }
  getAsCurrentPoint(xProp, yProp) {
    var point = this.getPoint(xProp, yProp);
    this.current = point;
    return point;
  }
  getReflectedControlPoint() {
    var previousCommand = this.previousCommand.type;
    if (previousCommand !== _.CURVE_TO && previousCommand !== _.SMOOTH_CURVE_TO && previousCommand !== _.QUAD_TO && previousCommand !== _.SMOOTH_QUAD_TO) {
      return this.current;
    }
    var {
      current: {
        x: cx,
        y: cy
      },
      control: {
        x: ox,
        y: oy
      }
    } = this;
    var point = new Point(2 * cx - ox, 2 * cy - oy);
    return point;
  }
  makeAbsolute(point) {
    if (this.command.relative) {
      var {
        x: x2,
        y: y2
      } = this.current;
      point.x += x2;
      point.y += y2;
    }
    return point;
  }
  addMarker(point, from, priorTo) {
    var {
      points,
      angles
    } = this;
    if (priorTo && angles.length > 0 && !angles[angles.length - 1]) {
      angles[angles.length - 1] = points[points.length - 1].angleTo(priorTo);
    }
    this.addMarkerAngle(point, from ? from.angleTo(point) : null);
  }
  addMarkerAngle(point, angle2) {
    this.points.push(point);
    this.angles.push(angle2);
  }
  getMarkerPoints() {
    return this.points;
  }
  getMarkerAngles() {
    var {
      angles
    } = this;
    var len = angles.length;
    for (var i2 = 0; i2 < len; i2++) {
      if (!angles[i2]) {
        for (var j2 = i2 + 1; j2 < len; j2++) {
          if (angles[j2]) {
            angles[i2] = angles[j2];
            break;
          }
        }
      }
    }
    return angles;
  }
}
class RenderedElement extends Element$1 {
  constructor() {
    super(...arguments);
    this.modifiedEmSizeStack = false;
  }
  calculateOpacity() {
    var opacity2 = 1;
    var element = this;
    while (element) {
      var opacityStyle = element.getStyle("opacity", false, true);
      if (opacityStyle.hasValue(true)) {
        opacity2 *= opacityStyle.getNumber();
      }
      element = element.parent;
    }
    return opacity2;
  }
  setContext(ctx) {
    var fromMeasure = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (!fromMeasure) {
      var fillStyleProp = this.getStyle("fill");
      var fillOpacityStyleProp = this.getStyle("fill-opacity");
      var strokeStyleProp = this.getStyle("stroke");
      var strokeOpacityProp = this.getStyle("stroke-opacity");
      if (fillStyleProp.isUrlDefinition()) {
        var fillStyle = fillStyleProp.getFillStyleDefinition(this, fillOpacityStyleProp);
        if (fillStyle) {
          ctx.fillStyle = fillStyle;
        }
      } else if (fillStyleProp.hasValue()) {
        if (fillStyleProp.getString() === "currentColor") {
          fillStyleProp.setValue(this.getStyle("color").getColor());
        }
        var _fillStyle = fillStyleProp.getColor();
        if (_fillStyle !== "inherit") {
          ctx.fillStyle = _fillStyle === "none" ? "rgba(0,0,0,0)" : _fillStyle;
        }
      }
      if (fillOpacityStyleProp.hasValue()) {
        var _fillStyle2 = new Property(this.document, "fill", ctx.fillStyle).addOpacity(fillOpacityStyleProp).getColor();
        ctx.fillStyle = _fillStyle2;
      }
      if (strokeStyleProp.isUrlDefinition()) {
        var strokeStyle = strokeStyleProp.getFillStyleDefinition(this, strokeOpacityProp);
        if (strokeStyle) {
          ctx.strokeStyle = strokeStyle;
        }
      } else if (strokeStyleProp.hasValue()) {
        if (strokeStyleProp.getString() === "currentColor") {
          strokeStyleProp.setValue(this.getStyle("color").getColor());
        }
        var _strokeStyle = strokeStyleProp.getString();
        if (_strokeStyle !== "inherit") {
          ctx.strokeStyle = _strokeStyle === "none" ? "rgba(0,0,0,0)" : _strokeStyle;
        }
      }
      if (strokeOpacityProp.hasValue()) {
        var _strokeStyle2 = new Property(this.document, "stroke", ctx.strokeStyle).addOpacity(strokeOpacityProp).getString();
        ctx.strokeStyle = _strokeStyle2;
      }
      var strokeWidthStyleProp = this.getStyle("stroke-width");
      if (strokeWidthStyleProp.hasValue()) {
        var newLineWidth = strokeWidthStyleProp.getPixels();
        ctx.lineWidth = !newLineWidth ? PSEUDO_ZERO : newLineWidth;
      }
      var strokeLinecapStyleProp = this.getStyle("stroke-linecap");
      var strokeLinejoinStyleProp = this.getStyle("stroke-linejoin");
      var strokeMiterlimitProp = this.getStyle("stroke-miterlimit");
      var strokeDasharrayStyleProp = this.getStyle("stroke-dasharray");
      var strokeDashoffsetProp = this.getStyle("stroke-dashoffset");
      if (strokeLinecapStyleProp.hasValue()) {
        ctx.lineCap = strokeLinecapStyleProp.getString();
      }
      if (strokeLinejoinStyleProp.hasValue()) {
        ctx.lineJoin = strokeLinejoinStyleProp.getString();
      }
      if (strokeMiterlimitProp.hasValue()) {
        ctx.miterLimit = strokeMiterlimitProp.getNumber();
      }
      if (strokeDasharrayStyleProp.hasValue() && strokeDasharrayStyleProp.getString() !== "none") {
        var gaps = toNumbers(strokeDasharrayStyleProp.getString());
        if (typeof ctx.setLineDash !== "undefined") {
          ctx.setLineDash(gaps);
        } else if (typeof ctx.webkitLineDash !== "undefined") {
          ctx.webkitLineDash = gaps;
        } else if (typeof ctx.mozDash !== "undefined" && !(gaps.length === 1 && gaps[0] === 0)) {
          ctx.mozDash = gaps;
        }
        var offset2 = strokeDashoffsetProp.getPixels();
        if (typeof ctx.lineDashOffset !== "undefined") {
          ctx.lineDashOffset = offset2;
        } else if (typeof ctx.webkitLineDashOffset !== "undefined") {
          ctx.webkitLineDashOffset = offset2;
        } else if (typeof ctx.mozDashOffset !== "undefined") {
          ctx.mozDashOffset = offset2;
        }
      }
    }
    this.modifiedEmSizeStack = false;
    if (typeof ctx.font !== "undefined") {
      var fontStyleProp = this.getStyle("font");
      var fontStyleStyleProp = this.getStyle("font-style");
      var fontVariantStyleProp = this.getStyle("font-variant");
      var fontWeightStyleProp = this.getStyle("font-weight");
      var fontSizeStyleProp = this.getStyle("font-size");
      var fontFamilyStyleProp = this.getStyle("font-family");
      var font = new Font(fontStyleStyleProp.getString(), fontVariantStyleProp.getString(), fontWeightStyleProp.getString(), fontSizeStyleProp.hasValue() ? "".concat(fontSizeStyleProp.getPixels(true), "px") : "", fontFamilyStyleProp.getString(), Font.parse(fontStyleProp.getString(), ctx.font));
      fontStyleStyleProp.setValue(font.fontStyle);
      fontVariantStyleProp.setValue(font.fontVariant);
      fontWeightStyleProp.setValue(font.fontWeight);
      fontSizeStyleProp.setValue(font.fontSize);
      fontFamilyStyleProp.setValue(font.fontFamily);
      ctx.font = font.toString();
      if (fontSizeStyleProp.isPixels()) {
        this.document.emSize = fontSizeStyleProp.getPixels();
        this.modifiedEmSizeStack = true;
      }
    }
    if (!fromMeasure) {
      this.applyEffects(ctx);
      ctx.globalAlpha = this.calculateOpacity();
    }
  }
  clearContext(ctx) {
    super.clearContext(ctx);
    if (this.modifiedEmSizeStack) {
      this.document.popEmSize();
    }
  }
}
class PathElement extends RenderedElement {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "path";
    this.pathParser = null;
    this.pathParser = new PathParser(this.getAttribute("d").getString());
  }
  path(ctx) {
    var {
      pathParser
    } = this;
    var boundingBox = new BoundingBox();
    pathParser.reset();
    if (ctx) {
      ctx.beginPath();
    }
    while (!pathParser.isEnd()) {
      switch (pathParser.next().type) {
        case PathParser.MOVE_TO:
          this.pathM(ctx, boundingBox);
          break;
        case PathParser.LINE_TO:
          this.pathL(ctx, boundingBox);
          break;
        case PathParser.HORIZ_LINE_TO:
          this.pathH(ctx, boundingBox);
          break;
        case PathParser.VERT_LINE_TO:
          this.pathV(ctx, boundingBox);
          break;
        case PathParser.CURVE_TO:
          this.pathC(ctx, boundingBox);
          break;
        case PathParser.SMOOTH_CURVE_TO:
          this.pathS(ctx, boundingBox);
          break;
        case PathParser.QUAD_TO:
          this.pathQ(ctx, boundingBox);
          break;
        case PathParser.SMOOTH_QUAD_TO:
          this.pathT(ctx, boundingBox);
          break;
        case PathParser.ARC:
          this.pathA(ctx, boundingBox);
          break;
        case PathParser.CLOSE_PATH:
          this.pathZ(ctx, boundingBox);
          break;
      }
    }
    return boundingBox;
  }
  getBoundingBox(_2) {
    return this.path();
  }
  getMarkers() {
    var {
      pathParser
    } = this;
    var points = pathParser.getMarkerPoints();
    var angles = pathParser.getMarkerAngles();
    var markers = points.map((point, i2) => [point, angles[i2]]);
    return markers;
  }
  renderChildren(ctx) {
    this.path(ctx);
    this.document.screen.mouse.checkPath(this, ctx);
    var fillRuleStyleProp = this.getStyle("fill-rule");
    if (ctx.fillStyle !== "") {
      if (fillRuleStyleProp.getString("inherit") !== "inherit") {
        ctx.fill(fillRuleStyleProp.getString());
      } else {
        ctx.fill();
      }
    }
    if (ctx.strokeStyle !== "") {
      if (this.getAttribute("vector-effect").getString() === "non-scaling-stroke") {
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.stroke();
        ctx.restore();
      } else {
        ctx.stroke();
      }
    }
    var markers = this.getMarkers();
    if (markers) {
      var markersLastIndex = markers.length - 1;
      var markerStartStyleProp = this.getStyle("marker-start");
      var markerMidStyleProp = this.getStyle("marker-mid");
      var markerEndStyleProp = this.getStyle("marker-end");
      if (markerStartStyleProp.isUrlDefinition()) {
        var marker = markerStartStyleProp.getDefinition();
        var [point, angle2] = markers[0];
        marker.render(ctx, point, angle2);
      }
      if (markerMidStyleProp.isUrlDefinition()) {
        var _marker = markerMidStyleProp.getDefinition();
        for (var i2 = 1; i2 < markersLastIndex; i2++) {
          var [_point, _angle] = markers[i2];
          _marker.render(ctx, _point, _angle);
        }
      }
      if (markerEndStyleProp.isUrlDefinition()) {
        var _marker2 = markerEndStyleProp.getDefinition();
        var [_point2, _angle2] = markers[markersLastIndex];
        _marker2.render(ctx, _point2, _angle2);
      }
    }
  }
  static pathM(pathParser) {
    var point = pathParser.getAsCurrentPoint();
    pathParser.start = pathParser.current;
    return {
      point
    };
  }
  pathM(ctx, boundingBox) {
    var {
      pathParser
    } = this;
    var {
      point
    } = PathElement.pathM(pathParser);
    var {
      x: x2,
      y: y2
    } = point;
    pathParser.addMarker(point);
    boundingBox.addPoint(x2, y2);
    if (ctx) {
      ctx.moveTo(x2, y2);
    }
  }
  static pathL(pathParser) {
    var {
      current
    } = pathParser;
    var point = pathParser.getAsCurrentPoint();
    return {
      current,
      point
    };
  }
  pathL(ctx, boundingBox) {
    var {
      pathParser
    } = this;
    var {
      current,
      point
    } = PathElement.pathL(pathParser);
    var {
      x: x2,
      y: y2
    } = point;
    pathParser.addMarker(point, current);
    boundingBox.addPoint(x2, y2);
    if (ctx) {
      ctx.lineTo(x2, y2);
    }
  }
  static pathH(pathParser) {
    var {
      current,
      command
    } = pathParser;
    var point = new Point((command.relative ? current.x : 0) + command.x, current.y);
    pathParser.current = point;
    return {
      current,
      point
    };
  }
  pathH(ctx, boundingBox) {
    var {
      pathParser
    } = this;
    var {
      current,
      point
    } = PathElement.pathH(pathParser);
    var {
      x: x2,
      y: y2
    } = point;
    pathParser.addMarker(point, current);
    boundingBox.addPoint(x2, y2);
    if (ctx) {
      ctx.lineTo(x2, y2);
    }
  }
  static pathV(pathParser) {
    var {
      current,
      command
    } = pathParser;
    var point = new Point(current.x, (command.relative ? current.y : 0) + command.y);
    pathParser.current = point;
    return {
      current,
      point
    };
  }
  pathV(ctx, boundingBox) {
    var {
      pathParser
    } = this;
    var {
      current,
      point
    } = PathElement.pathV(pathParser);
    var {
      x: x2,
      y: y2
    } = point;
    pathParser.addMarker(point, current);
    boundingBox.addPoint(x2, y2);
    if (ctx) {
      ctx.lineTo(x2, y2);
    }
  }
  static pathC(pathParser) {
    var {
      current
    } = pathParser;
    var point = pathParser.getPoint("x1", "y1");
    var controlPoint = pathParser.getAsControlPoint("x2", "y2");
    var currentPoint = pathParser.getAsCurrentPoint();
    return {
      current,
      point,
      controlPoint,
      currentPoint
    };
  }
  pathC(ctx, boundingBox) {
    var {
      pathParser
    } = this;
    var {
      current,
      point,
      controlPoint,
      currentPoint
    } = PathElement.pathC(pathParser);
    pathParser.addMarker(currentPoint, controlPoint, point);
    boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    if (ctx) {
      ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    }
  }
  static pathS(pathParser) {
    var {
      current
    } = pathParser;
    var point = pathParser.getReflectedControlPoint();
    var controlPoint = pathParser.getAsControlPoint("x2", "y2");
    var currentPoint = pathParser.getAsCurrentPoint();
    return {
      current,
      point,
      controlPoint,
      currentPoint
    };
  }
  pathS(ctx, boundingBox) {
    var {
      pathParser
    } = this;
    var {
      current,
      point,
      controlPoint,
      currentPoint
    } = PathElement.pathS(pathParser);
    pathParser.addMarker(currentPoint, controlPoint, point);
    boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    if (ctx) {
      ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    }
  }
  static pathQ(pathParser) {
    var {
      current
    } = pathParser;
    var controlPoint = pathParser.getAsControlPoint("x1", "y1");
    var currentPoint = pathParser.getAsCurrentPoint();
    return {
      current,
      controlPoint,
      currentPoint
    };
  }
  pathQ(ctx, boundingBox) {
    var {
      pathParser
    } = this;
    var {
      current,
      controlPoint,
      currentPoint
    } = PathElement.pathQ(pathParser);
    pathParser.addMarker(currentPoint, controlPoint, controlPoint);
    boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    if (ctx) {
      ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    }
  }
  static pathT(pathParser) {
    var {
      current
    } = pathParser;
    var controlPoint = pathParser.getReflectedControlPoint();
    pathParser.control = controlPoint;
    var currentPoint = pathParser.getAsCurrentPoint();
    return {
      current,
      controlPoint,
      currentPoint
    };
  }
  pathT(ctx, boundingBox) {
    var {
      pathParser
    } = this;
    var {
      current,
      controlPoint,
      currentPoint
    } = PathElement.pathT(pathParser);
    pathParser.addMarker(currentPoint, controlPoint, controlPoint);
    boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    if (ctx) {
      ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    }
  }
  static pathA(pathParser) {
    var {
      current,
      command
    } = pathParser;
    var {
      rX,
      rY,
      xRot,
      lArcFlag,
      sweepFlag
    } = command;
    var xAxisRotation = xRot * (Math.PI / 180);
    var currentPoint = pathParser.getAsCurrentPoint();
    var currp = new Point(Math.cos(xAxisRotation) * (current.x - currentPoint.x) / 2 + Math.sin(xAxisRotation) * (current.y - currentPoint.y) / 2, -Math.sin(xAxisRotation) * (current.x - currentPoint.x) / 2 + Math.cos(xAxisRotation) * (current.y - currentPoint.y) / 2);
    var l2 = Math.pow(currp.x, 2) / Math.pow(rX, 2) + Math.pow(currp.y, 2) / Math.pow(rY, 2);
    if (l2 > 1) {
      rX *= Math.sqrt(l2);
      rY *= Math.sqrt(l2);
    }
    var s2 = (lArcFlag === sweepFlag ? -1 : 1) * Math.sqrt((Math.pow(rX, 2) * Math.pow(rY, 2) - Math.pow(rX, 2) * Math.pow(currp.y, 2) - Math.pow(rY, 2) * Math.pow(currp.x, 2)) / (Math.pow(rX, 2) * Math.pow(currp.y, 2) + Math.pow(rY, 2) * Math.pow(currp.x, 2)));
    if (isNaN(s2)) {
      s2 = 0;
    }
    var cpp = new Point(s2 * rX * currp.y / rY, s2 * -rY * currp.x / rX);
    var centp = new Point((current.x + currentPoint.x) / 2 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y, (current.y + currentPoint.y) / 2 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y);
    var a1 = vectorsAngle([1, 0], [(currp.x - cpp.x) / rX, (currp.y - cpp.y) / rY]);
    var u2 = [(currp.x - cpp.x) / rX, (currp.y - cpp.y) / rY];
    var v2 = [(-currp.x - cpp.x) / rX, (-currp.y - cpp.y) / rY];
    var ad = vectorsAngle(u2, v2);
    if (vectorsRatio(u2, v2) <= -1) {
      ad = Math.PI;
    }
    if (vectorsRatio(u2, v2) >= 1) {
      ad = 0;
    }
    return {
      currentPoint,
      rX,
      rY,
      sweepFlag,
      xAxisRotation,
      centp,
      a1,
      ad
    };
  }
  pathA(ctx, boundingBox) {
    var {
      pathParser
    } = this;
    var {
      currentPoint,
      rX,
      rY,
      sweepFlag,
      xAxisRotation,
      centp,
      a1,
      ad
    } = PathElement.pathA(pathParser);
    var dir = 1 - sweepFlag ? 1 : -1;
    var ah = a1 + dir * (ad / 2);
    var halfWay = new Point(centp.x + rX * Math.cos(ah), centp.y + rY * Math.sin(ah));
    pathParser.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);
    pathParser.addMarkerAngle(currentPoint, ah - dir * Math.PI);
    boundingBox.addPoint(currentPoint.x, currentPoint.y);
    if (ctx && !isNaN(a1) && !isNaN(ad)) {
      var r2 = rX > rY ? rX : rY;
      var sx = rX > rY ? 1 : rX / rY;
      var sy = rX > rY ? rY / rX : 1;
      ctx.translate(centp.x, centp.y);
      ctx.rotate(xAxisRotation);
      ctx.scale(sx, sy);
      ctx.arc(0, 0, r2, a1, a1 + ad, Boolean(1 - sweepFlag));
      ctx.scale(1 / sx, 1 / sy);
      ctx.rotate(-xAxisRotation);
      ctx.translate(-centp.x, -centp.y);
    }
  }
  static pathZ(pathParser) {
    pathParser.current = pathParser.start;
  }
  pathZ(ctx, boundingBox) {
    PathElement.pathZ(this.pathParser);
    if (ctx) {
      if (boundingBox.x1 !== boundingBox.x2 && boundingBox.y1 !== boundingBox.y2) {
        ctx.closePath();
      }
    }
  }
}
class GlyphElement extends PathElement {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "glyph";
    this.horizAdvX = this.getAttribute("horiz-adv-x").getNumber();
    this.unicode = this.getAttribute("unicode").getString();
    this.arabicForm = this.getAttribute("arabic-form").getString();
  }
}
class TextElement extends RenderedElement {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, new.target === TextElement ? true : captureTextNodes);
    this.type = "text";
    this.x = 0;
    this.y = 0;
    this.measureCache = -1;
  }
  setContext(ctx) {
    var fromMeasure = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    super.setContext(ctx, fromMeasure);
    var textBaseline = this.getStyle("dominant-baseline").getTextBaseline() || this.getStyle("alignment-baseline").getTextBaseline();
    if (textBaseline) {
      ctx.textBaseline = textBaseline;
    }
  }
  initializeCoordinates(ctx) {
    this.x = this.getAttribute("x").getPixels("x");
    this.y = this.getAttribute("y").getPixels("y");
    var dxAttr = this.getAttribute("dx");
    var dyAttr = this.getAttribute("dy");
    if (dxAttr.hasValue()) {
      this.x += dxAttr.getPixels("x");
    }
    if (dyAttr.hasValue()) {
      this.y += dyAttr.getPixels("y");
    }
    this.x += this.getAnchorDelta(ctx, this, 0);
  }
  getBoundingBox(ctx) {
    if (this.type !== "text") {
      return this.getTElementBoundingBox(ctx);
    }
    this.initializeCoordinates(ctx);
    var boundingBox = null;
    this.children.forEach((_2, i2) => {
      var childBoundingBox = this.getChildBoundingBox(ctx, this, this, i2);
      if (!boundingBox) {
        boundingBox = childBoundingBox;
      } else {
        boundingBox.addBoundingBox(childBoundingBox);
      }
    });
    return boundingBox;
  }
  getFontSize() {
    var {
      document: document2,
      parent
    } = this;
    var inheritFontSize = Font.parse(document2.ctx.font).fontSize;
    var fontSize2 = parent.getStyle("font-size").getNumber(inheritFontSize);
    return fontSize2;
  }
  getTElementBoundingBox(ctx) {
    var fontSize2 = this.getFontSize();
    return new BoundingBox(this.x, this.y - fontSize2, this.x + this.measureText(ctx), this.y);
  }
  getGlyph(font, text2, i2) {
    var char = text2[i2];
    var glyph = null;
    if (font.isArabic) {
      var len = text2.length;
      var prevChar = text2[i2 - 1];
      var nextChar = text2[i2 + 1];
      var arabicForm = "isolated";
      if ((i2 === 0 || prevChar === " ") && i2 < len - 2 && nextChar !== " ") {
        arabicForm = "terminal";
      }
      if (i2 > 0 && prevChar !== " " && i2 < len - 2 && nextChar !== " ") {
        arabicForm = "medial";
      }
      if (i2 > 0 && prevChar !== " " && (i2 === len - 1 || nextChar === " ")) {
        arabicForm = "initial";
      }
      if (typeof font.glyphs[char] !== "undefined") {
        var maybeGlyph = font.glyphs[char];
        glyph = maybeGlyph instanceof GlyphElement ? maybeGlyph : maybeGlyph[arabicForm];
      }
    } else {
      glyph = font.glyphs[char];
    }
    if (!glyph) {
      glyph = font.missingGlyph;
    }
    return glyph;
  }
  getText() {
    return "";
  }
  getTextFromNode(node2) {
    var textNode = node2 || this.node;
    var childNodes = Array.from(textNode.parentNode.childNodes);
    var index2 = childNodes.indexOf(textNode);
    var lastIndex = childNodes.length - 1;
    var text2 = compressSpaces(textNode.textContent || "");
    if (index2 === 0) {
      text2 = trimLeft(text2);
    }
    if (index2 === lastIndex) {
      text2 = trimRight(text2);
    }
    return text2;
  }
  renderChildren(ctx) {
    if (this.type !== "text") {
      this.renderTElementChildren(ctx);
      return;
    }
    this.initializeCoordinates(ctx);
    this.children.forEach((_2, i2) => {
      this.renderChild(ctx, this, this, i2);
    });
    var {
      mouse
    } = this.document.screen;
    if (mouse.isWorking()) {
      mouse.checkBoundingBox(this, this.getBoundingBox(ctx));
    }
  }
  renderTElementChildren(ctx) {
    var {
      document: document2,
      parent
    } = this;
    var renderText = this.getText();
    var customFont = parent.getStyle("font-family").getDefinition();
    if (customFont) {
      var {
        unitsPerEm
      } = customFont.fontFace;
      var ctxFont = Font.parse(document2.ctx.font);
      var fontSize2 = parent.getStyle("font-size").getNumber(ctxFont.fontSize);
      var fontStyle2 = parent.getStyle("font-style").getString(ctxFont.fontStyle);
      var scale2 = fontSize2 / unitsPerEm;
      var text2 = customFont.isRTL ? renderText.split("").reverse().join("") : renderText;
      var dx = toNumbers(parent.getAttribute("dx").getString());
      var len = text2.length;
      for (var i2 = 0; i2 < len; i2++) {
        var glyph = this.getGlyph(customFont, text2, i2);
        ctx.translate(this.x, this.y);
        ctx.scale(scale2, -scale2);
        var lw = ctx.lineWidth;
        ctx.lineWidth = ctx.lineWidth * unitsPerEm / fontSize2;
        if (fontStyle2 === "italic") {
          ctx.transform(1, 0, 0.4, 1, 0, 0);
        }
        glyph.render(ctx);
        if (fontStyle2 === "italic") {
          ctx.transform(1, 0, -0.4, 1, 0, 0);
        }
        ctx.lineWidth = lw;
        ctx.scale(1 / scale2, -1 / scale2);
        ctx.translate(-this.x, -this.y);
        this.x += fontSize2 * (glyph.horizAdvX || customFont.horizAdvX) / unitsPerEm;
        if (typeof dx[i2] !== "undefined" && !isNaN(dx[i2])) {
          this.x += dx[i2];
        }
      }
      return;
    }
    var {
      x: x2,
      y: y2
    } = this;
    if (ctx.fillStyle) {
      ctx.fillText(renderText, x2, y2);
    }
    if (ctx.strokeStyle) {
      ctx.strokeText(renderText, x2, y2);
    }
  }
  getAnchorDelta(ctx, parent, startI) {
    var textAnchor = this.getStyle("text-anchor").getString("start");
    if (textAnchor !== "start") {
      var {
        children
      } = parent;
      var len = children.length;
      var child = null;
      var width = 0;
      for (var i2 = startI; i2 < len; i2++) {
        child = children[i2];
        if (i2 > startI && child.getAttribute("x").hasValue() || child.getAttribute("text-anchor").hasValue()) {
          break;
        }
        width += child.measureTextRecursive(ctx);
      }
      return -1 * (textAnchor === "end" ? width : width / 2);
    }
    return 0;
  }
  adjustChildCoordinates(ctx, textParent, parent, i2) {
    var child = parent.children[i2];
    if (typeof child.measureText !== "function") {
      return child;
    }
    ctx.save();
    child.setContext(ctx, true);
    var xAttr = child.getAttribute("x");
    var yAttr = child.getAttribute("y");
    var dxAttr = child.getAttribute("dx");
    var dyAttr = child.getAttribute("dy");
    var textAnchor = child.getAttribute("text-anchor").getString("start");
    if (i2 === 0 && child.type !== "textNode") {
      if (!xAttr.hasValue()) {
        xAttr.setValue(textParent.getAttribute("x").getValue("0"));
      }
      if (!yAttr.hasValue()) {
        yAttr.setValue(textParent.getAttribute("y").getValue("0"));
      }
      if (!dxAttr.hasValue()) {
        dxAttr.setValue(textParent.getAttribute("dx").getValue("0"));
      }
      if (!dyAttr.hasValue()) {
        dyAttr.setValue(textParent.getAttribute("dy").getValue("0"));
      }
    }
    if (xAttr.hasValue()) {
      child.x = xAttr.getPixels("x") + textParent.getAnchorDelta(ctx, parent, i2);
      if (textAnchor !== "start") {
        var width = child.measureTextRecursive(ctx);
        child.x += -1 * (textAnchor === "end" ? width : width / 2);
      }
      if (dxAttr.hasValue()) {
        child.x += dxAttr.getPixels("x");
      }
    } else {
      if (textAnchor !== "start") {
        var _width = child.measureTextRecursive(ctx);
        textParent.x += -1 * (textAnchor === "end" ? _width : _width / 2);
      }
      if (dxAttr.hasValue()) {
        textParent.x += dxAttr.getPixels("x");
      }
      child.x = textParent.x;
    }
    textParent.x = child.x + child.measureText(ctx);
    if (yAttr.hasValue()) {
      child.y = yAttr.getPixels("y");
      if (dyAttr.hasValue()) {
        child.y += dyAttr.getPixels("y");
      }
    } else {
      if (dyAttr.hasValue()) {
        textParent.y += dyAttr.getPixels("y");
      }
      child.y = textParent.y;
    }
    textParent.y = child.y;
    child.clearContext(ctx);
    ctx.restore();
    return child;
  }
  getChildBoundingBox(ctx, textParent, parent, i2) {
    var child = this.adjustChildCoordinates(ctx, textParent, parent, i2);
    if (typeof child.getBoundingBox !== "function") {
      return null;
    }
    var boundingBox = child.getBoundingBox(ctx);
    if (!boundingBox) {
      return null;
    }
    child.children.forEach((_2, i3) => {
      var childBoundingBox = textParent.getChildBoundingBox(ctx, textParent, child, i3);
      boundingBox.addBoundingBox(childBoundingBox);
    });
    return boundingBox;
  }
  renderChild(ctx, textParent, parent, i2) {
    var child = this.adjustChildCoordinates(ctx, textParent, parent, i2);
    child.render(ctx);
    child.children.forEach((_2, i3) => {
      textParent.renderChild(ctx, textParent, child, i3);
    });
  }
  measureTextRecursive(ctx) {
    var width = this.children.reduce((width2, child) => width2 + child.measureTextRecursive(ctx), this.measureText(ctx));
    return width;
  }
  measureText(ctx) {
    var {
      measureCache
    } = this;
    if (~measureCache) {
      return measureCache;
    }
    var renderText = this.getText();
    var measure = this.measureTargetText(ctx, renderText);
    this.measureCache = measure;
    return measure;
  }
  measureTargetText(ctx, targetText) {
    if (!targetText.length) {
      return 0;
    }
    var {
      parent
    } = this;
    var customFont = parent.getStyle("font-family").getDefinition();
    if (customFont) {
      var fontSize2 = this.getFontSize();
      var text2 = customFont.isRTL ? targetText.split("").reverse().join("") : targetText;
      var dx = toNumbers(parent.getAttribute("dx").getString());
      var len = text2.length;
      var _measure = 0;
      for (var i2 = 0; i2 < len; i2++) {
        var glyph = this.getGlyph(customFont, text2, i2);
        _measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize2 / customFont.fontFace.unitsPerEm;
        if (typeof dx[i2] !== "undefined" && !isNaN(dx[i2])) {
          _measure += dx[i2];
        }
      }
      return _measure;
    }
    if (!ctx.measureText) {
      return targetText.length * 10;
    }
    ctx.save();
    this.setContext(ctx, true);
    var {
      width: measure
    } = ctx.measureText(targetText);
    this.clearContext(ctx);
    ctx.restore();
    return measure;
  }
}
class TSpanElement extends TextElement {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, new.target === TSpanElement ? true : captureTextNodes);
    this.type = "tspan";
    this.text = this.children.length > 0 ? "" : this.getTextFromNode();
  }
  getText() {
    return this.text;
  }
}
class TextNode extends TSpanElement {
  constructor() {
    super(...arguments);
    this.type = "textNode";
  }
}
class SVGElement extends RenderedElement {
  constructor() {
    super(...arguments);
    this.type = "svg";
    this.root = false;
  }
  setContext(ctx) {
    var _this$node$parentNode;
    var {
      document: document2
    } = this;
    var {
      screen,
      window: window2
    } = document2;
    var canvas = ctx.canvas;
    screen.setDefaults(ctx);
    if (canvas.style && typeof ctx.font !== "undefined" && window2 && typeof window2.getComputedStyle !== "undefined") {
      ctx.font = window2.getComputedStyle(canvas).getPropertyValue("font");
      var fontSizeProp = new Property(document2, "fontSize", Font.parse(ctx.font).fontSize);
      if (fontSizeProp.hasValue()) {
        document2.rootEmSize = fontSizeProp.getPixels("y");
        document2.emSize = document2.rootEmSize;
      }
    }
    if (!this.getAttribute("x").hasValue()) {
      this.getAttribute("x", true).setValue(0);
    }
    if (!this.getAttribute("y").hasValue()) {
      this.getAttribute("y", true).setValue(0);
    }
    var {
      width,
      height
    } = screen.viewPort;
    if (!this.getStyle("width").hasValue()) {
      this.getStyle("width", true).setValue("100%");
    }
    if (!this.getStyle("height").hasValue()) {
      this.getStyle("height", true).setValue("100%");
    }
    if (!this.getStyle("color").hasValue()) {
      this.getStyle("color", true).setValue("black");
    }
    var refXAttr = this.getAttribute("refX");
    var refYAttr = this.getAttribute("refY");
    var viewBoxAttr = this.getAttribute("viewBox");
    var viewBox = viewBoxAttr.hasValue() ? toNumbers(viewBoxAttr.getString()) : null;
    var clip = !this.root && this.getStyle("overflow").getValue("hidden") !== "visible";
    var minX = 0;
    var minY = 0;
    var clipX = 0;
    var clipY = 0;
    if (viewBox) {
      minX = viewBox[0];
      minY = viewBox[1];
    }
    if (!this.root) {
      width = this.getStyle("width").getPixels("x");
      height = this.getStyle("height").getPixels("y");
      if (this.type === "marker") {
        clipX = minX;
        clipY = minY;
        minX = 0;
        minY = 0;
      }
    }
    screen.viewPort.setCurrent(width, height);
    if (this.node && (!this.parent || ((_this$node$parentNode = this.node.parentNode) === null || _this$node$parentNode === void 0 ? void 0 : _this$node$parentNode.nodeName) === "foreignObject") && this.getStyle("transform", false, true).hasValue() && !this.getStyle("transform-origin", false, true).hasValue()) {
      this.getStyle("transform-origin", true, true).setValue("50% 50%");
    }
    super.setContext(ctx);
    ctx.translate(this.getAttribute("x").getPixels("x"), this.getAttribute("y").getPixels("y"));
    if (viewBox) {
      width = viewBox[2];
      height = viewBox[3];
    }
    document2.setViewBox({
      ctx,
      aspectRatio: this.getAttribute("preserveAspectRatio").getString(),
      width: screen.viewPort.width,
      desiredWidth: width,
      height: screen.viewPort.height,
      desiredHeight: height,
      minX,
      minY,
      refX: refXAttr.getValue(),
      refY: refYAttr.getValue(),
      clip,
      clipX,
      clipY
    });
    if (viewBox) {
      screen.viewPort.removeCurrent();
      screen.viewPort.setCurrent(width, height);
    }
  }
  clearContext(ctx) {
    super.clearContext(ctx);
    this.document.screen.viewPort.removeCurrent();
  }
  resize(width) {
    var height = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : width;
    var preserveAspectRatio = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    var widthAttr = this.getAttribute("width", true);
    var heightAttr = this.getAttribute("height", true);
    var viewBoxAttr = this.getAttribute("viewBox");
    var styleAttr = this.getAttribute("style");
    var originWidth = widthAttr.getNumber(0);
    var originHeight = heightAttr.getNumber(0);
    if (preserveAspectRatio) {
      if (typeof preserveAspectRatio === "string") {
        this.getAttribute("preserveAspectRatio", true).setValue(preserveAspectRatio);
      } else {
        var preserveAspectRatioAttr = this.getAttribute("preserveAspectRatio");
        if (preserveAspectRatioAttr.hasValue()) {
          preserveAspectRatioAttr.setValue(preserveAspectRatioAttr.getString().replace(/^\s*(\S.*\S)\s*$/, "$1"));
        }
      }
    }
    widthAttr.setValue(width);
    heightAttr.setValue(height);
    if (!viewBoxAttr.hasValue()) {
      viewBoxAttr.setValue("0 0 ".concat(originWidth || width, " ").concat(originHeight || height));
    }
    if (styleAttr.hasValue()) {
      var widthStyle = this.getStyle("width");
      var heightStyle = this.getStyle("height");
      if (widthStyle.hasValue()) {
        widthStyle.setValue("".concat(width, "px"));
      }
      if (heightStyle.hasValue()) {
        heightStyle.setValue("".concat(height, "px"));
      }
    }
  }
}
class RectElement extends PathElement {
  constructor() {
    super(...arguments);
    this.type = "rect";
  }
  path(ctx) {
    var x2 = this.getAttribute("x").getPixels("x");
    var y2 = this.getAttribute("y").getPixels("y");
    var width = this.getStyle("width", false, true).getPixels("x");
    var height = this.getStyle("height", false, true).getPixels("y");
    var rxAttr = this.getAttribute("rx");
    var ryAttr = this.getAttribute("ry");
    var rx = rxAttr.getPixels("x");
    var ry = ryAttr.getPixels("y");
    if (rxAttr.hasValue() && !ryAttr.hasValue()) {
      ry = rx;
    }
    if (ryAttr.hasValue() && !rxAttr.hasValue()) {
      rx = ry;
    }
    rx = Math.min(rx, width / 2);
    ry = Math.min(ry, height / 2);
    if (ctx) {
      var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
      ctx.beginPath();
      if (height > 0 && width > 0) {
        ctx.moveTo(x2 + rx, y2);
        ctx.lineTo(x2 + width - rx, y2);
        ctx.bezierCurveTo(x2 + width - rx + KAPPA * rx, y2, x2 + width, y2 + ry - KAPPA * ry, x2 + width, y2 + ry);
        ctx.lineTo(x2 + width, y2 + height - ry);
        ctx.bezierCurveTo(x2 + width, y2 + height - ry + KAPPA * ry, x2 + width - rx + KAPPA * rx, y2 + height, x2 + width - rx, y2 + height);
        ctx.lineTo(x2 + rx, y2 + height);
        ctx.bezierCurveTo(x2 + rx - KAPPA * rx, y2 + height, x2, y2 + height - ry + KAPPA * ry, x2, y2 + height - ry);
        ctx.lineTo(x2, y2 + ry);
        ctx.bezierCurveTo(x2, y2 + ry - KAPPA * ry, x2 + rx - KAPPA * rx, y2, x2 + rx, y2);
        ctx.closePath();
      }
    }
    return new BoundingBox(x2, y2, x2 + width, y2 + height);
  }
  getMarkers() {
    return null;
  }
}
class CircleElement extends PathElement {
  constructor() {
    super(...arguments);
    this.type = "circle";
  }
  path(ctx) {
    var cx = this.getAttribute("cx").getPixels("x");
    var cy = this.getAttribute("cy").getPixels("y");
    var r2 = this.getAttribute("r").getPixels();
    if (ctx && r2 > 0) {
      ctx.beginPath();
      ctx.arc(cx, cy, r2, 0, Math.PI * 2, false);
      ctx.closePath();
    }
    return new BoundingBox(cx - r2, cy - r2, cx + r2, cy + r2);
  }
  getMarkers() {
    return null;
  }
}
class EllipseElement extends PathElement {
  constructor() {
    super(...arguments);
    this.type = "ellipse";
  }
  path(ctx) {
    var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
    var rx = this.getAttribute("rx").getPixels("x");
    var ry = this.getAttribute("ry").getPixels("y");
    var cx = this.getAttribute("cx").getPixels("x");
    var cy = this.getAttribute("cy").getPixels("y");
    if (ctx && rx > 0 && ry > 0) {
      ctx.beginPath();
      ctx.moveTo(cx + rx, cy);
      ctx.bezierCurveTo(cx + rx, cy + KAPPA * ry, cx + KAPPA * rx, cy + ry, cx, cy + ry);
      ctx.bezierCurveTo(cx - KAPPA * rx, cy + ry, cx - rx, cy + KAPPA * ry, cx - rx, cy);
      ctx.bezierCurveTo(cx - rx, cy - KAPPA * ry, cx - KAPPA * rx, cy - ry, cx, cy - ry);
      ctx.bezierCurveTo(cx + KAPPA * rx, cy - ry, cx + rx, cy - KAPPA * ry, cx + rx, cy);
      ctx.closePath();
    }
    return new BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);
  }
  getMarkers() {
    return null;
  }
}
class LineElement extends PathElement {
  constructor() {
    super(...arguments);
    this.type = "line";
  }
  getPoints() {
    return [new Point(this.getAttribute("x1").getPixels("x"), this.getAttribute("y1").getPixels("y")), new Point(this.getAttribute("x2").getPixels("x"), this.getAttribute("y2").getPixels("y"))];
  }
  path(ctx) {
    var [{
      x: x0,
      y: y0
    }, {
      x: x1,
      y: y1
    }] = this.getPoints();
    if (ctx) {
      ctx.beginPath();
      ctx.moveTo(x0, y0);
      ctx.lineTo(x1, y1);
    }
    return new BoundingBox(x0, y0, x1, y1);
  }
  getMarkers() {
    var [p0, p12] = this.getPoints();
    var a2 = p0.angleTo(p12);
    return [[p0, a2], [p12, a2]];
  }
}
class PolylineElement extends PathElement {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "polyline";
    this.points = [];
    this.points = Point.parsePath(this.getAttribute("points").getString());
  }
  path(ctx) {
    var {
      points
    } = this;
    var [{
      x: x0,
      y: y0
    }] = points;
    var boundingBox = new BoundingBox(x0, y0);
    if (ctx) {
      ctx.beginPath();
      ctx.moveTo(x0, y0);
    }
    points.forEach((_ref2) => {
      var {
        x: x2,
        y: y2
      } = _ref2;
      boundingBox.addPoint(x2, y2);
      if (ctx) {
        ctx.lineTo(x2, y2);
      }
    });
    return boundingBox;
  }
  getMarkers() {
    var {
      points
    } = this;
    var lastIndex = points.length - 1;
    var markers = [];
    points.forEach((point, i2) => {
      if (i2 === lastIndex) {
        return;
      }
      markers.push([point, point.angleTo(points[i2 + 1])]);
    });
    if (markers.length > 0) {
      markers.push([points[points.length - 1], markers[markers.length - 1][1]]);
    }
    return markers;
  }
}
class PolygonElement extends PolylineElement {
  constructor() {
    super(...arguments);
    this.type = "polygon";
  }
  path(ctx) {
    var boundingBox = super.path(ctx);
    var [{
      x: x2,
      y: y2
    }] = this.points;
    if (ctx) {
      ctx.lineTo(x2, y2);
      ctx.closePath();
    }
    return boundingBox;
  }
}
class PatternElement extends Element$1 {
  constructor() {
    super(...arguments);
    this.type = "pattern";
  }
  createPattern(ctx, _2, parentOpacityProp) {
    var width = this.getStyle("width").getPixels("x", true);
    var height = this.getStyle("height").getPixels("y", true);
    var patternSvg = new SVGElement(this.document, null);
    patternSvg.attributes.viewBox = new Property(this.document, "viewBox", this.getAttribute("viewBox").getValue());
    patternSvg.attributes.width = new Property(this.document, "width", "".concat(width, "px"));
    patternSvg.attributes.height = new Property(this.document, "height", "".concat(height, "px"));
    patternSvg.attributes.transform = new Property(this.document, "transform", this.getAttribute("patternTransform").getValue());
    patternSvg.children = this.children;
    var patternCanvas = this.document.createCanvas(width, height);
    var patternCtx = patternCanvas.getContext("2d");
    var xAttr = this.getAttribute("x");
    var yAttr = this.getAttribute("y");
    if (xAttr.hasValue() && yAttr.hasValue()) {
      patternCtx.translate(xAttr.getPixels("x", true), yAttr.getPixels("y", true));
    }
    if (parentOpacityProp.hasValue()) {
      this.styles["fill-opacity"] = parentOpacityProp;
    } else {
      Reflect.deleteProperty(this.styles, "fill-opacity");
    }
    for (var x2 = -1; x2 <= 1; x2++) {
      for (var y2 = -1; y2 <= 1; y2++) {
        patternCtx.save();
        patternSvg.attributes.x = new Property(this.document, "x", x2 * patternCanvas.width);
        patternSvg.attributes.y = new Property(this.document, "y", y2 * patternCanvas.height);
        patternSvg.render(patternCtx);
        patternCtx.restore();
      }
    }
    var pattern = ctx.createPattern(patternCanvas, "repeat");
    return pattern;
  }
}
class MarkerElement extends Element$1 {
  constructor() {
    super(...arguments);
    this.type = "marker";
  }
  render(ctx, point, angle2) {
    if (!point) {
      return;
    }
    var {
      x: x2,
      y: y2
    } = point;
    var orient = this.getAttribute("orient").getString("auto");
    var markerUnits = this.getAttribute("markerUnits").getString("strokeWidth");
    ctx.translate(x2, y2);
    if (orient === "auto") {
      ctx.rotate(angle2);
    }
    if (markerUnits === "strokeWidth") {
      ctx.scale(ctx.lineWidth, ctx.lineWidth);
    }
    ctx.save();
    var markerSvg = new SVGElement(this.document, null);
    markerSvg.type = this.type;
    markerSvg.attributes.viewBox = new Property(this.document, "viewBox", this.getAttribute("viewBox").getValue());
    markerSvg.attributes.refX = new Property(this.document, "refX", this.getAttribute("refX").getValue());
    markerSvg.attributes.refY = new Property(this.document, "refY", this.getAttribute("refY").getValue());
    markerSvg.attributes.width = new Property(this.document, "width", this.getAttribute("markerWidth").getValue());
    markerSvg.attributes.height = new Property(this.document, "height", this.getAttribute("markerHeight").getValue());
    markerSvg.attributes.overflow = new Property(this.document, "overflow", this.getAttribute("overflow").getValue());
    markerSvg.attributes.fill = new Property(this.document, "fill", this.getAttribute("fill").getColor("black"));
    markerSvg.attributes.stroke = new Property(this.document, "stroke", this.getAttribute("stroke").getValue("none"));
    markerSvg.children = this.children;
    markerSvg.render(ctx);
    ctx.restore();
    if (markerUnits === "strokeWidth") {
      ctx.scale(1 / ctx.lineWidth, 1 / ctx.lineWidth);
    }
    if (orient === "auto") {
      ctx.rotate(-angle2);
    }
    ctx.translate(-x2, -y2);
  }
}
class DefsElement extends Element$1 {
  constructor() {
    super(...arguments);
    this.type = "defs";
  }
  render() {
  }
}
class GElement extends RenderedElement {
  constructor() {
    super(...arguments);
    this.type = "g";
  }
  getBoundingBox(ctx) {
    var boundingBox = new BoundingBox();
    this.children.forEach((child) => {
      boundingBox.addBoundingBox(child.getBoundingBox(ctx));
    });
    return boundingBox;
  }
}
class GradientElement extends Element$1 {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.attributesToInherit = ["gradientUnits"];
    this.stops = [];
    var {
      stops,
      children
    } = this;
    children.forEach((child) => {
      if (child.type === "stop") {
        stops.push(child);
      }
    });
  }
  getGradientUnits() {
    return this.getAttribute("gradientUnits").getString("objectBoundingBox");
  }
  createGradient(ctx, element, parentOpacityProp) {
    var stopsContainer = this;
    if (this.getHrefAttribute().hasValue()) {
      stopsContainer = this.getHrefAttribute().getDefinition();
      this.inheritStopContainer(stopsContainer);
    }
    var {
      stops
    } = stopsContainer;
    var gradient = this.getGradient(ctx, element);
    if (!gradient) {
      return this.addParentOpacity(parentOpacityProp, stops[stops.length - 1].color);
    }
    stops.forEach((stop) => {
      gradient.addColorStop(stop.offset, this.addParentOpacity(parentOpacityProp, stop.color));
    });
    if (this.getAttribute("gradientTransform").hasValue()) {
      var {
        document: document2
      } = this;
      var {
        MAX_VIRTUAL_PIXELS,
        viewPort
      } = document2.screen;
      var [rootView] = viewPort.viewPorts;
      var rect = new RectElement(document2, null);
      rect.attributes.x = new Property(document2, "x", -MAX_VIRTUAL_PIXELS / 3);
      rect.attributes.y = new Property(document2, "y", -MAX_VIRTUAL_PIXELS / 3);
      rect.attributes.width = new Property(document2, "width", MAX_VIRTUAL_PIXELS);
      rect.attributes.height = new Property(document2, "height", MAX_VIRTUAL_PIXELS);
      var group = new GElement(document2, null);
      group.attributes.transform = new Property(document2, "transform", this.getAttribute("gradientTransform").getValue());
      group.children = [rect];
      var patternSvg = new SVGElement(document2, null);
      patternSvg.attributes.x = new Property(document2, "x", 0);
      patternSvg.attributes.y = new Property(document2, "y", 0);
      patternSvg.attributes.width = new Property(document2, "width", rootView.width);
      patternSvg.attributes.height = new Property(document2, "height", rootView.height);
      patternSvg.children = [group];
      var patternCanvas = document2.createCanvas(rootView.width, rootView.height);
      var patternCtx = patternCanvas.getContext("2d");
      patternCtx.fillStyle = gradient;
      patternSvg.render(patternCtx);
      return patternCtx.createPattern(patternCanvas, "no-repeat");
    }
    return gradient;
  }
  inheritStopContainer(stopsContainer) {
    this.attributesToInherit.forEach((attributeToInherit) => {
      if (!this.getAttribute(attributeToInherit).hasValue() && stopsContainer.getAttribute(attributeToInherit).hasValue()) {
        this.getAttribute(attributeToInherit, true).setValue(stopsContainer.getAttribute(attributeToInherit).getValue());
      }
    });
  }
  addParentOpacity(parentOpacityProp, color2) {
    if (parentOpacityProp.hasValue()) {
      var colorProp = new Property(this.document, "color", color2);
      return colorProp.addOpacity(parentOpacityProp).getColor();
    }
    return color2;
  }
}
class LinearGradientElement extends GradientElement {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "linearGradient";
    this.attributesToInherit.push("x1", "y1", "x2", "y2");
  }
  getGradient(ctx, element) {
    var isBoundingBoxUnits = this.getGradientUnits() === "objectBoundingBox";
    var boundingBox = isBoundingBoxUnits ? element.getBoundingBox(ctx) : null;
    if (isBoundingBoxUnits && !boundingBox) {
      return null;
    }
    if (!this.getAttribute("x1").hasValue() && !this.getAttribute("y1").hasValue() && !this.getAttribute("x2").hasValue() && !this.getAttribute("y2").hasValue()) {
      this.getAttribute("x1", true).setValue(0);
      this.getAttribute("y1", true).setValue(0);
      this.getAttribute("x2", true).setValue(1);
      this.getAttribute("y2", true).setValue(0);
    }
    var x1 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute("x1").getNumber() : this.getAttribute("x1").getPixels("x");
    var y1 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute("y1").getNumber() : this.getAttribute("y1").getPixels("y");
    var x2 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute("x2").getNumber() : this.getAttribute("x2").getPixels("x");
    var y2 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute("y2").getNumber() : this.getAttribute("y2").getPixels("y");
    if (x1 === x2 && y1 === y2) {
      return null;
    }
    return ctx.createLinearGradient(x1, y1, x2, y2);
  }
}
class RadialGradientElement extends GradientElement {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "radialGradient";
    this.attributesToInherit.push("cx", "cy", "r", "fx", "fy", "fr");
  }
  getGradient(ctx, element) {
    var isBoundingBoxUnits = this.getGradientUnits() === "objectBoundingBox";
    var boundingBox = element.getBoundingBox(ctx);
    if (isBoundingBoxUnits && !boundingBox) {
      return null;
    }
    if (!this.getAttribute("cx").hasValue()) {
      this.getAttribute("cx", true).setValue("50%");
    }
    if (!this.getAttribute("cy").hasValue()) {
      this.getAttribute("cy", true).setValue("50%");
    }
    if (!this.getAttribute("r").hasValue()) {
      this.getAttribute("r", true).setValue("50%");
    }
    var cx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute("cx").getNumber() : this.getAttribute("cx").getPixels("x");
    var cy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute("cy").getNumber() : this.getAttribute("cy").getPixels("y");
    var fx = cx;
    var fy = cy;
    if (this.getAttribute("fx").hasValue()) {
      fx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute("fx").getNumber() : this.getAttribute("fx").getPixels("x");
    }
    if (this.getAttribute("fy").hasValue()) {
      fy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute("fy").getNumber() : this.getAttribute("fy").getPixels("y");
    }
    var r2 = isBoundingBoxUnits ? (boundingBox.width + boundingBox.height) / 2 * this.getAttribute("r").getNumber() : this.getAttribute("r").getPixels();
    var fr = this.getAttribute("fr").getPixels();
    return ctx.createRadialGradient(fx, fy, fr, cx, cy, r2);
  }
}
class StopElement extends Element$1 {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "stop";
    var offset2 = Math.max(0, Math.min(1, this.getAttribute("offset").getNumber()));
    var stopOpacity = this.getStyle("stop-opacity");
    var stopColor = this.getStyle("stop-color", true);
    if (stopColor.getString() === "") {
      stopColor.setValue("#000");
    }
    if (stopOpacity.hasValue()) {
      stopColor = stopColor.addOpacity(stopOpacity);
    }
    this.offset = offset2;
    this.color = stopColor.getColor();
  }
}
class AnimateElement extends Element$1 {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "animate";
    this.duration = 0;
    this.initialValue = null;
    this.initialUnits = "";
    this.removed = false;
    this.frozen = false;
    document2.screen.animations.push(this);
    this.begin = this.getAttribute("begin").getMilliseconds();
    this.maxDuration = this.begin + this.getAttribute("dur").getMilliseconds();
    this.from = this.getAttribute("from");
    this.to = this.getAttribute("to");
    this.values = new Property(document2, "values", null);
    var valuesAttr = this.getAttribute("values");
    if (valuesAttr.hasValue()) {
      this.values.setValue(valuesAttr.getString().split(";"));
    }
  }
  getProperty() {
    var attributeType = this.getAttribute("attributeType").getString();
    var attributeName = this.getAttribute("attributeName").getString();
    if (attributeType === "CSS") {
      return this.parent.getStyle(attributeName, true);
    }
    return this.parent.getAttribute(attributeName, true);
  }
  calcValue() {
    var {
      initialUnits
    } = this;
    var {
      progress,
      from,
      to
    } = this.getProgress();
    var newValue = from.getNumber() + (to.getNumber() - from.getNumber()) * progress;
    if (initialUnits === "%") {
      newValue *= 100;
    }
    return "".concat(newValue).concat(initialUnits);
  }
  update(delta) {
    var {
      parent
    } = this;
    var prop = this.getProperty();
    if (!this.initialValue) {
      this.initialValue = prop.getString();
      this.initialUnits = prop.getUnits();
    }
    if (this.duration > this.maxDuration) {
      var fill = this.getAttribute("fill").getString("remove");
      if (this.getAttribute("repeatCount").getString() === "indefinite" || this.getAttribute("repeatDur").getString() === "indefinite") {
        this.duration = 0;
      } else if (fill === "freeze" && !this.frozen) {
        this.frozen = true;
        parent.animationFrozen = true;
        parent.animationFrozenValue = prop.getString();
      } else if (fill === "remove" && !this.removed) {
        this.removed = true;
        prop.setValue(parent.animationFrozen ? parent.animationFrozenValue : this.initialValue);
        return true;
      }
      return false;
    }
    this.duration += delta;
    var updated = false;
    if (this.begin < this.duration) {
      var newValue = this.calcValue();
      var typeAttr = this.getAttribute("type");
      if (typeAttr.hasValue()) {
        var type = typeAttr.getString();
        newValue = "".concat(type, "(").concat(newValue, ")");
      }
      prop.setValue(newValue);
      updated = true;
    }
    return updated;
  }
  getProgress() {
    var {
      document: document2,
      values: values3
    } = this;
    var result = {
      progress: (this.duration - this.begin) / (this.maxDuration - this.begin)
    };
    if (values3.hasValue()) {
      var p5 = result.progress * (values3.getValue().length - 1);
      var lb = Math.floor(p5);
      var ub = Math.ceil(p5);
      result.from = new Property(document2, "from", parseFloat(values3.getValue()[lb]));
      result.to = new Property(document2, "to", parseFloat(values3.getValue()[ub]));
      result.progress = (p5 - lb) / (ub - lb);
    } else {
      result.from = this.from;
      result.to = this.to;
    }
    return result;
  }
}
class AnimateColorElement extends AnimateElement {
  constructor() {
    super(...arguments);
    this.type = "animateColor";
  }
  calcValue() {
    var {
      progress,
      from,
      to
    } = this.getProgress();
    var colorFrom = new rgbcolor(from.getColor());
    var colorTo = new rgbcolor(to.getColor());
    if (colorFrom.ok && colorTo.ok) {
      var r2 = colorFrom.r + (colorTo.r - colorFrom.r) * progress;
      var g2 = colorFrom.g + (colorTo.g - colorFrom.g) * progress;
      var b2 = colorFrom.b + (colorTo.b - colorFrom.b) * progress;
      return "rgb(".concat(Math.floor(r2), ", ").concat(Math.floor(g2), ", ").concat(Math.floor(b2), ")");
    }
    return this.getAttribute("from").getColor();
  }
}
class AnimateTransformElement extends AnimateElement {
  constructor() {
    super(...arguments);
    this.type = "animateTransform";
  }
  calcValue() {
    var {
      progress,
      from,
      to
    } = this.getProgress();
    var transformFrom = toNumbers(from.getString());
    var transformTo = toNumbers(to.getString());
    var newValue = transformFrom.map((from2, i2) => {
      var to2 = transformTo[i2];
      return from2 + (to2 - from2) * progress;
    }).join(" ");
    return newValue;
  }
}
class FontElement extends Element$1 {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "font";
    this.glyphs = {};
    this.horizAdvX = this.getAttribute("horiz-adv-x").getNumber();
    var {
      definitions
    } = document2;
    var {
      children
    } = this;
    for (var child of children) {
      switch (child.type) {
        case "font-face": {
          this.fontFace = child;
          var fontFamilyStyle = child.getStyle("font-family");
          if (fontFamilyStyle.hasValue()) {
            definitions[fontFamilyStyle.getString()] = this;
          }
          break;
        }
        case "missing-glyph":
          this.missingGlyph = child;
          break;
        case "glyph": {
          var glyph = child;
          if (glyph.arabicForm) {
            this.isRTL = true;
            this.isArabic = true;
            if (typeof this.glyphs[glyph.unicode] === "undefined") {
              this.glyphs[glyph.unicode] = {};
            }
            this.glyphs[glyph.unicode][glyph.arabicForm] = glyph;
          } else {
            this.glyphs[glyph.unicode] = glyph;
          }
          break;
        }
      }
    }
  }
  render() {
  }
}
class FontFaceElement extends Element$1 {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "font-face";
    this.ascent = this.getAttribute("ascent").getNumber();
    this.descent = this.getAttribute("descent").getNumber();
    this.unitsPerEm = this.getAttribute("units-per-em").getNumber();
  }
}
class MissingGlyphElement extends PathElement {
  constructor() {
    super(...arguments);
    this.type = "missing-glyph";
    this.horizAdvX = 0;
  }
}
class TRefElement extends TextElement {
  constructor() {
    super(...arguments);
    this.type = "tref";
  }
  getText() {
    var element = this.getHrefAttribute().getDefinition();
    if (element) {
      var firstChild = element.children[0];
      if (firstChild) {
        return firstChild.getText();
      }
    }
    return "";
  }
}
class AElement extends TextElement {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "a";
    var {
      childNodes
    } = node2;
    var firstChild = childNodes[0];
    var hasText = childNodes.length > 0 && Array.from(childNodes).every((node3) => node3.nodeType === 3);
    this.hasText = hasText;
    this.text = hasText ? this.getTextFromNode(firstChild) : "";
  }
  getText() {
    return this.text;
  }
  renderChildren(ctx) {
    if (this.hasText) {
      super.renderChildren(ctx);
      var {
        document: document2,
        x: x2,
        y: y2
      } = this;
      var {
        mouse
      } = document2.screen;
      var fontSize2 = new Property(document2, "fontSize", Font.parse(document2.ctx.font).fontSize);
      if (mouse.isWorking()) {
        mouse.checkBoundingBox(this, new BoundingBox(x2, y2 - fontSize2.getPixels("y"), x2 + this.measureText(ctx), y2));
      }
    } else if (this.children.length > 0) {
      var g2 = new GElement(this.document, null);
      g2.children = this.children;
      g2.parent = this;
      g2.render(ctx);
    }
  }
  onClick() {
    var {
      window: window2
    } = this.document;
    if (window2) {
      window2.open(this.getHrefAttribute().getString());
    }
  }
  onMouseMove() {
    var ctx = this.document.ctx;
    ctx.canvas.style.cursor = "pointer";
  }
}
function ownKeys$2(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$2(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
class TextPathElement extends TextElement {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "textPath";
    this.textWidth = 0;
    this.textHeight = 0;
    this.pathLength = -1;
    this.glyphInfo = null;
    this.letterSpacingCache = [];
    this.measuresCache = /* @__PURE__ */ new Map([["", 0]]);
    var pathElement = this.getHrefAttribute().getDefinition();
    this.text = this.getTextFromNode();
    this.dataArray = this.parsePathData(pathElement);
  }
  getText() {
    return this.text;
  }
  path(ctx) {
    var {
      dataArray
    } = this;
    if (ctx) {
      ctx.beginPath();
    }
    dataArray.forEach((_ref2) => {
      var {
        type,
        points
      } = _ref2;
      switch (type) {
        case PathParser.LINE_TO:
          if (ctx) {
            ctx.lineTo(points[0], points[1]);
          }
          break;
        case PathParser.MOVE_TO:
          if (ctx) {
            ctx.moveTo(points[0], points[1]);
          }
          break;
        case PathParser.CURVE_TO:
          if (ctx) {
            ctx.bezierCurveTo(points[0], points[1], points[2], points[3], points[4], points[5]);
          }
          break;
        case PathParser.QUAD_TO:
          if (ctx) {
            ctx.quadraticCurveTo(points[0], points[1], points[2], points[3]);
          }
          break;
        case PathParser.ARC: {
          var [cx, cy, rx, ry, theta, dTheta, psi, fs2] = points;
          var r2 = rx > ry ? rx : ry;
          var scaleX = rx > ry ? 1 : rx / ry;
          var scaleY = rx > ry ? ry / rx : 1;
          if (ctx) {
            ctx.translate(cx, cy);
            ctx.rotate(psi);
            ctx.scale(scaleX, scaleY);
            ctx.arc(0, 0, r2, theta, theta + dTheta, Boolean(1 - fs2));
            ctx.scale(1 / scaleX, 1 / scaleY);
            ctx.rotate(-psi);
            ctx.translate(-cx, -cy);
          }
          break;
        }
        case PathParser.CLOSE_PATH:
          if (ctx) {
            ctx.closePath();
          }
          break;
      }
    });
  }
  renderChildren(ctx) {
    this.setTextData(ctx);
    ctx.save();
    var textDecoration = this.parent.getStyle("text-decoration").getString();
    var fontSize2 = this.getFontSize();
    var {
      glyphInfo
    } = this;
    var fill = ctx.fillStyle;
    if (textDecoration === "underline") {
      ctx.beginPath();
    }
    glyphInfo.forEach((glyph, i2) => {
      var {
        p0,
        p1: p12,
        rotation,
        text: partialText
      } = glyph;
      ctx.save();
      ctx.translate(p0.x, p0.y);
      ctx.rotate(rotation);
      if (ctx.fillStyle) {
        ctx.fillText(partialText, 0, 0);
      }
      if (ctx.strokeStyle) {
        ctx.strokeText(partialText, 0, 0);
      }
      ctx.restore();
      if (textDecoration === "underline") {
        if (i2 === 0) {
          ctx.moveTo(p0.x, p0.y + fontSize2 / 8);
        }
        ctx.lineTo(p12.x, p12.y + fontSize2 / 5);
      }
    });
    if (textDecoration === "underline") {
      ctx.lineWidth = fontSize2 / 20;
      ctx.strokeStyle = fill;
      ctx.stroke();
      ctx.closePath();
    }
    ctx.restore();
  }
  getLetterSpacingAt() {
    var idx = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return this.letterSpacingCache[idx] || 0;
  }
  findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, inputOffset, dy, c2, charI) {
    var offset2 = inputOffset;
    var glyphWidth = this.measureText(ctx, c2);
    if (c2 === " " && anchor === "justify" && textFullWidth < fullPathWidth) {
      glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;
    }
    if (charI > -1) {
      offset2 += this.getLetterSpacingAt(charI);
    }
    var splineStep = this.textHeight / 20;
    var p0 = this.getEquidistantPointOnPath(offset2, splineStep, 0);
    var p12 = this.getEquidistantPointOnPath(offset2 + glyphWidth, splineStep, 0);
    var segment = {
      p0,
      p1: p12
    };
    var rotation = p0 && p12 ? Math.atan2(p12.y - p0.y, p12.x - p0.x) : 0;
    if (dy) {
      var dyX = Math.cos(Math.PI / 2 + rotation) * dy;
      var dyY = Math.cos(-rotation) * dy;
      segment.p0 = _objectSpread$2(_objectSpread$2({}, p0), {}, {
        x: p0.x + dyX,
        y: p0.y + dyY
      });
      segment.p1 = _objectSpread$2(_objectSpread$2({}, p12), {}, {
        x: p12.x + dyX,
        y: p12.y + dyY
      });
    }
    offset2 += glyphWidth;
    return {
      offset: offset2,
      segment,
      rotation
    };
  }
  measureText(ctx, text2) {
    var {
      measuresCache
    } = this;
    var targetText = text2 || this.getText();
    if (measuresCache.has(targetText)) {
      return measuresCache.get(targetText);
    }
    var measure = this.measureTargetText(ctx, targetText);
    measuresCache.set(targetText, measure);
    return measure;
  }
  setTextData(ctx) {
    if (this.glyphInfo) {
      return;
    }
    var renderText = this.getText();
    var chars2 = renderText.split("");
    var spacesNumber = renderText.split(" ").length - 1;
    var dx = this.parent.getAttribute("dx").split().map((_2) => _2.getPixels("x"));
    var dy = this.parent.getAttribute("dy").getPixels("y");
    var anchor = this.parent.getStyle("text-anchor").getString("start");
    var thisSpacing = this.getStyle("letter-spacing");
    var parentSpacing = this.parent.getStyle("letter-spacing");
    var letterSpacing2 = 0;
    if (!thisSpacing.hasValue() || thisSpacing.getValue() === "inherit") {
      letterSpacing2 = parentSpacing.getPixels();
    } else if (thisSpacing.hasValue()) {
      if (thisSpacing.getValue() !== "initial" && thisSpacing.getValue() !== "unset") {
        letterSpacing2 = thisSpacing.getPixels();
      }
    }
    var letterSpacingCache = [];
    var textLen = renderText.length;
    this.letterSpacingCache = letterSpacingCache;
    for (var i2 = 0; i2 < textLen; i2++) {
      letterSpacingCache.push(typeof dx[i2] !== "undefined" ? dx[i2] : letterSpacing2);
    }
    var dxSum = letterSpacingCache.reduce((acc, cur, i3) => i3 === 0 ? 0 : acc + cur || 0, 0);
    var textWidth = this.measureText(ctx);
    var textFullWidth = Math.max(textWidth + dxSum, 0);
    this.textWidth = textWidth;
    this.textHeight = this.getFontSize();
    this.glyphInfo = [];
    var fullPathWidth = this.getPathLength();
    var startOffset = this.getStyle("startOffset").getNumber(0) * fullPathWidth;
    var offset2 = 0;
    if (anchor === "middle" || anchor === "center") {
      offset2 = -textFullWidth / 2;
    }
    if (anchor === "end" || anchor === "right") {
      offset2 = -textFullWidth;
    }
    offset2 += startOffset;
    chars2.forEach((char, i3) => {
      var {
        offset: nextOffset,
        segment,
        rotation
      } = this.findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, offset2, dy, char, i3);
      offset2 = nextOffset;
      if (!segment.p0 || !segment.p1) {
        return;
      }
      this.glyphInfo.push({
        text: chars2[i3],
        p0: segment.p0,
        p1: segment.p1,
        rotation
      });
    });
  }
  parsePathData(path) {
    this.pathLength = -1;
    if (!path) {
      return [];
    }
    var pathCommands = [];
    var {
      pathParser
    } = path;
    pathParser.reset();
    while (!pathParser.isEnd()) {
      var {
        current
      } = pathParser;
      var startX = current ? current.x : 0;
      var startY = current ? current.y : 0;
      var command = pathParser.next();
      var nextCommandType = command.type;
      var points = [];
      switch (command.type) {
        case PathParser.MOVE_TO:
          this.pathM(pathParser, points);
          break;
        case PathParser.LINE_TO:
          nextCommandType = this.pathL(pathParser, points);
          break;
        case PathParser.HORIZ_LINE_TO:
          nextCommandType = this.pathH(pathParser, points);
          break;
        case PathParser.VERT_LINE_TO:
          nextCommandType = this.pathV(pathParser, points);
          break;
        case PathParser.CURVE_TO:
          this.pathC(pathParser, points);
          break;
        case PathParser.SMOOTH_CURVE_TO:
          nextCommandType = this.pathS(pathParser, points);
          break;
        case PathParser.QUAD_TO:
          this.pathQ(pathParser, points);
          break;
        case PathParser.SMOOTH_QUAD_TO:
          nextCommandType = this.pathT(pathParser, points);
          break;
        case PathParser.ARC:
          points = this.pathA(pathParser);
          break;
        case PathParser.CLOSE_PATH:
          PathElement.pathZ(pathParser);
          break;
      }
      if (command.type !== PathParser.CLOSE_PATH) {
        pathCommands.push({
          type: nextCommandType,
          points,
          start: {
            x: startX,
            y: startY
          },
          pathLength: this.calcLength(startX, startY, nextCommandType, points)
        });
      } else {
        pathCommands.push({
          type: PathParser.CLOSE_PATH,
          points: [],
          pathLength: 0
        });
      }
    }
    return pathCommands;
  }
  pathM(pathParser, points) {
    var {
      x: x2,
      y: y2
    } = PathElement.pathM(pathParser).point;
    points.push(x2, y2);
  }
  pathL(pathParser, points) {
    var {
      x: x2,
      y: y2
    } = PathElement.pathL(pathParser).point;
    points.push(x2, y2);
    return PathParser.LINE_TO;
  }
  pathH(pathParser, points) {
    var {
      x: x2,
      y: y2
    } = PathElement.pathH(pathParser).point;
    points.push(x2, y2);
    return PathParser.LINE_TO;
  }
  pathV(pathParser, points) {
    var {
      x: x2,
      y: y2
    } = PathElement.pathV(pathParser).point;
    points.push(x2, y2);
    return PathParser.LINE_TO;
  }
  pathC(pathParser, points) {
    var {
      point,
      controlPoint,
      currentPoint
    } = PathElement.pathC(pathParser);
    points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
  }
  pathS(pathParser, points) {
    var {
      point,
      controlPoint,
      currentPoint
    } = PathElement.pathS(pathParser);
    points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    return PathParser.CURVE_TO;
  }
  pathQ(pathParser, points) {
    var {
      controlPoint,
      currentPoint
    } = PathElement.pathQ(pathParser);
    points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
  }
  pathT(pathParser, points) {
    var {
      controlPoint,
      currentPoint
    } = PathElement.pathT(pathParser);
    points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    return PathParser.QUAD_TO;
  }
  pathA(pathParser) {
    var {
      rX,
      rY,
      sweepFlag,
      xAxisRotation,
      centp,
      a1,
      ad
    } = PathElement.pathA(pathParser);
    if (sweepFlag === 0 && ad > 0) {
      ad -= 2 * Math.PI;
    }
    if (sweepFlag === 1 && ad < 0) {
      ad += 2 * Math.PI;
    }
    return [centp.x, centp.y, rX, rY, a1, ad, xAxisRotation, sweepFlag];
  }
  calcLength(x2, y2, commandType, points) {
    var len = 0;
    var p12 = null;
    var p22 = null;
    var t3 = 0;
    switch (commandType) {
      case PathParser.LINE_TO:
        return this.getLineLength(x2, y2, points[0], points[1]);
      case PathParser.CURVE_TO:
        len = 0;
        p12 = this.getPointOnCubicBezier(0, x2, y2, points[0], points[1], points[2], points[3], points[4], points[5]);
        for (t3 = 0.01; t3 <= 1; t3 += 0.01) {
          p22 = this.getPointOnCubicBezier(t3, x2, y2, points[0], points[1], points[2], points[3], points[4], points[5]);
          len += this.getLineLength(p12.x, p12.y, p22.x, p22.y);
          p12 = p22;
        }
        return len;
      case PathParser.QUAD_TO:
        len = 0;
        p12 = this.getPointOnQuadraticBezier(0, x2, y2, points[0], points[1], points[2], points[3]);
        for (t3 = 0.01; t3 <= 1; t3 += 0.01) {
          p22 = this.getPointOnQuadraticBezier(t3, x2, y2, points[0], points[1], points[2], points[3]);
          len += this.getLineLength(p12.x, p12.y, p22.x, p22.y);
          p12 = p22;
        }
        return len;
      case PathParser.ARC: {
        len = 0;
        var start2 = points[4];
        var dTheta = points[5];
        var end = points[4] + dTheta;
        var inc = Math.PI / 180;
        if (Math.abs(start2 - end) < inc) {
          inc = Math.abs(start2 - end);
        }
        p12 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], start2, 0);
        if (dTheta < 0) {
          for (t3 = start2 - inc; t3 > end; t3 -= inc) {
            p22 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t3, 0);
            len += this.getLineLength(p12.x, p12.y, p22.x, p22.y);
            p12 = p22;
          }
        } else {
          for (t3 = start2 + inc; t3 < end; t3 += inc) {
            p22 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t3, 0);
            len += this.getLineLength(p12.x, p12.y, p22.x, p22.y);
            p12 = p22;
          }
        }
        p22 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], end, 0);
        len += this.getLineLength(p12.x, p12.y, p22.x, p22.y);
        return len;
      }
    }
    return 0;
  }
  getPointOnLine(dist, p1x, p1y, p2x, p2y) {
    var fromX = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : p1x;
    var fromY = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : p1y;
    var m2 = (p2y - p1y) / (p2x - p1x + PSEUDO_ZERO);
    var run2 = Math.sqrt(dist * dist / (1 + m2 * m2));
    if (p2x < p1x) {
      run2 *= -1;
    }
    var rise = m2 * run2;
    var pt2 = null;
    if (p2x === p1x) {
      pt2 = {
        x: fromX,
        y: fromY + rise
      };
    } else if ((fromY - p1y) / (fromX - p1x + PSEUDO_ZERO) === m2) {
      pt2 = {
        x: fromX + run2,
        y: fromY + rise
      };
    } else {
      var ix = 0;
      var iy = 0;
      var len = this.getLineLength(p1x, p1y, p2x, p2y);
      if (len < PSEUDO_ZERO) {
        return null;
      }
      var u2 = (fromX - p1x) * (p2x - p1x) + (fromY - p1y) * (p2y - p1y);
      u2 /= len * len;
      ix = p1x + u2 * (p2x - p1x);
      iy = p1y + u2 * (p2y - p1y);
      var pRise = this.getLineLength(fromX, fromY, ix, iy);
      var pRun = Math.sqrt(dist * dist - pRise * pRise);
      run2 = Math.sqrt(pRun * pRun / (1 + m2 * m2));
      if (p2x < p1x) {
        run2 *= -1;
      }
      rise = m2 * run2;
      pt2 = {
        x: ix + run2,
        y: iy + rise
      };
    }
    return pt2;
  }
  getPointOnPath(distance2) {
    var fullLen = this.getPathLength();
    var cumulativePathLength = 0;
    var p5 = null;
    if (distance2 < -5e-5 || distance2 - 5e-5 > fullLen) {
      return null;
    }
    var {
      dataArray
    } = this;
    for (var command of dataArray) {
      if (command && (command.pathLength < 5e-5 || cumulativePathLength + command.pathLength + 5e-5 < distance2)) {
        cumulativePathLength += command.pathLength;
        continue;
      }
      var delta = distance2 - cumulativePathLength;
      var currentT = 0;
      switch (command.type) {
        case PathParser.LINE_TO:
          p5 = this.getPointOnLine(delta, command.start.x, command.start.y, command.points[0], command.points[1], command.start.x, command.start.y);
          break;
        case PathParser.ARC: {
          var start2 = command.points[4];
          var dTheta = command.points[5];
          var end = command.points[4] + dTheta;
          currentT = start2 + delta / command.pathLength * dTheta;
          if (dTheta < 0 && currentT < end || dTheta >= 0 && currentT > end) {
            break;
          }
          p5 = this.getPointOnEllipticalArc(command.points[0], command.points[1], command.points[2], command.points[3], currentT, command.points[6]);
          break;
        }
        case PathParser.CURVE_TO:
          currentT = delta / command.pathLength;
          if (currentT > 1) {
            currentT = 1;
          }
          p5 = this.getPointOnCubicBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3], command.points[4], command.points[5]);
          break;
        case PathParser.QUAD_TO:
          currentT = delta / command.pathLength;
          if (currentT > 1) {
            currentT = 1;
          }
          p5 = this.getPointOnQuadraticBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3]);
          break;
      }
      if (p5) {
        return p5;
      }
      break;
    }
    return null;
  }
  getLineLength(x1, y1, x2, y2) {
    return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
  }
  getPathLength() {
    if (this.pathLength === -1) {
      this.pathLength = this.dataArray.reduce((length, command) => command.pathLength > 0 ? length + command.pathLength : length, 0);
    }
    return this.pathLength;
  }
  getPointOnCubicBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {
    var x2 = p4x * CB1(pct) + p3x * CB2(pct) + p2x * CB3(pct) + p1x * CB4(pct);
    var y2 = p4y * CB1(pct) + p3y * CB2(pct) + p2y * CB3(pct) + p1y * CB4(pct);
    return {
      x: x2,
      y: y2
    };
  }
  getPointOnQuadraticBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y) {
    var x2 = p3x * QB1(pct) + p2x * QB2(pct) + p1x * QB3(pct);
    var y2 = p3y * QB1(pct) + p2y * QB2(pct) + p1y * QB3(pct);
    return {
      x: x2,
      y: y2
    };
  }
  getPointOnEllipticalArc(cx, cy, rx, ry, theta, psi) {
    var cosPsi = Math.cos(psi);
    var sinPsi = Math.sin(psi);
    var pt2 = {
      x: rx * Math.cos(theta),
      y: ry * Math.sin(theta)
    };
    return {
      x: cx + (pt2.x * cosPsi - pt2.y * sinPsi),
      y: cy + (pt2.x * sinPsi + pt2.y * cosPsi)
    };
  }
  buildEquidistantCache(inputStep, inputPrecision) {
    var fullLen = this.getPathLength();
    var precision = inputPrecision || 0.25;
    var step = inputStep || fullLen / 100;
    if (!this.equidistantCache || this.equidistantCache.step !== step || this.equidistantCache.precision !== precision) {
      this.equidistantCache = {
        step,
        precision,
        points: []
      };
      var s2 = 0;
      for (var l2 = 0; l2 <= fullLen; l2 += precision) {
        var p0 = this.getPointOnPath(l2);
        var p12 = this.getPointOnPath(l2 + precision);
        if (!p0 || !p12) {
          continue;
        }
        s2 += this.getLineLength(p0.x, p0.y, p12.x, p12.y);
        if (s2 >= step) {
          this.equidistantCache.points.push({
            x: p0.x,
            y: p0.y,
            distance: l2
          });
          s2 -= step;
        }
      }
    }
  }
  getEquidistantPointOnPath(targetDistance, step, precision) {
    this.buildEquidistantCache(step, precision);
    if (targetDistance < 0 || targetDistance - this.getPathLength() > 5e-5) {
      return null;
    }
    var idx = Math.round(targetDistance / this.getPathLength() * (this.equidistantCache.points.length - 1));
    return this.equidistantCache.points[idx] || null;
  }
}
var dataUriRegex = /^\s*data:(([^/,;]+\/[^/,;]+)(?:;([^,;=]+=[^,;=]+))?)?(?:;(base64))?,(.*)$/i;
class ImageElement extends RenderedElement {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "image";
    this.loaded = false;
    var href = this.getHrefAttribute().getString();
    if (!href) {
      return;
    }
    var isSvg = href.endsWith(".svg") || /^\s*data:image\/svg\+xml/i.test(href);
    document2.images.push(this);
    if (!isSvg) {
      void this.loadImage(href);
    } else {
      void this.loadSvg(href);
    }
    this.isSvg = isSvg;
  }
  loadImage(href) {
    var _this = this;
    return _asyncToGenerator(function* () {
      try {
        var image2 = yield _this.document.createImage(href);
        _this.image = image2;
      } catch (err2) {
        console.error('Error while loading image "'.concat(href, '":'), err2);
      }
      _this.loaded = true;
    })();
  }
  loadSvg(href) {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      var match2 = dataUriRegex.exec(href);
      if (match2) {
        var data2 = match2[5];
        if (match2[4] === "base64") {
          _this2.image = atob(data2);
        } else {
          _this2.image = decodeURIComponent(data2);
        }
      } else {
        try {
          var response = yield _this2.document.fetch(href);
          var svg2 = yield response.text();
          _this2.image = svg2;
        } catch (err2) {
          console.error('Error while loading image "'.concat(href, '":'), err2);
        }
      }
      _this2.loaded = true;
    })();
  }
  renderChildren(ctx) {
    var {
      document: document2,
      image: image2,
      loaded
    } = this;
    var x2 = this.getAttribute("x").getPixels("x");
    var y2 = this.getAttribute("y").getPixels("y");
    var width = this.getStyle("width").getPixels("x");
    var height = this.getStyle("height").getPixels("y");
    if (!loaded || !image2 || !width || !height) {
      return;
    }
    ctx.save();
    ctx.translate(x2, y2);
    if (this.isSvg) {
      var subDocument = document2.canvg.forkString(ctx, this.image, {
        ignoreMouse: true,
        ignoreAnimation: true,
        ignoreDimensions: true,
        ignoreClear: true,
        offsetX: 0,
        offsetY: 0,
        scaleWidth: width,
        scaleHeight: height
      });
      subDocument.document.documentElement.parent = this;
      void subDocument.render();
    } else {
      var _image = this.image;
      document2.setViewBox({
        ctx,
        aspectRatio: this.getAttribute("preserveAspectRatio").getString(),
        width,
        desiredWidth: _image.width,
        height,
        desiredHeight: _image.height
      });
      if (this.loaded) {
        if (typeof _image.complete === "undefined" || _image.complete) {
          ctx.drawImage(_image, 0, 0);
        }
      }
    }
    ctx.restore();
  }
  getBoundingBox() {
    var x2 = this.getAttribute("x").getPixels("x");
    var y2 = this.getAttribute("y").getPixels("y");
    var width = this.getStyle("width").getPixels("x");
    var height = this.getStyle("height").getPixels("y");
    return new BoundingBox(x2, y2, x2 + width, y2 + height);
  }
}
class SymbolElement extends RenderedElement {
  constructor() {
    super(...arguments);
    this.type = "symbol";
  }
  render(_2) {
  }
}
class SVGFontLoader {
  constructor(document2) {
    this.document = document2;
    this.loaded = false;
    document2.fonts.push(this);
  }
  load(fontFamily2, url) {
    var _this = this;
    return _asyncToGenerator(function* () {
      try {
        var {
          document: document2
        } = _this;
        var svgDocument = yield document2.canvg.parser.load(url);
        var fonts = svgDocument.getElementsByTagName("font");
        Array.from(fonts).forEach((fontNode) => {
          var font = document2.createElement(fontNode);
          document2.definitions[fontFamily2] = font;
        });
      } catch (err2) {
        console.error('Error while loading font "'.concat(url, '":'), err2);
      }
      _this.loaded = true;
    })();
  }
}
class StyleElement extends Element$1 {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "style";
    var css = compressSpaces(Array.from(node2.childNodes).map((_2) => _2.textContent).join("").replace(/(\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+\/)|(^[\s]*\/\/.*)/gm, "").replace(/@import.*;/g, ""));
    var cssDefs = css.split("}");
    cssDefs.forEach((_2) => {
      var def = _2.trim();
      if (!def) {
        return;
      }
      var cssParts = def.split("{");
      var cssClasses = cssParts[0].split(",");
      var cssProps = cssParts[1].split(";");
      cssClasses.forEach((_3) => {
        var cssClass = _3.trim();
        if (!cssClass) {
          return;
        }
        var props = document2.styles[cssClass] || {};
        cssProps.forEach((cssProp) => {
          var prop = cssProp.indexOf(":");
          var name = cssProp.substr(0, prop).trim();
          var value = cssProp.substr(prop + 1, cssProp.length - prop).trim();
          if (name && value) {
            props[name] = new Property(document2, name, value);
          }
        });
        document2.styles[cssClass] = props;
        document2.stylesSpecificity[cssClass] = getSelectorSpecificity(cssClass);
        if (cssClass === "@font-face") {
          var fontFamily2 = props["font-family"].getString().replace(/"|'/g, "");
          var srcs = props.src.getString().split(",");
          srcs.forEach((src) => {
            if (src.indexOf('format("svg")') > 0) {
              var url = parseExternalUrl(src);
              if (url) {
                void new SVGFontLoader(document2).load(fontFamily2, url);
              }
            }
          });
        }
      });
    });
  }
}
StyleElement.parseExternalUrl = parseExternalUrl;
class UseElement extends RenderedElement {
  constructor() {
    super(...arguments);
    this.type = "use";
  }
  setContext(ctx) {
    super.setContext(ctx);
    var xAttr = this.getAttribute("x");
    var yAttr = this.getAttribute("y");
    if (xAttr.hasValue()) {
      ctx.translate(xAttr.getPixels("x"), 0);
    }
    if (yAttr.hasValue()) {
      ctx.translate(0, yAttr.getPixels("y"));
    }
  }
  path(ctx) {
    var {
      element
    } = this;
    if (element) {
      element.path(ctx);
    }
  }
  renderChildren(ctx) {
    var {
      document: document2,
      element
    } = this;
    if (element) {
      var tempSvg = element;
      if (element.type === "symbol") {
        tempSvg = new SVGElement(document2, null);
        tempSvg.attributes.viewBox = new Property(document2, "viewBox", element.getAttribute("viewBox").getString());
        tempSvg.attributes.preserveAspectRatio = new Property(document2, "preserveAspectRatio", element.getAttribute("preserveAspectRatio").getString());
        tempSvg.attributes.overflow = new Property(document2, "overflow", element.getAttribute("overflow").getString());
        tempSvg.children = element.children;
        element.styles.opacity = new Property(document2, "opacity", this.calculateOpacity());
      }
      if (tempSvg.type === "svg") {
        var widthStyle = this.getStyle("width", false, true);
        var heightStyle = this.getStyle("height", false, true);
        if (widthStyle.hasValue()) {
          tempSvg.attributes.width = new Property(document2, "width", widthStyle.getString());
        }
        if (heightStyle.hasValue()) {
          tempSvg.attributes.height = new Property(document2, "height", heightStyle.getString());
        }
      }
      var oldParent = tempSvg.parent;
      tempSvg.parent = this;
      tempSvg.render(ctx);
      tempSvg.parent = oldParent;
    }
  }
  getBoundingBox(ctx) {
    var {
      element
    } = this;
    if (element) {
      return element.getBoundingBox(ctx);
    }
    return null;
  }
  elementTransform() {
    var {
      document: document2,
      element
    } = this;
    return Transform.fromElement(document2, element);
  }
  get element() {
    if (!this.cachedElement) {
      this.cachedElement = this.getHrefAttribute().getDefinition();
    }
    return this.cachedElement;
  }
}
function imGet(img, x2, y2, width, _height, rgba) {
  return img[y2 * width * 4 + x2 * 4 + rgba];
}
function imSet(img, x2, y2, width, _height, rgba, val) {
  img[y2 * width * 4 + x2 * 4 + rgba] = val;
}
function m(matrix2, i2, v2) {
  var mi = matrix2[i2];
  return mi * v2;
}
function c(a2, m1, m2, m3) {
  return m1 + Math.cos(a2) * m2 + Math.sin(a2) * m3;
}
class FeColorMatrixElement extends Element$1 {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "feColorMatrix";
    var matrix2 = toNumbers(this.getAttribute("values").getString());
    switch (this.getAttribute("type").getString("matrix")) {
      case "saturate": {
        var s2 = matrix2[0];
        matrix2 = [0.213 + 0.787 * s2, 0.715 - 0.715 * s2, 0.072 - 0.072 * s2, 0, 0, 0.213 - 0.213 * s2, 0.715 + 0.285 * s2, 0.072 - 0.072 * s2, 0, 0, 0.213 - 0.213 * s2, 0.715 - 0.715 * s2, 0.072 + 0.928 * s2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];
        break;
      }
      case "hueRotate": {
        var a2 = matrix2[0] * Math.PI / 180;
        matrix2 = [c(a2, 0.213, 0.787, -0.213), c(a2, 0.715, -0.715, -0.715), c(a2, 0.072, -0.072, 0.928), 0, 0, c(a2, 0.213, -0.213, 0.143), c(a2, 0.715, 0.285, 0.14), c(a2, 0.072, -0.072, -0.283), 0, 0, c(a2, 0.213, -0.213, -0.787), c(a2, 0.715, -0.715, 0.715), c(a2, 0.072, 0.928, 0.072), 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];
        break;
      }
      case "luminanceToAlpha":
        matrix2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.2125, 0.7154, 0.0721, 0, 0, 0, 0, 0, 0, 1];
        break;
    }
    this.matrix = matrix2;
    this.includeOpacity = this.getAttribute("includeOpacity").hasValue();
  }
  apply(ctx, _x, _y, width, height) {
    var {
      includeOpacity,
      matrix: matrix2
    } = this;
    var srcData = ctx.getImageData(0, 0, width, height);
    for (var y2 = 0; y2 < height; y2++) {
      for (var x2 = 0; x2 < width; x2++) {
        var r2 = imGet(srcData.data, x2, y2, width, height, 0);
        var g2 = imGet(srcData.data, x2, y2, width, height, 1);
        var b2 = imGet(srcData.data, x2, y2, width, height, 2);
        var a2 = imGet(srcData.data, x2, y2, width, height, 3);
        var nr = m(matrix2, 0, r2) + m(matrix2, 1, g2) + m(matrix2, 2, b2) + m(matrix2, 3, a2) + m(matrix2, 4, 1);
        var ng = m(matrix2, 5, r2) + m(matrix2, 6, g2) + m(matrix2, 7, b2) + m(matrix2, 8, a2) + m(matrix2, 9, 1);
        var nb = m(matrix2, 10, r2) + m(matrix2, 11, g2) + m(matrix2, 12, b2) + m(matrix2, 13, a2) + m(matrix2, 14, 1);
        var na = m(matrix2, 15, r2) + m(matrix2, 16, g2) + m(matrix2, 17, b2) + m(matrix2, 18, a2) + m(matrix2, 19, 1);
        if (includeOpacity) {
          nr = 0;
          ng = 0;
          nb = 0;
          na *= a2 / 255;
        }
        imSet(srcData.data, x2, y2, width, height, 0, nr);
        imSet(srcData.data, x2, y2, width, height, 1, ng);
        imSet(srcData.data, x2, y2, width, height, 2, nb);
        imSet(srcData.data, x2, y2, width, height, 3, na);
      }
    }
    ctx.clearRect(0, 0, width, height);
    ctx.putImageData(srcData, 0, 0);
  }
}
class MaskElement extends Element$1 {
  constructor() {
    super(...arguments);
    this.type = "mask";
  }
  apply(ctx, element) {
    var {
      document: document2
    } = this;
    var x2 = this.getAttribute("x").getPixels("x");
    var y2 = this.getAttribute("y").getPixels("y");
    var width = this.getStyle("width").getPixels("x");
    var height = this.getStyle("height").getPixels("y");
    if (!width && !height) {
      var boundingBox = new BoundingBox();
      this.children.forEach((child) => {
        boundingBox.addBoundingBox(child.getBoundingBox(ctx));
      });
      x2 = Math.floor(boundingBox.x1);
      y2 = Math.floor(boundingBox.y1);
      width = Math.floor(boundingBox.width);
      height = Math.floor(boundingBox.height);
    }
    var ignoredStyles = this.removeStyles(element, MaskElement.ignoreStyles);
    var maskCanvas = document2.createCanvas(x2 + width, y2 + height);
    var maskCtx = maskCanvas.getContext("2d");
    document2.screen.setDefaults(maskCtx);
    this.renderChildren(maskCtx);
    new FeColorMatrixElement(document2, {
      nodeType: 1,
      childNodes: [],
      attributes: [{
        nodeName: "type",
        value: "luminanceToAlpha"
      }, {
        nodeName: "includeOpacity",
        value: "true"
      }]
    }).apply(maskCtx, 0, 0, x2 + width, y2 + height);
    var tmpCanvas = document2.createCanvas(x2 + width, y2 + height);
    var tmpCtx = tmpCanvas.getContext("2d");
    document2.screen.setDefaults(tmpCtx);
    element.render(tmpCtx);
    tmpCtx.globalCompositeOperation = "destination-in";
    tmpCtx.fillStyle = maskCtx.createPattern(maskCanvas, "no-repeat");
    tmpCtx.fillRect(0, 0, x2 + width, y2 + height);
    ctx.fillStyle = tmpCtx.createPattern(tmpCanvas, "no-repeat");
    ctx.fillRect(0, 0, x2 + width, y2 + height);
    this.restoreStyles(element, ignoredStyles);
  }
  render(_2) {
  }
}
MaskElement.ignoreStyles = ["mask", "transform", "clip-path"];
var noop = () => {
};
class ClipPathElement extends Element$1 {
  constructor() {
    super(...arguments);
    this.type = "clipPath";
  }
  apply(ctx) {
    var {
      document: document2
    } = this;
    var contextProto = Reflect.getPrototypeOf(ctx);
    var {
      beginPath,
      closePath
    } = ctx;
    if (contextProto) {
      contextProto.beginPath = noop;
      contextProto.closePath = noop;
    }
    Reflect.apply(beginPath, ctx, []);
    this.children.forEach((child) => {
      if (typeof child.path === "undefined") {
        return;
      }
      var transform2 = typeof child.elementTransform !== "undefined" ? child.elementTransform() : null;
      if (!transform2) {
        transform2 = Transform.fromElement(document2, child);
      }
      if (transform2) {
        transform2.apply(ctx);
      }
      child.path(ctx);
      if (contextProto) {
        contextProto.closePath = closePath;
      }
      if (transform2) {
        transform2.unapply(ctx);
      }
    });
    Reflect.apply(closePath, ctx, []);
    ctx.clip();
    if (contextProto) {
      contextProto.beginPath = beginPath;
      contextProto.closePath = closePath;
    }
  }
  render(_2) {
  }
}
class FilterElement extends Element$1 {
  constructor() {
    super(...arguments);
    this.type = "filter";
  }
  apply(ctx, element) {
    var {
      document: document2,
      children
    } = this;
    var boundingBox = element.getBoundingBox(ctx);
    if (!boundingBox) {
      return;
    }
    var px = 0;
    var py = 0;
    children.forEach((child) => {
      var efd = child.extraFilterDistance || 0;
      px = Math.max(px, efd);
      py = Math.max(py, efd);
    });
    var width = Math.floor(boundingBox.width);
    var height = Math.floor(boundingBox.height);
    var tmpCanvasWidth = width + 2 * px;
    var tmpCanvasHeight = height + 2 * py;
    if (tmpCanvasWidth < 1 || tmpCanvasHeight < 1) {
      return;
    }
    var x2 = Math.floor(boundingBox.x);
    var y2 = Math.floor(boundingBox.y);
    var ignoredStyles = this.removeStyles(element, FilterElement.ignoreStyles);
    var tmpCanvas = document2.createCanvas(tmpCanvasWidth, tmpCanvasHeight);
    var tmpCtx = tmpCanvas.getContext("2d");
    document2.screen.setDefaults(tmpCtx);
    tmpCtx.translate(-x2 + px, -y2 + py);
    element.render(tmpCtx);
    children.forEach((child) => {
      if (typeof child.apply === "function") {
        child.apply(tmpCtx, 0, 0, tmpCanvasWidth, tmpCanvasHeight);
      }
    });
    ctx.drawImage(tmpCanvas, 0, 0, tmpCanvasWidth, tmpCanvasHeight, x2 - px, y2 - py, tmpCanvasWidth, tmpCanvasHeight);
    this.restoreStyles(element, ignoredStyles);
  }
  render(_2) {
  }
}
FilterElement.ignoreStyles = ["filter", "transform", "clip-path"];
class FeDropShadowElement extends Element$1 {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "feDropShadow";
    this.addStylesFromStyleDefinition();
  }
  apply(_2, _x, _y, _width, _height) {
  }
}
class FeMorphologyElement extends Element$1 {
  constructor() {
    super(...arguments);
    this.type = "feMorphology";
  }
  apply(_2, _x, _y, _width, _height) {
  }
}
class FeCompositeElement extends Element$1 {
  constructor() {
    super(...arguments);
    this.type = "feComposite";
  }
  apply(_2, _x, _y, _width, _height) {
  }
}
class FeGaussianBlurElement extends Element$1 {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "feGaussianBlur";
    this.blurRadius = Math.floor(this.getAttribute("stdDeviation").getNumber());
    this.extraFilterDistance = this.blurRadius;
  }
  apply(ctx, x2, y2, width, height) {
    var {
      document: document2,
      blurRadius
    } = this;
    var body = document2.window ? document2.window.document.body : null;
    var canvas = ctx.canvas;
    canvas.id = document2.getUniqueId();
    if (body) {
      canvas.style.display = "none";
      body.appendChild(canvas);
    }
    processCanvasRGBA(canvas, x2, y2, width, height, blurRadius);
    if (body) {
      body.removeChild(canvas);
    }
  }
}
class TitleElement extends Element$1 {
  constructor() {
    super(...arguments);
    this.type = "title";
  }
}
class DescElement extends Element$1 {
  constructor() {
    super(...arguments);
    this.type = "desc";
  }
}
var elements = {
  "svg": SVGElement,
  "rect": RectElement,
  "circle": CircleElement,
  "ellipse": EllipseElement,
  "line": LineElement,
  "polyline": PolylineElement,
  "polygon": PolygonElement,
  "path": PathElement,
  "pattern": PatternElement,
  "marker": MarkerElement,
  "defs": DefsElement,
  "linearGradient": LinearGradientElement,
  "radialGradient": RadialGradientElement,
  "stop": StopElement,
  "animate": AnimateElement,
  "animateColor": AnimateColorElement,
  "animateTransform": AnimateTransformElement,
  "font": FontElement,
  "font-face": FontFaceElement,
  "missing-glyph": MissingGlyphElement,
  "glyph": GlyphElement,
  "text": TextElement,
  "tspan": TSpanElement,
  "tref": TRefElement,
  "a": AElement,
  "textPath": TextPathElement,
  "image": ImageElement,
  "g": GElement,
  "symbol": SymbolElement,
  "style": StyleElement,
  "use": UseElement,
  "mask": MaskElement,
  "clipPath": ClipPathElement,
  "filter": FilterElement,
  "feDropShadow": FeDropShadowElement,
  "feMorphology": FeMorphologyElement,
  "feComposite": FeCompositeElement,
  "feColorMatrix": FeColorMatrixElement,
  "feGaussianBlur": FeGaussianBlurElement,
  "title": TitleElement,
  "desc": DescElement
};
function ownKeys$1(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$1(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$1(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function createCanvas(width, height) {
  var canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  return canvas;
}
function createImage(_x) {
  return _createImage.apply(this, arguments);
}
function _createImage() {
  _createImage = _asyncToGenerator(function* (src) {
    var anonymousCrossOrigin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var image2 = document.createElement("img");
    if (anonymousCrossOrigin) {
      image2.crossOrigin = "Anonymous";
    }
    return new Promise((resolve2, reject2) => {
      image2.onload = () => {
        resolve2(image2);
      };
      image2.onerror = (_event, _source, _lineno, _colno, error) => {
        reject2(error);
      };
      image2.src = src;
    });
  });
  return _createImage.apply(this, arguments);
}
class Document {
  constructor(canvg) {
    var {
      rootEmSize = 12,
      emSize = 12,
      createCanvas: createCanvas2 = Document.createCanvas,
      createImage: createImage2 = Document.createImage,
      anonymousCrossOrigin
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.canvg = canvg;
    this.definitions = {};
    this.styles = {};
    this.stylesSpecificity = {};
    this.images = [];
    this.fonts = [];
    this.emSizeStack = [];
    this.uniqueId = 0;
    this.screen = canvg.screen;
    this.rootEmSize = rootEmSize;
    this.emSize = emSize;
    this.createCanvas = createCanvas2;
    this.createImage = this.bindCreateImage(createImage2, anonymousCrossOrigin);
    this.screen.wait(this.isImagesLoaded.bind(this));
    this.screen.wait(this.isFontsLoaded.bind(this));
  }
  bindCreateImage(createImage2, anonymousCrossOrigin) {
    if (typeof anonymousCrossOrigin === "boolean") {
      return (source, forceAnonymousCrossOrigin) => createImage2(source, typeof forceAnonymousCrossOrigin === "boolean" ? forceAnonymousCrossOrigin : anonymousCrossOrigin);
    }
    return createImage2;
  }
  get window() {
    return this.screen.window;
  }
  get fetch() {
    return this.screen.fetch;
  }
  get ctx() {
    return this.screen.ctx;
  }
  get emSize() {
    var {
      emSizeStack
    } = this;
    return emSizeStack[emSizeStack.length - 1];
  }
  set emSize(value) {
    var {
      emSizeStack
    } = this;
    emSizeStack.push(value);
  }
  popEmSize() {
    var {
      emSizeStack
    } = this;
    emSizeStack.pop();
  }
  getUniqueId() {
    return "canvg".concat(++this.uniqueId);
  }
  isImagesLoaded() {
    return this.images.every((_2) => _2.loaded);
  }
  isFontsLoaded() {
    return this.fonts.every((_2) => _2.loaded);
  }
  createDocumentElement(document2) {
    var documentElement = this.createElement(document2.documentElement);
    documentElement.root = true;
    documentElement.addStylesFromStyleDefinition();
    this.documentElement = documentElement;
    return documentElement;
  }
  createElement(node2) {
    var elementType = node2.nodeName.replace(/^[^:]+:/, "");
    var ElementType = Document.elementTypes[elementType];
    if (typeof ElementType !== "undefined") {
      return new ElementType(this, node2);
    }
    return new UnknownElement(this, node2);
  }
  createTextNode(node2) {
    return new TextNode(this, node2);
  }
  setViewBox(config) {
    this.screen.setViewBox(_objectSpread$1({
      document: this
    }, config));
  }
}
Document.createCanvas = createCanvas;
Document.createImage = createImage;
Document.elementTypes = elements;
function ownKeys2(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys2(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
class Canvg {
  constructor(ctx, svg2) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    this.parser = new Parser(options);
    this.screen = new Screen(ctx, options);
    this.options = options;
    var document2 = new Document(this, options);
    var documentElement = document2.createDocumentElement(svg2);
    this.document = document2;
    this.documentElement = documentElement;
  }
  static from(ctx, svg2) {
    var _arguments = arguments;
    return _asyncToGenerator(function* () {
      var options = _arguments.length > 2 && _arguments[2] !== void 0 ? _arguments[2] : {};
      var parser = new Parser(options);
      var svgDocument = yield parser.parse(svg2);
      return new Canvg(ctx, svgDocument, options);
    })();
  }
  static fromString(ctx, svg2) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var parser = new Parser(options);
    var svgDocument = parser.parseFromString(svg2);
    return new Canvg(ctx, svgDocument, options);
  }
  fork(ctx, svg2) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Canvg.from(ctx, svg2, _objectSpread(_objectSpread({}, this.options), options));
  }
  forkString(ctx, svg2) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Canvg.fromString(ctx, svg2, _objectSpread(_objectSpread({}, this.options), options));
  }
  ready() {
    return this.screen.ready();
  }
  isReady() {
    return this.screen.isReady();
  }
  render() {
    var _arguments2 = arguments, _this = this;
    return _asyncToGenerator(function* () {
      var options = _arguments2.length > 0 && _arguments2[0] !== void 0 ? _arguments2[0] : {};
      _this.start(_objectSpread({
        enableRedraw: true,
        ignoreAnimation: true,
        ignoreMouse: true
      }, options));
      yield _this.ready();
      _this.stop();
    })();
  }
  start() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var {
      documentElement,
      screen,
      options: baseOptions
    } = this;
    screen.start(documentElement, _objectSpread(_objectSpread({
      enableRedraw: true
    }, baseOptions), options));
  }
  stop() {
    this.screen.stop();
  }
  resize(width) {
    var height = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : width;
    var preserveAspectRatio = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    this.documentElement.resize(width, height, preserveAspectRatio);
  }
}
var index_es = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": Canvg,
  AElement,
  AnimateColorElement,
  AnimateElement,
  AnimateTransformElement,
  BoundingBox,
  CB1,
  CB2,
  CB3,
  CB4,
  Canvg,
  CircleElement,
  ClipPathElement,
  DefsElement,
  DescElement,
  Document,
  Element: Element$1,
  EllipseElement,
  FeColorMatrixElement,
  FeCompositeElement,
  FeDropShadowElement,
  FeGaussianBlurElement,
  FeMorphologyElement,
  FilterElement,
  Font,
  FontElement,
  FontFaceElement,
  GElement,
  GlyphElement,
  GradientElement,
  ImageElement,
  LineElement,
  LinearGradientElement,
  MarkerElement,
  MaskElement,
  Matrix,
  MissingGlyphElement,
  Mouse,
  PSEUDO_ZERO,
  Parser,
  PathElement,
  PathParser,
  PatternElement,
  Point,
  PolygonElement,
  PolylineElement,
  Property,
  QB1,
  QB2,
  QB3,
  RadialGradientElement,
  RectElement,
  RenderedElement,
  Rotate,
  SVGElement,
  SVGFontLoader,
  Scale,
  Screen,
  Skew,
  SkewX,
  SkewY,
  StopElement,
  StyleElement,
  SymbolElement,
  TRefElement,
  TSpanElement,
  TextElement,
  TextPathElement,
  TitleElement,
  Transform,
  Translate,
  UnknownElement,
  UseElement,
  ViewPort,
  compressSpaces,
  getSelectorSpecificity,
  normalizeAttributeName,
  normalizeColor,
  parseExternalUrl,
  presets: index,
  toNumbers,
  trimLeft,
  trimRight,
  vectorMagnitude,
  vectorsAngle,
  vectorsRatio
}, Symbol.toStringTag, { value: "Module" }));
export { Animations, Geometries, Interactions, Layers, Map$1 as Map, MapControls, Sources, Styles, install as default, install };
